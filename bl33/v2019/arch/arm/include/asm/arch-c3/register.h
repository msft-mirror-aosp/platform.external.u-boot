// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_from_register_h.pl
//
// and was applied to the file
//
// Project name: c3
//
// Create time: Wed Mar  2 10:24:58 CST 2022 by chong.gu
//
// ./REG_LIST_RTL.h
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef REGISTER_H
#else
#define REGISTER_H


#ifndef VERIFICATION
    #define Wr64(addr, data) *(volatile uint64_t *)(addr)=(data)
    #define Rd64(addr) *(volatile uint64_t *)(addr)
    #define Wr8(addr, data) *(volatile uint8_t *)(addr)=(data)
    #define Rd8(addr) *(volatile uint8_t *)(addr)
    //#define Wr(addr, data) *(volatile uint32_t *)(addr)=(data)
    //#define Rd(addr) *(volatile uint32_t *)(addr)
    #define Wr_reg_bits(reg, val, start, len) \
      Wr(reg, ((Rd(reg) & ~(((1L<<(len))-1)<<(start))) | ((uint32_t)(val & ((1L<<len)-1)) << (start))))
#else
    //#include "dpi.h"
#endif

//
// Reading file:  ./REG_LIST_RTL.h
//
// synopsys translate_off
// synopsys translate_on
//
//
// Reading file:  ././dmc_clk_freq.vh
//
//`ifdef DMC_FREQ_REG_DEFINE
//`else
//`define DMC_FREQ_REG_DEFINE
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe040000
// -----------------------------------------------
//`define DMC_FREQ_REG_BASE      32'hfe040000
#define AM_DDR_PLL_CNTL0                           ((0x0000  << 2) + 0xfe040000)
  //bit 29    : dpll_reset.
  //bit 28    : dpll_en.
  //bit 27:26 : dpll_clk_en
  //bit 25    : dpll_inv_sel
  //bit 21:19 : od1  OD1[0] : 0 /2,  1: /4.   OD1[2:1].  2'b00: /1, 2'b01: /2. 2'b10 /4. 2'b11: /8.
  //bit 18:16 : od
  //bit 14:10 : dpll_ref_div_n
  //bit 8:0   : dpll_int_num
#define AM_DDR_PLL_CNTL1                           ((0x0001  << 2) + 0xfe040000)
  //bit 18:0    : ddr_dpll_frac
#define AM_DDR_PLL_CNTL2                           ((0x0002  << 2) + 0xfe040000)
  //bit 22:20  : fref_sel
  //bit 17:16  : os_ssc
  //bit 15:12  : ssc_str_m
  //bit 8      : ssc_en
  //bit 7:4    : ssc_dep_sel
  //bit 1:0    : dpll ss_mode.
#define AM_DDR_PLL_CNTL3                           ((0x0003  << 2) + 0xfe040000)
  //bit 31     : afc bypass
  //bit 30     : afc clk sel
  //bit 29     : code new
  //bit 28     : dco_m_en
  //bit 27     : dco_sdm_en
  //bit 26     : div2
  //bit 25     : div mode
  //bit 24     : fast_lock mode
  //bit 23     : fb_pre_div
  //bit 22     : filter_mode
  //bit 21     : fix_en
  //bit 20     : freq_shift_en
  //bit 19     : load
  //bit 18     : load_en
  //bit 17     : lock_f
  //bit 16     : pulse_width_en
  //bit 15     : sdmnc_en
  //bit 14     : sdmnc_mode
  //bit 13     : sdmnc_range
  //bit 12     : tdc_en
  //bit 11     : tdc_mode_sel
  //bit 10     :  wait_en
#define AM_DDR_PLL_CNTL4                           ((0x0004  << 2) + 0xfe040000)
  //bit 1:0    : pfd_gain
  //bit 7:4    : filter_pvt1
  //bit 11:8   : filter pvt2
  //bit 13:12  : acq_gain
  //bit 18:16  : lambda0
  //bit 22:20  : lambda1
  //bit 26:24  : rou
  //bit 30:28  : alpha
#define AM_DDR_PLL_CNTL5                           ((0x0005  << 2) + 0xfe040000)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo
#define AM_DDR_PLL_CNTL6                           ((0x0006  << 2) + 0xfe040000)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo
#define AM_DDR_PLL_STS                             ((0x0007  << 2) + 0xfe040000)
  //bit 31     : DDR_PLL_LOCK
  //bit 30:19  : not used.
  //bit 18     : DDR_AFC_DONE
  //bit 17     : DDR_PLL_LOCK
  //bit 16:7   : DDR_DPLL_OUT_RSV
  //bit 6:0    : DDR_SDMNC_MONITOR
#define DDR_CLK_CNTL                               ((0x0008  << 2) + 0xfe040000)
  //bit 31     ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
  // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 30.    ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 29.    not used.
  //bit 28.    clock generation logic soft reset. 0 = reset.
  //bit 27.    phy_4xclk phase inverter..
  //bit 25.    DDRPHY DfiClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 24.    enable AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 16.   enable DMC at speed mbist mode.
  //bit 9     enable DFICLK use LPCLK/4 at FREQ1..
  //bit 8.    reset lpclk logic.
  //bit 7     enalbe DFICLK use LPCLK/4 at current freq.
  //bit 6.    enable 4Xclock use LPCLK
  //bit 5.    not used.
  //bit 4.   enable DFICLK use APB clock.
  //bit 2. enable dmc_clk.
  //bit 1. not used.
  //bit 0. enable LPDDR4-PHY clock
#define DDR_PHY_CTRL                               ((0x0009  << 2) + 0xfe040000)
  // LPDDR4 power on reset need to special combination of PwrOkIn and phy_reset_n.
  //bit 31:  DDr PHY power on status.  read only.
  //bit 5.   DDR PHY dfi_init_start_or.   1: for dfi_init_start = 1 if dmc need to power down.  0: normal working mode.
  //bit 4.   DDR PHY PwrOkIn pin.
  //bit 1.   DDR PHY APB soft reset_n.
  //bit 0.   phy_reset_n.
#define AM_DDR_PLL_FREQ1_OD                        ((0x000c  << 2) + 0xfe040000)
 //freqency set 1 PLL OD and OD1 setting. when change to freqency 1 will use this setting.
//frequency set 0 use original DDR_PLL_CNTL0 setting.
 //bit 8     currunt FREQ selection.  it can forced to change to select which freqency to select, or it can auto changed by FREQ change hardware.
 //bit 5:3   OD1.
 //bit 2:0.  OD.
//`endif
//
// Closing file:  ././dmc_clk_freq.vh
//
//
// Reading file:  ./../mmc_lp4/dmc/rtl/dmc_reg.vh
//
//`define DMC_REG_BASE      32'hfe036000
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe036000
// -----------------------------------------------
#define DMC_REQ_CTRL                               ((0x0000  << 2) + 0xfe036000)
  //bit 31~8.  Not used.
  //bit 7.   enable dmc request of axibus chan 7.  DEV0.( Audio eth_top, SPICCx2).
  //bit 6.   enable dmc request of axibus chan 6.  DEV1 ( EMMC, SDIO, SEC_TOP USB2).
  //bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.  DSP
  //bit 3.   enable dmc request of axibus chan 3.  NNA
  //bit 2.   enable dmc request of axibus chan 2.  not used.
  //bit 1.   enable dmc request of axibus chan 1.  Not used.
  //bit 0.   enable dmc request of axibus chan 0.  CPU/A53   async interface.
//DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST                               ((0x0001  << 2) + 0xfe036000)
  //bit 31~8. reserved for future.
  //bit 7:0. 8 AXI BUS input interfaces n_clk domain reset_n signal. 0: reset. 1: normal working mode. each bit for one interface.
#define DMC_SOFT_RST1                              ((0x0002  << 2) + 0xfe036000)
  //To reset the Async interface, you need to disable the interface both clock domain, then reset both n_clk and m_clk domain
  //bit 31~8 not used.
  //bit 7:0.  8 AXI bus interfaces master clock domain reset_n signal. 0 : reset : 1 normal working mode.
#define DMC_SOFT_RST2                              ((0x0003  << 2) + 0xfe036000)
  //bit 31~11.  reserved for future.
  //bit 10  DMC DFI cmd soft reset_n
  //bit 9   DMC DFI MISC soft reset_n
  //bit 8   DMC DFI data soft reset_n
  //bit 7   DMC DFI dcu soft reset_n
  //bit 6   DMC siu soft reset_n
  //bit 5.  DMC test soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 4.  DMC low power control module soft reset_n.    0 : reset. 1 : normal working mode.
  //bit 3.  DMC QOS monitor module soft reset_n.   0 : reset. 1 : normal working mode.
  //bit 2.  DMC register module soft reset_n.       0 : reset. 1 : normal working mode.
  //bit 1.  DMC canvas transfer module soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 0.  DMC command buffers and command generation modules soft reset.  0 = reset. 1:
#define DMC_RST_STS1                               ((0x0004  << 2) + 0xfe036000)
  //31~24.  not used.
  //23~0.   Read only.  the DMC_SOFT_RST1 signal in n_clk domain. the purpose of this register is when one of the 2 clocks is too slow or too fast,  we can read this register to make sure another clock domain reset is done.
#define DMC_CLKG_CTRL0                             ((0x0006  << 2) + 0xfe036000)
  //bit 23:16. enable the 8 ambus interfaces both main and n_clk auto clock gating function. each 1 bit for one interface.
  //bit 15:0.  enable the 16 axi interfaces both main and n_clk auto clock gating function. each 1 bit for one interface.
#define DMC_CLKG_CTRL1                             ((0x0007  << 2) + 0xfe036000)
  //bit 23:16. force to disable the 8 ambus interfaces both main and n_clk. each 1 bit for one interface.
  //bit 15:0.  force to disable the 16 axi interfaces both main and n_clk. each 1 bit for one interface.
#define DMC_CLKG_CTRL2                             ((0x0008  << 2) + 0xfe036000)
  //bit 12  enalbe auto clock gating for awcmdfifo.
  //bit 11  enalbe auto clock gating for arcmdfifo.
  //bit 10  enable auto clock gating for dfi command generation
  //bit 9   enable auto clock gating for dram controller
  //bit 8   enable auto clock gating for dfi data path.
  //bit 7.  enalbe auto clock gating for write rsp generation.
  //bit 6.  enalbe auto clock gating for read rsp generation.
  //bit 5.  enalbe auto clock gating for ddr0 command filter.
  //bit 4.  enalbe auto clock gating for ddr0 write reorder buffer.
  //bit 3.  enalbe auto clock gating for ddr0 write data buffer.
  //bit 2.  enalbe auto clock gating for ddr0 read reorder buffer.
  //bit 1.  enalbe auto clock gating for read canvas.
  //bit 0.  enalbe auto clock gating for write canvas.
#define DMC_CLKG_CTRL3                             ((0x0009  << 2) + 0xfe036000)
  //bit 12  force to disable the clock of awcmdfifo.
  //bit 11  force to disable the clock of arcmdfifo.
  //bit 10  force to disable the clock of dfi command generation
  //bit 9   force to disable the clock of dram controller
  //bit 8   force to disable the clock of dfi data path.
  //bit 7. force to disalbe the clock of write rsp generation.
  //bit 6. force to disalbe the clock of read rsp generation.
  //bit 5.  force to disalbe the clock of  command filter.
  //bit 4.  force to disalbe the clock of  write reorder buffer.
  //bit 3.  force to disalbe the clock of write data buffer.
  //bit 2.  force to disalbe the clock of read reorder buffer.
  //bit 1.  force to disalbe the clock of read canvas.
  //bit 0.  force to disalbe the clock of write canvas.
#define DMC_MON_CTRL0                              ((0x0020  << 2) + 0xfe036000)
   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.  read 1 = qos mon finish interrupt.
   //bit 7.    BW monitor 3 enable.
   //bit 6.    BW monitor 3 enable.
   //bit 5.    BW monitor 3 enable.
   //bit 4.    BW monitor 3 enable.
   //bit 3.    BW monitor 3 enable.
   //bit 2.    BW monitor 2 enable.
   //bit 1.    BW monitor 1 enable.
   //bit 0.    BW monitor 0 enable.
#define DMC_MON_TIMER                              ((0x0021  << 2) + 0xfe036000)
 // timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT                       ((0x0022  << 2) + 0xfe036000)
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW                             ((0x0023  << 2) + 0xfe036000)
  // at the test period,  the whole MMC granted data cycles. 64bits unit.
#define DMC_MON_ALL16_BW                           ((0x0024  << 2) + 0xfe036000)
  // at the test period,  the whole MMC granted data cycles which goes to 16bits ddr. unit:64bits
#define DMC_MON0_CTRL                              ((0x0025  << 2) + 0xfe036000)
  //BW MONTIOR 0 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON0_CTRL1                             ((0x0026  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 0 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON0_CTRL2                             ((0x0027  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 0 port select for the selected channel.
#define DMC_MON0_BW                                ((0x0028  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON1_CTRL                              ((0x0029  << 2) + 0xfe036000)
  //BW monitor 1 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON1_CTRL1                             ((0x002a  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 1 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON1_CTRL2                             ((0x002b  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 1 port select for the selected channel.
#define DMC_MON1_BW                                ((0x002c  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON2_CTRL                              ((0x002d  << 2) + 0xfe036000)
  //BW monitor 2 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON2_CTRL1                             ((0x002e  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 2 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON2_CTRL2                             ((0x002f  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 2 port select for the selected channel.
#define DMC_MON2_BW                                ((0x0030  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON3_CTRL                              ((0x0031  << 2) + 0xfe036000)
  //BW monitor 3 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON3_CTRL1                             ((0x0032  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 3 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON3_CTRL2                             ((0x0033  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 3 port select for the selected channel.
#define DMC_MON3_BW                                ((0x0034  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON4_CTRL                              ((0x0035  << 2) + 0xfe036000)
  //BW monitor 4 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON4_CTRL1                             ((0x0036  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 4 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON4_CTRL2                             ((0x0037  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 4 port select for the selected channel.
#define DMC_MON4_BW                                ((0x0038  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON5_CTRL                              ((0x0039  << 2) + 0xfe036000)
  //BW monitor 5 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON5_CTRL1                             ((0x003a  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 5 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON5_CTRL2                             ((0x003b  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 5 port select for the selected channel.
#define DMC_MON5_BW                                ((0x003c  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON6_CTRL                              ((0x003d  << 2) + 0xfe036000)
  //BW monitor 6 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON6_CTRL1                             ((0x003e  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 6 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON6_CTRL2                             ((0x003f  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 6 port select for the selected channel.
#define DMC_MON6_BW                                ((0x0040  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_MON7_CTRL                              ((0x0041  << 2) + 0xfe036000)
  //BW monitor 7 address range control.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON7_CTRL1                             ((0x0042  << 2) + 0xfe036000)
   //bit 23:0.  BW monitor 7 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON7_CTRL2                             ((0x0043  << 2) + 0xfe036000)
   //bit 15:0.  BW monitor 7 port select for the selected channel.
#define DMC_MON7_BW                                ((0x0044  << 2) + 0xfe036000)
  // at the test period, this range granted data cycles for the select channel and ports.
#define DMC_CMD_FILTER_CTRL1                       ((0x0050  << 2) + 0xfe036000)
  //not used.
#define DMC_CMD_FILTER_CTRL2                       ((0x0051  << 2) + 0xfe036000)
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.
#define DMC_CMD_FILTER_CTRL3                       ((0x0052  << 2) + 0xfe036000)
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number
#define DMC_CMD_FILTER_CTRL4                       ((0x0053  << 2) + 0xfe036000)
  //bit 29:25.  tITW.long
  //bit 24:20.  tITW. short
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.
#define DMC_CMD_FILTER_CTRL5                       ((0x0054  << 2) + 0xfe036000)
  //bit 31:24   Once ddr data bus switch to read, the maxmum read command number to give up the bus when there's write request pending for write buffer.
  //bit 23:16   Once ddr data bus switch to write, the maxmum write command number to give up the bus when there's read request pending too long.
  //bit 15:8.   Once ddr data bus switch to read, the minimum read command number to transfer back to write stage if there's still pending read request.
  //bit 7:0.    Once ddr data bus switch to write, the minimum write command number to transfer back to read stage if there's still pending write request.
#define DMC_CMD_FILTER_CTRL6                       ((0x0055  << 2) + 0xfe036000)
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.
#define DMC_CMD_FILTER_CTRL7                       ((0x0056  << 2) + 0xfe036000)
  //bit 31:24.  aw_req_pedning singal assertion after wbuf full.
  //bit 23:16   aw_req_pending singal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.
#define DMC_CMD_FILTER_CTRL8                       ((0x0057  << 2) + 0xfe036000)
  //bit 31:8    reserved.
  //bit 7:0     rank limit to change to another rank.
#define DMC_CMD_BUFFER_CTRL                        ((0x0058  << 2) + 0xfe036000)
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8    reserved.
  //bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write command waiting to in write buffer that long.
#define DMC_CMD_BUFFER_CTRL1                       ((0x0059  << 2) + 0xfe036000)
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.
#define DMC_2ARB_CTRL                              ((0x005c  << 2) + 0xfe036000)
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //22.    1: allow to increase 2 urgent levels if waiting time is doubled than inc_ugt_limit.
  //21:12  inc_ugt_limit.  if waiting time > inc_ugt_limit, increase the urgent level by one
  //11:6.  the final arbitration control from AXI bus(port channel 0~7).
  //5:0.   the final arbitration weight control for Ambus ( port channel 8~15).
#define DMC_VERSION                                ((0x005f  << 2) + 0xfe036000)
   //read only 32'h000a0008  for sc2
#define DMC_AXI0_CHAN_CTRL                         ((0x0080  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL                         ((0x0081  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI0_CHAN_CTRL1                        ((0x0082  << 2) + 0xfe036000)
 //31:28.  FIQ  chan0 QOS setting.
  //27:24.  IRQ  chan0 QOS setting.
  //23:23.  chan0 write QOS with VPU request.
  //19:16.  chan0 write QOS with other request .
  //15:12.  chan0 write QOS with none other requests.
  //11:8.   chan0 read QOS with VPU request.
  //7:4.    chan0 read QOS with other request .
  //3:0.    chan0 read QOS with none other requests.
#define DMC_AXI0_CHAN_CTRL2                        ((0x0083  << 2) + 0xfe036000)
 //bit 31:4.  Not used.
 //bit 3.     CPU FIQ QOS ctrl_en.
 //bit 2.     CPU IRQ QOS ctrl_en.
 //bit 1.     CPU read channel auto QOS enable (based on other traffic).
 //bit 0.     CPU write channel auto QOS enable( based on other traffic).
#define DMC_AXI1_CHAN_CTRL                         ((0x0084  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI1_HOLD_CTRL                         ((0x0085  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1                        ((0x0086  << 2) + 0xfe036000)
   //bit 31:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI2_CHAN_CTRL                         ((0x0088  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI2_HOLD_CTRL                         ((0x0089  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI2_CHAN_CTRL1                        ((0x008a  << 2) + 0xfe036000)
   //bit 31:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI3_CHAN_CTRL                         ((0x008c  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI3_HOLD_CTRL                         ((0x008d  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI3_CHAN_CTRL1                        ((0x008e  << 2) + 0xfe036000)
   //bit 31:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI4_CHAN_CTRL                         ((0x0090  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI4_HOLD_CTRL                         ((0x0091  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI4_CHAN_CTRL1                        ((0x0092  << 2) + 0xfe036000)
   //bit 31:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI5_CHAN_CTRL                         ((0x0094  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
  //3:0 arbitor number
#define DMC_AXI5_HOLD_CTRL                         ((0x0095  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI6_CHAN_CTRL                         ((0x0098  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI6_HOLD_CTRL                         ((0x0099  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI6_CHAN_CTRL1                        ((0x009a  << 2) + 0xfe036000)
   //bit 31  write data hold mode. 1: hold write read before wrdata received. 0. no hold.
   //bit 30:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI7_CHAN_CTRL                         ((0x009c  << 2) + 0xfe036000)
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19:16.   QOS value if this port is define use register value.
  //bit 15       force this ports QOS to use this register bit 19:16.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI7_HOLD_CTRL                         ((0x009d  << 2) + 0xfe036000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI7_CHAN_CTRL1                        ((0x009e  << 2) + 0xfe036000)
   //bit 31:20. not used.
   //bit 19. use side band write urgent control signal to control AWQOS.  1: enable. 0: disable.
   //bit 18. use side band read urgent control signal to control ARQOS.  1: enable. 0: disable.
   //bit 17. use side band write urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 16. use side band read urgent control singal to block other master request.  1: enable. 0 disable.
   //bit 15:12.  the AWQOS value when side band write urgent control signal = 1 while bit 19 enabled.
   //bit 11:8.   the ARQOS value when side band read urgent control signal = 1 while bit 18 enabled.
   //bit 7:0.    when write/read side band singal used to block other request. configure which master we can block. each bit for  one master.
                //Note. don't block VPU and CPU or other urgent request.
#define DMC_AXI0_CHAN_STS                          ((0x00c0  << 2) + 0xfe036000)
  // AXI0 Async interface status.
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:12.  FIQ STS
  //11:8.   IRQ STS.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI1_CHAN_STS                          ((0x00c1  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI2_CHAN_STS                          ((0x00c2  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI3_CHAN_STS                          ((0x00c3  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI4_CHAN_STS                          ((0x00c4  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI5_CHAN_STS                          ((0x00c5  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI6_CHAN_STS                          ((0x00c6  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_AXI7_CHAN_STS                          ((0x00c7  << 2) + 0xfe036000)
  //31:24.  read command pending transaction number.
  //23:16.  write command pending transaction number.
  //15:8.  Not used.
  //7:0.   read back data waiting counter.( RVALID high with RREADY low max time counter.
#define DMC_CHAN_STS                               ((0x00ce  << 2) + 0xfe036000)
  //AXI0  is first CPU and Mali combined channel from CCI-400 directly.  The first 2Gbyte address will go through this channel.
  //AXI10  is the second CPU, Mali channel combined with NNA  from NIC-400.  The upper 2Gbyte address will go through this channel.
  // read only regsiter.
  // the second mali and NNA channel IDLE.
  // the second CPU channel IDLE.
  // the first mali channel IDLE.
  // the first CPU channel IDLE.
  //bit 27      always 1
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      always 1.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:16   ambus channel idle.          1 : idle 0: busy.
  //bit 15:0.   axibus channel idle.         1 : idle 0: busy.
#define DMC_IRQ_STS                                ((0x00cf  << 2) + 0xfe036000)
  //bit 31:3   Not used.
  //bit 2 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrup.  write 1 to clean this interrupt.
  //bit 1 :    WRITE protection interrupt.  1: means there's write protection violation.  need to write DMC_PROT_IRQ_CTRL  bit 1to clean this bit.
  //bit 0 :    read protection interrupt.   1: means there's read  protection violation.  need to write DMC_PROT_IRQ_CTRL bit 0 to clean this bit.
//DMC protection function domain regsiter.
// one protection can chose upto 4 master IDs to monitors.
//for these 4 master IDs, you can chose either include them. or exclude them.
#define DMC_PROT0_STA                              ((0x00d0  << 2) + 0xfe036000)
  //31:20. not used.
  //19:0   protection 0 start address . unit 4Kbyte.
#define DMC_PROT0_EDA                              ((0x00d1  << 2) + 0xfe036000)
  //31:20. not used.
  //19:0   protection 0 end address. unit 4Kbyte.
#define DMC_PROT0_CTRL                             ((0x00d2  << 2) + 0xfe036000)
  //bit 27.  protection 0 write monitor enable.
  //bit 26.  protection 0 read monitor enable.
  //bit 8.   montior policy:  1 include the ids.  0: exclude the IDS.
  //bit 3.   ID3 enable.
  //bit 2.   ID2 enable.
  //bit 1.   ID1 enable.
  //bit 0.   ID0 enable.
#define DMC_PROT0_CTRL1                            ((0x00d3  << 2) + 0xfe036000)
  //bit 31:24.   ID3 id number.
  //bit 23:16.   ID2 id number.
  //bit 15:8     ID1 id number.
  //bit 7:0.     ID0 id number.
#define DMC_PROT1_STA                              ((0x00d4  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0   protection 1 start address . unit 4Kbyte.
#define DMC_PROT1_EDA                              ((0x00d5  << 2) + 0xfe036000)
  //bit 31:20. not used.
  //bit 19:0   protection 1 end address. unit 4Kbyte.
#define DMC_PROT1_CTRL                             ((0x00d6  << 2) + 0xfe036000)
  //bit 27.  protection 1 write monitor enable.
  //bit 26.  protection 1 read monitor enable.
  //bit 8.   montior policy:  1 include the ids.  0: exclude the IDS.
  //bit 3.   ID3 enable.
  //bit 2.   ID2 enable.
  //bit 1.   ID1 enable.
  //bit 0.   ID0 enable.
#define DMC_PROT1_CTRL1                            ((0x00d7  << 2) + 0xfe036000)
  //bit 31:24.   ID3 id number.
  //bit 23:16.   ID2 id number.
  //bit 15:8     ID1 id number.
  //bit 7:0.     ID0 id number.
#define DMC_PROT_VIO_0                             ((0x00d8  << 2) + 0xfe036000)
  //ddr0 write protection violation address.
#define DMC_PROT_VIO_1                             ((0x00d9  << 2) + 0xfe036000)
  //bit 31:22 . not used. always 0.
  //21.    ddr0 protection 1 violation.
  //20     ddr0 protection 0 violation.
  //19:14. ddr0 write violation AWPROT bits. ( 6 bits for write security)
  //15     Not used.
  //14:0   ddr0_write USER bits. [7:0] for master ID.  14:8 for master security information.
#define DMC_PROT_VIO_2                             ((0x00da  << 2) + 0xfe036000)
  //ddr0 read prot violation address
#define DMC_PROT_VIO_3                             ((0x00db  << 2) + 0xfe036000)
  //bit 31:21 . not used. always 0.
  //21     ddr0 read protection 1 violation.
  //20     ddr0 read protection 0 violation.
  //19:15  Not used.
  //14:0   ddr0 read violation USER bits. [7:0] for master ID.  [14:8] master security info.
#define DMC_PROT_IRQ_CTRL                          ((0x00dc  << 2) + 0xfe036000)
  //bit 2 :  protect function IRQ enable.
  //bit 1 :  write protection violation.  write 1 to clean write protection vio registers.
  //bit 0 :  read  protection violation.  write 1 to clean read protection vio registers.
//`define DMC_TEST_REG_BASE                32'hfe037800
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe037800
// -----------------------------------------------
#define DMC_TEST_STA                               ((0x0000  << 2) + 0xfe037800)
  //test start address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                     for sha mode,      address must be in 64 bytes boundary. that mean the last 6 bits must be 0.
#define DMC_TEST_EDA                               ((0x0001  << 2) + 0xfe037800)
  //test end address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                   for sha mode,       address must be in 64 bytes boundary. that mean the last 6bits must be 1.
#define DMC_TEST_CTRL                              ((0x0002  << 2) + 0xfe037800)
   //bit 31.  enable test.
   //bit 30.  when enable test, enable the write to DDR function.
   //bit 29.  when enable test, enable the read from DDR function.
   //bit 28.  when enable test,  enable the sha calculation function  must be same as read enable but without write function.
   //bit 27.  enable to compare data.  when do the read enable to enable the error comparison. suppose the read data should be same as the data in the write buffer.
   //bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
   //bit 25.  address generation type.  0: continuous increase the address in the range of test start address and test end address.
   //                                   1: test module would pick the random address from test start address  and test end address.
   //bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
   //                             for write if the write command number == the DMC_TEST_NUM, the write is done.
   //                             for read if the read command number == the DMC TEST_num, the read id done. for one read command can be repeated repeat number times.
   //                         1 : finshed at end address.
   //bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0}, then the latter is the previous data plus a pattern.( { + WD7,  + WD6, + WD5, + WD4}).
   //                         0 : the WDATA is the data in write register.
   //bit 23.  1  compare the sha result with the test sha message registers. 0 : dont compare the result.
   //bit 22:20.   read repeat times.  for non-sha function, we can define multi times of the read. the test module would repeat the same adddress repeat times.
   //bit 19.     limit write.  0: no outstanding write request limitation.
   //                          1: limit the outstanding write commands to the number of bits [15:8]
   //bit 18.     limit read.   0. no outstanding read request limitation.
   //                          1. limit the read outstanding request to the number of bits[7:0].
   //bit 17:16.  sha mode for sha function enabled.  00 : not used.  01 : sha1. 2: sha2-256. 3: sha2_224. not used in GXL fixed to be  Sha 2.
   //bit 15:8.   write outstanding commands limit.
   //bit 7:0.    read  outstanding commands limit.
#define DMC_TEST_NUM                               ((0x0003  << 2) + 0xfe037800)
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.
#define DMC_TEST_WDG                               ((0x0004  << 2) + 0xfe037800)
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.
#define DMC_TEST_COMP_MASK                         ((0x0005  << 2) + 0xfe037800)
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.
#define DMC_TEST_WSTRB0                            ((0x0006  << 2) + 0xfe037800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_TEST_WSTRB1                            ((0x0007  << 2) + 0xfe037800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.
#define DMC_TEST_WD0                               ((0x0010  << 2) + 0xfe037800)
   // write data 0 for write command. also for read back data comparision.
#define DMC_TEST_WD1                               ((0x0011  << 2) + 0xfe037800)
   // write data 1 for write command. also for read back data comparision.
#define DMC_TEST_WD2                               ((0x0012  << 2) + 0xfe037800)
   // write data 2 for write command. also for read back data comparision.
#define DMC_TEST_WD3                               ((0x0013  << 2) + 0xfe037800)
   // write data 3 for write command. also for read back data comparision.
#define DMC_TEST_WD4                               ((0x0014  << 2) + 0xfe037800)
   // write data 4 for write command. also for read back data comparision.
#define DMC_TEST_WD5                               ((0x0015  << 2) + 0xfe037800)
   // write data 5 for write command. also for read back data comparision.
#define DMC_TEST_WD6                               ((0x0016  << 2) + 0xfe037800)
   // write data 6 for write command. also for read back data comparision.
#define DMC_TEST_WD7                               ((0x0017  << 2) + 0xfe037800)
   // write data 7 for write command. also for read back data comparision.
#define DMC_TEST_WD8                               ((0x0018  << 2) + 0xfe037800)
   // write data 8 for write command. also for read back data comparision.
#define DMC_TEST_WD9                               ((0x0019  << 2) + 0xfe037800)
   // write data 9 for write command. also for read back data comparision.
#define DMC_TEST_WD10                              ((0x001a  << 2) + 0xfe037800)
   // write data 10 for write command. also for read back data comparision.
#define DMC_TEST_WD11                              ((0x001b  << 2) + 0xfe037800)
   // write data 11 for write command. also for read back data comparision.
#define DMC_TEST_WD12                              ((0x001c  << 2) + 0xfe037800)
   // write data 12 for write command. also for read back data comparision.
#define DMC_TEST_WD13                              ((0x001d  << 2) + 0xfe037800)
   // write data 13 for write command. also for read back data comparision.
#define DMC_TEST_WD14                              ((0x001e  << 2) + 0xfe037800)
   // write data 14 for write command. also for read back data comparision.
#define DMC_TEST_WD15                              ((0x001f  << 2) + 0xfe037800)
   // write data 15 for write command. also for read back data comparision.
#define DMC_TEST_RD0                               ((0x0020  << 2) + 0xfe037800)
   // the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1                               ((0x0021  << 2) + 0xfe037800)
   // the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2                               ((0x0022  << 2) + 0xfe037800)
   // the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3                               ((0x0023  << 2) + 0xfe037800)
   // the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4                               ((0x0024  << 2) + 0xfe037800)
   // the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5                               ((0x0025  << 2) + 0xfe037800)
   // the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6                               ((0x0026  << 2) + 0xfe037800)
   // the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7                               ((0x0027  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8                               ((0x0028  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9                               ((0x0029  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10                              ((0x002a  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11                              ((0x002b  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12                              ((0x002c  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13                              ((0x002d  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14                              ((0x002e  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15                              ((0x002f  << 2) + 0xfe037800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_ERR_ADDR                          ((0x0040  << 2) + 0xfe037800)
  //read only. it capture the first error address.
#define DMC_TEST_ERR_CNT                           ((0x0041  << 2) + 0xfe037800)
  //read only. how many data error happens in the whole test period.
#define DMC_TEST_STS                               ((0x0042  << 2) + 0xfe037800)
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.
#define DMC_TEST_WRCMD_ADDR                        ((0x0043  << 2) + 0xfe037800)
  //read only. the current write cmd address.
#define DMC_TEST_RDCMD_ADDR                        ((0x0044  << 2) + 0xfe037800)
   //read only. the current read command address.
#define DMC_TEST_RDRSP_ADDR                        ((0x0045  << 2) + 0xfe037800)
  //read only. the failed read response address(for error data )
//`define DMC_DRAM_REG_BASE      32'hfe036400
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe036400
// -----------------------------------------------
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency, the hardware would automatically select one of these two set of timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD                              ((0x0000  << 2) + 0xfe036400)
   //bit 4:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC                              ((0x0001  << 2) + 0xfe036400)
   //bit 9:0 tRFC
#define DMC_DRAM_TRP                               ((0x0002  << 2) + 0xfe036400)
   //bit 21:16.  tRP for precharge all banks.
   //bit 5:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW                              ((0x0003  << 2) + 0xfe036400)
   //bit 31:6:   Not used.
   //bit 5:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + TDQSCK_MAX + tWPRE +RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL                               ((0x0004  << 2) + 0xfe036400)
  //bit 5:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL                              ((0x0005  << 2) + 0xfe036400)
  //bit 5:0.  CWL:  write latency.
#define DMC_DRAM_TRAS                              ((0x0006  << 2) + 0xfe036400)
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC                               ((0x0007  << 2) + 0xfe036400)
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD                              ((0x0008  << 2) + 0xfe036400)
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD                              ((0x0009  << 2) + 0xfe036400)
  //bit 21:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 5:0.    tRRD/tRRD_s   active bank A to active bank b time.
              //tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW                              ((0x000a  << 2) + 0xfe036400)
  //bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP                              ((0x000b  << 2) + 0xfe036400)
  //bit 5:0  tRTP.
#define DMC_DRAM_TWR                               ((0x000c  << 2) + 0xfe036400)
  //bit 5:0 tWR.
#define DMC_DRAM_TWTR                              ((0x000d  << 2) + 0xfe036400)
  //bit 21:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 5:0 tWTR_s.
#define DMC_DRAM_TCCD                              ((0x000e  << 2) + 0xfe036400)
  //bit 19:16. tCCD/tCCD_l.
  //bit 3:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR                             ((0x000f  << 2) + 0xfe036400)
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS                               ((0x0010  << 2) + 0xfe036400)
  //bit 9:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP                               ((0x0011  << 2) + 0xfe036400)
  //bit 3:0. tXP.  EXIT power down to other command time
#define DMC_DRAM_TXPDLL                            ((0x0012  << 2) + 0xfe036400)
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS                             ((0x0013  << 2) + 0xfe036400)
  //bit 11:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE                            ((0x0014  << 2) + 0xfe036400)
  //bit 4:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX                            ((0x0015  << 2) + 0xfe036400)
  //bit 4:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE                              ((0x0016  << 2) + 0xfe036400)
  //bit 4:0.  CKE high or low minimum time.
#define DMC_DRAM_TMOD                              ((0x0017  << 2) + 0xfe036400)
  //bit 4:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register but it called tMRD.
#define DMC_DRAM_TDQS                              ((0x0018  << 2) + 0xfe036400)
  //bit 31:28 reserved
  //bit 27:24 tDQS. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL                             ((0x0019  << 2) + 0xfe036400)
  //not used.
#define DMC_DRAM_TZQLAT                            ((0x001a  << 2) + 0xfe036400)
  //bit 5:0 ZQ LATCH command to other comand timing in LPDDR4 mode.
#define DMC_DRAM_TMRR                              ((0x001b  << 2) + 0xfe036400)
  //bit 7:0 tMRR  not used in DMC.
#define DMC_DRAM_TCKESR                            ((0x001c  << 2) + 0xfe036400)
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD                              ((0x001d  << 2) + 0xfe036400)
 //not support.
#define DMC_DRAM_DFITCTRLDELAY                     ((0x001e  << 2) + 0xfe036400)
  //bit 3:0. DFI_t_ctrldealy
#define DMC_DRAM_DFITPHYWRDATA                     ((0x001f  << 2) + 0xfe036400)
  //bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT                      ((0x0020  << 2) + 0xfe036400)
  //bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN                      ((0x0021  << 2) + 0xfe036400)
  //bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT                      ((0x0022  << 2) + 0xfe036400)
  //bit 5:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN                    ((0x0023  << 2) + 0xfe036400)
  //bit 7:0.  CTRLUPD_MIN  minimux clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX                    ((0x0024  << 2) + 0xfe036400)
  //bit 7:0   CTRLUPD_MAX.  maxmum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI                       ((0x0026  << 2) + 0xfe036400)
  //not used.
#define DMC_DRAM_DFITCTRLUPDI                      ((0x0027  << 2) + 0xfe036400)
  //not used.
#define DMC_DRAM_DFITDRAMCLK                       ((0x0028  << 2) + 0xfe036400)
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer
#define DMC_DRAM_DFITLPRESP                        ((0x002a  << 2) + 0xfe036400)
  //bit 3:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.
#define DMC_DRAM_TCKECK                            ((0x002c  << 2) + 0xfe036400)
 //bit 4:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay
#define DMC_DRAM_TREFI                             ((0x002d  << 2) + 0xfe036400)
 //write this register will update the auto refresh related register to the auto refresh control logic.
 //bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
 //bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
 //bit 15:8.   tREFI.dmc send auto refresh command period. unit is 100ns.
 //bit 7:0.    t100ns period. unit is dmc clock cycles
#define DMC_DRAM_TSR                               ((0x002e  << 2) + 0xfe036400)
  //bit 5:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW                            ((0x002f  << 2) + 0xfe036400)
  //bit 5:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE                            ((0x0030  << 2) + 0xfe036400)
  //bit 5:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3                        ((0x0031  << 2) + 0xfe036400)
  //7:0. DDR3 SDRAM tREFI single auto refresh time . the unit is t100ns.
  //use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL                            ((0x0032  << 2) + 0xfe036400)
  //11:0. ZQCAL for LPDDR4. ZQINIT/ZQoper for DDR3/4 ZQCL command.
#define DMC_DRAM_T10US                             ((0x0033  << 2) + 0xfe036400)
  //10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI                             ((0x0034  << 2) + 0xfe036400)
//bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST                          ((0x0035  << 2) + 0xfe036400)
 //bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG                         ((0x0036  << 2) + 0xfe036400)
  //bit 12.  rank1 ODT default. default value for ODT[1] pins if theres no read/write activity.
  //bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
  //bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
  //bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
  //bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occure in rank0.
  //bit 4.   rank0 ODT default.    default value for ODT[0] pins if theres no read/write activity.
  //bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
  //bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
  //bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
  //bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occure in rank1.
#define DMC_DRAM_DFIODTCFG1                        ((0x0037  << 2) + 0xfe036400)
  //bit 27:24  ODT length for BL8 read transfer.
  //bit 19:16. ODT length for BL8 write transfer.
  //bit 12:8.  ODT latency for reads.  suppose to be 0.
  //bit 4:0.   ODT latency for writes.  suppose to be 0.
#define DMC_DRAM_TWODTON                           ((0x0038  << 2) + 0xfe036400)
  //bit 5:0   DRAM write access ODT on time.
  //   in DDR3/4 should be same as WL.
  //   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
  //   In LPDDR4 ODT disable mode:  tWL.
#define DMC_DRAM_TRETRAIN                          ((0x0039  << 2) + 0xfe036400)
 //bit 15:0 LPDDR4 OSCRING retraining timer(units = auto_refresh timer). sync with autorefresh
#define DMC_DRAM_PHYADDRON                         ((0x003a  << 2) + 0xfe036400)
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON                           ((0x003b  << 2) + 0xfe036400)
  //bit 6:0 PHY_CTRL_ADDR_ON for new PHY. unit: ddr clk
  // PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON                           ((0x003c  << 2) + 0xfe036400)
  // PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2
#define DMC_DRAM_ZQCTRL                            ((0x003d  << 2) + 0xfe036400)
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period, which refresh period count to send partial ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.
//timing paramter for frequency set 1.
#define DMC_NFQ_TMRD                               ((0x0040  << 2) + 0xfe036400)
#define DMC_NFQ_TRFC                               ((0x0041  << 2) + 0xfe036400)
#define DMC_NFQ_TRP                                ((0x0042  << 2) + 0xfe036400)
#define DMC_NFQ_TRTW                               ((0x0043  << 2) + 0xfe036400)
#define DMC_NFQ_TCL                                ((0x0044  << 2) + 0xfe036400)
#define DMC_NFQ_TCWL                               ((0x0045  << 2) + 0xfe036400)
#define DMC_NFQ_TRAS                               ((0x0046  << 2) + 0xfe036400)
#define DMC_NFQ_TRC                                ((0x0047  << 2) + 0xfe036400)
#define DMC_NFQ_TRCD                               ((0x0048  << 2) + 0xfe036400)
#define DMC_NFQ_TRRD                               ((0x0049  << 2) + 0xfe036400)
#define DMC_NFQ_TFAW                               ((0x004a  << 2) + 0xfe036400)
#define DMC_NFQ_TRTP                               ((0x004b  << 2) + 0xfe036400)
#define DMC_NFQ_TWR                                ((0x004c  << 2) + 0xfe036400)
#define DMC_NFQ_TWTR                               ((0x004d  << 2) + 0xfe036400)
#define DMC_NFQ_TCCD                               ((0x004e  << 2) + 0xfe036400)
#define DMC_NFQ_TEXSR                              ((0x004f  << 2) + 0xfe036400)
#define DMC_NFQ_TXS                                ((0x0050  << 2) + 0xfe036400)
#define DMC_NFQ_TXP                                ((0x0051  << 2) + 0xfe036400)
#define DMC_NFQ_TXPDLL                             ((0x0052  << 2) + 0xfe036400)
#define DMC_NFQ_TZQCS                              ((0x0053  << 2) + 0xfe036400)
#define DMC_NFQ_TCKSRE                             ((0x0054  << 2) + 0xfe036400)
#define DMC_NFQ_TCKSRX                             ((0x0055  << 2) + 0xfe036400)
#define DMC_NFQ_TCKE                               ((0x0056  << 2) + 0xfe036400)
#define DMC_NFQ_TMOD                               ((0x0057  << 2) + 0xfe036400)
#define DMC_NFQ_TDQS                               ((0x0058  << 2) + 0xfe036400)
#define DMC_NFQ_TRSTL                              ((0x0059  << 2) + 0xfe036400)
#define DMC_NFQ_TZQLAT                             ((0x005a  << 2) + 0xfe036400)
#define DMC_NFQ_TMRR                               ((0x005b  << 2) + 0xfe036400)
#define DMC_NFQ_TCKESR                             ((0x005c  << 2) + 0xfe036400)
#define DMC_NFQ_TDPD                               ((0x005d  << 2) + 0xfe036400)
#define DMC_NFQ_DFITCTRLDELAY                      ((0x005e  << 2) + 0xfe036400)
#define DMC_NFQ_DFITPHYWRDATA                      ((0x005f  << 2) + 0xfe036400)
#define DMC_NFQ_DFITPHYWRLAT                       ((0x0060  << 2) + 0xfe036400)
#define DMC_NFQ_DFITRDDATAEN                       ((0x0061  << 2) + 0xfe036400)
#define DMC_NFQ_DFITPHYRDLAT                       ((0x0062  << 2) + 0xfe036400)
#define DMC_NFQ_DFITCTRLUPDMIN                     ((0x0063  << 2) + 0xfe036400)
#define DMC_NFQ_DFITCTRLUPDMAX                     ((0x0064  << 2) + 0xfe036400)
#define DMC_NFQ_DFITREFMSKI                        ((0x0066  << 2) + 0xfe036400)
#define DMC_NFQ_DFITCTRLUPDI                       ((0x0067  << 2) + 0xfe036400)
#define DMC_NFQ_DFITDRAMCLK                        ((0x0068  << 2) + 0xfe036400)
#define DMC_NFQ_DFITLPRESP                         ((0x006a  << 2) + 0xfe036400)
#define DMC_NFQ_TCKECK                             ((0x006c  << 2) + 0xfe036400)
#define DMC_NFQ_TREFI                              ((0x006d  << 2) + 0xfe036400)
#define DMC_NFQ_TSR                                ((0x006e  << 2) + 0xfe036400)
#define DMC_NFQ_TCCDMW                             ((0x006f  << 2) + 0xfe036400)
#define DMC_NFQ_TESCKE                             ((0x0070  << 2) + 0xfe036400)
#define DMC_NFQ_TREFI_DDR3                         ((0x0071  << 2) + 0xfe036400)
#define DMC_NFQ_TZQCAL                             ((0x0072  << 2) + 0xfe036400)
#define DMC_NFQ_T10US                              ((0x0073  << 2) + 0xfe036400)
#define DMC_NFQ_TMRRI                              ((0x0074  << 2) + 0xfe036400)
#define DMC_NFQ_TXS_FAST                           ((0x0075  << 2) + 0xfe036400)
#define DMC_NFQ_DFIODTCFG                          ((0x0076  << 2) + 0xfe036400)
#define DMC_NFQ_DFIODTCFG1                         ((0x0077  << 2) + 0xfe036400)
#define DMC_NFQ_TWODTON                            ((0x0078  << 2) + 0xfe036400)
#define DMC_NFQ_TRETRAIN                           ((0x0079  << 2) + 0xfe036400)
#define DMC_NFQ_PHYADDRON                          ((0x007a  << 2) + 0xfe036400)
#define DMC_NFQ_PHYWRON                            ((0x007b  << 2) + 0xfe036400)
#define DMC_NFQ_PHYRDON                            ((0x007c  << 2) + 0xfe036400)
#define DMC_NFQ_ZQCTRL                             ((0x007d  << 2) + 0xfe036400)
//end of second frequency timing parameter
#define DMC_DRAM_DFITPHYUPDTYPE0                   ((0x0080  << 2) + 0xfe036400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1                   ((0x0081  << 2) + 0xfe036400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2                   ((0x0082  << 2) + 0xfe036400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3                   ((0x0083  << 2) + 0xfe036400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.
#define DMC_DRAM_MCFG                              ((0x0086  << 2) + 0xfe036400)
 //bit 31:27  not used.
 //bit 26:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23     not used.
 //bit 22:20. rank0_d16_sel. 16bit mode, rank 0 byte selection.
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit regsiter triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.
#define DMC_DRAM_ZQ_CTRL                           ((0x0087  << 2) + 0xfe036400)
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only
#define DMC_DRAM_MCFG1                             ((0x0088  << 2) + 0xfe036400)
 //bit7:0 LPDDR4 WDBI mode maskwrite dbi pattern
#define DMC_DRAM_DFI_CTRL                          ((0x0089  << 2) + 0xfe036400)
  //bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data error. 0 : disable.
  //bit 20 phy_ctrl_rd_on phy_ctrl_wr_on ignore 16bit mode.  1: sending 0xf in 16bit mode.  0: sending valid byte enable in 16bit mode
  //bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional EXSR time for new command. 0: phy will handle all the timing    after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polarity.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 16:  force PHY ctrl_on  if = 1, phy_ctrl_on singal will keep on.
   //bit 15 siu_dfi1_lp_en
  //bit 14 siu_dfi_lp_ack_and
  //bit 13 siu_dfi_lp_ack_or
  //bit 12 siu_dfi1_init_start_en
  //bit 11 siu_dfi_init_com_and
  //bit 10 siu_dfi_init_com_or
  //bit  9 siu_dfi1_freq_en
  //bit  8 siu_dfi1_dram_clk_dis_en
  //bit  7 siu_dfi_phyupd_type_sel
  //bit  6 siu_dfi1_phyupd_ack_en
  //bit  5 siu_dfi_phyupd_req_and
  //bit  4 siu_dfi_phyupd_req_or
  //bit  3 siu_dfi_ctrlupd_ack_and
  //bit  2 siu_dfi_ctrlupd_ack_or
  //bit  1 siu_dfi1_ctrlupd_req_en
  //bit  0 siu_dfi1_cmd_en
#define DMC_DRAM_DFIINITCFG                        ((0x008a  << 2) + 0xfe036400)
  //bit 31.   dfi_init_complete status. read only.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.
#define DMC_DRAM_APD_CTRL                          ((0x008c  << 2) + 0xfe036400)
 //bit 19:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
            //non zero value to enable auto power down when DMC is in idle state for this number of clock cycles.
#define DMC_DRAM_ASR_CTRL                          ((0x008d  << 2) + 0xfe036400)
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit 28. enable dmc wait 10us after LP2 mode exit if it's long time the PHY in LP2 mode..
  //bit [27:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode.
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
             // Non-zero value enable ASR mode. when DMC is in idle state for this number of clock cycles, the DMC will enter ASR mode.
#define DMC_DRAM_REFR_CTRL                         ((0x0092  << 2) + 0xfe036400)
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  retrain enable for auto refresh frequent. 1: enable. 0: disable.
  //bit 6  Disabled auto refresh command if over 16 auto refresh command sent in 2 TREFI_DDR3 period
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.
#define DMC_DRAM_FREQ_CTRL                         ((0x0093  << 2) + 0xfe036400)
//bit 31 .  write 1 to change freqency   read 0: finished.
//bit 30.   waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29:23.  not used.
//bit 22.   after freqchenge send refresh command.
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW fucntion: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh state in case there's something need to handle.
              //     0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.
#define DMC_DRAM_SCFG                              ((0x0094  << 2) + 0xfe036400)
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.
#define DMC_DRAM_STAT                              ((0x0095  << 2) + 0xfe036400)
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:15   sleep_st
  //bit 14:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
                          //1 :   ACCESS sending precharge command.
                          //2 :   ACCESS sending AUTO REFRESH command.
                          //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
                          //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
                          //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.
  //bit 11:8   APD STATUS:   0 :   APD_IDLE
                          //1 :    APD sending PRECHARGE command
                          //2 :    APD sending CKE low command
                          //3 :    APD sending DISABLE DRAM CLOCK command
                          //4 :    APD sending DFI_LP_CTRL_REQ
                          //5 :    APD in Auto Power down mode.
                          //6 :    APD deassert DFI_LP_CTRL_REQ
                          //7 :    APD sending enable DRAM CLOCK command
                          //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
                         //1  :    DRAM_STOP/DRAM_CFG
                         //2  :    DRAM_ACCESS
                         //3  :    DRAM_SLEEP
                         //4  :    DRAM APD(AUTO POWER DOWN).
                         //5  :    IDLE -> STOP/CONFIG
                         //6  :    STOP -> SLEEP
                         //7  :    STOP -> ACCESS
                         //8  :    ACCESS -> SLEEP.
                         //9  :    ACCESS -> STOP
                         //A  :    ACCESS -> APD
                         //B  :    SLEEP -> STOP
                         //C  :    SLEEP -> ACCESS
                         //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.
#define DMC_DRAM_STAT1                             ((0x0096  << 2) + 0xfe036400)
  //bit 11:8  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 7:5   train_st
  //bit 4:0   dram_phy_st
#define DMC_PHY_RETRAINING_CTRL                    ((0x0097  << 2) + 0xfe036400)
  //bit 31 :  phy_retraining enable.
  //bit 30 :  check  vpu sleep_en.
  //bit 25:24 : retraining dfi_freq[4:3], the [2:0] bit still use the dfi_freq bits to keep the frequency.
  //bit 23:0: retraining period unit : 100ns.
#define DMC_DFI_ERR_STAT                           ((0x0098  << 2) + 0xfe036400)
 //LPDDR4 PHY DFI error infomation.
 //bit 31:20. not used.
 //bit 9.    ddr0_dfi_error
 //bit 8:5   ddr0_dfi_error_info.
 //bit 4.    ddr1_dfi_error.
 //bit 3:0.  ddr1_dfi_error_info.
#define DMC_LP2_TIMER                              ((0x009a  << 2) + 0xfe036400)
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register. if the counter is large than this number,  that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.
#define DMC_DRAM_COMPLETE_WAIT                     ((0x009b  << 2) + 0xfe036400)
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.
#define DMC_DRAM_DFI_SWAP_0                        ((0x00a0  << 2) + 0xfe036400)
  //bit 5:0. dfi_act_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_1                        ((0x00a1  << 2) + 0xfe036400)
  //bit 5:0. dfi_ras_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_2                        ((0x00a2  << 2) + 0xfe036400)
  //bit 5:0. dfi_cas_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_3                        ((0x00a3  << 2) + 0xfe036400)
  //bit 5:0. dfi_we_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_4                        ((0x00a4  << 2) + 0xfe036400)
  //bit 5:0. dfi_bg0 function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_5                        ((0x00a5  << 2) + 0xfe036400)
  //bit 5:0. dfi_bg[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_6                        ((0x00a6  << 2) + 0xfe036400)
  //bit 5:0. dfi_ba[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_7                        ((0x00a7  << 2) + 0xfe036400)
  //bit 5:0. dfi_ba[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_8                        ((0x00a8  << 2) + 0xfe036400)
  //bit 5:0. dfi_ba[2] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_9                        ((0x00a9  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_10                       ((0x00aa  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[1] function select
#define DMC_DRAM_DFI_SWAP_11                       ((0x00ab  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[2] function select
#define DMC_DRAM_DFI_SWAP_12                       ((0x00ac  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[3] function select
#define DMC_DRAM_DFI_SWAP_13                       ((0x00ad  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[4] function select
#define DMC_DRAM_DFI_SWAP_14                       ((0x00ae  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[5] function select
#define DMC_DRAM_DFI_SWAP_15                       ((0x00af  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[6] function select
#define DMC_DRAM_DFI_SWAP_16                       ((0x00b0  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[7] function select
#define DMC_DRAM_DFI_SWAP_17                       ((0x00b1  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[8] function select
#define DMC_DRAM_DFI_SWAP_18                       ((0x00b2  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[9] function select
#define DMC_DRAM_DFI_SWAP_19                       ((0x00b3  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[10] function select
#define DMC_DRAM_DFI_SWAP_20                       ((0x00b4  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[11] function select
#define DMC_DRAM_DFI_SWAP_21                       ((0x00b5  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[12] function select
#define DMC_DRAM_DFI_SWAP_22                       ((0x00b6  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[13] function select
#define DMC_DRAM_DFI_SWAP_23                       ((0x00b7  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[14] function select
#define DMC_DRAM_DFI_SWAP_24                       ((0x00b8  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[15] function select
#define DMC_DRAM_DFI_SWAP_25                       ((0x00b9  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[16] function select
#define DMC_DRAM_DFI_SWAP_26                       ((0x00ba  << 2) + 0xfe036400)
  //bit 5:0. dfi_a[17] function select
#define DMC_DRAM_CMD                               ((0x00d0  << 2) + 0xfe036400)
 //bit 31. cmd done.  write 0 to clean.
 //bit 30. data done. write 0 to clean.
 //bit 8.  1: MPC/MRR comand is in a 16bits width SDRAM. 0 : normal operation.
 //bit 5.  user defined command.
 //bit 4.  LPDDR4 MPC write data command( MPC WR FIFO).
 //bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO).
 //bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
 //bit 1.  mrr comand.
 //bit 0.  mrw command.
#define DMC_DRAM_CMD_CODE                          ((0x00d1  << 2) + 0xfe036400)
 //bit 31:28  user command case: = {act_n, ras_n, cas_n, we_n}
 //bit 27:26. 128bits data cycles . 0: 1 clock cycles;  1: 2  clock cycles; 2: 3 clock cycles; 3:4 clock cycles.
 //           LPDDR4 : 4 clock cycles;
 //           DDR3/4/LPDDR3  : 2 clock cycles.
 //bit 25     MRW/MRR/MPC command rank 1 select.  1: select.  0: not select.
 //bit 24.    MRW/MRR/MPC command rank 0 select.  1: select.  0: not select.
 //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
 //bit 15:0   opcode.
#define DMC_DRAM_CMD_TIME                          ((0x00d2  << 2) + 0xfe036400)
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.
#define DMC_DRAM_WSTRB0                            ((0x00d3  << 2) + 0xfe036400)
#define DMC_DRAM_WSTRB1                            ((0x00d4  << 2) + 0xfe036400)
#define DMC_DRAM_RDBI0                             ((0x00d5  << 2) + 0xfe036400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1                             ((0x00d6  << 2) + 0xfe036400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.
//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER comand enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command, the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n, ras_n, cas_n, we_n} value for user command
                                     //in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
             //DDR3:    18:16 bank address. 15:0:  address.
             //DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
             //LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
             //LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge address. 23:18, forth edge address.
           //MRW command format:
              //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
              //bit 15:0   opcode.
#define DMC_DRAM_WD0                               ((0x00e0  << 2) + 0xfe036400)
#define DMC_DRAM_WD1                               ((0x00e1  << 2) + 0xfe036400)
#define DMC_DRAM_WD2                               ((0x00e2  << 2) + 0xfe036400)
#define DMC_DRAM_WD3                               ((0x00e3  << 2) + 0xfe036400)
#define DMC_DRAM_WD4                               ((0x00e4  << 2) + 0xfe036400)
#define DMC_DRAM_WD5                               ((0x00e5  << 2) + 0xfe036400)
#define DMC_DRAM_WD6                               ((0x00e6  << 2) + 0xfe036400)
#define DMC_DRAM_WD7                               ((0x00e7  << 2) + 0xfe036400)
#define DMC_DRAM_WD8                               ((0x00e8  << 2) + 0xfe036400)
#define DMC_DRAM_WD9                               ((0x00e9  << 2) + 0xfe036400)
#define DMC_DRAM_WD10                              ((0x00ea  << 2) + 0xfe036400)
#define DMC_DRAM_WD11                              ((0x00eb  << 2) + 0xfe036400)
#define DMC_DRAM_WD12                              ((0x00ec  << 2) + 0xfe036400)
#define DMC_DRAM_WD13                              ((0x00ed  << 2) + 0xfe036400)
#define DMC_DRAM_WD14                              ((0x00ee  << 2) + 0xfe036400)
#define DMC_DRAM_WD15                              ((0x00ef  << 2) + 0xfe036400)
#define DMC_DRAM_RD0                               ((0x00f0  << 2) + 0xfe036400)
#define DMC_DRAM_RD1                               ((0x00f1  << 2) + 0xfe036400)
#define DMC_DRAM_RD2                               ((0x00f2  << 2) + 0xfe036400)
#define DMC_DRAM_RD3                               ((0x00f3  << 2) + 0xfe036400)
#define DMC_DRAM_RD4                               ((0x00f4  << 2) + 0xfe036400)
#define DMC_DRAM_RD5                               ((0x00f5  << 2) + 0xfe036400)
#define DMC_DRAM_RD6                               ((0x00f6  << 2) + 0xfe036400)
#define DMC_DRAM_RD7                               ((0x00f7  << 2) + 0xfe036400)
#define DMC_DRAM_RD8                               ((0x00f8  << 2) + 0xfe036400)
#define DMC_DRAM_RD9                               ((0x00f9  << 2) + 0xfe036400)
#define DMC_DRAM_RD10                              ((0x00fa  << 2) + 0xfe036400)
#define DMC_DRAM_RD11                              ((0x00fb  << 2) + 0xfe036400)
#define DMC_DRAM_RD12                              ((0x00fc  << 2) + 0xfe036400)
#define DMC_DRAM_RD13                              ((0x00fd  << 2) + 0xfe036400)
#define DMC_DRAM_RD14                              ((0x00fe  << 2) + 0xfe036400)
#define DMC_DRAM_RD15                              ((0x00ff  << 2) + 0xfe036400)
//`define DMC_STICKY_REG_BASE   32'hfe036800
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe036800
// -----------------------------------------------
//those register is for software save some temporary value. and because it's in RAM. it won't lose if DMC get reseted.
#define DMC_STICKY_0                               ((0x0000  << 2) + 0xfe036800)
#define DMC_STICKY_1                               ((0x0001  << 2) + 0xfe036800)
#define DMC_STICKY_2                               ((0x0002  << 2) + 0xfe036800)
#define DMC_STICKY_3                               ((0x0003  << 2) + 0xfe036800)
#define DMC_STICKY_4                               ((0x0004  << 2) + 0xfe036800)
#define DMC_STICKY_5                               ((0x0005  << 2) + 0xfe036800)
#define DMC_STICKY_6                               ((0x0006  << 2) + 0xfe036800)
#define DMC_STICKY_7                               ((0x0007  << 2) + 0xfe036800)
#define DMC_STICKY_8                               ((0x0008  << 2) + 0xfe036800)
#define DMC_STICKY_9                               ((0x0009  << 2) + 0xfe036800)
#define DMC_STICKY_10                              ((0x000a  << 2) + 0xfe036800)
#define DMC_STICKY_11                              ((0x000b  << 2) + 0xfe036800)
#define DMC_STICKY_12                              ((0x000c  << 2) + 0xfe036800)
#define DMC_STICKY_13                              ((0x000d  << 2) + 0xfe036800)
#define DMC_STICKY_14                              ((0x000e  << 2) + 0xfe036800)
#define DMC_STICKY_15                              ((0x000f  << 2) + 0xfe036800)
#define DMC_STICKY_16                              ((0x0010  << 2) + 0xfe036800)
#define DMC_STICKY_17                              ((0x0011  << 2) + 0xfe036800)
#define DMC_STICKY_18                              ((0x0012  << 2) + 0xfe036800)
#define DMC_STICKY_19                              ((0x0013  << 2) + 0xfe036800)
#define DMC_STICKY_20                              ((0x0014  << 2) + 0xfe036800)
#define DMC_STICKY_21                              ((0x0015  << 2) + 0xfe036800)
#define DMC_STICKY_22                              ((0x0016  << 2) + 0xfe036800)
#define DMC_STICKY_23                              ((0x0017  << 2) + 0xfe036800)
#define DMC_STICKY_24                              ((0x0018  << 2) + 0xfe036800)
#define DMC_STICKY_25                              ((0x0019  << 2) + 0xfe036800)
#define DMC_STICKY_26                              ((0x001a  << 2) + 0xfe036800)
#define DMC_STICKY_27                              ((0x001b  << 2) + 0xfe036800)
#define DMC_STICKY_28                              ((0x001c  << 2) + 0xfe036800)
#define DMC_STICKY_29                              ((0x001d  << 2) + 0xfe036800)
#define DMC_STICKY_30                              ((0x001e  << 2) + 0xfe036800)
#define DMC_STICKY_31                              ((0x001f  << 2) + 0xfe036800)
#define DMC_STICKY_32                              ((0x0020  << 2) + 0xfe036800)
#define DMC_STICKY_33                              ((0x0021  << 2) + 0xfe036800)
#define DMC_STICKY_34                              ((0x0022  << 2) + 0xfe036800)
#define DMC_STICKY_35                              ((0x0023  << 2) + 0xfe036800)
#define DMC_STICKY_36                              ((0x0024  << 2) + 0xfe036800)
#define DMC_STICKY_37                              ((0x0025  << 2) + 0xfe036800)
#define DMC_STICKY_38                              ((0x0026  << 2) + 0xfe036800)
#define DMC_STICKY_39                              ((0x0027  << 2) + 0xfe036800)
#define DMC_STICKY_40                              ((0x0028  << 2) + 0xfe036800)
#define DMC_STICKY_41                              ((0x0029  << 2) + 0xfe036800)
#define DMC_STICKY_42                              ((0x002a  << 2) + 0xfe036800)
#define DMC_STICKY_43                              ((0x002b  << 2) + 0xfe036800)
#define DMC_STICKY_44                              ((0x002c  << 2) + 0xfe036800)
#define DMC_STICKY_45                              ((0x002d  << 2) + 0xfe036800)
#define DMC_STICKY_46                              ((0x002e  << 2) + 0xfe036800)
#define DMC_STICKY_47                              ((0x002f  << 2) + 0xfe036800)
#define DMC_STICKY_48                              ((0x0030  << 2) + 0xfe036800)
#define DMC_STICKY_49                              ((0x0031  << 2) + 0xfe036800)
#define DMC_STICKY_50                              ((0x0032  << 2) + 0xfe036800)
#define DMC_STICKY_51                              ((0x0033  << 2) + 0xfe036800)
#define DMC_STICKY_52                              ((0x0034  << 2) + 0xfe036800)
#define DMC_STICKY_53                              ((0x0035  << 2) + 0xfe036800)
#define DMC_STICKY_54                              ((0x0036  << 2) + 0xfe036800)
#define DMC_STICKY_55                              ((0x0037  << 2) + 0xfe036800)
#define DMC_STICKY_56                              ((0x0038  << 2) + 0xfe036800)
#define DMC_STICKY_57                              ((0x0039  << 2) + 0xfe036800)
#define DMC_STICKY_58                              ((0x003a  << 2) + 0xfe036800)
#define DMC_STICKY_59                              ((0x003b  << 2) + 0xfe036800)
#define DMC_STICKY_60                              ((0x003c  << 2) + 0xfe036800)
#define DMC_STICKY_61                              ((0x003d  << 2) + 0xfe036800)
#define DMC_STICKY_62                              ((0x003e  << 2) + 0xfe036800)
#define DMC_STICKY_63                              ((0x003f  << 2) + 0xfe036800)
//`define DMC_SEC_REG_BASE                32'hfe037000
// -----------------------------------------------
// REG_BASE:  APB1_BASE_ADDR = 0xfe037000
// -----------------------------------------------
//DMC use 15bits ID to identify the input ports and ID.
// bit 14:10.
// AXI bus ID number from 0 ~15.  2, 8~10, 12~15 Not used the others defined as bellow.
// 0 : CPU and MALI.   Mali and cpu will be seperated to 2 channel. CPU traffic will be assigned to ID = 0. Mali traffic will assigned to ID =1.
// 1 : Mali
// 3 : HDMI.
// 4 : HEVC.   //HEVC_F/B combined to one
// 5 : TEST.
// 6 : USB
// 7 : Device.
//11 : DEMUX
// 16: VPU read 0.
// 17: VPU read 1.
// 18: VPU read 2.
// 19: VPU write 0.
// 20: VPU write 1.
// 21: VDEC.
// 22: HCODEC.
// 23: ge2d.
//control bit for  SubID functions for all the input.
// ARM   2 bit.    HPROT[1] == 0 : SECURE CPU;   HPROT[1] == 1 : NONSEC CPU.
// GPU   2 bit.    HPROT[2] == 1 : SECURE GPU;   HPROT[2] == 0 : NONSEC GPU access;
// HDCP  4 bits.   ID AR/AWID[1:0].
// HEVC  9 bits.   HEVC use ARUSER/AWUSER[3:0] 16 levels of security control.
// TEST  1 type.
// USB   1 type.
// DEVICE  DMA    : AR/AWID[7:3] == 4'h2.  8bits control   use AR/WID[3:1].
//         AUDIO  : AR/AWID[7:3] == 4'h6.  8bits control.  use AR/AWID[2:0].
//         the others total 16 bits use AR/AWID[7:3].  bit 2 and bit 6 not used.
//VPU the 5 VPU ports use ARSEC/AWSEC as the security control.
//VDEC  total 16bits.  use AR/WID[5:2]
//GE2D. total 3bits.  2 read bits, check ARID[0].  1 write bit.   AWID dont care.
//there's total 16 ranges in the whole memory range.
// 15 ranges can be defined in 64kbyte boundary start address and end address.
// the 16th range is all other space not defined by 15 ranges.
// Each range can be enabled or disabled and  each range use security level bit to select key to do data scramble.
// The ranges can be overlapped or crossover.  But from 0 to 15 ranges, the earlier has higher priority.
#define DMC_SEC_RANGE0_CTRL                        ((0x0000  << 2) + 0xfe037000)
  //bit 31:16   | 0 | range0_eda | range 0 end address  higher 16bits.
  //bit 15:0    | 0 | range0_sta | range 0 start address higher 16bits.
#define DMC_SEC_RANGE0_CTRL1                       ((0x0001  << 2) + 0xfe037000)
  //bit 7:5 | 0 | range0_security_level | range0 security level for DMC and DEMUX only.
  //bit 4  | 0 | range0_prot_en       | range0 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range0_local_des_en  | range0 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES_EN to decide this region data describe enable or not.
  //bit 2  | 0 | range0_lock  |  lock range 0 registers. write 1 to lock range 0 register. can't change anymore.
  //bit 1  | 0 | range0_key_sel | range 0 data describe key selection.  1 : key1. 0 : key0.
  //bit 0  | 0 | range0_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE1_CTRL                        ((0x0002  << 2) + 0xfe037000)
  //bit 31:16   | 0 | range1_eda | range 1 end address  higher 16bits.
  //bit 15:0    | 0 | range1_sta | range 1 start address higher 16bits.
#define DMC_SEC_RANGE1_CTRL1                       ((0x0003  << 2) + 0xfe037000)
  //bit 7:5 | 0 | range1_security_level | range1 security level for DMC and DEMUX only.
  //bit 4  | 0 | range1_prot_en       | range1 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range1_local_des_en  | range1 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES_EN to decide this region data describe enable or not.
  //bit 2  | 0 | range1_lock  |  lock range 1 registers. write 1 to lock range 1 register. can't change anymore.
  //bit 1  | 0 | range1_key_sel | range 1 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range1_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE2_CTRL                        ((0x0004  << 2) + 0xfe037000)
  //bit 31:16   | 0 | range2_eda | range 2 end address  higher 16bits.
  //bit 15:0    | 0 | range2_sta | range 2 start address higher 16bits.
#define DMC_SEC_RANGE2_CTRL1                       ((0x0005  << 2) + 0xfe037000)
  //bit 7:5 | 0 | range2_security_level | range2 security level for DMC and DEMUX only.
  //bit 4  | 0 | range2_prot_en       | range2 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range2_local_des_en  | range2 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describe enable or not.
  //bit 2  | 0 | range2_lock  |  lock range 2 registers. write 1 to lock range 2 register. can't change anymore.
  //bit 1  | 0 | range2_key_sel | range 2 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range2_en    | range 2 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE3_CTRL                        ((0x0006  << 2) + 0xfe037000)
  //bit 31:16   | 0 | range3_eda | range 3 end address  higher 16bits.
  //bit 15:0    | 0 | range3_sta | range 3 start address higher 16bits.
#define DMC_SEC_RANGE3_CTRL1                       ((0x0007  << 2) + 0xfe037000)
  //bit 7:5 | 0 | range3_security_level | range3 security level for DMC and DEMUX only.
  //bit 4  | 0 | range3_prot_en       | range3 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range3_local_des_en  | range3 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describe enable or not.
  //bit 2  | 0 | range3_lock    | lock range 3 registers. write 1 to lock range 3 related registers. can't change anymore.
  //bit 1  | 0 | range3_key_sel | range 3 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range3_en      | range 3 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE4_CTRL                        ((0x0008  << 2) + 0xfe037000)
  //bit 31:16   | 0 | range4_eda | range 4 end address  higher 16bits.
  //bit 15:0    | 0 | range4_sta | range 4 start address higher 16bits.
#define DMC_SEC_RANGE4_CTRL1                       ((0x0009  << 2) + 0xfe037000)
  //bit 7:5 | 0 | range4_security_level | range4 security level for DMC and DEMUX only.
  //bit 4  | 0 | range4_prot_en       | range4 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range4_local_des_en  | range4 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describe enable or not.
  //bit 2  | 0 | range4_lock    | lock range 4 registers. write 1 to lock range 4 related registers. can't change anymore.
  //bit 1  | 0 | range4_key_sel | range 4 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range4_en      | range 4 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE5_CTRL                        ((0x000a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_CTRL1                       ((0x000b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_CTRL                        ((0x000c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_CTRL1                       ((0x000d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_CTRL                        ((0x000e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_CTRL1                       ((0x000f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_CTRL                        ((0x0010  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_CTRL1                       ((0x0011  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_CTRL                        ((0x0012  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_CTRL1                       ((0x0013  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_CTRL                       ((0x0014  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_CTRL1                      ((0x0015  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_CTRL                       ((0x0016  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_CTRL1                      ((0x0017  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_CTRL                       ((0x0018  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_CTRL1                      ((0x0019  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_CTRL                       ((0x001a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_CTRL1                      ((0x001b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_CTRL                       ((0x001c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_CTRL1                      ((0x001d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_CTRL1                      ((0x001f  << 2) + 0xfe037000)
  //default : 0
  //bit 7:5 | 0 | range1_security_level | range1 security level for DMC and DEMUX only.
  //bit 4  | 0 | range1_prot_en       | range1 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range1_local_des_en  | range1 data describe enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES_EN to decide this region data describe enable or not.
  //bit 2  | 0 | range1_lock  |  lock range 1 registers. write 1 to lock range 1 register. can't change anymore.
  //bit 1  | 0 | range1_key_sel | range 1 data describe key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | not used. range 15 is always enabled.
//for each range there's 96bits read/write subid control to control all master DDR access.
//the 96bits assignments  rangex_rd_sid_en[95:0] and range_wr_sid_en[95:0] is as below:
//bit 3:0. for CPU  ARPROT[2:1]/AWPROT[2:1] selection.
      //CPU ARPROT[2:1] /AWPROT[2:1] define:
//bit0 PROT[2:1]==00:   data secure access.
//bit1 PROT[2:1]==01:   data non-secure access.
//bit2 PROT[2:1] 10:    instruction secure access.
//bit3 PROT[2:1] 11:    instruction non-secure access.
//per range per sub ID access enable.
#define DMC_SEC_RANGE0_RID_CTRL0                   ((0x0020  << 2) + 0xfe037000)
  //default : 0
  //range0_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1                   ((0x0021  << 2) + 0xfe037000)
  //default : 0
  //range0_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_RID_CTRL2                   ((0x0022  << 2) + 0xfe037000)
  //default : 0
  //range0_rd_sid_en[95:64];
#define DMC_SEC_RANGE0_RID_CTRL3                   ((0x0023  << 2) + 0xfe037000)
  //default : 0
  // not used.
#define DMC_SEC_RANGE0_RID_CTRL4                   ((0x0024  << 2) + 0xfe037000)
  //default : 0 not used in
#define DMC_SEC_RANGE1_RID_CTRL0                   ((0x0026  << 2) + 0xfe037000)
  //default : 0
  //range1_rd_sid_en[31:0];
#define DMC_SEC_RANGE1_RID_CTRL1                   ((0x0027  << 2) + 0xfe037000)
  //default : 0
  //range1_rd_sid_en[63:32];
#define DMC_SEC_RANGE1_RID_CTRL2                   ((0x0028  << 2) + 0xfe037000)
  //default : 0
  //range1_rd_sid_en[95:64];
#define DMC_SEC_RANGE1_RID_CTRL3                   ((0x0029  << 2) + 0xfe037000)
  // not used.
#define DMC_SEC_RANGE1_RID_CTRL4                   ((0x002a  << 2) + 0xfe037000)
  // not used.
#define DMC_SEC_RANGE2_RID_CTRL0                   ((0x002c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_RID_CTRL1                   ((0x002d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_RID_CTRL2                   ((0x002e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_RID_CTRL3                   ((0x002f  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE2_RID_CTRL4                   ((0x0030  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE3_RID_CTRL0                   ((0x0032  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_RID_CTRL1                   ((0x0033  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_RID_CTRL2                   ((0x0034  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_RID_CTRL3                   ((0x0035  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE3_RID_CTRL4                   ((0x0036  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE4_RID_CTRL0                   ((0x0038  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_RID_CTRL1                   ((0x0039  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_RID_CTRL2                   ((0x003a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_RID_CTRL3                   ((0x003b  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE4_RID_CTRL4                   ((0x003c  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE5_RID_CTRL0                   ((0x003e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_RID_CTRL1                   ((0x003f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_RID_CTRL2                   ((0x0040  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_RID_CTRL3                   ((0x0041  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE5_RID_CTRL4                   ((0x0042  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE6_RID_CTRL0                   ((0x0044  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_RID_CTRL1                   ((0x0045  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_RID_CTRL2                   ((0x0046  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_RID_CTRL3                   ((0x0047  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE6_RID_CTRL4                   ((0x0048  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE7_RID_CTRL0                   ((0x004a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_RID_CTRL1                   ((0x004b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_RID_CTRL2                   ((0x004c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_RID_CTRL3                   ((0x004d  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE7_RID_CTRL4                   ((0x004e  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE8_RID_CTRL0                   ((0x0050  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_RID_CTRL1                   ((0x0051  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_RID_CTRL2                   ((0x0052  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_RID_CTRL3                   ((0x0053  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE8_RID_CTRL4                   ((0x0054  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE9_RID_CTRL0                   ((0x0056  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_RID_CTRL1                   ((0x0057  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_RID_CTRL2                   ((0x0058  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_RID_CTRL3                   ((0x0059  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_RID_CTRL4                   ((0x005a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_RID_CTRL0                  ((0x005c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_RID_CTRL1                  ((0x005d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_RID_CTRL2                  ((0x005e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_RID_CTRL3                  ((0x005f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_RID_CTRL4                  ((0x0060  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_RID_CTRL0                  ((0x0062  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_RID_CTRL1                  ((0x0063  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_RID_CTRL2                  ((0x0064  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_RID_CTRL3                  ((0x0065  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_RID_CTRL4                  ((0x0066  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_RID_CTRL0                  ((0x0068  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_RID_CTRL1                  ((0x0069  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_RID_CTRL2                  ((0x006a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_RID_CTRL3                  ((0x006b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_RID_CTRL4                  ((0x006c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_RID_CTRL0                  ((0x006e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_RID_CTRL1                  ((0x006f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_RID_CTRL2                  ((0x0070  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_RID_CTRL3                  ((0x0071  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_RID_CTRL4                  ((0x0072  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_RID_CTRL0                  ((0x0074  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_RID_CTRL1                  ((0x0075  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_RID_CTRL2                  ((0x0076  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_RID_CTRL3                  ((0x0077  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_RID_CTRL4                  ((0x0078  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_RID_CTRL0                  ((0x007a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_RID_CTRL1                  ((0x007b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_RID_CTRL2                  ((0x007c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_RID_CTRL3                  ((0x007d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_RID_CTRL4                  ((0x007e  << 2) + 0xfe037000)
//per range per sub ID access enable.
#define DMC_SEC_RANGE0_WID_CTRL0                   ((0x0080  << 2) + 0xfe037000)
  //default : 0
  //range0_wr_sid_en[31:0];
#define DMC_SEC_RANGE0_WID_CTRL1                   ((0x0081  << 2) + 0xfe037000)
  //default : 0
  //range0_wr_sid_en[63:32];
#define DMC_SEC_RANGE0_WID_CTRL2                   ((0x0082  << 2) + 0xfe037000)
  //default : 0
  //range0_wr_sid_en[95:64];
#define DMC_SEC_RANGE0_WID_CTRL3                   ((0x0083  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE0_WID_CTRL4                   ((0x0084  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE1_WID_CTRL0                   ((0x0086  << 2) + 0xfe037000)
  //default : 0
  //range1_wr_sid_en[31:0];
#define DMC_SEC_RANGE1_WID_CTRL1                   ((0x0087  << 2) + 0xfe037000)
  //default : 0
  //range1_wr_sid_en[63:32];
#define DMC_SEC_RANGE1_WID_CTRL2                   ((0x0088  << 2) + 0xfe037000)
  //default : 0
  //range1_wr_sid_en[95:64];
#define DMC_SEC_RANGE1_WID_CTRL3                   ((0x0089  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE1_WID_CTRL4                   ((0x008a  << 2) + 0xfe037000)
  //not used.
#define DMC_SEC_RANGE2_WID_CTRL0                   ((0x008c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_WID_CTRL1                   ((0x008d  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_WID_CTRL2                   ((0x008e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_WID_CTRL3                   ((0x008f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE2_WID_CTRL4                   ((0x0090  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_WID_CTRL0                   ((0x0092  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_WID_CTRL1                   ((0x0093  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_WID_CTRL2                   ((0x0094  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_WID_CTRL3                   ((0x0095  << 2) + 0xfe037000)
#define DMC_SEC_RANGE3_WID_CTRL4                   ((0x0096  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_WID_CTRL0                   ((0x0098  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_WID_CTRL1                   ((0x0099  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_WID_CTRL2                   ((0x009a  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_WID_CTRL3                   ((0x009b  << 2) + 0xfe037000)
#define DMC_SEC_RANGE4_WID_CTRL4                   ((0x009c  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_WID_CTRL0                   ((0x009e  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_WID_CTRL1                   ((0x009f  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_WID_CTRL2                   ((0x00a0  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_WID_CTRL3                   ((0x00a1  << 2) + 0xfe037000)
#define DMC_SEC_RANGE5_WID_CTRL4                   ((0x00a2  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_WID_CTRL0                   ((0x00a4  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_WID_CTRL1                   ((0x00a5  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_WID_CTRL2                   ((0x00a6  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_WID_CTRL3                   ((0x00a7  << 2) + 0xfe037000)
#define DMC_SEC_RANGE6_WID_CTRL4                   ((0x00a8  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_WID_CTRL0                   ((0x00aa  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_WID_CTRL1                   ((0x00ab  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_WID_CTRL2                   ((0x00ac  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_WID_CTRL3                   ((0x00ad  << 2) + 0xfe037000)
#define DMC_SEC_RANGE7_WID_CTRL4                   ((0x00ae  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_WID_CTRL0                   ((0x00b0  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_WID_CTRL1                   ((0x00b1  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_WID_CTRL2                   ((0x00b2  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_WID_CTRL3                   ((0x00b3  << 2) + 0xfe037000)
#define DMC_SEC_RANGE8_WID_CTRL4                   ((0x00b4  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_WID_CTRL0                   ((0x00b6  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_WID_CTRL1                   ((0x00b7  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_WID_CTRL2                   ((0x00b8  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_WID_CTRL3                   ((0x00b9  << 2) + 0xfe037000)
#define DMC_SEC_RANGE9_WID_CTRL4                   ((0x00ba  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_WID_CTRL0                  ((0x00bc  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_WID_CTRL1                  ((0x00bd  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_WID_CTRL2                  ((0x00be  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_WID_CTRL3                  ((0x00bf  << 2) + 0xfe037000)
#define DMC_SEC_RANGE10_WID_CTRL4                  ((0x00c0  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_WID_CTRL0                  ((0x00c2  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_WID_CTRL1                  ((0x00c3  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_WID_CTRL2                  ((0x00c4  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_WID_CTRL3                  ((0x00c5  << 2) + 0xfe037000)
#define DMC_SEC_RANGE11_WID_CTRL4                  ((0x00c6  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_WID_CTRL0                  ((0x00c8  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_WID_CTRL1                  ((0x00c9  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_WID_CTRL2                  ((0x00ca  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_WID_CTRL3                  ((0x00cb  << 2) + 0xfe037000)
#define DMC_SEC_RANGE12_WID_CTRL4                  ((0x00cc  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_WID_CTRL0                  ((0x00ce  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_WID_CTRL1                  ((0x00cf  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_WID_CTRL2                  ((0x00d0  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_WID_CTRL3                  ((0x00d1  << 2) + 0xfe037000)
#define DMC_SEC_RANGE13_WID_CTRL4                  ((0x00d2  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_WID_CTRL0                  ((0x00d4  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_WID_CTRL1                  ((0x00d5  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_WID_CTRL2                  ((0x00d6  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_WID_CTRL3                  ((0x00d7  << 2) + 0xfe037000)
#define DMC_SEC_RANGE14_WID_CTRL4                  ((0x00d8  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_WID_CTRL0                  ((0x00da  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_WID_CTRL1                  ((0x00db  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_WID_CTRL2                  ((0x00dc  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_WID_CTRL3                  ((0x00dd  << 2) + 0xfe037000)
#define DMC_SEC_RANGE15_WID_CTRL4                  ((0x00de  << 2) + 0xfe037000)
#define DMC_DES_CTRL                               ((0x00e1  << 2) + 0xfe037000)
 //bit 31 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN. 0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
 //bit 30 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && GLOBAL_DES_EN. 0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
 //bit 29 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
 //bit 28 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
 //bit 27 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN. 0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
 //bit 26 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && GLOBAL_DES_EN. 0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
 //bit 25 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
 //bit 24 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
 //bit 23 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN. 0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
 //bit 22 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
 //bit 21 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
 //bit 20 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN. 0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
 //bit 19 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
 //bit 18 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
 //bit 17 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN. 0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
 //bit 16 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && GLOBAL_DES_EN. 0 :  range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.
 //bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
 //bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit, DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.
//DES KEY registers and DES_PADDING can only be reset by pad reset.  But it can be changed by software after watch dog reset.
#define DMC_DES_KEY0_REG0                          ((0x00e2  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY0_REG1                          ((0x00e3  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY0_REG2                          ((0x00e4  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY0_REG3                          ((0x00e5  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY1_REG0                          ((0x00e6  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY1_REG1                          ((0x00e7  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY1_REG2                          ((0x00e8  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_KEY1_REG3                          ((0x00e9  << 2) + 0xfe037000)
  //default : 0
#define DMC_DES_PADDING                            ((0x00e0  << 2) + 0xfe037000)
  //default : 0
  //bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.
//FROM SC2, the APB bus provided Master ID through PUSER signals.
//there's total 8 master IDs could access DMC non-secure registers.
//we assign 1 control bit for each APB Master and each DMC non-secure register domains
//and we added one lock bits to lock this setting can't be modified any more.
#define DDR_APB_SEC_CTRL0                          ((0x00f0  << 2) + 0xfe037000)
   // APB access  control for dmc REQUEST control register access control register.
   // default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL1                          ((0x00f1  << 2) + 0xfe037000)
   // APB access control for DMC DRAM timing parameter and DFI inteface registers.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL2                          ((0x00f2  << 2) + 0xfe037000)
   // APB access control for DMC PLL clock frequency control regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL3                          ((0x00f3  << 2) + 0xfe037000)
   // APB access control for DMC sticky control regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL4                          ((0x00f4  << 2) + 0xfe037000)
   // APB access control for DMC test control regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL5                          ((0x00f5  << 2) + 0xfe037000)
   // APB access control for DMC clk reset control regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL6                          ((0x00f6  << 2) + 0xfe037000)
   // APB access control for DMC protection regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL7                          ((0x00f7  << 2) + 0xfe037000)
   // APB access control for DMC normal regsiter.
   //default : 0x0ff
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL8                          ((0x00f8  << 2) + 0xfe037000)
   // APB access control for DDR PHY group regsiters.
   //default : 0x50005
   //bit 23:16.  APB access enable for DDR PHY group 1 register.
   //bit 10  PHY IMEM control 1: force PHY IMEM output 0. 0: normal working mode.
   //bit 9   PHY DMEM control 1: force PHY DMEM output 0. 0: normal working mode.
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
#define DDR_APB_SEC_CTRL9                          ((0x00f9  << 2) + 0xfe037000)
   // APB access control for DMC canvas regsiter.
   //default : 0x005
   //bit 8    lock bit if this bit =  1,  this register is locked and cannot modified anymore.
   //bit 7:0.  APB access enable for each APB user ID. one ID one bit. 1: enable. 0 disable.
//registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS                             ((0x00fa  << 2) + 0xfe037000)
 //bit 31~2. not used.
 //bit 6
 //bit 5
 //bit 4
 //bit 3   1 : normal security register write violation.( APB bus WDATA not equal the register value when APB write).  write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC security register alert function triggered. can't clean. only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.
#define DMC_VIO_ADDR0                              ((0x00fb  << 2) + 0xfe037000)
  //ddr0 write secure violation address.
#define DMC_VIO_ADDR1                              ((0x00fc  << 2) + 0xfe037000)
  //bit 31:26 . not used. always 0.
  //24      ddr0 secure check violation.
  //23:21.  not used.
  //20     ddr0 write address overflow. write out of DDR size.
  //13:12  Not used.
  //11:0   ddr0_write violation ID. bit 11~9. Master ID bit 7:4 for subid.
#define DMC_VIO_ADDR2                              ((0x00fd  << 2) + 0xfe037000)
  //ddr0 read secure violation address
#define DMC_VIO_ADDR3                              ((0x00fe  << 2) + 0xfe037000)
  //bit 31:26. not used. always 0.
  //24     ddr0 read secure check violation.
  //23:21. Not used.
  //20     ddr 0 read address overflow. write out of DDR size.
  //19:15. not used.
  //14:0   ddr 0 read violation USER bit.
#define DMC_DDR_CTRL                               ((0x0100  << 2) + 0xfe037000)
   //bit 27.   0 : canvas use 64bytes boundary
              // 1 : canvas use 32bytes boundary.
  //bit 24:22   3'b000 : ddr3 mode.
              //3'b001 : ddr4 mode.
              //3'b010 : lpddr3 mode.
              //3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. 0 : normal data interface.
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b0101 : DDR rank 1 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b0101 : DDR rank 0 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
//DDR3/4 LPDDR3/4 SDRAM address  to 32bits linear address address map:
//DDR0_ADDRMAP is used to select RANK0 bank, row, col address selection.
//DDR1_ADDRMAP is used to select RANK1 bank, row, col address selection.
#define DDR0_ADDRMAP_0                             ((0x0101  << 2) + 0xfe037000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.
#define DDR0_ADDRMAP_1                             ((0x0102  << 2) + 0xfe037000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.
#define DDR0_ADDRMAP_2                             ((0x0103  << 2) + 0xfe037000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.
#define DDR0_ADDRMAP_3                             ((0x0104  << 2) + 0xfe037000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.
#define DDR0_ADDRMAP_4                             ((0x0105  << 2) + 0xfe037000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2.    or bg0 for DDR4.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.
#define DDR1_ADDRMAP_0                             ((0x0106  << 2) + 0xfe037000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.
#define DDR1_ADDRMAP_1                             ((0x0107  << 2) + 0xfe037000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.
#define DDR1_ADDRMAP_2                             ((0x0108  << 2) + 0xfe037000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.
#define DDR1_ADDRMAP_3                             ((0x0109  << 2) + 0xfe037000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.
#define DDR1_ADDRMAP_4                             ((0x010a  << 2) + 0xfe037000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2  or bg0 for DDR4 SDRAM..
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.
#define DMC_AXI2DDR0                               ((0x0120  << 2) + 0xfe037000)
  //for AXI address first 256MB  AXI ADDRESS[31:28] == 4'b0000.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr data 16bits mode   0 : 32bits.  1: 16 bits valid data in a 32bits data bus.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR1                               ((0x0121  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0001.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR2                               ((0x0122  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0010.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR3                               ((0x0123  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0011.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR4                               ((0x0124  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0100.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR5                               ((0x0125  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0101.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR6                               ((0x0126  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0110.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR7                               ((0x0127  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b0111.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR8                               ((0x0128  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1000.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR9                               ((0x0129  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1001.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRA                               ((0x012a  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1010.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRB                               ((0x012b  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1011.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRC                               ((0x012c  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1100.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRD                               ((0x012d  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1101.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRE                               ((0x012e  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1110.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRF                               ((0x012f  << 2) + 0xfe037000)
  //for AXI_ADDRESS[31:28] == 4'b1111.
  //bit 7  ddr_data_with   0 : 32bits.  1: 16bits data in a 16bits data bus.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_DDR_CTRL1                              ((0x0130  << 2) + 0xfe037000)
  //bit 1.  1: only allow DMA/DEMUX write data level == region security level.   0:  DMA/DEMUX write data level <= region sec level.
  //bit 0. DMC_DDR_LOCK.    1: LOCK DMC_DDR_CTRL, DMC_DDR_CTRL1, DMC_AXI2DDRx, DDR0/1_ADDRMAP_x registers. those register can't modified any more.
                        //  0: all these regsiters can be read/write by secure APB access.
//
// Closing file:  ./../mmc_lp4/dmc/rtl/dmc_reg.vh
//
//========================================================================
// STARTUP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe02e000
// -----------------------------------------------
#define STARTUP_LOCK                               ((0x0000  << 2) + 0xfe02e000)
#define STARTUP_DFU_STS                            ((0x0004  << 2) + 0xfe02e000)
#define STARTUP_BOOT_SRC                           ((0x0008  << 2) + 0xfe02e000)
#define STARTUP_TEE_REQ_DFU                        ((0x0009  << 2) + 0xfe02e000)
#define STARTUP_BOOT_OVERRIDE                      ((0x000a  << 2) + 0xfe02e000)
#define STARTUP_COLD_BOOT_CNT                      ((0x000b  << 2) + 0xfe02e000)
#define STARTUP_KEY_PRESERVE                       ((0x000c  << 2) + 0xfe02e000)
//========================================================================
// MIPI_DSI_PHY
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01c000
// -----------------------------------------------
//`define MIPI_DSI_PHY_START      8'h00
//`define MIPI_DSI_PHY_END        16'hffff
#define MIPI_DSI_PHY_CTRL                          ((0x0000  << 2) + 0xfe01c000)
  //bit 31.  soft reset for the phy. 1 = reset. 0 = dessert the reset.
  //bit 30.  clock lane soft reset.
  //bit 29.  data byte lane 3 soft reset.
  //bit 28.  data byte lane 2 soft reset.
  //bit 27.  data byte lane 1 soft reset.
  //bit 26.  data byte lane 0 soft reset.
  //bit 5.   LPDT data endian.  1 = transfer the high bit first. 0 : transfer the low bit first.
  //bit 4.   HS data endian.
  //bit 3.  force data byte lane in stop mode.
  //bit 2.  force data byte lane 0 in reciever mode.
  //bit 1. write 1 to sync the txclkesc input. the internal logic have to use txclkesc to decide Txvalid and Txready.
  //bit 0.  enalbe the MIPI DSI PHY TxDDRClk.
#define MIPI_DSI_CHAN_CTRL                         ((0x0001  << 2) + 0xfe01c000)
  //bit 31.   clk lane tx_hs_en control selection.  1 = from register. 0 use clk lane state machine.
  //bit 30.   register bit for clock lane tx_hs_en.
  //bit 29.  clk lane tx_lp_en contrl selection.  1 = from register. 0 from clk lane state machine.
  //bit 28.  register bit for clock lane tx_lp_en.
  //bit 27.  chan0 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 26.  register bit for chan0 tx_hs_en.
  //bit 25.  chan0 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 24. register bit from chan0 tx_lp_en.
  //bit 23.  chan0 rx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 22. register bit from chan0 rx_lp_en.
  //bit 21.  chan0 contention detection enable control selection. 1 = from register. 0 from chan0 state machine.
  //bit 20. register bit from chan0 contention detection enable.
  //bit 19.  chan1 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 18.  register bit for chan1 tx_hs_en.
  //bit 17.  chan1 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 16. register bit from chan1 tx_lp_en.
  //bit 15.  chan2 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 14.  register bit for chan2 tx_hs_en.
  //bit 13.  chan2 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 12. register bit from chan2 tx_lp_en.
  //bit 11. chan3 tx_hs_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 10. register bit for chan3 tx_hs_en.
  //bit 9.  chan3 tx_lp_en control selection. 1 = from register. 0 from chan0 state machine.
  //bit 8. register bit from chan3 tx_lp_en.
  //bit 4.  clk chan power down. this bit is also used as the power down of the whole MIPI_DSI_PHY.
  //bit 3.  chan3 power down.
  //bit 2.  chan2 power down.
  //bit 1.  chan1 power down.
  //bit 0.  chan0 power down.
#define MIPI_DSI_CHAN_STS                          ((0x0002  << 2) + 0xfe01c000)
 //bit 24.  chan0 TX->RX turn can't accept the ACK command from slave watch dog triggered.  write 1 to clear the status bit.
 //bit 23.  chan0 RX ESC command watch dog triggered. write 1 to clean this bit.
 //bit
#define MIPI_DSI_CLK_TIM                           ((0x0003  << 2) + 0xfe01c000)
  //bit 31:24. TCLK_PREPARE.
  //bit 23:16. TCLK_ZERO.
  //bit 15:8.  TCLK_POST.
  //bit 7:0.   TCLK_TRAIL.
#define MIPI_DSI_HS_TIM                            ((0x0004  << 2) + 0xfe01c000)
  //bit 31:24. THS_PREPARE.
  //bit 23:16. THS_ZERO.
  //bit 15:8.  THS_TRAIL.
  //bit 7:0.   THS_EXIT.
#define MIPI_DSI_LP_TIM                            ((0x0005  << 2) + 0xfe01c000)
  //bit 31:24. tTA_GET.
  //bit 23:16. tTA_GO.
  //bit 15:8.  tTA_SURE.
  //bit 7:0.   tLPX.
#define MIPI_DSI_ANA_UP_TIM                        ((0x0006  << 2) + 0xfe01c000)
  //wait time to  MIPI DIS analog ready.
#define MIPI_DSI_INIT_TIM                          ((0x0007  << 2) + 0xfe01c000)
  // TINIT.
#define MIPI_DSI_WAKEUP_TIM                        ((0x0008  << 2) + 0xfe01c000)
  //TWAKEUP.
#define MIPI_DSI_LPOK_TIM                          ((0x0009  << 2) + 0xfe01c000)
  //bit 31:0 when in RxULPS state, RX reciever is in sleep mode.
  //every MIPI_DSI_ULPS_CHECK period, the reciever would be enabled once, and waiting this timer period to get the stable input.
#define MIPI_DSI_LP_WCHDOG                         ((0x000a  << 2) + 0xfe01c000)
  //bit 31:0 watch dog timer for MIPI DSI LP receive state.
#define MIPI_DSI_ANA_CTRL                          ((0x000b  << 2) + 0xfe01c000)
  //bit 31:0 tMBIAS.  timer to wait for analog mBIAS voltage stable.
#define MIPI_DSI_CLK_TIM1                          ((0x000c  << 2) + 0xfe01c000)
  //bit 31:8  not used.
  //bit 7:0    tCLK_PRE
#define MIPI_DSI_TURN_WCHDOG                       ((0x000d  << 2) + 0xfe01c000)
 //bit 31:0 watch dog timer for lane 0 LP turn around waiting time.
#define MIPI_DSI_ULPS_CHECK                        ((0x000e  << 2) + 0xfe01c000)
 //bit 31:0 when Lane0 in LP recieve state,  if the another side sent Low power command,  using this timer to enable Tcheck the another size wakeup nor not.
#define MIPI_DSI_TEST_CTRL0                        ((0x000f  << 2) + 0xfe01c000)
#define MIPI_DSI_TEST_CTRL1                        ((0x0010  << 2) + 0xfe01c000)
//========================================================================
//  rtc dig
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09a000
// -----------------------------------------------
//
//
//
#define RTC_CTRL                                   ((0x0000  << 2) + 0xfe09a000)
#define RTC_COUNTER_REG                            ((0x0001  << 2) + 0xfe09a000)
#define RTC_ALARM0_REG                             ((0x0002  << 2) + 0xfe09a000)
#define RTC_ALARM1_REG                             ((0x0003  << 2) + 0xfe09a000)
#define RTC_ALARM2_REG                             ((0x0004  << 2) + 0xfe09a000)
#define RTC_ALARM3_REG                             ((0x0005  << 2) + 0xfe09a000)
#define RTC_SEC_ADJUST_REG                         ((0x0006  << 2) + 0xfe09a000)
#define RTC_WIDEN_VAL                              ((0x0007  << 2) + 0xfe09a000)
#define RTC_INT_MASK                               ((0x0008  << 2) + 0xfe09a000)
#define RTC_INT_CLR                                ((0x0009  << 2) + 0xfe09a000)
#define RTC_OSCIN_CTRL0                            ((0x000a  << 2) + 0xfe09a000)
#define RTC_OSCIN_CTRL1                            ((0x000b  << 2) + 0xfe09a000)
#define RTC_INT_STATUS                             ((0x000c  << 2) + 0xfe09a000)
#define RTC_REAL_TIME                              ((0x000d  << 2) + 0xfe09a000)
//========================================================================
//  Temp sensor PLL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe020000
// -----------------------------------------------
#define TS_PLL_CFG_REG1                            ((0x0001  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG2                            ((0x0002  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG3                            ((0x0003  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG4                            ((0x0004  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG5                            ((0x0005  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG6                            ((0x0006  << 2) + 0xfe020000)
#define TS_PLL_CFG_REG7                            ((0x0007  << 2) + 0xfe020000)
#define TS_PLL_STAT0                               ((0x0010  << 2) + 0xfe020000)
#define TS_PLL_STAT1                               ((0x0011  << 2) + 0xfe020000)
#define TS_PLL_STAT2                               ((0x0012  << 2) + 0xfe020000)
#define TS_PLL_STAT3                               ((0x0013  << 2) + 0xfe020000)
#define TS_PLL_STAT4                               ((0x0014  << 2) + 0xfe020000)
#define TS_PLL_STAT5                               ((0x0015  << 2) + 0xfe020000)
#define TS_PLL_STAT6                               ((0x0016  << 2) + 0xfe020000)
#define TS_PLL_STAT7                               ((0x0017  << 2) + 0xfe020000)
#define TS_PLL_STAT8                               ((0x0018  << 2) + 0xfe020000)
#define TS_PLL_STAT9                               ((0x0019  << 2) + 0xfe020000)
//========================================================================
//  Temp sensor DDR
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe022000
// -----------------------------------------------
#define TS_DDR_CFG_REG1                            ((0x0001  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG2                            ((0x0002  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG3                            ((0x0003  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG4                            ((0x0004  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG5                            ((0x0005  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG6                            ((0x0006  << 2) + 0xfe022000)
#define TS_DDR_CFG_REG7                            ((0x0007  << 2) + 0xfe022000)
#define TS_DDR_STAT0                               ((0x0010  << 2) + 0xfe022000)
#define TS_DDR_STAT1                               ((0x0011  << 2) + 0xfe022000)
#define TS_DDR_STAT2                               ((0x0012  << 2) + 0xfe022000)
#define TS_DDR_STAT3                               ((0x0013  << 2) + 0xfe022000)
#define TS_DDR_STAT4                               ((0x0014  << 2) + 0xfe022000)
#define TS_DDR_STAT5                               ((0x0015  << 2) + 0xfe022000)
#define TS_DDR_STAT6                               ((0x0016  << 2) + 0xfe022000)
#define TS_DDR_STAT7                               ((0x0017  << 2) + 0xfe022000)
#define TS_DDR_STAT8                               ((0x0018  << 2) + 0xfe022000)
#define TS_DDR_STAT9                               ((0x0019  << 2) + 0xfe022000)
//========================================================================
//  Temp sensor GPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe035000
// -----------------------------------------------
//`define TS_GPU_CFG_REG1                         8'h01
//`define TS_GPU_CFG_REG2                         8'h02
//`define TS_GPU_CFG_REG3                         8'h03
//`define TS_GPU_CFG_REG4                         8'h04
//`define TS_GPU_CFG_REG5                         8'h05
//`define TS_GPU_CFG_REG6                         8'h06
//`define TS_GPU_CFG_REG7                         8'h07
//`define TS_GPU_STAT0                            8'h10
//`define TS_GPU_STAT1                            8'h11
//`define TS_GPU_STAT2                            8'h12
//`define TS_GPU_STAT3                            8'h13
//`define TS_GPU_STAT4                            8'h14
//`define TS_GPU_STAT5                            8'h15
//`define TS_GPU_STAT6                            8'h16
//`define TS_GPU_STAT7                            8'h17
//`define TS_GPU_STAT8                            8'h18
//`define TS_GPU_STAT9                            8'h19
//========================================================================
//  RNG
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe034000
// -----------------------------------------------
//========================================================================
//  ACODEC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01a000
// -----------------------------------------------
#define ACODEC_0                                   ((0x0000  << 2) + 0xfe01a000)
#define ACODEC_1                                   ((0x0001  << 2) + 0xfe01a000)
#define ACODEC_2                                   ((0x0002  << 2) + 0xfe01a000)
#define ACODEC_3                                   ((0x0003  << 2) + 0xfe01a000)
#define ACODEC_4                                   ((0x0004  << 2) + 0xfe01a000)
#define ACODEC_5                                   ((0x0005  << 2) + 0xfe01a000)
#define ACODEC_6                                   ((0x0006  << 2) + 0xfe01a000)
#define ACODEC_7                                   ((0x0007  << 2) + 0xfe01a000)
//========================================================================
//  AML USB PHY A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe03c000
// -----------------------------------------------
#define AMLUSB_A0                                  ((0x0000  << 2) + 0xfe03c000)
#define AMLUSB_A1                                  ((0x0001  << 2) + 0xfe03c000)
#define AMLUSB_A2                                  ((0x0002  << 2) + 0xfe03c000)
#define AMLUSB_A3                                  ((0x0003  << 2) + 0xfe03c000)
#define AMLUSB_A4                                  ((0x0004  << 2) + 0xfe03c000)
#define AMLUSB_A5                                  ((0x0005  << 2) + 0xfe03c000)
#define AMLUSB_A6                                  ((0x0006  << 2) + 0xfe03c000)
#define AMLUSB_A7                                  ((0x0007  << 2) + 0xfe03c000)
#define AMLUSB_A8                                  ((0x0008  << 2) + 0xfe03c000)
#define AMLUSB_A9                                  ((0x0009  << 2) + 0xfe03c000)
#define AMLUSB_A10                                 ((0x000a  << 2) + 0xfe03c000)
#define AMLUSB_A11                                 ((0x000b  << 2) + 0xfe03c000)
#define AMLUSB_A12                                 ((0x000c  << 2) + 0xfe03c000)
#define AMLUSB_A13                                 ((0x000d  << 2) + 0xfe03c000)
#define AMLUSB_A14                                 ((0x000e  << 2) + 0xfe03c000)
#define AMLUSB_A15                                 ((0x000f  << 2) + 0xfe03c000)
#define AMLUSB_A16                                 ((0x0010  << 2) + 0xfe03c000)
#define AMLUSB_A17                                 ((0x0011  << 2) + 0xfe03c000)
#define AMLUSB_A18                                 ((0x0012  << 2) + 0xfe03c000)
#define AMLUSB_A19                                 ((0x0013  << 2) + 0xfe03c000)
#define AMLUSB_A20                                 ((0x0014  << 2) + 0xfe03c000)
#define AMLUSB_A21                                 ((0x0015  << 2) + 0xfe03c000)
#define AMLUSB_A22                                 ((0x0016  << 2) + 0xfe03c000)
#define AMLUSB_A23                                 ((0x0017  << 2) + 0xfe03c000)
#define AMLUSB_A24                                 ((0x0018  << 2) + 0xfe03c000)
#define AMLUSB_A25                                 ((0x0019  << 2) + 0xfe03c000)
#define AMLUSB_A26                                 ((0x001a  << 2) + 0xfe03c000)
#define AMLUSB_A27                                 ((0x001b  << 2) + 0xfe03c000)
#define AMLUSB_A28                                 ((0x001c  << 2) + 0xfe03c000)
#define AMLUSB_A29                                 ((0x001d  << 2) + 0xfe03c000)
#define AMLUSB_A30                                 ((0x001e  << 2) + 0xfe03c000)
#define AMLUSB_A31                                 ((0x001f  << 2) + 0xfe03c000)
//========================================================================
//  AML USB PHY B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe03e000
// -----------------------------------------------
#define AMLUSB_B0                                  ((0x0000  << 2) + 0xfe03e000)
#define AMLUSB_B1                                  ((0x0001  << 2) + 0xfe03e000)
#define AMLUSB_B2                                  ((0x0002  << 2) + 0xfe03e000)
#define AMLUSB_B3                                  ((0x0003  << 2) + 0xfe03e000)
#define AMLUSB_B4                                  ((0x0004  << 2) + 0xfe03e000)
#define AMLUSB_B5                                  ((0x0005  << 2) + 0xfe03e000)
#define AMLUSB_B6                                  ((0x0006  << 2) + 0xfe03e000)
#define AMLUSB_B7                                  ((0x0007  << 2) + 0xfe03e000)
#define AMLUSB_B8                                  ((0x0008  << 2) + 0xfe03e000)
#define AMLUSB_B9                                  ((0x0009  << 2) + 0xfe03e000)
#define AMLUSB_B10                                 ((0x000a  << 2) + 0xfe03e000)
#define AMLUSB_B11                                 ((0x000b  << 2) + 0xfe03e000)
#define AMLUSB_B12                                 ((0x000c  << 2) + 0xfe03e000)
#define AMLUSB_B13                                 ((0x000d  << 2) + 0xfe03e000)
#define AMLUSB_B14                                 ((0x000e  << 2) + 0xfe03e000)
#define AMLUSB_B15                                 ((0x000f  << 2) + 0xfe03e000)
#define AMLUSB_B16                                 ((0x0010  << 2) + 0xfe03e000)
#define AMLUSB_B17                                 ((0x0011  << 2) + 0xfe03e000)
#define AMLUSB_B18                                 ((0x0012  << 2) + 0xfe03e000)
#define AMLUSB_B19                                 ((0x0013  << 2) + 0xfe03e000)
#define AMLUSB_B20                                 ((0x0014  << 2) + 0xfe03e000)
#define AMLUSB_B21                                 ((0x0015  << 2) + 0xfe03e000)
#define AMLUSB_B22                                 ((0x0016  << 2) + 0xfe03e000)
#define AMLUSB_B23                                 ((0x0017  << 2) + 0xfe03e000)
#define AMLUSB_B24                                 ((0x0018  << 2) + 0xfe03e000)
#define AMLUSB_B25                                 ((0x0019  << 2) + 0xfe03e000)
#define AMLUSB_B26                                 ((0x001a  << 2) + 0xfe03e000)
#define AMLUSB_B27                                 ((0x001b  << 2) + 0xfe03e000)
#define AMLUSB_B28                                 ((0x001c  << 2) + 0xfe03e000)
#define AMLUSB_B29                                 ((0x001d  << 2) + 0xfe03e000)
#define AMLUSB_B30                                 ((0x001e  << 2) + 0xfe03e000)
#define AMLUSB_B31                                 ((0x001f  << 2) + 0xfe03e000)
//========================================================================
//  PAD_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe004000
// -----------------------------------------------
#define PADCTRL_PIN_MUX_REG0                       ((0x0000  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG1                       ((0x0001  << 2) + 0xfe004000)
//`define PADCTRL_PIN_MUX_REG2          8'h02
#define PADCTRL_PIN_MUX_REG3                       ((0x0003  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REG4                       ((0x0004  << 2) + 0xfe004000)
//`define PADCTRL_PIN_MUX_REG5          8'h05
//`define PADCTRL_PIN_MUX_REG6          8'h06
//`define PADCTRL_PIN_MUX_REG7          8'h07
//`define PADCTRL_PIN_MUX_REG8          8'h08
#define PADCTRL_PIN_MUX_REG9                       ((0x0009  << 2) + 0xfe004000)
//`define PADCTRL_PIN_MUX_REGA          8'h0a
#define PADCTRL_PIN_MUX_REGB                       ((0x000b  << 2) + 0xfe004000)
//`define PADCTRL_PIN_MUX_REGC          8'h0c
//`define PADCTRL_PIN_MUX_REGD          8'h0d
//`define PADCTRL_PIN_MUX_REGE          8'h0e
//`define PADCTRL_PIN_MUX_REGF          8'h0f
#define PADCTRL_PIN_MUX_REGG                       ((0x0010  << 2) + 0xfe004000)
//`define PADCTRL_PIN_MUX_REGH          8'h11
#define PADCTRL_PIN_MUX_REGI                       ((0x0012  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGJ                       ((0x0013  << 2) + 0xfe004000)
#define PADCTRL_PIN_MUX_REGK                       ((0x0014  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL0                     ((0x0020  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL1                     ((0x0021  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL2                     ((0x0022  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL3                     ((0x0023  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL4                     ((0x0024  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL5                     ((0x0025  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL6                     ((0x0026  << 2) + 0xfe004000)
#define PADCTRL_GPIO_IRQ_CTRL7                     ((0x0027  << 2) + 0xfe004000)
#define PADCTRL_WORLD_SYNC_CTRL0                   ((0x0028  << 2) + 0xfe004000)
#define PADCTRL_GPIO_MSR_CTRL0                     ((0x0029  << 2) + 0xfe004000)
#define PADCTRL_MISC_CTRL0                         ((0x002a  << 2) + 0xfe004000)
//`define PADCTRL_GPIOZ_I               8'h30
//`define PADCTRL_GPIOZ_O               8'h31
//`define PADCTRL_GPIOZ_OEN             8'h32
//`define PADCTRL_GPIOZ_PULL_EN         8'h33
//`define PADCTRL_GPIOZ_PULL_UP         8'h34
//`define PADCTRL_GPIOZ_LOCK            8'h35
//`define PADCTRL_GPIOZ_PROT            8'h36
//`define PADCTRL_GPIOZ_DS              8'h37
#define PADCTRL_GPIOX_I                            ((0x0040  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_O                            ((0x0041  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_OEN                          ((0x0042  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PULL_EN                      ((0x0043  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PULL_UP                      ((0x0044  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_LOCK                         ((0x0045  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_PROT                         ((0x0046  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_DS                           ((0x0047  << 2) + 0xfe004000)
#define PADCTRL_GPIOX_DS_EXT                       ((0x0048  << 2) + 0xfe004000)
//`define PADCTRL_GPIOT_I               8'h50
//`define PADCTRL_GPIOT_O               8'h51
//`define PADCTRL_GPIOT_OEN             8'h52
//`define PADCTRL_GPIOT_PULL_EN         8'h53
//`define PADCTRL_GPIOT_PULL_UP         8'h54
//`define PADCTRL_GPIOT_LOCK            8'h55
//`define PADCTRL_GPIOT_PROT            8'h56
//`define PADCTRL_GPIOT_DS              8'h57
//`define PADCTRL_GPIOH_I               8'h50
//`define PADCTRL_GPIOH_O               8'h51
//`define PADCTRL_GPIOH_OEN             8'h52
//`define PADCTRL_GPIOH_PULL_EN         8'h53
//`define PADCTRL_GPIOH_PULL_UP         8'h54
//`define PADCTRL_GPIOH_LOCK            8'h55
//`define PADCTRL_GPIOH_PROT            8'h56
//`define PADCTRL_GPIOH_DS              8'h57
#define PADCTRL_GPIOD_I                            ((0x0060  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_O                            ((0x0061  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_OEN                          ((0x0062  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PULL_EN                      ((0x0063  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PULL_UP                      ((0x0064  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_LOCK                         ((0x0065  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_PROT                         ((0x0066  << 2) + 0xfe004000)
#define PADCTRL_GPIOD_DS                           ((0x0067  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_I                            ((0x0070  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_O                            ((0x0071  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_OEN                          ((0x0072  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PULL_EN                      ((0x0073  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PULL_UP                      ((0x0074  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_LOCK                         ((0x0075  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_PROT                         ((0x0076  << 2) + 0xfe004000)
#define PADCTRL_GPIOE_DS                           ((0x0077  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_I                            ((0x0080  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_O                            ((0x0081  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_OEN                          ((0x0082  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PULL_EN                      ((0x0083  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PULL_UP                      ((0x0084  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_LOCK                         ((0x0085  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_PROT                         ((0x0086  << 2) + 0xfe004000)
#define PADCTRL_GPIOC_DS                           ((0x0087  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_I                            ((0x0090  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_O                            ((0x0091  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_OEN                          ((0x0092  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PULL_EN                      ((0x0093  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PULL_UP                      ((0x0094  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_LOCK                         ((0x0095  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_PROT                         ((0x0096  << 2) + 0xfe004000)
#define PADCTRL_GPIOB_DS                           ((0x0097  << 2) + 0xfe004000)
//`define PADCTRL_GPIOH_I               8'hA0
//`define PADCTRL_GPIOH_O               8'hA1
//`define PADCTRL_GPIOH_OEN             8'hA2
//`define PADCTRL_GPIOH_PULL_EN         8'hA3
//`define PADCTRL_GPIOH_PULL_UP         8'hA4
//`define PADCTRL_GPIOH_LOCK            8'hA5
//`define PADCTRL_GPIOH_PROT            8'hA6
//`define PADCTRL_GPIOH_DS              8'hA7
#define PADCTRL_GPIOA_I                            ((0x00a0  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_O                            ((0x00a1  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_OEN                          ((0x00a2  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_PULL_EN                      ((0x00a3  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_PULL_UP                      ((0x00a4  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_LOCK                         ((0x00a5  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_PROT                         ((0x00a6  << 2) + 0xfe004000)
#define PADCTRL_GPIOA_DS                           ((0x00a7  << 2) + 0xfe004000)
#define PADCTRL_TESTN_I                            ((0x00b0  << 2) + 0xfe004000)
#define PADCTRL_TESTN_O                            ((0x00b1  << 2) + 0xfe004000)
#define PADCTRL_TESTN_OEN                          ((0x00b2  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PULL_EN                      ((0x00b3  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PULL_UP                      ((0x00b4  << 2) + 0xfe004000)
#define PADCTRL_TESTN_LOCK                         ((0x00b5  << 2) + 0xfe004000)
#define PADCTRL_TESTN_PROT                         ((0x00b6  << 2) + 0xfe004000)
#define PADCTRL_TESTN_DS                           ((0x00b7  << 2) + 0xfe004000)
//`define PADCTRL_ANALOG_I              8'hC0
//`define PADCTRL_ANALOG_EN             8'hC1
#define PADCTRL_LOCK_PIN_MUX0                      ((0x00d0  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX1                      ((0x00d1  << 2) + 0xfe004000)
#define PADCTRL_LOCK_PIN_MUX2                      ((0x00d2  << 2) + 0xfe004000)
//`define PADCTRL_LOCK_PIN_MUX3         8'hD3
#define PADCTRL_LOCK_PIN_MUX4                      ((0x00d4  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX0                      ((0x00d8  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX1                      ((0x00d9  << 2) + 0xfe004000)
#define PADCTRL_PROT_PIN_MUX2                      ((0x00da  << 2) + 0xfe004000)
//`define PADCTRL_PROT_PIN_MUX3         8'hDB
#define PADCTRL_PROT_PIN_MUX4                      ((0x00dc  << 2) + 0xfe004000)
#define PADCTRL_MUTE_CTRL                          ((0x00e0  << 2) + 0xfe004000)
#define PADCTRL_MUTE_TDM_DISA                      ((0x00e1  << 2) + 0xfe004000)
#define PADCTRL_DEBUG_SEL                          ((0x00e2  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_O                          ((0x00e3  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_IE                         ((0x00e4  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_OEN                        ((0x00e5  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_PD                         ((0x00e6  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_PU                         ((0x00e7  << 2) + 0xfe004000)
#define PADCTRL_GPIODSI_I                          ((0x00e8  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_O                          ((0x00e9  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_IE                         ((0x00ea  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_OEN                        ((0x00eb  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_PD                         ((0x00ec  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_PU                         ((0x00ed  << 2) + 0xfe004000)
#define PADCTRL_GPIOSAR_I                          ((0x00ee  << 2) + 0xfe004000)
//`define PADCTRL_AUDIO_PAD_SEL0        8'hE3
//`define PADCTRL_AUDIO_PAD_SEL1        8'hE4
//========================================================================
//  SYS_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe010000
// -----------------------------------------------
#define SYSCTRL_METAL_REV0                         ((0x0000  << 2) + 0xfe010000)
#define SYSCTRL_METAL_REV1                         ((0x0001  << 2) + 0xfe010000)
#define SYSCTRL_METAL_REV2                         ((0x0002  << 2) + 0xfe010000)
#define SYSCTRL_CHIP_ID                            ((0x000b  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_REG0                    ((0x0010  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_STICKY_REG0             ((0x0011  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_SEC_REG0                ((0x0012  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE1_STICKY_SEC_REG0         ((0x0013  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_REG0                     ((0x0014  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_REG1                     ((0x0015  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_SEC_REG0                 ((0x0016  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_REG0              ((0x0017  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_REG1              ((0x0018  << 2) + 0xfe010000)
#define SYSCTRL_WRITEONCE_STICKY_SEC_REG0          ((0x0019  << 2) + 0xfe010000)
#define SYSCTRL_TIMERA_CTRL                        ((0x0030  << 2) + 0xfe010000)
#define SYSCTRL_TIMERA                             ((0x0031  << 2) + 0xfe010000)
#define SYSCTRL_TIMERB_CTRL                        ((0x0032  << 2) + 0xfe010000)
#define SYSCTRL_TIMERB                             ((0x0033  << 2) + 0xfe010000)
#define SYSCTRL_TIMERC_CTRL                        ((0x0034  << 2) + 0xfe010000)
#define SYSCTRL_TIMERC                             ((0x0035  << 2) + 0xfe010000)
#define SYSCTRL_TIMERD_CTRL                        ((0x0036  << 2) + 0xfe010000)
#define SYSCTRL_TIMERD                             ((0x0037  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERA_CTRL                    ((0x0038  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERA                         ((0x0039  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE_CTRL                        ((0x003a  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE                             ((0x003b  << 2) + 0xfe010000)
#define SYSCTRL_TIMERE_HI                          ((0x003c  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF_CTRL                        ((0x003d  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF                             ((0x003e  << 2) + 0xfe010000)
#define SYSCTRL_TIMERF_HI                          ((0x003f  << 2) + 0xfe010000)
#define SYSCTRL_TIMERG_CTRL                        ((0x0040  << 2) + 0xfe010000)
#define SYSCTRL_TIMERG                             ((0x0041  << 2) + 0xfe010000)
#define SYSCTRL_TIMERH_CTRL                        ((0x0042  << 2) + 0xfe010000)
#define SYSCTRL_TIMERH                             ((0x0043  << 2) + 0xfe010000)
#define SYSCTRL_TIMERI_CTRL                        ((0x0044  << 2) + 0xfe010000)
#define SYSCTRL_TIMERI                             ((0x0045  << 2) + 0xfe010000)
#define SYSCTRL_TIMERJ_CTRL                        ((0x0046  << 2) + 0xfe010000)
#define SYSCTRL_TIMERJ                             ((0x0047  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE_CTRL                    ((0x0048  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE                         ((0x0049  << 2) + 0xfe010000)
#define SYSCTRL_SEC_TIMERE_HI                      ((0x004a  << 2) + 0xfe010000)
#define SYSCTRL_OSC_RING_CTRL0                     ((0x0050  << 2) + 0xfe010000)
#define SYSCTRL_OSC_RING_CTRL1                     ((0x0051  << 2) + 0xfe010000)
#define SYSCTRL_AM2AXI_CTRL0                       ((0x0052  << 2) + 0xfe010000)
#define SYSCTRL_AM2AXI_STS                         ((0x0053  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL0                     ((0x0055  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL1                     ((0x0056  << 2) + 0xfe010000)
#define SYSCTRL_TIMER90K                           ((0x0057  << 2) + 0xfe010000)
#define SYSCTRL_SCR                                ((0x0058  << 2) + 0xfe010000)
#define SYSCTRL_HPG_TIMER                          ((0x0059  << 2) + 0xfe010000)
#define SYSCTRL_AXI_PIPE_CTRL2                     ((0x005a  << 2) + 0xfe010000)
//`define SYSCTRL_VIPNANOQ_CTRL0                  10'h5A
#define SYSCTRL_AHB2DDR_CTRL0                      ((0x005b  << 2) + 0xfe010000)
#define SYSCTRL_AHB2DDR_CTRL1                      ((0x005c  << 2) + 0xfe010000)
#define SYSCTRL_POC                                ((0x0060  << 2) + 0xfe010000)
#define SYSCTRL_VPU_SECURE_REG0                    ((0x0061  << 2) + 0xfe010000)
#define SYSCTRL_VPU_SECURE_REG1                    ((0x0062  << 2) + 0xfe010000)
//`define SYSCTRL_NIC_CFG0                        10'h63
#define SYSCTRL_ALERT_STS_STICKY                   ((0x0064  << 2) + 0xfe010000)
#define SYSCTRL_ALERT_ENABLE                       ((0x0066  << 2) + 0xfe010000)
#define SYSCTRL_ENABLE_SPIFC                       ((0x0068  << 2) + 0xfe010000)
#define SYSCTRL_DEV_BUS_CFG                        ((0x0069  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG0                         ((0x0090  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG1                         ((0x0091  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG2                         ((0x0092  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG3                         ((0x0093  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG4                         ((0x0094  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG5                         ((0x0095  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG6                         ((0x0096  << 2) + 0xfe010000)
#define SYSCTRL_DEBUG_REG7                         ((0x0097  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG0                        ((0x00a0  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG1                        ((0x00a1  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG2                        ((0x00a2  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG3                        ((0x00a3  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG4                        ((0x00a4  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG5                        ((0x00a5  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG6                        ((0x00a6  << 2) + 0xfe010000)
#define SYSCTRL_STATUS_REG7                        ((0x00a7  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG0                        ((0x00b0  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG1                        ((0x00b1  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG2                        ((0x00b2  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG3                        ((0x00b3  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG4                        ((0x00b4  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG5                        ((0x00b5  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG6                        ((0x00b6  << 2) + 0xfe010000)
#define SYSCTRL_STICKY_REG7                        ((0x00b7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG0                    ((0x00c0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG1                    ((0x00c1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG2                    ((0x00c2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG3                    ((0x00c3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG4                    ((0x00c4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG5                    ((0x00c5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG6                    ((0x00c6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG7                    ((0x00c7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG8                    ((0x00c8  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG9                    ((0x00c9  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG10                   ((0x00ca  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG11                   ((0x00cb  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG12                   ((0x00cc  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG13                   ((0x00cd  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG14                   ((0x00ce  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG15                   ((0x00cf  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG16                   ((0x00d0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG17                   ((0x00d1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG18                   ((0x00d2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG19                   ((0x00d3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG20                   ((0x00d4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG21                   ((0x00d5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG22                   ((0x00d6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG23                   ((0x00d7  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG24                   ((0x00d8  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG25                   ((0x00d9  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG26                   ((0x00da  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG27                   ((0x00db  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG28                   ((0x00dc  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG29                   ((0x00dd  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG30                   ((0x00de  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STATUS_REG31                   ((0x00df  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG0                    ((0x00e0  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG1                    ((0x00e1  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG2                    ((0x00e2  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG3                    ((0x00e3  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG4                    ((0x00e4  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG5                    ((0x00e5  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG6                    ((0x00e6  << 2) + 0xfe010000)
#define SYSCTRL_SEC_STICKY_REG7                    ((0x00e7  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX0_STICKY                  ((0x00f0  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX1_STICKY                  ((0x00f1  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX2_STICKY                  ((0x00f2  << 2) + 0xfe010000)
#define SYSCTRL_MSG_INDEX3_STICKY                  ((0x00f3  << 2) + 0xfe010000)
//========================================================================
//  CLK_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe000000
// -----------------------------------------------
#define CLKCTRL_OSCIN_CTRL                         ((0x0001  << 2) + 0xfe000000)
#define CLKCTRL_RTC_BY_OSCIN_CTRL0                 ((0x0002  << 2) + 0xfe000000)
#define CLKCTRL_RTC_BY_OSCIN_CTRL1                 ((0x0003  << 2) + 0xfe000000)
#define CLKCTRL_RTC_CTRL                           ((0x0004  << 2) + 0xfe000000)
#define CLKCTRL_CHECK_CLK_RESULT                   ((0x0005  << 2) + 0xfe000000)
#define CLKCTRL_MBIST_ATSPEED_CTRL                 ((0x0006  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG0                      ((0x0008  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG1                      ((0x0009  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG2                      ((0x000a  << 2) + 0xfe000000)
#define CLKCTRL_LOCK_BIT_REG3                      ((0x000b  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG0                      ((0x000c  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG1                      ((0x000d  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG2                      ((0x000e  << 2) + 0xfe000000)
#define CLKCTRL_PROT_BIT_REG3                      ((0x000f  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_CTRL0                      ((0x0010  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG0                   ((0x0011  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG1                   ((0x0012  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG2                   ((0x0013  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN0_REG3                   ((0x0014  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG0                   ((0x0015  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG1                   ((0x0016  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG2                   ((0x0017  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_EN1_REG3                   ((0x0018  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_VPU_EN0                    ((0x0019  << 2) + 0xfe000000)
#define CLKCTRL_SYS_CLK_VPU_EN1                    ((0x001a  << 2) + 0xfe000000)
#define CLKCTRL_AXI_CLK_CTRL0                      ((0x001b  << 2) + 0xfe000000)
#define CLKCTRL_SYSOSCIN_CTRL                      ((0x001c  << 2) + 0xfe000000)
#define CLKCTRL_TST_CTRL0                          ((0x0020  << 2) + 0xfe000000)
#define CLKCTRL_TST_CTRL1                          ((0x0021  << 2) + 0xfe000000)
#define CLKCTRL_CECA_CTRL0                         ((0x0022  << 2) + 0xfe000000)
#define CLKCTRL_CECA_CTRL1                         ((0x0023  << 2) + 0xfe000000)
#define CLKCTRL_CECB_CTRL0                         ((0x0024  << 2) + 0xfe000000)
#define CLKCTRL_CECB_CTRL1                         ((0x0025  << 2) + 0xfe000000)
#define CLKCTRL_SC_CLK_CTRL                        ((0x0026  << 2) + 0xfe000000)
#define CLKCTRL_DSPA_CLK_CTRL0                     ((0x0027  << 2) + 0xfe000000)
//`define CLKCTRL_DSPB_CLK_CTRL0          10'h28
#define CLKCTRL_RAMA_CLK_CTRL0                     ((0x0029  << 2) + 0xfe000000)
#define CLKCTRL_CLK12_24_CTRL                      ((0x002a  << 2) + 0xfe000000)
#define CLKCTRL_AXI_CLK_EN0                        ((0x002b  << 2) + 0xfe000000)
#define CLKCTRL_AXI_CLK_EN1                        ((0x002c  << 2) + 0xfe000000)
//`define CLKCTRL_RTCPLL_CTRL0            10'h2b
//`define CLKCTRL_RTCPLL_CTRL1            10'h2c
//`define CLKCTRL_RTCPLL_CTRL2            10'h2d
//`define CLKCTRL_RTCPLL_CTRL3            10'h2e
//`define CLKCTRL_RTCPLL_CTRL4            10'h2f
//`define CLKCTRL_RTCPLL_STS              10'h28
#define CLKCTRL_VID_CLK_CTRL                       ((0x0030  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK_CTRL2                      ((0x0031  << 2) + 0xfe000000)
#define CLKCTRL_VID_CLK_DIV                        ((0x0032  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK_DIV                       ((0x0033  << 2) + 0xfe000000)
#define CLKCTRL_VIID_CLK_CTRL                      ((0x0034  << 2) + 0xfe000000)
#define CLKCTRL_HDMI_CLK_CTRL                      ((0x0038  << 2) + 0xfe000000)
#define CLKCTRL_VID_PLL_CLK_DIV                    ((0x0039  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLK_CTRL                       ((0x003a  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLKB_CTRL                      ((0x003b  << 2) + 0xfe000000)
#define CLKCTRL_VPU_CLKC_CTRL                      ((0x003c  << 2) + 0xfe000000)
#define CLKCTRL_VID_LOCK_CLK_CTRL                  ((0x003d  << 2) + 0xfe000000)
#define CLKCTRL_VDIN_MEAS_CLK_CTRL                 ((0x003e  << 2) + 0xfe000000)
#define CLKCTRL_VAPBCLK_CTRL                       ((0x003f  << 2) + 0xfe000000)
#define CLKCTRL_HDCP22_CLK_CTRL                    ((0x0040  << 2) + 0xfe000000)
#define CLKCTRL_MIPIDSI_PHY_CLK_CTRL               ((0x0041  << 2) + 0xfe000000)
#define CLKCTRL_CDAC_CLK_CTRL                      ((0x0042  << 2) + 0xfe000000)
#define CLKCTRL_GE2DCLK_CTRL                       ((0x0043  << 2) + 0xfe000000)
//`define CLKCTRL_MIPI_CSI_PHY_CLK_CTRL   10'h43
//`define CLKCTRL_CSI2_ADAPT_CLK_CTRL     10'h44
#define CLKCTRL_ISP0_CLK_CTRL                      ((0x0044  << 2) + 0xfe000000)
#define CLKCTRL_DEWARPA_CLK_CTRL                   ((0x0045  << 2) + 0xfe000000)
#define CLKCTRL_VOUTENC_CLK_CTRL                   ((0x0046  << 2) + 0xfe000000)
#define CLKCTRL_VDEC_CLK_CTRL                      ((0x0050  << 2) + 0xfe000000)
#define CLKCTRL_VDEC2_CLK_CTRL                     ((0x0051  << 2) + 0xfe000000)
#define CLKCTRL_VDEC3_CLK_CTRL                     ((0x0052  << 2) + 0xfe000000)
#define CLKCTRL_VDEC4_CLK_CTRL                     ((0x0053  << 2) + 0xfe000000)
//`define CLKCTRL_WAVE420L_CLK_CTRL       10'h54
//`define CLKCTRL_WAVE420L_CLK_CTRL2      10'h55
#define CLKCTRL_TS_CLK_CTRL                        ((0x0056  << 2) + 0xfe000000)
#define CLKCTRL_MALI_CLK_CTRL                      ((0x0057  << 2) + 0xfe000000)
//`define CLKCTRL_VIPNANOQ_CLK_CTRL       10'h58
#define CLKCTRL_ETH_CLK_CTRL                       ((0x0059  << 2) + 0xfe000000)
#define CLKCTRL_NAND_CLK_CTRL                      ((0x005a  << 2) + 0xfe000000)
#define CLKCTRL_SD_EMMC_CLK_CTRL                   ((0x005b  << 2) + 0xfe000000)
//`define CLKCTRL_BT656_CLK_CTRL          10'h5C
#define CLKCTRL_SPICC_CLK_CTRL                     ((0x005d  << 2) + 0xfe000000)
#define CLKCTRL_GEN_CLK_CTRL                       ((0x005e  << 2) + 0xfe000000)
#define CLKCTRL_SAR_CLK_CTRL0                      ((0x005f  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_AB_CTRL                    ((0x0060  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_CD_CTRL                    ((0x0061  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_EF_CTRL                    ((0x0062  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_GH_CTRL                    ((0x0063  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_IJ_CTRL                    ((0x0064  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_KL_CTRL                    ((0x0065  << 2) + 0xfe000000)
#define CLKCTRL_PWM_CLK_MN_CTRL                    ((0x0066  << 2) + 0xfe000000)
#define CLKCTRL_VC9000E_CLK_CTRL                   ((0x0067  << 2) + 0xfe000000)
#define CLKTREE_SPIFC_CLK_CTRL                     ((0x0068  << 2) + 0xfe000000)
#define CLKCTRL_DEMOD_CLK_CTRL                     ((0x0080  << 2) + 0xfe000000)
#define CLKCTRL_NNA_CLK_CNTL                       ((0x0088  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL                     ((0x0100  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL1                    ((0x0101  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_CTRL2                    ((0x0103  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_RD0                      ((0x0104  << 2) + 0xfe000000)
#define CLKCTRL_TIMESTAMP_RD1                      ((0x0105  << 2) + 0xfe000000)
#define CLKCTRL_TIMEBASE_CTRL0                     ((0x0106  << 2) + 0xfe000000)
#define CLKCTRL_TIMEBASE_CTRL1                     ((0x0107  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_CPU_CFG01                    ((0x0120  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_CPU_CFG2                     ((0x0121  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_ENCP_CFG0                    ((0x0122  << 2) + 0xfe000000)
#define CLKCTRL_EFUSE_MALI_CFG01                   ((0x0123  << 2) + 0xfe000000)
//`define CLKCTRL_EFUSE_HEVCB_CFG01       10'h124
//`define CLKCTRL_EFUSE_HEVCB_CFG2        10'h125
#define CLKCTRL_EFUSE_LOCK                         ((0x0126  << 2) + 0xfe000000)
//========================================================================
//  PWR_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00c000
// -----------------------------------------------
#define PWRCTRL_PWR_ACK0                           ((0x0000  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_ACK1                           ((0x0001  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_OFF0                           ((0x0004  << 2) + 0xfe00c000)
#define PWRCTRL_PWR_OFF1                           ((0x0005  << 2) + 0xfe00c000)
#define PWRCTRL_ISO_EN0                            ((0x0008  << 2) + 0xfe00c000)
#define PWRCTRL_ISO_EN1                            ((0x0009  << 2) + 0xfe00c000)
#define PWRCTRL_FOCRST0                            ((0x000c  << 2) + 0xfe00c000)
#define PWRCTRL_FOCRST1                            ((0x000d  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD0                            ((0x0010  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD1                            ((0x0011  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD2                            ((0x0012  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD3                            ((0x0013  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD4                            ((0x0014  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD5                            ((0x0015  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD6                            ((0x0016  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD7                            ((0x0017  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD8                            ((0x0018  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD9                            ((0x0019  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD10                           ((0x001a  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD11                           ((0x001b  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD12                           ((0x001c  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD13                           ((0x001d  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD14                           ((0x001e  << 2) + 0xfe00c000)
#define PWRCTRL_MEM_PD15                           ((0x001f  << 2) + 0xfe00c000)
#define PWRCTRL_NNA_AXI_PWR_CTRL                   ((0x0020  << 2) + 0xfe00c000)
#define PWRCTRL_ACCESS_CTRL                        ((0x0021  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL0                ((0x0040  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL1                ((0x0041  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL2                ((0x0042  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL3                ((0x0043  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_AUTO_OFF_CTRL4                ((0x0044  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_01                   ((0x0048  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_23                   ((0x0049  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_45                   ((0x004a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_67                   ((0x004b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_TIMER_TH_89                   ((0x004c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK0                     ((0x0050  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK1                     ((0x0051  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK2                     ((0x0052  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK3                     ((0x0053  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK4                     ((0x0054  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK5                     ((0x0055  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK6                     ((0x0056  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_IRQ_MASK7                     ((0x0057  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_INIT_SET                ((0x0060  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_OFF_SET                 ((0x0061  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_A_SET                ((0x0062  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_B_SET                ((0x0063  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_C_SET                ((0x0064  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_ON_D_SET                ((0x0065  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_MEMPD_STS                     ((0x0066  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS0                      ((0x0067  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS1                      ((0x0068  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_STS2                      ((0x0069  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_START_OFF                 ((0x006d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_START_ON                  ((0x006e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU0_FSM_JUMP                      ((0x006f  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL0                ((0x0070  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL1                ((0x0071  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL2                ((0x0072  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL3                ((0x0073  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_AUTO_OFF_CTRL4                ((0x0074  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_01                   ((0x0078  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_23                   ((0x0079  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_45                   ((0x007a  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_67                   ((0x007b  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_TIMER_TH_89                   ((0x007c  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK0                     ((0x0080  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK1                     ((0x0081  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK2                     ((0x0082  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK3                     ((0x0083  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK4                     ((0x0084  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK5                     ((0x0085  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK6                     ((0x0086  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_IRQ_MASK7                     ((0x0087  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_INIT_SET                ((0x0090  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_OFF_SET                 ((0x0091  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_A_SET                ((0x0092  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_B_SET                ((0x0093  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_C_SET                ((0x0094  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_ON_D_SET                ((0x0095  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_MEMPD_STS                     ((0x0096  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS0                      ((0x0097  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS1                      ((0x0098  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_STS2                      ((0x0099  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_START_OFF                 ((0x009d  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_START_ON                  ((0x009e  << 2) + 0xfe00c000)
#define PWRCTRL_CPU1_FSM_JUMP                      ((0x009f  << 2) + 0xfe00c000)
//`define PWRCTRL_CPU2_AUTO_OFF_CTRL0      10'hA0
//`define PWRCTRL_CPU2_AUTO_OFF_CTRL1      10'hA1
//`define PWRCTRL_CPU2_AUTO_OFF_CTRL2      10'hA2
//`define PWRCTRL_CPU2_AUTO_OFF_CTRL3      10'hA3
//`define PWRCTRL_CPU2_AUTO_OFF_CTRL4      10'hA4
//`define PWRCTRL_CPU2_TIMER_TH_01         10'hA8
//`define PWRCTRL_CPU2_TIMER_TH_23         10'hA9
//`define PWRCTRL_CPU2_TIMER_TH_45         10'hAA
//`define PWRCTRL_CPU2_TIMER_TH_67         10'hAB
//`define PWRCTRL_CPU2_TIMER_TH_89         10'hAC
//`define PWRCTRL_CPU2_IRQ_MASK0           10'hB0
//`define PWRCTRL_CPU2_IRQ_MASK1           10'hB1
//`define PWRCTRL_CPU2_IRQ_MASK2           10'hB2
//`define PWRCTRL_CPU2_IRQ_MASK3           10'hB3
//`define PWRCTRL_CPU2_IRQ_MASK4           10'hB4
//`define PWRCTRL_CPU2_IRQ_MASK5           10'hB5
//`define PWRCTRL_CPU2_IRQ_MASK6           10'hB6
//`define PWRCTRL_CPU2_IRQ_MASK7           10'hB7
//`define PWRCTRL_CPU2_MEMPD_INIT_SET      10'hC0
//`define PWRCTRL_CPU2_MEMPD_OFF_SET       10'hC1
//`define PWRCTRL_CPU2_MEMPD_ON_A_SET      10'hC2
//`define PWRCTRL_CPU2_MEMPD_ON_B_SET      10'hC3
//`define PWRCTRL_CPU2_MEMPD_ON_C_SET      10'hC4
//`define PWRCTRL_CPU2_MEMPD_ON_D_SET      10'hC5
//`define PWRCTRL_CPU2_MEMPD_STS           10'hC6
//`define PWRCTRL_CPU2_FSM_STS0            10'hC7
//`define PWRCTRL_CPU2_FSM_STS1            10'hC8
//`define PWRCTRL_CPU2_FSM_STS2            10'hC9
//`define PWRCTRL_CPU2_FSM_START_OFF       10'hCD
//`define PWRCTRL_CPU2_FSM_START_ON        10'hCE
//`define PWRCTRL_CPU2_FSM_JUMP            10'hCF
//`define PWRCTRL_CPU3_AUTO_OFF_CTRL0      10'hD0
//`define PWRCTRL_CPU3_AUTO_OFF_CTRL1      10'hD1
//`define PWRCTRL_CPU3_AUTO_OFF_CTRL2      10'hD2
//`define PWRCTRL_CPU3_AUTO_OFF_CTRL3      10'hD3
//`define PWRCTRL_CPU3_AUTO_OFF_CTRL4      10'hD4
//`define PWRCTRL_CPU3_TIMER_TH_01         10'hD8
//`define PWRCTRL_CPU3_TIMER_TH_23         10'hD9
//`define PWRCTRL_CPU3_TIMER_TH_45         10'hDA
//`define PWRCTRL_CPU3_TIMER_TH_67         10'hDB
//`define PWRCTRL_CPU3_TIMER_TH_89         10'hDC
//`define PWRCTRL_CPU3_IRQ_MASK0           10'hE0
//`define PWRCTRL_CPU3_IRQ_MASK1           10'hE1
//`define PWRCTRL_CPU3_IRQ_MASK2           10'hE2
//`define PWRCTRL_CPU3_IRQ_MASK3           10'hE3
//`define PWRCTRL_CPU3_IRQ_MASK4           10'hE4
//`define PWRCTRL_CPU3_IRQ_MASK5           10'hE5
//`define PWRCTRL_CPU3_IRQ_MASK6           10'hE6
//`define PWRCTRL_CPU3_IRQ_MASK7           10'hE7
//`define PWRCTRL_CPU3_MEMPD_INIT_SET      10'hF0
//`define PWRCTRL_CPU3_MEMPD_OFF_SET       10'hF1
//`define PWRCTRL_CPU3_MEMPD_ON_A_SET      10'hF2
//`define PWRCTRL_CPU3_MEMPD_ON_B_SET      10'hF3
//`define PWRCTRL_CPU3_MEMPD_ON_C_SET      10'hF4
//`define PWRCTRL_CPU3_MEMPD_ON_D_SET      10'hF5
//`define PWRCTRL_CPU3_MEMPD_STS           10'hF6
//`define PWRCTRL_CPU3_FSM_STS0            10'hF7
//`define PWRCTRL_CPU3_FSM_STS1            10'hF8
//`define PWRCTRL_CPU3_FSM_STS2            10'hF9
//`define PWRCTRL_CPU3_FSM_START_OFF       10'hFD
//`define PWRCTRL_CPU3_FSM_START_ON        10'hFE
//`define PWRCTRL_CPU3_FSM_JUMP            10'hFF
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL0              ((0x0100  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL1              ((0x0101  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL2              ((0x0102  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL3              ((0x0103  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_AUTO_OFF_CTRL4              ((0x0104  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_01                 ((0x0108  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_23                 ((0x0109  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_45                 ((0x010a  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_67                 ((0x010b  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_TIMER_TH_89                 ((0x010c  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK0                   ((0x0110  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK1                   ((0x0111  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK2                   ((0x0112  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK3                   ((0x0113  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK4                   ((0x0114  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK5                   ((0x0115  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK6                   ((0x0116  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_IRQ_MASK7                   ((0x0117  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_INIT_SET              ((0x0120  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_OFF_SET               ((0x0121  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_A_SET              ((0x0122  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_B_SET              ((0x0123  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_C_SET              ((0x0124  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_ON_D_SET              ((0x0125  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_MEMPD_STS                   ((0x0126  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS0                    ((0x0127  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS1                    ((0x0128  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_STS2                    ((0x0129  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_START_OFF               ((0x012d  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_START_ON                ((0x012e  << 2) + 0xfe00c000)
#define PWRCTRL_CPUTOP_FSM_JUMP                    ((0x012f  << 2) + 0xfe00c000)
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL0      10'h130
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL1      10'h131
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL2      10'h132
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL3      10'h133
//`define PWRCTRL_DSPA_AUTO_OFF_CTRL4      10'h134
//`define PWRCTRL_DSPA_TIMER_TH_01         10'h138
//`define PWRCTRL_DSPA_TIMER_TH_23         10'h139
//`define PWRCTRL_DSPA_TIMER_TH_45         10'h13A
//`define PWRCTRL_DSPA_TIMER_TH_67         10'h13B
//`define PWRCTRL_DSPA_TIMER_TH_89         10'h13C
//`define PWRCTRL_DSPA_IRQ_MASK0           10'h140
//`define PWRCTRL_DSPA_IRQ_MASK1           10'h141
//`define PWRCTRL_DSPA_IRQ_MASK2           10'h142
//`define PWRCTRL_DSPA_IRQ_MASK3           10'h143
//`define PWRCTRL_DSPA_IRQ_MASK4           10'h144
//`define PWRCTRL_DSPA_IRQ_MASK5           10'h145
//`define PWRCTRL_DSPA_IRQ_MASK6           10'h146
//`define PWRCTRL_DSPA_IRQ_MASK7           10'h147
//`define PWRCTRL_DSPA_MEMPD_INIT_SET      10'h150
//`define PWRCTRL_DSPA_MEMPD_OFF_SET       10'h151
//`define PWRCTRL_DSPA_MEMPD_ON_A_SET      10'h152
//`define PWRCTRL_DSPA_MEMPD_ON_B_SET      10'h153
//`define PWRCTRL_DSPA_MEMPD_ON_C_SET      10'h154
//`define PWRCTRL_DSPA_MEMPD_ON_D_SET      10'h155
//`define PWRCTRL_DSPA_MEMPD_STS           10'h156
//`define PWRCTRL_DSPA_FSM_STS0            10'h157
//`define PWRCTRL_DSPA_FSM_STS1            10'h158
//`define PWRCTRL_DSPA_FSM_STS2            10'h159
//`define PWRCTRL_DSPA_FSM_START_OFF       10'h15D
//`define PWRCTRL_DSPA_FSM_START_ON        10'h15E
//`define PWRCTRL_DSPA_FSM_JUMP            10'h15F
//`define PWRCTRL_AOCPU_AUTO_OFF_CTRL0     10'h160
//`define PWRCTRL_AOCPU_AUTO_OFF_CTRL1     10'h161
//`define PWRCTRL_AOCPU_AUTO_OFF_CTRL2     10'h162
//`define PWRCTRL_AOCPU_AUTO_OFF_CTRL3     10'h163
//`define PWRCTRL_AOCPU_AUTO_OFF_CTRL4     10'h164
//`define PWRCTRL_AOCPU_TIMER_TH_01        10'h168
//`define PWRCTRL_AOCPU_TIMER_TH_23        10'h169
//`define PWRCTRL_AOCPU_TIMER_TH_45        10'h16A
//`define PWRCTRL_AOCPU_TIMER_TH_67        10'h16B
//`define PWRCTRL_AOCPU_TIMER_TH_89        10'h16C
//`define PWRCTRL_AOCPU_IRQ_MASK0          10'h170
//`define PWRCTRL_AOCPU_IRQ_MASK1          10'h171
//`define PWRCTRL_AOCPU_IRQ_MASK2          10'h172
//`define PWRCTRL_AOCPU_IRQ_MASK3          10'h173
//`define PWRCTRL_AOCPU_IRQ_MASK4          10'h174
//`define PWRCTRL_AOCPU_IRQ_MASK5          10'h175
//`define PWRCTRL_AOCPU_IRQ_MASK6          10'h176
//`define PWRCTRL_AOCPU_IRQ_MASK7          10'h177
//`define PWRCTRL_AOCPU_MEMPD_INIT_SET     10'h180
//`define PWRCTRL_AOCPU_MEMPD_OFF_SET      10'h181
//`define PWRCTRL_AOCPU_MEMPD_ON_A_SET     10'h182
//`define PWRCTRL_AOCPU_MEMPD_ON_B_SET     10'h183
//`define PWRCTRL_AOCPU_MEMPD_ON_C_SET     10'h184
//`define PWRCTRL_AOCPU_MEMPD_ON_D_SET     10'h185
//`define PWRCTRL_AOCPU_MEMPD_STS          10'h186
//`define PWRCTRL_AOCPU_FSM_STS0           10'h187
//`define PWRCTRL_AOCPU_FSM_STS1           10'h188
//`define PWRCTRL_AOCPU_FSM_STS2           10'h189
//`define PWRCTRL_AOCPU_FSM_START_OFF      10'h18D
//`define PWRCTRL_AOCPU_FSM_START_ON       10'h18E
//`define PWRCTRL_AOCPU_FSM_JUMP           10'h18F
//========================================================================
// RSA
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe042000
// -----------------------------------------------
#define RSA_BASE                                   ((0x0000  << 2) + 0xfe042000)
//========================================================================
// ADLA1T
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04a000
// -----------------------------------------------
//
// Reading file:  ./adla_1t_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
//========================================================================
//  ADLA_1T - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04a000
// -----------------------------------------------
#define ADLA_1T_REV                                ((0x0000  << 2) + 0xfe04a000)
//Bit 5:0            reg_imp_rev
//Bit 11:6           reg_minor_rev
//Bit 15:12          reg_major_rev
#define ADLA_1T_WAIT_TIMER                         ((0x0001  << 2) + 0xfe04a000)
//Bit 15:0           reg_wait_timer_val
#define ADLA_1T_IRQ_MASKED                         ((0x0004  << 2) + 0xfe04a000)
//Bit 15:0           reg_irqsts_masked
#define ADLA_1T_IRQ_MASK                           ((0x0005  << 2) + 0xfe04a000)
//Bit 15:0           reg_irqsts_mask
#define ADLA_1T_IRQ_RAW                            ((0x0006  << 2) + 0xfe04a000)
//Bit 15:0           reg_irqsts_raw
#define ADLA_1T_STS_REPORT                         ((0x0007  << 2) + 0xfe04a000)
//Bit 15:0           reg_sts_report
#define ADLA_1T_SWRST                              ((0x0008  << 2) + 0xfe04a000)
//Bit 0:0            reg_adla_swrst
#define ADLA_1T_EN                                 ((0x0009  << 2) + 0xfe04a000)
//Bit 0:0            reg_adla_en
#define ADLA_1T_CLK_AUTOCLK                        ((0x000a  << 2) + 0xfe04a000)
//Bit 31:0           reg_adla_autoclk_en
#define ADLA_1T_CLK_IDLE_CNT                       ((0x000b  << 2) + 0xfe04a000)
//Bit 4:0            reg_adla_autoclk_idle_cnt
//Bit 12:8           reg_adla_autoclk_busy_cnt
#define ADLA_1T_DBG_EN                             ((0x000c  << 2) + 0xfe04a000)
//Bit 0:0            reg_dbg_en
#define ADLA_1T_DBG_SEL                            ((0x000d  << 2) + 0xfe04a000)
#define ADLA_1T_DBG_SUB_SEL                        ((0x000e  << 2) + 0xfe04a000)
#define ADLA_1T_DBG_DAT                            ((0x000f  << 2) + 0xfe04a000)
#define ADLA_1T_SRAM_CTRL                          ((0x0010  << 2) + 0xfe04a000)
#define ADLA_1T_SRAM_ADDR                          ((0x0011  << 2) + 0xfe04a000)
#define ADLA_1T_SRAM_WDAT                          ((0x0012  << 2) + 0xfe04a000)
#define ADLA_1T_SRAM_RDAT                          ((0x0013  << 2) + 0xfe04a000)
#define ADLA_1T_PS_CTRL                            ((0x0014  << 2) + 0xfe04a000)
#define ADLA_1T_PS_STS                             ((0x0015  << 2) + 0xfe04a000)
#define ADLA_1T_PS_ERR_DAT                         ((0x0016  << 2) + 0xfe04a000)
#define ADLA_1T_PS_IDLE_STS                        ((0x0017  << 2) + 0xfe04a000)
#define ADLA_1T_PS_TIME_STAMP                      ((0x0018  << 2) + 0xfe04a000)
#define ADLA_1T_PS_RBF_BASE                        ((0x0019  << 2) + 0xfe04a000)
#define ADLA_1T_PS_RBF_SIZE                        ((0x001a  << 2) + 0xfe04a000)
#define ADLA_1T_PS_RBF_WPT                         ((0x001b  << 2) + 0xfe04a000)
#define ADLA_1T_PS_RBF_RPT                         ((0x001c  << 2) + 0xfe04a000)
#define ADLA_1T_PS_RBF_PPT                         ((0x001d  << 2) + 0xfe04a000)
#define ADLA_1T_PS_FINISH_ID                       ((0x001e  << 2) + 0xfe04a000)
#define ADLA_1T_PS_HCNT                            ((0x001f  << 2) + 0xfe04a000)
#define ADLA_1T_PS_OST                             ((0x0020  << 2) + 0xfe04a000)
#define ADLA_1T_PS_PEND_EN                         ((0x0021  << 2) + 0xfe04a000)
#define ADLA_1T_PS_PEND_VAL                        ((0x0022  << 2) + 0xfe04a000)
#define ADLA_1T_PS_MDL_IDLE_STS                    ((0x0023  << 2) + 0xfe04a000)
#define ADLA_1T_PS_DBG_SW_ID                       ((0x0024  << 2) + 0xfe04a000)
#define ADLA_1T_AB_AXI_PADDR                       ((0x0027  << 2) + 0xfe04a000)
#define ADLA_1T_AB_CTL                             ((0x0028  << 2) + 0xfe04a000)
#define ADLA_1T_AB_AXI_SADDR                       ((0x0029  << 2) + 0xfe04a000)
#define ADLA_1T_AB_AXI_EADDR                       ((0x002a  << 2) + 0xfe04a000)
#define ADLA_1T_AB_R_CS_PRIO                       ((0x002b  << 2) + 0xfe04a000)
#define ADLA_1T_AB_R_LS_PRIO                       ((0x002c  << 2) + 0xfe04a000)
#define ADLA_1T_AB_R_L2_PRIO                       ((0x002d  << 2) + 0xfe04a000)
#define ADLA_1T_AB_W_PRIO                          ((0x002e  << 2) + 0xfe04a000)
#define ADLA_1T_AB_AXI_USER                        ((0x002f  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_EN                            ((0x0030  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_TTBR_L                        ((0x0031  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_TTBR_H                        ((0x0032  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_PRIO_POW2_0                   ((0x0033  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_PRIO_POW2_1                   ((0x0034  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_INV_CTL                       ((0x0035  << 2) + 0xfe04a000)
#define ADLA_1T_SMMU_INV_VA                        ((0x0036  << 2) + 0xfe04a000)
#define ADLA_1T_PM_EN                              ((0x003c  << 2) + 0xfe04a000)
#define ADLA_1T_PM_RBF_BASE                        ((0x003d  << 2) + 0xfe04a000)
#define ADLA_1T_PM_RBF_SIZE                        ((0x003e  << 2) + 0xfe04a000)
#define ADLA_1T_PM_RBF_WPT                         ((0x003f  << 2) + 0xfe04a000)
#define ADLA_1T_PM_RBF_RPT                         ((0x0040  << 2) + 0xfe04a000)
#define ADLA_1T_PM_STS                             ((0x0041  << 2) + 0xfe04a000)
#define ADLA_1T_AXXIBRG_DX_CTL                     ((0x0044  << 2) + 0xfe04a000)
#define ADLA_1T_AXXIBRG_DX_HOLD                    ((0x0045  << 2) + 0xfe04a000)
#define ADLA_1T_AXXIBRG_SX_CTL                     ((0x0046  << 2) + 0xfe04a000)
#define ADLA_1T_AXXIBRG_SX_HOLD                    ((0x0047  << 2) + 0xfe04a000)
#define ADLA_1T_MC_CTL                             ((0x0048  << 2) + 0xfe04a000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./adla_1t_regs.h
//
//========================================================================
//  AOCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  // = 0x00000000
// -----------------------------------------------
//`define AOCPU_CPU_CTRL0           8'h00
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_CTRL1           8'h01
////Bit 31:11-       0   - n205 address shift, 1: 0x8000_0000~0x4000_0000
////Bit 30:11-       0   - reserved
////Bit 10   -       0   - gate by sleep, 1: gate, 0: free run
////Bit  9   -       0   - RXEV for riscv input refer riscv doc
////Bit  8   -       0   - reserved
////Bit   7:6-       0   - n205_debug_sel,aocpu_core_status0 info select
////Bit   5:2-       0   - reserved
////Bit 1    -       0   - n205_i_dbg_stop
////Bit 0    -       0   - n205_pc_enable
//`define AOCPU_CPU_CTRL2           8'h02
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_CTRL3           8'h03
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_CTRL4           8'h04
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_CTRL5           8'h05
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_STS0            8'h0A
////Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
//`define AOCPU_CPU_STS1            8'h0B
////Bit 31   -       0   - n205_core_sleep_value
////Bit 30:29-       0   - n205_trace_priv
////Bit 28:20-       0   - reserved
////Bit 19   -       0   - n205_core_wfi_mode
////Bit 18   -       0   - n205_trace_invalid
////Bit 17   -       0   - n205_trace_iexception
////Bit 16   -       0   - n205_trace_interrupt
////Bit 15:0 -       0   - reserved
//`define AOCPU_CPU_STS2            8'h0C
////Bit 31:0-       0   - reserved
//`define AOCPU_CPU_STS3            8'h0D
////Bit 31   -       0   - n205_hart_halted
////Bit 30   -       0   - n205_ndmreset
////Bit 29   -       0   - n205_dmactive
////Bit 28:0 -       0   - reserved
//`define AOCPU_CPU_VECTOR          8'h0F
////Bit 31:0-   0x1000_0000   - reserved
//`define AOCPU_IRQ_SEL0            8'h10
////Bit 31:24-       0   - INTISR03 interrupt source select in int_map
////Bit 23:16-       0   - INTISR02 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR01 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR00 interrupt source select in int_map
//`define AOCPU_IRQ_SEL1            8'h11
////Bit 31:24-       0   - INTISR07 interrupt source select in int_map
////Bit 23:16-       0   - INTISR06 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR05 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR04 interrupt source select in int_map
//`define AOCPU_IRQ_SEL2            8'h12
////Bit 31:24-       0   - INTISR11 interrupt source select in int_map
////Bit 23:16-       0   - INTISR10 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR09 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR08 interrupt source select in int_map
//`define AOCPU_IRQ_SEL3            8'h13
////Bit 31:24-       0   - INTISR15 interrupt source select in int_map
////Bit 23:16-       0   - INTISR14 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR13 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR12 interrupt source select in int_map
//`define AOCPU_IRQ_SEL4            8'h14
////Bit 31:24-       0   - INTISR19 interrupt source select in int_map
////Bit 23:16-       0   - INTISR18 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR17 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR16 interrupt source select in int_map
//`define AOCPU_IRQ_SEL5            8'h15
////Bit 31:24-       0   - INTISR23 interrupt source select in int_map
////Bit 23:16-       0   - INTISR22 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR21 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR20 interrupt source select in int_map
//`define AOCPU_IRQ_SEL6            8'h16
////Bit 31:24-       0   - INTISR27 interrupt source select in int_map
////Bit 23:16-       0   - INTISR26 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR25 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR24 interrupt source select in int_map
//`define AOCPU_IRQ_SEL7            8'h17
////Bit 31:24-       0   - INTISR31 interrupt source select in int_map
////Bit 23:16-       0   - INTISR30 interrupt source select in int_map
////Bit 15:8 -       0   - INTISR29 interrupt source select in int_map
////Bit  7:0 -       0   - INTISR28 interrupt source select in int_map
//`define AOCPU_STS00_BYCPU         8'h18
////Bit 31:0-       0   - reserved
//`define AOCPU_STS01_BYCPU         8'h19
////Bit 31:0-       0   - reserved
//`define AOCPU_STS02_BYCPU         8'h1a
////Bit 31:0-       0   - reserved
//`define AOCPU_STS03_BYCPU         8'h1b
////Bit 31:0-       0   - reserved
//`define AOCPU_STS04_BYCPU         8'h1c
////Bit 31:0-       0   - reserved
//`define AOCPU_STS05_BYCPU         8'h1d
////Bit 31:0-       0   - reserved
//`define AOCPU_STS06_BYCPU         8'h1e
////Bit 31:0-       0   - reserved
//`define AOCPU_STS07_BYCPU         8'h1f
////Bit 31:0-       0   - reserved
//========================================================================
//  AUCPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe09e000
// -----------------------------------------------
//`define AUCPU_CPU_CTRL0           8'h00
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_CTRL1           8'h01
////Bit 31:11-       0   - reserved
////Bit 10   -       0   - gate by sleep
////Bit 9    -       0   - RXEV
////Bit 8    -       0   - reserved
////Bit 7:6  -       0   - n205_debug_sel,aucpu_core_status0 info select
////Bit 5:2  -       0   - reserved
////Bit 1    -       0   - n205_i_dbg_stop
////Bit 0    -       0   - n205_pc_enable
//`define AUCPU_CPU_CTRL2           8'h02
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_CTRL3           8'h03
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_CTRL4           8'h04
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_CTRL5           8'h05
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_STS0            8'h0A
////Bit 31:0 -       0   - n205_debug_sel==0 : n205_trace_cause, 1:n205_trace_tval, 2:n205_trace_iaddr, 3:n205_trace_instr
//`define AUCPU_CPU_STS1            8'h0B
////Bit 31   -       0   - n205_core_sleep_value
////Bit 30:29-       0   - n205_trace_priv
////Bit 28:20-       0   - reserved
////Bit 19   -       0   - n205_core_wfi_mode
////Bit 18   -       0   - n205_trace_invalid
////Bit 17   -       0   - n205_trace_iexception
////Bit 16   -       0   - n205_trace_interrupt
////Bit 15:0 -       0   - reserved
//`define AUCPU_CPU_STS2            8'h0C
////Bit 31:0 -       0   - reserved
//`define AUCPU_CPU_STS3            8'h0D
////Bit 31   -       0   - n205_hart_halted
////Bit 30   -       0   - n205_ndmreset
////Bit 29   -       0   - n205_dmactive
////Bit 28:0 -       0   - reserved
//`define AUCPU_DMA_APB_SEL         8'h10
////Bit 31:30-       0   - reserved
////Bit 0    -       0   - 1: riscv control dma, 0: ap control dma
//`define AUCPU_IRQ_AP2RISCV        8'h11
////Bit 31:0 -       0   - AP cpu send irq to riscv
//`define AUCPU_IRQ_RISCV2AP        8'h12
////Bit 31:0 -       0   - riscv send irq to AP
//`define AUCPU_STS00_BY_AP         8'h20
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS01_BY_AP         8'h21
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS02_BY_AP         8'h22
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS03_BY_AP         8'h23
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS04_BY_AP         8'h24
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS05_BY_AP         8'h25
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS06_BY_AP         8'h26
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS07_BY_AP         8'h27
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS08_BY_AP         8'h28
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS09_BY_AP         8'h29
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS10_BY_AP         8'h2A
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS11_BY_AP         8'h2B
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS12_BY_AP         8'h2C
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS13_BY_AP         8'h2D
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS14_BY_AP         8'h2E
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS15_BY_AP         8'h2F
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS16_BY_AP         8'h30
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS17_BY_AP         8'h31
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS18_BY_AP         8'h32
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS19_BY_AP         8'h33
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS20_BY_AP         8'h34
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS21_BY_AP         8'h35
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS22_BY_AP         8'h36
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS23_BY_AP         8'h37
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS24_BY_AP         8'h38
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS25_BY_AP         8'h39
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS26_BY_AP         8'h3A
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS27_BY_AP         8'h3B
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS28_BY_AP         8'h3C
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS29_BY_AP         8'h3D
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS30_BY_AP         8'h3E
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS31_BY_AP         8'h3F
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS00_BY_RISCV      8'h40
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS01_BY_RISCV      8'h41
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS02_BY_RISCV      8'h42
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS03_BY_RISCV      8'h43
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS04_BY_RISCV      8'h44
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS05_BY_RISCV      8'h45
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS06_BY_RISCV      8'h46
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS07_BY_RISCV      8'h47
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS08_BY_RISCV      8'h48
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS09_BY_RISCV      8'h49
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS10_BY_RISCV      8'h4A
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS11_BY_RISCV      8'h4B
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS12_BY_RISCV      8'h4C
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS13_BY_RISCV      8'h4D
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS14_BY_RISCV      8'h4E
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS15_BY_RISCV      8'h4F
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS16_BY_RISCV      8'h50
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS17_BY_RISCV      8'h51
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS18_BY_RISCV      8'h52
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS19_BY_RISCV      8'h53
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS20_BY_RISCV      8'h54
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS21_BY_RISCV      8'h55
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS22_BY_RISCV      8'h56
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS23_BY_RISCV      8'h57
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS24_BY_RISCV      8'h58
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS25_BY_RISCV      8'h59
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS26_BY_RISCV      8'h5A
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS27_BY_RISCV      8'h5B
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS28_BY_RISCV      8'h5C
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS29_BY_RISCV      8'h5D
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS30_BY_RISCV      8'h5E
////Bit 31:0 -       0   - reserved
//`define AUCPU_STS31_BY_RISCV      8'h5F
////Bit 31:0 -       0   - reserved
//`define AUCPU_DEMUX_STS_BY_RISCV  8'h60
////Bit 31   -       0   - read only, demux status updated
////Bit 31:8 -       0   - reserved
////Bit  7:0 -       0   - read demux chn select
//`define AUCPU_DEMUX_STS0          8'h61
////Bit 31:0 -       0   - demux status 0
//`define AUCPU_DEMUX_STS1          8'h62
////Bit 31:0 -       0   - demux status 1
//========================================================================
//  AXI_SRAM
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe090000
// -----------------------------------------------
#define SRAM_RANGE0_STA                            ((0x0000  << 2) + 0xfe090000)
#define SRAM_RANGE1_STA                            ((0x0001  << 2) + 0xfe090000)
#define SRAM_RANGE2_STA                            ((0x0002  << 2) + 0xfe090000)
#define SRAM_RANGE3_STA                            ((0x0003  << 2) + 0xfe090000)
#define SRAM_RANGE4_STA                            ((0x0004  << 2) + 0xfe090000)
#define SRAM_RANGE5_STA                            ((0x0005  << 2) + 0xfe090000)
#define SRAM_RANGE6_STA                            ((0x0006  << 2) + 0xfe090000)
#define SRAM_RANGE7_STA                            ((0x0007  << 2) + 0xfe090000)
#define SRAM_RANGE8_STA                            ((0x0008  << 2) + 0xfe090000)
#define SRAM_RANGE9_STA                            ((0x0009  << 2) + 0xfe090000)
#define SRAM_RANGE10_STA                           ((0x000a  << 2) + 0xfe090000)
#define SRAM_RANGE11_STA                           ((0x000b  << 2) + 0xfe090000)
#define SRAM_RANGE12_STA                           ((0x000c  << 2) + 0xfe090000)
#define SRAM_RANGE13_STA                           ((0x000d  << 2) + 0xfe090000)
#define SRAM_RANGE14_STA                           ((0x000e  << 2) + 0xfe090000)
#define SRAM_RANGE0_EDA                            ((0x000f  << 2) + 0xfe090000)
#define SRAM_RANGE1_EDA                            ((0x0010  << 2) + 0xfe090000)
#define SRAM_RANGE2_EDA                            ((0x0011  << 2) + 0xfe090000)
#define SRAM_RANGE3_EDA                            ((0x0012  << 2) + 0xfe090000)
#define SRAM_RANGE4_EDA                            ((0x0013  << 2) + 0xfe090000)
#define SRAM_RANGE5_EDA                            ((0x0014  << 2) + 0xfe090000)
#define SRAM_RANGE6_EDA                            ((0x0015  << 2) + 0xfe090000)
#define SRAM_RANGE7_EDA                            ((0x0016  << 2) + 0xfe090000)
#define SRAM_RANGE8_EDA                            ((0x0017  << 2) + 0xfe090000)
#define SRAM_RANGE9_EDA                            ((0x0018  << 2) + 0xfe090000)
#define SRAM_RANGE10_EDA                           ((0x0019  << 2) + 0xfe090000)
#define SRAM_RANGE11_EDA                           ((0x001a  << 2) + 0xfe090000)
#define SRAM_RANGE12_EDA                           ((0x001b  << 2) + 0xfe090000)
#define SRAM_RANGE13_EDA                           ((0x001c  << 2) + 0xfe090000)
#define SRAM_RANGE14_EDA                           ((0x001d  << 2) + 0xfe090000)
#define SRAM_RANGE0_READ_CTRL0                     ((0x001e  << 2) + 0xfe090000)
#define SRAM_RANGE1_READ_CTRL0                     ((0x001f  << 2) + 0xfe090000)
#define SRAM_RANGE2_READ_CTRL0                     ((0x0020  << 2) + 0xfe090000)
#define SRAM_RANGE3_READ_CTRL0                     ((0x0021  << 2) + 0xfe090000)
#define SRAM_RANGE4_READ_CTRL0                     ((0x0022  << 2) + 0xfe090000)
#define SRAM_RANGE5_READ_CTRL0                     ((0x0023  << 2) + 0xfe090000)
#define SRAM_RANGE6_READ_CTRL0                     ((0x0024  << 2) + 0xfe090000)
#define SRAM_RANGE7_READ_CTRL0                     ((0x0025  << 2) + 0xfe090000)
#define SRAM_RANGE8_READ_CTRL0                     ((0x0026  << 2) + 0xfe090000)
#define SRAM_RANGE9_READ_CTRL0                     ((0x0027  << 2) + 0xfe090000)
#define SRAM_RANGE10_READ_CTRL0                    ((0x0028  << 2) + 0xfe090000)
#define SRAM_RANGE11_READ_CTRL0                    ((0x0029  << 2) + 0xfe090000)
#define SRAM_RANGE12_READ_CTRL0                    ((0x002a  << 2) + 0xfe090000)
#define SRAM_RANGE13_READ_CTRL0                    ((0x002b  << 2) + 0xfe090000)
#define SRAM_RANGE14_READ_CTRL0                    ((0x002c  << 2) + 0xfe090000)
#define SRAM_RANGE15_READ_CTRL0                    ((0x002d  << 2) + 0xfe090000)
#define SRAM_RANGE0_WRITE_CTRL0                    ((0x002e  << 2) + 0xfe090000)
#define SRAM_RANGE1_WRITE_CTRL0                    ((0x002f  << 2) + 0xfe090000)
#define SRAM_RANGE2_WRITE_CTRL0                    ((0x0030  << 2) + 0xfe090000)
#define SRAM_RANGE3_WRITE_CTRL0                    ((0x0031  << 2) + 0xfe090000)
#define SRAM_RANGE4_WRITE_CTRL0                    ((0x0032  << 2) + 0xfe090000)
#define SRAM_RANGE5_WRITE_CTRL0                    ((0x0033  << 2) + 0xfe090000)
#define SRAM_RANGE6_WRITE_CTRL0                    ((0x0034  << 2) + 0xfe090000)
#define SRAM_RANGE7_WRITE_CTRL0                    ((0x0035  << 2) + 0xfe090000)
#define SRAM_RANGE8_WRITE_CTRL0                    ((0x0036  << 2) + 0xfe090000)
#define SRAM_RANGE9_WRITE_CTRL0                    ((0x0037  << 2) + 0xfe090000)
#define SRAM_RANGE10_WRITE_CTRL0                   ((0x0038  << 2) + 0xfe090000)
#define SRAM_RANGE11_WRITE_CTRL0                   ((0x0039  << 2) + 0xfe090000)
#define SRAM_RANGE12_WRITE_CTRL0                   ((0x003a  << 2) + 0xfe090000)
#define SRAM_RANGE13_WRITE_CTRL0                   ((0x003b  << 2) + 0xfe090000)
#define SRAM_RANGE14_WRITE_CTRL0                   ((0x003c  << 2) + 0xfe090000)
#define SRAM_RANGE15_WRITE_CTRL0                   ((0x003d  << 2) + 0xfe090000)
#define SRAM_RANGE0_READ_CTRL1                     ((0x003e  << 2) + 0xfe090000)
#define SRAM_RANGE1_READ_CTRL1                     ((0x003f  << 2) + 0xfe090000)
#define SRAM_RANGE2_READ_CTRL1                     ((0x0040  << 2) + 0xfe090000)
#define SRAM_RANGE3_READ_CTRL1                     ((0x0041  << 2) + 0xfe090000)
#define SRAM_RANGE4_READ_CTRL1                     ((0x0042  << 2) + 0xfe090000)
#define SRAM_RANGE5_READ_CTRL1                     ((0x0043  << 2) + 0xfe090000)
#define SRAM_RANGE6_READ_CTRL1                     ((0x0044  << 2) + 0xfe090000)
#define SRAM_RANGE7_READ_CTRL1                     ((0x0045  << 2) + 0xfe090000)
#define SRAM_RANGE8_READ_CTRL1                     ((0x0046  << 2) + 0xfe090000)
#define SRAM_RANGE9_READ_CTRL1                     ((0x0047  << 2) + 0xfe090000)
#define SRAM_RANGE10_READ_CTRL1                    ((0x0048  << 2) + 0xfe090000)
#define SRAM_RANGE11_READ_CTRL1                    ((0x0049  << 2) + 0xfe090000)
#define SRAM_RANGE12_READ_CTRL1                    ((0x004a  << 2) + 0xfe090000)
#define SRAM_RANGE13_READ_CTRL1                    ((0x004b  << 2) + 0xfe090000)
#define SRAM_RANGE14_READ_CTRL1                    ((0x004c  << 2) + 0xfe090000)
#define SRAM_RANGE15_READ_CTRL1                    ((0x004d  << 2) + 0xfe090000)
#define SRAM_RANGE0_WRITE_CTRL1                    ((0x004e  << 2) + 0xfe090000)
#define SRAM_RANGE1_WRITE_CTRL1                    ((0x004f  << 2) + 0xfe090000)
#define SRAM_RANGE2_WRITE_CTRL1                    ((0x0050  << 2) + 0xfe090000)
#define SRAM_RANGE3_WRITE_CTRL1                    ((0x0051  << 2) + 0xfe090000)
#define SRAM_RANGE4_WRITE_CTRL1                    ((0x0052  << 2) + 0xfe090000)
#define SRAM_RANGE5_WRITE_CTRL1                    ((0x0053  << 2) + 0xfe090000)
#define SRAM_RANGE6_WRITE_CTRL1                    ((0x0054  << 2) + 0xfe090000)
#define SRAM_RANGE7_WRITE_CTRL1                    ((0x0055  << 2) + 0xfe090000)
#define SRAM_RANGE8_WRITE_CTRL1                    ((0x0056  << 2) + 0xfe090000)
#define SRAM_RANGE9_WRITE_CTRL1                    ((0x0057  << 2) + 0xfe090000)
#define SRAM_RANGE10_WRITE_CTRL1                   ((0x0058  << 2) + 0xfe090000)
#define SRAM_RANGE11_WRITE_CTRL1                   ((0x0059  << 2) + 0xfe090000)
#define SRAM_RANGE12_WRITE_CTRL1                   ((0x005a  << 2) + 0xfe090000)
#define SRAM_RANGE13_WRITE_CTRL1                   ((0x005b  << 2) + 0xfe090000)
#define SRAM_RANGE14_WRITE_CTRL1                   ((0x005c  << 2) + 0xfe090000)
#define SRAM_RANGE15_WRITE_CTRL1                   ((0x005d  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL0                     ((0x005e  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL1                     ((0x005f  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL0                    ((0x0060  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL1                    ((0x0061  << 2) + 0xfe090000)
#define SRAM_SEC_CTRL0                             ((0x0062  << 2) + 0xfe090000)
#define SRAM_REG_LOCK0                             ((0x0063  << 2) + 0xfe090000)
#define SRAM_REG_LOCK1                             ((0x0064  << 2) + 0xfe090000)
#define SRAM_REG_LOCK2                             ((0x0065  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL0_LOCK                ((0x0066  << 2) + 0xfe090000)
#define SRAM_GLOBAL_READ_CTRL1_LOCK                ((0x0067  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL0_LOCK               ((0x0068  << 2) + 0xfe090000)
#define SRAM_GLOBAL_WRITE_CTRL1_LOCK               ((0x0069  << 2) + 0xfe090000)
#define SRAM_SEC_CTRL0_LOCK                        ((0x006a  << 2) + 0xfe090000)
#define SRAM_STATUS_REG                            ((0x006b  << 2) + 0xfe090000)
#define SRAM_INIT_DLY_TCNT                         ((0x006c  << 2) + 0xfe090000)
//========================================================================
//  AXI_SRAM B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe092000
// -----------------------------------------------
#define SRAM_B_RANGE0_STA                          ((0x0000  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_STA                          ((0x0001  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_STA                          ((0x0002  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_STA                          ((0x0003  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_STA                          ((0x0004  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_STA                          ((0x0005  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_STA                          ((0x0006  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_STA                          ((0x0007  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_STA                          ((0x0008  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_STA                          ((0x0009  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_STA                         ((0x000a  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_STA                         ((0x000b  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_STA                         ((0x000c  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_STA                         ((0x000d  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_STA                         ((0x000e  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_EDA                          ((0x000f  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_EDA                          ((0x0010  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_EDA                          ((0x0011  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_EDA                          ((0x0012  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_EDA                          ((0x0013  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_EDA                          ((0x0014  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_EDA                          ((0x0015  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_EDA                          ((0x0016  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_EDA                          ((0x0017  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_EDA                          ((0x0018  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_EDA                         ((0x0019  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_EDA                         ((0x001a  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_EDA                         ((0x001b  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_EDA                         ((0x001c  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_EDA                         ((0x001d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_READ_CTRL0                   ((0x001e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_READ_CTRL0                   ((0x001f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_READ_CTRL0                   ((0x0020  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_READ_CTRL0                   ((0x0021  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_READ_CTRL0                   ((0x0022  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_READ_CTRL0                   ((0x0023  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_READ_CTRL0                   ((0x0024  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_READ_CTRL0                   ((0x0025  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_READ_CTRL0                   ((0x0026  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_READ_CTRL0                   ((0x0027  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_READ_CTRL0                  ((0x0028  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_READ_CTRL0                  ((0x0029  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_READ_CTRL0                  ((0x002a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_READ_CTRL0                  ((0x002b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_READ_CTRL0                  ((0x002c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_READ_CTRL0                  ((0x002d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_WRITE_CTRL0                  ((0x002e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_WRITE_CTRL0                  ((0x002f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_WRITE_CTRL0                  ((0x0030  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_WRITE_CTRL0                  ((0x0031  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_WRITE_CTRL0                  ((0x0032  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_WRITE_CTRL0                  ((0x0033  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_WRITE_CTRL0                  ((0x0034  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_WRITE_CTRL0                  ((0x0035  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_WRITE_CTRL0                  ((0x0036  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_WRITE_CTRL0                  ((0x0037  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_WRITE_CTRL0                 ((0x0038  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_WRITE_CTRL0                 ((0x0039  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_WRITE_CTRL0                 ((0x003a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_WRITE_CTRL0                 ((0x003b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_WRITE_CTRL0                 ((0x003c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_WRITE_CTRL0                 ((0x003d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_READ_CTRL1                   ((0x003e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_READ_CTRL1                   ((0x003f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_READ_CTRL1                   ((0x0040  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_READ_CTRL1                   ((0x0041  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_READ_CTRL1                   ((0x0042  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_READ_CTRL1                   ((0x0043  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_READ_CTRL1                   ((0x0044  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_READ_CTRL1                   ((0x0045  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_READ_CTRL1                   ((0x0046  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_READ_CTRL1                   ((0x0047  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_READ_CTRL1                  ((0x0048  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_READ_CTRL1                  ((0x0049  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_READ_CTRL1                  ((0x004a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_READ_CTRL1                  ((0x004b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_READ_CTRL1                  ((0x004c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_READ_CTRL1                  ((0x004d  << 2) + 0xfe092000)
#define SRAM_B_RANGE0_WRITE_CTRL1                  ((0x004e  << 2) + 0xfe092000)
#define SRAM_B_RANGE1_WRITE_CTRL1                  ((0x004f  << 2) + 0xfe092000)
#define SRAM_B_RANGE2_WRITE_CTRL1                  ((0x0050  << 2) + 0xfe092000)
#define SRAM_B_RANGE3_WRITE_CTRL1                  ((0x0051  << 2) + 0xfe092000)
#define SRAM_B_RANGE4_WRITE_CTRL1                  ((0x0052  << 2) + 0xfe092000)
#define SRAM_B_RANGE5_WRITE_CTRL1                  ((0x0053  << 2) + 0xfe092000)
#define SRAM_B_RANGE6_WRITE_CTRL1                  ((0x0054  << 2) + 0xfe092000)
#define SRAM_B_RANGE7_WRITE_CTRL1                  ((0x0055  << 2) + 0xfe092000)
#define SRAM_B_RANGE8_WRITE_CTRL1                  ((0x0056  << 2) + 0xfe092000)
#define SRAM_B_RANGE9_WRITE_CTRL1                  ((0x0057  << 2) + 0xfe092000)
#define SRAM_B_RANGE10_WRITE_CTRL1                 ((0x0058  << 2) + 0xfe092000)
#define SRAM_B_RANGE11_WRITE_CTRL1                 ((0x0059  << 2) + 0xfe092000)
#define SRAM_B_RANGE12_WRITE_CTRL1                 ((0x005a  << 2) + 0xfe092000)
#define SRAM_B_RANGE13_WRITE_CTRL1                 ((0x005b  << 2) + 0xfe092000)
#define SRAM_B_RANGE14_WRITE_CTRL1                 ((0x005c  << 2) + 0xfe092000)
#define SRAM_B_RANGE15_WRITE_CTRL1                 ((0x005d  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL0                   ((0x005e  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL1                   ((0x005f  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL0                  ((0x0060  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL1                  ((0x0061  << 2) + 0xfe092000)
#define SRAM_B_SEC_CTRL0                           ((0x0062  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK0                           ((0x0063  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK1                           ((0x0064  << 2) + 0xfe092000)
#define SRAM_B_REG_LOCK2                           ((0x0065  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL0_LOCK              ((0x0066  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_READ_CTRL1_LOCK              ((0x0067  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL0_LOCK             ((0x0068  << 2) + 0xfe092000)
#define SRAM_B_GLOBAL_WRITE_CTRL1_LOCK             ((0x0069  << 2) + 0xfe092000)
#define SRAM_B_SEC_CTRL0_LOCK                      ((0x006a  << 2) + 0xfe092000)
#define SRAM_B_STATUS_REG                          ((0x006b  << 2) + 0xfe092000)
#define SRAM_B_INIT_DLY_TCNT                       ((0x006c  << 2) + 0xfe092000)
//========================================================================
//  MAILBOX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe006000
// -----------------------------------------------
#define MAILBOX_WR_MBOX00                          ((0x0000  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX01                          ((0x0020  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX02                          ((0x0040  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX03                          ((0x0060  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX04                          ((0x0080  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX05                          ((0x00a0  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX06                          ((0x00c0  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX07                          ((0x00e0  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX08                          ((0x0100  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX09                          ((0x0120  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX10                          ((0x0140  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX11                          ((0x0160  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX12                          ((0x0180  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX13                          ((0x01a0  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX14                          ((0x01c0  << 2) + 0xfe006000)
#define MAILBOX_WR_MBOX15                          ((0x01e0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX00                          ((0x0200  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX01                          ((0x0220  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX02                          ((0x0240  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX03                          ((0x0260  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX04                          ((0x0280  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX05                          ((0x02a0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX06                          ((0x02c0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX07                          ((0x02e0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX08                          ((0x0300  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX09                          ((0x0320  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX10                          ((0x0340  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX11                          ((0x0360  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX12                          ((0x0380  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX13                          ((0x03a0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX14                          ((0x03c0  << 2) + 0xfe006000)
#define MAILBOX_RD_MBOX15                          ((0x03e0  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT0                          ((0x0400  << 2) + 0xfe006000)
#define MAILBOX_LOCK_BIT1                          ((0x0401  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT0                          ((0x0402  << 2) + 0xfe006000)
#define MAILBOX_PROT_BIT1                          ((0x0403  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQA_CLR                 ((0x0404  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQB_CLR                 ((0x0405  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQC_CLR                 ((0x0406  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_IRQD_CLR                 ((0x0407  << 2) + 0xfe006000)
#define MAILBOX_IRQA_MASK                          ((0x0408  << 2) + 0xfe006000)
#define MAILBOX_IRQB_MASK                          ((0x0409  << 2) + 0xfe006000)
#define MAILBOX_IRQC_MASK                          ((0x040a  << 2) + 0xfe006000)
#define MAILBOX_IRQD_MASK                          ((0x040b  << 2) + 0xfe006000)
#define MAILBOX_IRQ_TYPE                           ((0x040c  << 2) + 0xfe006000)
#define MAILBOX_IRQA_CLR                           ((0x0410  << 2) + 0xfe006000)
#define MAILBOX_IRQB_CLR                           ((0x0411  << 2) + 0xfe006000)
#define MAILBOX_IRQC_CLR                           ((0x0412  << 2) + 0xfe006000)
#define MAILBOX_IRQD_CLR                           ((0x0413  << 2) + 0xfe006000)
#define MAILBOX_IRQA_STS                           ((0x0414  << 2) + 0xfe006000)
#define MAILBOX_IRQB_STS                           ((0x0415  << 2) + 0xfe006000)
#define MAILBOX_IRQC_STS                           ((0x0416  << 2) + 0xfe006000)
#define MAILBOX_IRQD_STS                           ((0x0417  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX00                   ((0x0420  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX01                   ((0x0421  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX02                   ((0x0422  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX03                   ((0x0423  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX04                   ((0x0424  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX05                   ((0x0425  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX06                   ((0x0426  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX07                   ((0x0427  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX08                   ((0x0428  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX09                   ((0x0429  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX10                   ((0x042a  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX11                   ((0x042b  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX12                   ((0x042c  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX13                   ((0x042d  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX14                   ((0x042e  << 2) + 0xfe006000)
#define MAILBOX_ACCESS_EN_MBOX15                   ((0x042f  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX00                         ((0x0430  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX01                         ((0x0431  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX02                         ((0x0432  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX03                         ((0x0433  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX04                         ((0x0434  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX05                         ((0x0435  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX06                         ((0x0436  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX07                         ((0x0437  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX08                         ((0x0438  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX09                         ((0x0439  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX10                         ((0x043a  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX11                         ((0x043b  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX12                         ((0x043c  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX13                         ((0x043d  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX14                         ((0x043e  << 2) + 0xfe006000)
#define MAILBOX_SET_MBOX15                         ((0x043f  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX00                         ((0x0440  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX01                         ((0x0441  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX02                         ((0x0442  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX03                         ((0x0443  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX04                         ((0x0444  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX05                         ((0x0445  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX06                         ((0x0446  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX07                         ((0x0447  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX08                         ((0x0448  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX09                         ((0x0449  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX10                         ((0x044a  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX11                         ((0x044b  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX12                         ((0x044c  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX13                         ((0x044d  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX14                         ((0x044e  << 2) + 0xfe006000)
#define MAILBOX_CLR_MBOX15                         ((0x044f  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX00                         ((0x0450  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX01                         ((0x0451  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX02                         ((0x0452  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX03                         ((0x0453  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX04                         ((0x0454  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX05                         ((0x0455  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX06                         ((0x0456  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX07                         ((0x0457  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX08                         ((0x0458  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX09                         ((0x0459  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX10                         ((0x045a  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX11                         ((0x045b  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX12                         ((0x045c  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX13                         ((0x045d  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX14                         ((0x045e  << 2) + 0xfe006000)
#define MAILBOX_STS_MBOX15                         ((0x045f  << 2) + 0xfe006000)
//========================================================================
//  IRQ_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00a000
// -----------------------------------------------
#define IRQCTRL_IRQ_INV0                           ((0x0000  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV1                           ((0x0001  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV2                           ((0x0002  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV3                           ((0x0003  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV4                           ((0x0004  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV5                           ((0x0005  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV6                           ((0x0006  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_INV7                           ((0x0007  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_GIC                          ((0x0010  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_GIC                          ((0x0011  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_GIC                          ((0x0012  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_GIC                          ((0x0013  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_GIC                          ((0x0014  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_GIC                          ((0x0015  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_GIC                          ((0x0016  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_GIC                          ((0x0017  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_DSP                          ((0x0020  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_DSP                          ((0x0021  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_DSP                          ((0x0022  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_DSP                          ((0x0023  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_DSP                          ((0x0024  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_DSP                          ((0x0025  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_DSP                          ((0x0026  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_DSP                          ((0x0027  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_PWRCTRL                      ((0x0030  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_PWRCTRL                      ((0x0031  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_PWRCTRL                      ((0x0032  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_PWRCTRL                      ((0x0033  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_PWRCTRL                      ((0x0034  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_PWRCTRL                      ((0x0035  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_PWRCTRL                      ((0x0036  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_PWRCTRL                      ((0x0037  << 2) + 0xfe00a000)
#define IRQCTRL_MASK0_AOCPU                        ((0x0040  << 2) + 0xfe00a000)
#define IRQCTRL_MASK1_AOCPU                        ((0x0041  << 2) + 0xfe00a000)
#define IRQCTRL_MASK2_AOCPU                        ((0x0042  << 2) + 0xfe00a000)
#define IRQCTRL_MASK3_AOCPU                        ((0x0043  << 2) + 0xfe00a000)
#define IRQCTRL_MASK4_AOCPU                        ((0x0044  << 2) + 0xfe00a000)
#define IRQCTRL_MASK5_AOCPU                        ((0x0045  << 2) + 0xfe00a000)
#define IRQCTRL_MASK6_AOCPU                        ((0x0046  << 2) + 0xfe00a000)
#define IRQCTRL_MASK7_AOCPU                        ((0x0047  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE0                          ((0x0050  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE1                          ((0x0051  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE2                          ((0x0052  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE3                          ((0x0053  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE4                          ((0x0054  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE5                          ((0x0055  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE6                          ((0x0056  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_MODE7                          ((0x0057  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH0                         ((0x0060  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH1                         ((0x0061  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH2                         ((0x0062  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH3                         ((0x0063  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH4                         ((0x0064  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH5                         ((0x0065  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH6                         ((0x0066  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH7                         ((0x0067  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR0                     ((0x0070  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR1                     ((0x0071  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR2                     ((0x0072  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR3                     ((0x0073  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR4                     ((0x0074  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR5                     ((0x0075  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR6                     ((0x0076  << 2) + 0xfe00a000)
#define IRQCTRL_IRQ_LATCH_CLR7                     ((0x0077  << 2) + 0xfe00a000)
#define IRQCTRL_LOCK_BIT                           ((0x0080  << 2) + 0xfe00a000)
#define IRQCTRL_PROT_BIT                           ((0x0081  << 2) + 0xfe00a000)
//========================================================================
//  RESET_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe002000
// -----------------------------------------------
#define RESETCTRL_RESET0                           ((0x0000  << 2) + 0xfe002000)
#define RESETCTRL_RESET1                           ((0x0001  << 2) + 0xfe002000)
#define RESETCTRL_RESET2                           ((0x0002  << 2) + 0xfe002000)
#define RESETCTRL_RESET3                           ((0x0003  << 2) + 0xfe002000)
#define RESETCTRL_RESET4                           ((0x0004  << 2) + 0xfe002000)
#define RESETCTRL_RESET5                           ((0x0005  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_LEVEL                     ((0x0010  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_LEVEL                     ((0x0011  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_LEVEL                     ((0x0012  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_LEVEL                     ((0x0013  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_LEVEL                     ((0x0014  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_LEVEL                     ((0x0015  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_MASK                      ((0x0020  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_MASK                      ((0x0021  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_MASK                      ((0x0022  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_MASK                      ((0x0023  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_MASK                      ((0x0024  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_MASK                      ((0x0025  << 2) + 0xfe002000)
#define RESETCTRL_RESET_HOLD_CYC                   ((0x0030  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CTRL0                   ((0x0040  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CTRL1                   ((0x0041  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CNT                     ((0x0042  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_CLR                     ((0x0043  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CTRL0               ((0x0044  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CTRL1               ((0x0045  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CNT                 ((0x0046  << 2) + 0xfe002000)
#define RESETCTRL_SEC_WATCHDOG_CLR                 ((0x0047  << 2) + 0xfe002000)
#define RESETCTRL_WATCHDOG_DLY_CNT                 ((0x0048  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0                       ((0x0050  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1                       ((0x0051  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_LEVEL                 ((0x0060  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_LEVEL                 ((0x0061  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_MASK                  ((0x0070  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_MASK                  ((0x0071  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_LOCK                      ((0x0080  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_LOCK                      ((0x0081  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_LOCK                      ((0x0082  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_LOCK                      ((0x0083  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_LOCK                      ((0x0084  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_LOCK                      ((0x0085  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_LOCK                  ((0x0088  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_LOCK                  ((0x0089  << 2) + 0xfe002000)
#define RESETCTRL_RESET0_PROT                      ((0x0090  << 2) + 0xfe002000)
#define RESETCTRL_RESET1_PROT                      ((0x0091  << 2) + 0xfe002000)
#define RESETCTRL_RESET2_PROT                      ((0x0092  << 2) + 0xfe002000)
#define RESETCTRL_RESET3_PROT                      ((0x0093  << 2) + 0xfe002000)
#define RESETCTRL_RESET4_PROT                      ((0x0094  << 2) + 0xfe002000)
#define RESETCTRL_RESET5_PROT                      ((0x0095  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET0_PROT                  ((0x0098  << 2) + 0xfe002000)
#define RESETCTRL_SEC_RESET1_PROT                  ((0x0099  << 2) + 0xfe002000)
//========================================================================
//  CPU_CTRL
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe00e000
// -----------------------------------------------
#define CPUCTRL_SYS_CPU_RESET_CNTL                 ((0x0050  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL                   ((0x0051  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL1                  ((0x0052  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL2                  ((0x0053  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL3                  ((0x0054  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL4                  ((0x0055  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL5                  ((0x0056  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_CTRL6                  ((0x0057  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CLK_RESULT                 ((0x0058  << 2) + 0xfe00e000)
#define CPUCTRL_ROM_DISABLE                        ((0x0060  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_POR_CFG0                   ((0x0090  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_POR_CFG1                   ((0x0091  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG0                       ((0x0092  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG1                       ((0x0093  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG2                       ((0x0094  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG3                       ((0x0095  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG4                       ((0x0096  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG5                       ((0x0097  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG6                       ((0x0098  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG7                       ((0x0099  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG8                       ((0x009a  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG9                       ((0x009b  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG10                      ((0x009c  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG11                      ((0x009d  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG12                      ((0x009e  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_CFG13                      ((0x009f  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS0                    ((0x00a0  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS1                    ((0x00a1  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS2                    ((0x00a2  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS3                    ((0x00a3  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS4                    ((0x00a4  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS5                    ((0x00a5  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS6                    ((0x00a6  << 2) + 0xfe00e000)
#define CPUCTRL_SYS_CPU_STATUS7                    ((0x00a7  << 2) + 0xfe00e000)
#define SYS_CPU_MISC                               ((0x00a8  << 2) + 0xfe00e000)
//========================================================================
//  SAR_ADC
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe026000
// -----------------------------------------------
#define SAR_ADC_REG0                               ((0x0000  << 2) + 0xfe026000)
#define SAR_ADC_CHAN_LIST                          ((0x0001  << 2) + 0xfe026000)
#define SAR_ADC_AVG_CNTL                           ((0x0002  << 2) + 0xfe026000)
#define SAR_ADC_REG3                               ((0x0003  << 2) + 0xfe026000)
#define SAR_ADC_DELAY                              ((0x0004  << 2) + 0xfe026000)
#define SAR_ADC_LAST_RD                            ((0x0005  << 2) + 0xfe026000)
#define SAR_ADC_FIFO_RD                            ((0x0006  << 2) + 0xfe026000)
#define SAR_ADC_AUX_SW                             ((0x0007  << 2) + 0xfe026000)
#define SAR_ADC_CHAN_10_SW                         ((0x0008  << 2) + 0xfe026000)
#define SAR_ADC_DETECT_IDLE_SW                     ((0x0009  << 2) + 0xfe026000)
#define SAR_ADC_DELTA_10                           ((0x000a  << 2) + 0xfe026000)
#define SAR_ADC_REG11                              ((0x000b  << 2) + 0xfe026000)
#define SAR_ADC_REG12                              ((0x000c  << 2) + 0xfe026000)
#define SAR_ADC_REG13                              ((0x000d  << 2) + 0xfe026000)
#define SAR_ADC_REG14                              ((0x000e  << 2) + 0xfe026000)
#define SAR_ADC_CH0_CTRL1                          ((0x0013  << 2) + 0xfe026000)
#define SAR_ADC_CH0_CTRL2                          ((0x0014  << 2) + 0xfe026000)
#define SAR_ADC_CH0_CTRL3                          ((0x0015  << 2) + 0xfe026000)
#define SAR_ADC_CH1_CTRL1                          ((0x0016  << 2) + 0xfe026000)
#define SAR_ADC_CH1_CTRL2                          ((0x0017  << 2) + 0xfe026000)
#define SAR_ADC_CH1_CTRL3                          ((0x0018  << 2) + 0xfe026000)
#define SAR_ADC_CH2_CTRL1                          ((0x0019  << 2) + 0xfe026000)
#define SAR_ADC_CH2_CTRL2                          ((0x001a  << 2) + 0xfe026000)
#define SAR_ADC_CH2_CTRL3                          ((0x001b  << 2) + 0xfe026000)
#define SAR_ADC_CH3_CTRL1                          ((0x001c  << 2) + 0xfe026000)
#define SAR_ADC_CH3_CTRL2                          ((0x001d  << 2) + 0xfe026000)
#define SAR_ADC_CH3_CTRL3                          ((0x001e  << 2) + 0xfe026000)
#define SAR_ADC_CH4_CTRL1                          ((0x001f  << 2) + 0xfe026000)
#define SAR_ADC_CH4_CTRL2                          ((0x0020  << 2) + 0xfe026000)
#define SAR_ADC_CH4_CTRL3                          ((0x0021  << 2) + 0xfe026000)
#define SAR_ADC_CH5_CTRL1                          ((0x0022  << 2) + 0xfe026000)
#define SAR_ADC_CH5_CTRL2                          ((0x0023  << 2) + 0xfe026000)
#define SAR_ADC_CH5_CTRL3                          ((0x0024  << 2) + 0xfe026000)
#define SAR_ADC_CH6_CTRL1                          ((0x0025  << 2) + 0xfe026000)
#define SAR_ADC_CH6_CTRL2                          ((0x0026  << 2) + 0xfe026000)
#define SAR_ADC_CH6_CTRL3                          ((0x0027  << 2) + 0xfe026000)
#define SAR_ADC_CH7_CTRL1                          ((0x0028  << 2) + 0xfe026000)
#define SAR_ADC_CH7_CTRL2                          ((0x0029  << 2) + 0xfe026000)
#define SAR_ADC_CH7_CTRL3                          ((0x002a  << 2) + 0xfe026000)
#define SAR_ADC_HCIC_CTRL1                         ((0x002b  << 2) + 0xfe026000)
#define SAR_ADC_F1_CTRL                            ((0x002c  << 2) + 0xfe026000)
#define SAR_ADC_F2_CTRL                            ((0x002d  << 2) + 0xfe026000)
#define SAR_ADC_F3_CTRL                            ((0x002e  << 2) + 0xfe026000)
#define SAR_ADC_DECI_FILTER_CTRL                   ((0x002f  << 2) + 0xfe026000)
#define SAR_ADC_COEF_RAM_CNTL                      ((0x0030  << 2) + 0xfe026000)
#define SAR_ADC_COEF_RAM_DATA                      ((0x0031  << 2) + 0xfe026000)
#define SAR_ADC_FIFO_RD_NEW                        ((0x0032  << 2) + 0xfe026000)
#define SAR_ADC_RAW                                ((0x0033  << 2) + 0xfe026000)
#define SAR_ADC_CHNL0                              ((0x0034  << 2) + 0xfe026000)
#define SAR_ADC_CHNL1                              ((0x0035  << 2) + 0xfe026000)
#define SAR_ADC_CHNL2                              ((0x0036  << 2) + 0xfe026000)
#define SAR_ADC_CHNL3                              ((0x0037  << 2) + 0xfe026000)
#define SAR_ADC_CHNL4                              ((0x0038  << 2) + 0xfe026000)
#define SAR_ADC_CHNL5                              ((0x0039  << 2) + 0xfe026000)
#define SAR_ADC_CHNL6                              ((0x003a  << 2) + 0xfe026000)
#define SAR_ADC_CHNL7                              ((0x003b  << 2) + 0xfe026000)
//========================================================================
//  ANA_CTRL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe008000
// -----------------------------------------------
#define ANACTRL_SYSPLL_CTRL0                       ((0x0000  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL1                       ((0x0001  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL2                       ((0x0002  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL3                       ((0x0003  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL4                       ((0x0004  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL5                       ((0x0005  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_CTRL6                       ((0x0006  << 2) + 0xfe008000)
#define ANACTRL_SYSPLL_STS                         ((0x0007  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL0                       ((0x0010  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL1                       ((0x0011  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL2                       ((0x0012  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL3                       ((0x0013  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL4                       ((0x0014  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL5                       ((0x0015  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_CTRL6                       ((0x0016  << 2) + 0xfe008000)
#define ANACTRL_FIXPLL_STS                         ((0x0017  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL0                       ((0x0020  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL1                       ((0x0021  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL2                       ((0x0022  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL3                       ((0x0023  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL4                       ((0x0024  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL5                       ((0x0025  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_CTRL6                       ((0x0026  << 2) + 0xfe008000)
#define ANACTRL_GP0PLL_STS                         ((0x0027  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL0                       ((0x0030  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL1                       ((0x0031  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL2                       ((0x0032  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL3                       ((0x0033  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL4                       ((0x0034  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL5                       ((0x0035  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_CTRL6                       ((0x0036  << 2) + 0xfe008000)
#define ANACTRL_GP1PLL_STS                         ((0x0037  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL0                      ((0x0040  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL1                      ((0x0041  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL2                      ((0x0042  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL3                      ((0x0043  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL4                      ((0x0044  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL5                      ((0x0045  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_CTRL6                      ((0x0046  << 2) + 0xfe008000)
#define ANACTRL_HIFIPLL_STS                        ((0x0047  << 2) + 0xfe008000)
//`define ANACTRL_PCIEPLL_CTRL0    8'h50
//`define ANACTRL_PCIEPLL_CTRL1    8'h51
//`define ANACTRL_PCIEPLL_CTRL2    8'h52
//`define ANACTRL_PCIEPLL_CTRL3    8'h53
//`define ANACTRL_PCIEPLL_CTRL4    8'h54
//`define ANACTRL_PCIEPLL_CTRL5    8'h55
//`define ANACTRL_PCIEPLL_STS      8'h56
#define ANACTRL_MPLL_CTRL0                         ((0x0060  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL1                         ((0x0061  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL2                         ((0x0062  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL3                         ((0x0063  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL4                         ((0x0064  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL5                         ((0x0065  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL6                         ((0x0066  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL7                         ((0x0067  << 2) + 0xfe008000)
#define ANACTRL_MPLL_CTRL8                         ((0x0068  << 2) + 0xfe008000)
#define ANACTRL_MPLL_STS                           ((0x0069  << 2) + 0xfe008000)
//`define ANACTRL_HDMIPLL_CTRL0    8'h70
//`define ANACTRL_HDMIPLL_CTRL1    8'h71
//`define ANACTRL_HDMIPLL_CTRL2    8'h72
//`define ANACTRL_HDMIPLL_CTRL3    8'h73
//`define ANACTRL_HDMIPLL_CTRL4    8'h74
//`define ANACTRL_HDMIPLL_CTRL5    8'h75
//`define ANACTRL_HDMIPLL_CTRL6    8'h76
//`define ANACTRL_HDMIPLL_STS      8'h77
//`define ANACTRL_HDMIPLL_VLOCK    8'h79
//`define ANACTRL_HDMIPHY_CTRL0    8'h80
//`define ANACTRL_HDMIPHY_CTRL1    8'h81
//`define ANACTRL_HDMIPHY_CTRL2    8'h82
//`define ANACTRL_HDMIPHY_CTRL3    8'h83
//`define ANACTRL_HDMIPHY_CTRL4    8'h84
//`define ANACTRL_HDMIPHY_CTRL5    8'h85
//`define ANACTRL_HDMIPHY_STS      8'h86
//`define ANACTRL_MIPICSI_CTRL0    8'h90
//`define ANACTRL_MIPICSI_CTRL1    8'h91
//`define ANACTRL_MIPICSI_CTRL2    8'h92
//`define ANACTRL_MIPICSI_CTRL3    8'h93
//`define ANACTRL_MIPICSI_CTRL4    8'h94
//`define ANACTRL_MIPICSI_CTRL5    8'h95
#define ANACTRL_MIPIDSI_CTRL0                      ((0x00a0  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_CTRL1                      ((0x00a1  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_CTRL2                      ((0x00a2  << 2) + 0xfe008000)
#define ANACTRL_MIPIDSI_STS                        ((0x00a3  << 2) + 0xfe008000)
//`define ANACTRL_VDAC_CTRL0       8'hB0
//`define ANACTRL_VDAC_CTRL1       8'hB1
#define ANACTRL_POR_CTRL                           ((0x00b6  << 2) + 0xfe008000)
#define ANACTRL_LOCK_BIT                           ((0x00b8  << 2) + 0xfe008000)
#define ANACTRL_PROT_BIT                           ((0x00b9  << 2) + 0xfe008000)
//`define ANACTRL_ADC_PLL_CTRL     8'hC0
//`define ANACTRL_ADC_PLL_CTRL1    8'hC1
//`define ANACTRL_ADC_PLL_CTRL2    8'hC2
//`define ANACTRL_ADC_PLL_CTRL3    8'hC3
//`define ANACTRL_ADC_PLL_CTRL4    8'hC4
//`define ANACTRL_ADC_PLL_CTRL5    8'hC5
//`define ANACTRL_ADC_PLL_CTRL6    8'hC6
//`define ANACTRL_ADC_PLL_STS      8'hC7
#define ANACTRL_RTCPLL_CTRL0                       ((0x00d0  << 2) + 0xfe008000)
#define ANACTRL_RTCPLL_CTRL1                       ((0x00d1  << 2) + 0xfe008000)
#define ANACTRL_RTCPLL_CTRL2                       ((0x00d2  << 2) + 0xfe008000)
#define ANACTRL_RTCPLL_CTRL3                       ((0x00d3  << 2) + 0xfe008000)
#define ANACTRL_RTCPLL_CTRL4                       ((0x00d4  << 2) + 0xfe008000)
#define ANACTRL_RTCPLL_STS                         ((0x00d5  << 2) + 0xfe008000)
//`define ANACTRL_S2_DADC_CTRL     8'hD0
//`define ANACTRL_S2_DADC_CTRL2    8'hD1
#define ANACTRL_CHIP_TEST_STS                      ((0x00e0  << 2) + 0xfe008000)
//========================================================================
//  Ethernet Phy
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe028000
// -----------------------------------------------
#define ETH_PHY_DBG_CTL0                           ((0x0000  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CTL1                           ((0x0001  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG0                           ((0x0002  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG1                           ((0x0003  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG2                           ((0x0004  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG3                           ((0x0005  << 2) + 0xfe028000)
#define ETH_PHY_DBG_CFG4                           ((0x0006  << 2) + 0xfe028000)
#define ETH_PLL_STS                                ((0x0010  << 2) + 0xfe028000)
#define ETH_PLL_CTL0                               ((0x0011  << 2) + 0xfe028000)
#define ETH_PLL_CTL1                               ((0x0012  << 2) + 0xfe028000)
#define ETH_PLL_CTL2                               ((0x0013  << 2) + 0xfe028000)
#define ETH_PLL_CTL3                               ((0x0014  << 2) + 0xfe028000)
#define ETH_PLL_CTL4                               ((0x0015  << 2) + 0xfe028000)
#define ETH_PLL_CTL5                               ((0x0016  << 2) + 0xfe028000)
#define ETH_PLL_CTL6                               ((0x0017  << 2) + 0xfe028000)
#define ETH_PLL_CTL7                               ((0x0018  << 2) + 0xfe028000)
#define ETH_PHY_CNTL0                              ((0x0020  << 2) + 0xfe028000)
#define ETH_PHY_CNTL1                              ((0x0021  << 2) + 0xfe028000)
#define ETH_PHY_CNTL2                              ((0x0022  << 2) + 0xfe028000)
#define ETH_PHY_CNTL3                              ((0x0023  << 2) + 0xfe028000)
#define ETH_PHY_STS0                               ((0x0025  << 2) + 0xfe028000)
#define ETH_PHY_STS1                               ((0x0026  << 2) + 0xfe028000)
#define ETH_PHY_STS2                               ((0x0027  << 2) + 0xfe028000)
#define ETH_PHY_DBG_REG                            ((0x0028  << 2) + 0xfe028000)
//========================================================================
//  Ethernet TOP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe024000
// -----------------------------------------------
#define ETHTOP_CNTL0                               ((0x0000  << 2) + 0xfe024000)
#define ETHTOP_CNTL1                               ((0x0001  << 2) + 0xfe024000)
//========================================================================
//  I2C Slave A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe064000
// -----------------------------------------------
#define I2C_S_A_CONTROL_REG                        ((0x0000  << 2) + 0xfe064000)
#define I2C_S_A_SEND_REG                           ((0x0001  << 2) + 0xfe064000)
#define I2C_S_A_RECV_REG                           ((0x0002  << 2) + 0xfe064000)
#define I2C_S_A_CNTL1_REG                          ((0x0003  << 2) + 0xfe064000)
//========================================================================
//  IR RX/TX
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe084000
// -----------------------------------------------
#define IRCTRL_IR_DEC_LDR_ACTIVE                   ((0x0000  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_LDR_IDLE                     ((0x0001  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_LDR_REPEAT                   ((0x0002  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_BIT_0                        ((0x0003  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_REG0                         ((0x0004  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_FRAME                        ((0x0005  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_STATUS                       ((0x0006  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_REG1                         ((0x0007  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_ACTIVE                ((0x0010  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_IDLE                  ((0x0011  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_LDR_REPEAT                ((0x0012  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_BIT_0                     ((0x0013  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG0                      ((0x0014  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME                     ((0x0015  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS                    ((0x0016  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG1                      ((0x0017  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG2                      ((0x0018  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_DURATN2                   ((0x0019  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_DURATN3                   ((0x001a  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME1                    ((0x001b  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS1                   ((0x001c  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_STATUS2                   ((0x001d  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REG3                      ((0x001e  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME_RSV0                ((0x001f  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FRAME_RSV1                ((0x0020  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FILTE                     ((0x0021  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_IRQ_CTL                   ((0x0022  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_FIFO_CTL                  ((0x0023  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_WIDTH_NEW                 ((0x0024  << 2) + 0xfe084000)
#define IRCTRL_MF_IR_DEC_REPEAT_DET                ((0x0025  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNTL0                  ((0x0030  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNTL1                  ((0x0031  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_IIR_THD                ((0x0032  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_THD0                   ((0x0033  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_THD1                   ((0x0034  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_SUM_CNT0               ((0x0035  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_SUM_CNT1               ((0x0036  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNT0                   ((0x0037  << 2) + 0xfe084000)
#define IRCTRL_IR_DEC_DEMOD_CNT1                   ((0x0038  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR0                    ((0x0043  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR1                    ((0x0044  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR2                    ((0x0045  << 2) + 0xfe084000)
#define IRCTRL_IR_BLASTER_ADDR3                    ((0x0046  << 2) + 0xfe084000)
//========================================================================
//  I2C Master A
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe066000
// -----------------------------------------------
#define I2C_M_A_CONTROL_REG                        ((0x0000  << 2) + 0xfe066000)
#define I2C_M_A_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe066000)
#define I2C_M_A_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe066000)
#define I2C_M_A_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe066000)
#define I2C_M_A_WDATA_REG0                         ((0x0004  << 2) + 0xfe066000)
#define I2C_M_A_WDATA_REG1                         ((0x0005  << 2) + 0xfe066000)
#define I2C_M_A_RDATA_REG0                         ((0x0006  << 2) + 0xfe066000)
#define I2C_M_A_RDATA_REG1                         ((0x0007  << 2) + 0xfe066000)
#define I2C_M_A_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe066000)
#define I2C_M_A_CNTL_DELY1                         ((0x0009  << 2) + 0xfe066000)
#define I2C_M_A_CNTL_DELY2                         ((0x000a  << 2) + 0xfe066000)
#define I2C_M_A_LOW_DELY                           ((0x000b  << 2) + 0xfe066000)
#define I2C_M_A_HIGH_DELY                          ((0x000c  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_PENDING                       ((0x000f  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe066000)
#define I2C_M_A_FIFO_ST0                           ((0x0011  << 2) + 0xfe066000)
//========================================================================
//  I2C Master B
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe068000
// -----------------------------------------------
#define I2C_M_B_CONTROL_REG                        ((0x0000  << 2) + 0xfe068000)
#define I2C_M_B_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe068000)
#define I2C_M_B_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe068000)
#define I2C_M_B_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe068000)
#define I2C_M_B_WDATA_REG0                         ((0x0004  << 2) + 0xfe068000)
#define I2C_M_B_WDATA_REG1                         ((0x0005  << 2) + 0xfe068000)
#define I2C_M_B_RDATA_REG0                         ((0x0006  << 2) + 0xfe068000)
#define I2C_M_B_RDATA_REG1                         ((0x0007  << 2) + 0xfe068000)
#define I2C_M_B_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe068000)
#define I2C_M_B_CNTL_DELY1                         ((0x0009  << 2) + 0xfe068000)
#define I2C_M_B_CNTL_DELY2                         ((0x000a  << 2) + 0xfe068000)
#define I2C_M_B_LOW_DELY                           ((0x000b  << 2) + 0xfe068000)
#define I2C_M_B_HIGH_DELY                          ((0x000c  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_PENDING                       ((0x000f  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe068000)
#define I2C_M_B_FIFO_ST0                           ((0x0011  << 2) + 0xfe068000)
//========================================================================
//  I2C Master C
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06a000
// -----------------------------------------------
#define I2C_M_C_CONTROL_REG                        ((0x0000  << 2) + 0xfe06a000)
#define I2C_M_C_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06a000)
#define I2C_M_C_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06a000)
#define I2C_M_C_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06a000)
#define I2C_M_C_WDATA_REG0                         ((0x0004  << 2) + 0xfe06a000)
#define I2C_M_C_WDATA_REG1                         ((0x0005  << 2) + 0xfe06a000)
#define I2C_M_C_RDATA_REG0                         ((0x0006  << 2) + 0xfe06a000)
#define I2C_M_C_RDATA_REG1                         ((0x0007  << 2) + 0xfe06a000)
#define I2C_M_C_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06a000)
#define I2C_M_C_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06a000)
#define I2C_M_C_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06a000)
#define I2C_M_C_LOW_DELY                           ((0x000b  << 2) + 0xfe06a000)
#define I2C_M_C_HIGH_DELY                          ((0x000c  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06a000)
#define I2C_M_C_FIFO_ST0                           ((0x0011  << 2) + 0xfe06a000)
//========================================================================
//  I2C Master D
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06c000
// -----------------------------------------------
#define I2C_M_D_CONTROL_REG                        ((0x0000  << 2) + 0xfe06c000)
#define I2C_M_D_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06c000)
#define I2C_M_D_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06c000)
#define I2C_M_D_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06c000)
#define I2C_M_D_WDATA_REG0                         ((0x0004  << 2) + 0xfe06c000)
#define I2C_M_D_WDATA_REG1                         ((0x0005  << 2) + 0xfe06c000)
#define I2C_M_D_RDATA_REG0                         ((0x0006  << 2) + 0xfe06c000)
#define I2C_M_D_RDATA_REG1                         ((0x0007  << 2) + 0xfe06c000)
#define I2C_M_D_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06c000)
#define I2C_M_D_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06c000)
#define I2C_M_D_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06c000)
#define I2C_M_D_LOW_DELY                           ((0x000b  << 2) + 0xfe06c000)
#define I2C_M_D_HIGH_DELY                          ((0x000c  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06c000)
#define I2C_M_D_FIFO_ST0                           ((0x0011  << 2) + 0xfe06c000)
//========================================================================
//  I2C Master E
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe06e000
// -----------------------------------------------
#define I2C_M_E_CONTROL_REG                        ((0x0000  << 2) + 0xfe06e000)
#define I2C_M_E_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe06e000)
#define I2C_M_E_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe06e000)
#define I2C_M_E_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe06e000)
#define I2C_M_E_WDATA_REG0                         ((0x0004  << 2) + 0xfe06e000)
#define I2C_M_E_WDATA_REG1                         ((0x0005  << 2) + 0xfe06e000)
#define I2C_M_E_RDATA_REG0                         ((0x0006  << 2) + 0xfe06e000)
#define I2C_M_E_RDATA_REG1                         ((0x0007  << 2) + 0xfe06e000)
#define I2C_M_E_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe06e000)
#define I2C_M_E_CNTL_DELY1                         ((0x0009  << 2) + 0xfe06e000)
#define I2C_M_E_CNTL_DELY2                         ((0x000a  << 2) + 0xfe06e000)
#define I2C_M_E_LOW_DELY                           ((0x000b  << 2) + 0xfe06e000)
#define I2C_M_E_HIGH_DELY                          ((0x000c  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_CTRL0                         ((0x000d  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_CTRL1                         ((0x000e  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_PENDING                       ((0x000f  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_PENDING_MASK                  ((0x0010  << 2) + 0xfe06e000)
#define I2C_M_E_FIFO_ST0                           ((0x0011  << 2) + 0xfe06e000)
//========================================================================
//  I2C Master F
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe070000
// -----------------------------------------------
#define I2C_M_F_CONTROL_REG                        ((0x0000  << 2) + 0xfe070000)
#define I2C_M_F_SLAVE_ADDR                         ((0x0001  << 2) + 0xfe070000)
#define I2C_M_F_TOKEN_LIST0                        ((0x0002  << 2) + 0xfe070000)
#define I2C_M_F_TOKEN_LIST1                        ((0x0003  << 2) + 0xfe070000)
#define I2C_M_F_WDATA_REG0                         ((0x0004  << 2) + 0xfe070000)
#define I2C_M_F_WDATA_REG1                         ((0x0005  << 2) + 0xfe070000)
#define I2C_M_F_RDATA_REG0                         ((0x0006  << 2) + 0xfe070000)
#define I2C_M_F_RDATA_REG1                         ((0x0007  << 2) + 0xfe070000)
#define I2C_M_F_TIMEOUT_TH                         ((0x0008  << 2) + 0xfe070000)
#define I2C_M_F_CNTL_DELY1                         ((0x0009  << 2) + 0xfe070000)
#define I2C_M_F_CNTL_DELY2                         ((0x000a  << 2) + 0xfe070000)
#define I2C_M_F_LOW_DELY                           ((0x000b  << 2) + 0xfe070000)
#define I2C_M_F_HIGH_DELY                          ((0x000c  << 2) + 0xfe070000)
#define I2C_M_F_FIFO_CTRL_REG                      ((0x000d  << 2) + 0xfe070000)
#define I2C_M_F_STATE_REG                          ((0x000e  << 2) + 0xfe070000)
//========================================================================
//  APB0_UART_A - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe078000
// -----------------------------------------------
#define UART_A_WFIFO                               ((0x0000  << 2) + 0xfe078000)
#define UART_A_RFIFO                               ((0x0001  << 2) + 0xfe078000)
#define UART_A_CONTROL                             ((0x0002  << 2) + 0xfe078000)
#define UART_A_STATUS                              ((0x0003  << 2) + 0xfe078000)
#define UART_A_MISC                                ((0x0004  << 2) + 0xfe078000)
#define UART_A_REG5                                ((0x0005  << 2) + 0xfe078000)
//========================================================================
//  APB0_UART_B - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07a000
// -----------------------------------------------
#define UART_B_WFIFO                               ((0x0000  << 2) + 0xfe07a000)
#define UART_B_RFIFO                               ((0x0001  << 2) + 0xfe07a000)
#define UART_B_CONTROL                             ((0x0002  << 2) + 0xfe07a000)
#define UART_B_STATUS                              ((0x0003  << 2) + 0xfe07a000)
#define UART_B_MISC                                ((0x0004  << 2) + 0xfe07a000)
#define UART_B_REG5                                ((0x0005  << 2) + 0xfe07a000)
//========================================================================
//  APB0_UART_C - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07c000
// -----------------------------------------------
#define UART_C_WFIFO                               ((0x0000  << 2) + 0xfe07c000)
#define UART_C_RFIFO                               ((0x0001  << 2) + 0xfe07c000)
#define UART_C_CONTROL                             ((0x0002  << 2) + 0xfe07c000)
#define UART_C_STATUS                              ((0x0003  << 2) + 0xfe07c000)
#define UART_C_MISC                                ((0x0004  << 2) + 0xfe07c000)
#define UART_C_REG5                                ((0x0005  << 2) + 0xfe07c000)
//========================================================================
//  APB0_UART_D - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe07e000
// -----------------------------------------------
#define UART_D_WFIFO                               ((0x0000  << 2) + 0xfe07e000)
#define UART_D_RFIFO                               ((0x0001  << 2) + 0xfe07e000)
#define UART_D_CONTROL                             ((0x0002  << 2) + 0xfe07e000)
#define UART_D_STATUS                              ((0x0003  << 2) + 0xfe07e000)
#define UART_D_MISC                                ((0x0004  << 2) + 0xfe07e000)
#define UART_D_REG5                                ((0x0005  << 2) + 0xfe07e000)
//========================================================================
//  APB0_UART_E - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe080000
// -----------------------------------------------
#define UART_E_WFIFO                               ((0x0000  << 2) + 0xfe080000)
#define UART_E_RFIFO                               ((0x0001  << 2) + 0xfe080000)
#define UART_E_CONTROL                             ((0x0002  << 2) + 0xfe080000)
#define UART_E_STATUS                              ((0x0003  << 2) + 0xfe080000)
#define UART_E_MISC                                ((0x0004  << 2) + 0xfe080000)
#define UART_E_REG5                                ((0x0005  << 2) + 0xfe080000)
//========================================================================
//  APB0_UART_F - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe082000
// -----------------------------------------------
#define UART_F_WFIFO                               ((0x0000  << 2) + 0xfe082000)
#define UART_F_RFIFO                               ((0x0001  << 2) + 0xfe082000)
#define UART_F_CONTROL                             ((0x0002  << 2) + 0xfe082000)
#define UART_F_STATUS                              ((0x0003  << 2) + 0xfe082000)
#define UART_F_MISC                                ((0x0004  << 2) + 0xfe082000)
#define UART_F_REG5                                ((0x0005  << 2) + 0xfe082000)
//========================================================================
//  PWM_AB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe058000
// -----------------------------------------------
#define PWMAB_PWM_A                                ((0x0000  << 2) + 0xfe058000)
#define PWMAB_PWM_B                                ((0x0001  << 2) + 0xfe058000)
#define PWMAB_MISC_REG_AB                          ((0x0002  << 2) + 0xfe058000)
#define PWMAB_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe058000)
#define PWMAB_TIME_AB                              ((0x0004  << 2) + 0xfe058000)
#define PWMAB_A2                                   ((0x0005  << 2) + 0xfe058000)
#define PWMAB_B2                                   ((0x0006  << 2) + 0xfe058000)
#define PWMAB_BLINK_AB                             ((0x0007  << 2) + 0xfe058000)
#define PWMAB_LOCK_AB                              ((0x0008  << 2) + 0xfe058000)
//========================================================================
//  PWM_CD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05a000
// -----------------------------------------------
#define PWMCD_PWM_A                                ((0x0000  << 2) + 0xfe05a000)
#define PWMCD_PWM_B                                ((0x0001  << 2) + 0xfe05a000)
#define PWMCD_MISC_REG_AB                          ((0x0002  << 2) + 0xfe05a000)
#define PWMCD_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe05a000)
#define PWMCD_TIME_AB                              ((0x0004  << 2) + 0xfe05a000)
#define PWMCD_A2                                   ((0x0005  << 2) + 0xfe05a000)
#define PWMCD_B2                                   ((0x0006  << 2) + 0xfe05a000)
#define PWMCD_BLINK_AB                             ((0x0007  << 2) + 0xfe05a000)
#define PWMCD_LOCK_AB                              ((0x0008  << 2) + 0xfe05a000)
//========================================================================
//  PWM_EF - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05c000
// -----------------------------------------------
#define PWMEF_PWM_A                                ((0x0000  << 2) + 0xfe05c000)
#define PWMEF_PWM_B                                ((0x0001  << 2) + 0xfe05c000)
#define PWMEF_MISC_REG_AB                          ((0x0002  << 2) + 0xfe05c000)
#define PWMEF_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe05c000)
#define PWMEF_TIME_AB                              ((0x0004  << 2) + 0xfe05c000)
#define PWMEF_A2                                   ((0x0005  << 2) + 0xfe05c000)
#define PWMEF_B2                                   ((0x0006  << 2) + 0xfe05c000)
#define PWMEF_BLINK_AB                             ((0x0007  << 2) + 0xfe05c000)
#define PWMEF_LOCK_AB                              ((0x0008  << 2) + 0xfe05c000)
//========================================================================
//  PWM_GH - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe05e000
// -----------------------------------------------
#define PWMGH_PWM_A                                ((0x0000  << 2) + 0xfe05e000)
#define PWMGH_PWM_B                                ((0x0001  << 2) + 0xfe05e000)
#define PWMGH_MISC_REG_AB                          ((0x0002  << 2) + 0xfe05e000)
#define PWMGH_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe05e000)
#define PWMGH_TIME_AB                              ((0x0004  << 2) + 0xfe05e000)
#define PWMGH_A2                                   ((0x0005  << 2) + 0xfe05e000)
#define PWMGH_B2                                   ((0x0006  << 2) + 0xfe05e000)
#define PWMGH_BLINK_AB                             ((0x0007  << 2) + 0xfe05e000)
#define PWMGH_LOCK_AB                              ((0x0008  << 2) + 0xfe05e000)
//========================================================================
//  PWM_IJ - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe060000
// -----------------------------------------------
#define PWMIJ_PWM_A                                ((0x0000  << 2) + 0xfe060000)
#define PWMIJ_PWM_B                                ((0x0001  << 2) + 0xfe060000)
#define PWMIJ_MISC_REG_AB                          ((0x0002  << 2) + 0xfe060000)
#define PWMIJ_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe060000)
#define PWMIJ_TIME_AB                              ((0x0004  << 2) + 0xfe060000)
#define PWMIJ_A2                                   ((0x0005  << 2) + 0xfe060000)
#define PWMIJ_B2                                   ((0x0006  << 2) + 0xfe060000)
#define PWMIJ_BLINK_AB                             ((0x0007  << 2) + 0xfe060000)
#define PWMIJ_LOCK_AB                              ((0x0008  << 2) + 0xfe060000)
//========================================================================
//  PWM_KL - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe062000
// -----------------------------------------------
#define PWMKL_PWM_A                                ((0x0000  << 2) + 0xfe062000)
#define PWMKL_PWM_B                                ((0x0001  << 2) + 0xfe062000)
#define PWMKL_MISC_REG_AB                          ((0x0002  << 2) + 0xfe062000)
#define PWMKL_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe062000)
#define PWMKL_TIME_AB                              ((0x0004  << 2) + 0xfe062000)
#define PWMKL_A2                                   ((0x0005  << 2) + 0xfe062000)
#define PWMKL_B2                                   ((0x0006  << 2) + 0xfe062000)
#define PWMKL_BLINK_AB                             ((0x0007  << 2) + 0xfe062000)
#define PWMKL_LOCK_AB                              ((0x0008  << 2) + 0xfe062000)
//========================================================================
//  PWM_MN - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe054000
// -----------------------------------------------
#define PWMMN_PWM_A                                ((0x0000  << 2) + 0xfe054000)
#define PWMMN_PWM_B                                ((0x0001  << 2) + 0xfe054000)
#define PWMMN_MISC_REG_AB                          ((0x0002  << 2) + 0xfe054000)
#define PWMMN_DELTA_SIGMA_AB                       ((0x0003  << 2) + 0xfe054000)
#define PWMMN_TIME_AB                              ((0x0004  << 2) + 0xfe054000)
#define PWMMN_A2                                   ((0x0005  << 2) + 0xfe054000)
#define PWMMN_B2                                   ((0x0006  << 2) + 0xfe054000)
#define PWMMN_BLINK_AB                             ((0x0007  << 2) + 0xfe054000)
#define PWMMN_LOCK_AB                              ((0x0008  << 2) + 0xfe054000)
//========================================================================
//  SPICC_0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe050000
// -----------------------------------------------
#define SPICC0_RXDATA                              ((0x0000  << 2) + 0xfe050000)
#define SPICC0_TXDATA                              ((0x0001  << 2) + 0xfe050000)
#define SPICC0_CONREG                              ((0x0002  << 2) + 0xfe050000)
#define SPICC0_INTREG                              ((0x0003  << 2) + 0xfe050000)
#define SPICC0_DMAREG                              ((0x0004  << 2) + 0xfe050000)
#define SPICC0_STATREG                             ((0x0005  << 2) + 0xfe050000)
#define SPICC0_PERIODREG                           ((0x0006  << 2) + 0xfe050000)
#define SPICC0_TESTREG                             ((0x0007  << 2) + 0xfe050000)
#define SPICC0_DRADDR                              ((0x0008  << 2) + 0xfe050000)
#define SPICC0_DWADDR                              ((0x0009  << 2) + 0xfe050000)
#define SPICC0_LD_CNTL0                            ((0x000a  << 2) + 0xfe050000)
#define SPICC0_LD_CNTL1                            ((0x000b  << 2) + 0xfe050000)
#define SPICC0_LD_RADDR                            ((0x000c  << 2) + 0xfe050000)
#define SPICC0_LD_WADDR                            ((0x000d  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe050000)
#define SPICC0_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe050000)
//========================================================================
//  SPICC_1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe052000
// -----------------------------------------------
#define SPICC1_RXDATA                              ((0x0000  << 2) + 0xfe052000)
#define SPICC1_TXDATA                              ((0x0001  << 2) + 0xfe052000)
#define SPICC1_CONREG                              ((0x0002  << 2) + 0xfe052000)
#define SPICC1_INTREG                              ((0x0003  << 2) + 0xfe052000)
#define SPICC1_DMAREG                              ((0x0004  << 2) + 0xfe052000)
#define SPICC1_STATREG                             ((0x0005  << 2) + 0xfe052000)
#define SPICC1_PERIODREG                           ((0x0006  << 2) + 0xfe052000)
#define SPICC1_TESTREG                             ((0x0007  << 2) + 0xfe052000)
#define SPICC1_DRADDR                              ((0x0008  << 2) + 0xfe052000)
#define SPICC1_DWADDR                              ((0x0009  << 2) + 0xfe052000)
#define SPICC1_LD_CNTL0                            ((0x000a  << 2) + 0xfe052000)
#define SPICC1_LD_CNTL1                            ((0x000b  << 2) + 0xfe052000)
#define SPICC1_LD_RADDR                            ((0x000c  << 2) + 0xfe052000)
#define SPICC1_LD_WADDR                            ((0x000d  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL                        ((0x000e  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL1                       ((0x000f  << 2) + 0xfe052000)
#define SPICC1_ENHANCE_CNTL2                       ((0x0010  << 2) + 0xfe052000)
//========================================================================
//  AIFIFO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe046f00
// -----------------------------------------------
#define AIU_AIFIFO_CTRL                            ((0x0000  << 2) + 0xfe046f00)
#define AIU_AIFIFO_STATUS                          ((0x0001  << 2) + 0xfe046f00)
#define AIU_AIFIFO_GBIT                            ((0x0002  << 2) + 0xfe046f00)
#define AIU_AIFIFO_CLB                             ((0x0003  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_START_PTR                   ((0x0004  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_CURR_PTR                    ((0x0005  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_END_PTR                     ((0x0006  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_BYTES_AVAIL                 ((0x0007  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_CONTROL                     ((0x0008  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_MAN_WP                      ((0x0009  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_MAN_RP                      ((0x000a  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_LEVEL                       ((0x000b  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_BUF_CNTL                    ((0x000c  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_BUF_WRAP_COUNT              ((0x000d  << 2) + 0xfe046f00)
#define AIU_MEM_AIFIFO_MEM_CTL                     ((0x000f  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_CNTL                     ((0x0010  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_SYNC_0                   ((0x0011  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_SYNC_1                   ((0x0012  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_0                        ((0x0013  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_1                        ((0x0014  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_2                        ((0x0015  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_3                        ((0x0016  << 2) + 0xfe046f00)
#define AIFIFO_TIME_STAMP_LENGTH                   ((0x0017  << 2) + 0xfe046f00)
//========================================================================
//  MSR_CLK - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe048000
// -----------------------------------------------
#define MSR_CLK_REG0                               ((0x0000  << 2) + 0xfe048000)
#define MSR_CLK_REG1                               ((0x0001  << 2) + 0xfe048000)
#define MSR_CLK_REG2                               ((0x0002  << 2) + 0xfe048000)
#define MSR_CLK_REG3                               ((0x0003  << 2) + 0xfe048000)
#define MSR_CLK_REG4                               ((0x0004  << 2) + 0xfe048000)
#define MSR_CLK_REG5                               ((0x0005  << 2) + 0xfe048000)
#define MSR_CLK_DUTY                               ((0x0006  << 2) + 0xfe048000)
//
// Reading file:  ./spifc_reg.vh
//
//`ifdef SPIFC_REG_DEFINE
//`else
//`define SPIFC_REG_DEFINE
//`define SPIFC BASE ADDR      32'hfe056000
// -----------------------------------------------
// REG_BASE:  APB2_BASE_ADDR = 0xfe056000
// -----------------------------------------------
//AHB domain regsiter.
#define SPIFC_AHB_CTRL                             ((0x0000  << 2) + 0xfe056000)
  //bit 31   AHB BUS enable.  1 enable ahb request.  0: disable ahb request.
  //bit 30.  decerr_en for (AXI->AHB bridge).
  //bit 29.  force_incr.  for ( AXI->AHB bridge).
  //bit 20.  ahb_idle_ctrl. 1: show idle status in C1 mode. 0: show Idle always.
  //bit 19.  critical word first.  CWF_EN.  1: enable.   0 : disable.
  //bit 18:17 RDBUF_SIZE . 00: 64bytes. 01: 32 bytes. 10: 16 bytes. 11: reserved.
  //bit 16  AHB MASTER enable.  if enabled, each master use one dedicated HRDATA buffer inside ahb2api model. total 3 HRDATA buffers inside ahb2spi.
                               //if disabled the 3 HRDATA buffer will random be used for all masters.
  //bit 14  write 1 to clean the HRDATA buffer 2. read 0 finished clean operation.
  //bit 13  write 1 to clean the HRDATA buffer 1. read 0 finished clean operation.
  //bit 12  write 1 to clean the HRDATA buffer 0. read 0 finished clean operation.
  //bit 11.  clr_wtchdg:   1: clear WTCHDG_STS bits in STS registers. 0 : normal.
  //bit 10:0.  not used.
#define SPIFC_CLK_CTRL                             ((0x0001  << 2) + 0xfe056000)
  //bit 14   asynchronous buffer ahb clock disable.  1 = disable. 0 = enable.
  //bit 13   ahb2spi ahb clock disable.  1 = disable. 0 = enable.
  //bit 12   ahb_arb ahb clock disable.  1 = disable. 0 = enable.
  //bit 10   asynchronous buffer ahb clock auto gating enable.  1 = enable. 0 = disable.
  //bit 9    ahb2spi ahb clock auto gating enable.  1 = enable. 0 = disable.
  //bit 8    ahbarb  ahb clock auto gating enable.  1 = enable. 0 = disable.
  //bit 2.    asynchronous AHB clock domain software reset.  1 = reset. 0 = normal working mode.
  //bit 1.    ahb2spi ahb clock domain software reset.  1 = reset. 0 = normal working mode.
  //bit 0.    not used.
#define SPIFC_SEC_CTRL                             ((0x0002  << 2) + 0xfe056000)
   //bit 31.  ADDRESS security range enable.  1 = enable; 0: disable.
   //bit 14.  range6 enable:   1: enable; 0 : disable.
   //bit 13.  range5 enable:   1: enable; 0 : disable.
   //bit 12.  range4 enable:   1: enable; 0 : disable.
   //bit 11.  range3 enable:   1: enable; 0 : disable.
   //bit 10.  range2 enable:   1: enable; 0 : disable.
   //bit 9.   range1 enable:   1: enable; 0 : disable.
   //bit 8.   range0 enable:   1: enable; 0 : disable.
#define SPIFC_APB_CTRL                             ((0x0003  << 2) + 0xfe056000)
  //bit 31   APB control lock bit. if this bit = 1, this register can't access any more.
  //bit 30~16. Not used.
  //bit 15:8.  SPI clock domain regsiter APB access control. each bit for one APB user ID.
  //bit 7:0    AHB clock domain register APB access control. each bit for one APB user ID.
#define SPIFC_RANGE0_STA                           ((0x0010  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 0  start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE0_EDA                           ((0x0011  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 0  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
//HMASTER[4:0] defines:
//5'h0:     CPU secure data access.
//5'h1:     CPU secure instruction access.
//5'h2:     CPU non-secure data access.
//5'h3:     CPU non-secure instruction access.
//5'h4:     DSPA secure data access.
//5'h5:     DSPA secure instruction access.
//5'h6:     DSPA non-secure data access.
//5'h7:     DSPA non-secure instruction access.
//5'h08~5'h0f. for DMA access with HMASTER[2:0] as DMA thread ID.
//5'h10     all other REQUEST not CPU DSP and DMA.
//5'h1x.    Not used.
#define SPIFC_RANGE0_CTRL                          ((0x0012  << 2) + 0xfe056000)
  // AHB security range 0 control.
  // bit 16. range 0 access control for HMASTEr == 6   //all other access that is not CPU DSP and DMA.
  //bit 15:8 range 0 access control for DMA access.
  //bit  15  range 0 access control for DMA thread 7
  //bit  14  range 0 access control for DMA Thread 6
  //bit  13  range 0 access control for DMA Thread 5.
  //bit  12  range 0 access control for DMA Thread 4.
  // bit 11. range 0 access control for DMA thread 3
  // bit 10. range 0 access control for DMA Thread 2
  // bit  9. range 0 access control for DMA Thread 1.
  // bit  8. range 0 access control for DMA Thread 0.
  // bit  7. range 0 access control for HMASTER == 7   //DSPA secure   instruction access.
  // bit  6. range 0 access control for HMASTER == 6   //DSPA secure   data access.
  // bit  5. range 0 access control for HMASTER == 5   //DSPA non secure   instruction access
  // bit  4. range 0 access control for HMASTER == 4   //DSPA non secure   data access.
  // bit  3. range 0 access control for HMASTER == 3   //CPU secure   instruction access.
  // bit  2. range 0 access control for HMASTER == 2   //CPU secure   data access.
  // bit  1. range 0 access control for HMASTER == 1   //CPU non secure   instruction access
  // bit  0. range 0 access control for HMASTER == 0   //CPU non secure   data access.
#define SPIFC_RANGE1_STA                           ((0x0013  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 1  start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE1_EDA                           ((0x0014  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 1  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE1_CTRL                          ((0x0015  << 2) + 0xfe056000)
  // AHB security range 1 control.
  //bit 15:8 range 1 access control for DMA access.
  //bit  15  range 1 access control for DMA thread 7
  //bit  14  range 1 access control for DMA Thread 6
  //bit  13  range 1 access control for DMA Thread 5.
  //bit  12  range 1 access control for DMA Thread 4.
  // bit 11. range 1 access control for DMA thread 3
  // bit 10. range 1 access control for DMA Thread 2
  // bit  9. range 1 access control for DMA Thread 1.
  // bit  8. range 1 access control for DMA Thread 0.
  // bit  7. range 1 access control for HMASTER == 7   Not used.
  // bit  6. range 1 access control for HMASTEr == 6   //all other access that is not CPU DSP and DMA.
  // bit  5. range 1 access control for HMASTER == 5   //DSPB non secure
  // bit  4. range 1 access control for HMASTER == 4   //DSPB non secure
  // bit  3. range 1 access control for HMASTER == 3   //DSPA secure
  // bit  2. range 1 access control for HMASTER == 2   //DSPA non secure
  // bit  1. range 1 access control for HMASTER == 1   //CPU secure access
  // bit  0. range 1 access control for HMASTER == 0   //CPU non secure.
#define SPIFC_RANGE2_STA                           ((0x0016  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 2  start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE2_EDA                           ((0x0017  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 2  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE2_CTRL                          ((0x0018  << 2) + 0xfe056000)
  // AHB security range 2 control.
  //bit 15:8 range 2 access control for DMA access.
  //bit  15  range 2 access control for DMA thread 7
  //bit  14  range 2 access control for DMA Thread 6
  //bit  13  range 2 access control for DMA Thread 5.
  //bit  12  range 2 access control for DMA Thread 4.
  // bit 11. range 2 access control for DMA thread 3
  // bit 10. range 2 access control for DMA Thread 2
  // bit  9. range 2 access control for DMA Thread 1.
  // bit  8. range 2 access control for DMA Thread 0.
  // bit  7. range 2 access control for HMASTER == 7   Not used.
  // bit  6. range 2 access control for HMASTEr == 6   //all other access that is not CPU DSP and DMA.
  // bit  5. range 2 access control for HMASTER == 5   //DSPB non secure
  // bit  4. range 2 access control for HMASTER == 4   //DSPB non secure
  // bit  3. range 2 access control for HMASTER == 3   //DSPA secure
  // bit  2. range 2 access control for HMASTER == 2   //DSPA non secure
  // bit  1. range 2 access control for HMASTER == 1   //CPU secure access
  // bit  0. range 2 access control for HMASTER == 0   //CPU non secure.
#define SPIFC_RANGE3_STA                           ((0x0019  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 3  start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE3_EDA                           ((0x001a  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 3  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE3_CTRL                          ((0x001b  << 2) + 0xfe056000)
  // AHB security range 3 control.
  //bit 15:8 range 3 access control for DMA access.
  //bit  15  range 3 access control for DMA thread 7
  //bit  14  range 3 access control for DMA Thread 6
  //bit  13  range 3 access control for DMA Thread 5.
  //bit  12  range 3 access control for DMA Thread 4.
  // bit 11. range 3 access control for DMA thread 3
  // bit 10. range 3 access control for DMA Thread 2
  // bit  9. range 3 access control for DMA Thread 1.
  // bit  8. range 3 access control for DMA Thread 0.
  // bit  7. range 3 access control for HMASTER == 7   Not used.
  // bit  6. range 3 access control for HMASTEr == 6   //all other access that is not CPU DSP and DMA.
  // bit  5. range 3 access control for HMASTER == 5   //DSPB non secure
  // bit  4. range 3 access control for HMASTER == 4   //DSPB non secure
  // bit  3. range 3 access control for HMASTER == 3   //DSPA secure
  // bit  2. range 3 access control for HMASTER == 2   //DSPA non secure
  // bit  1. range 3 access control for HMASTER == 1   //CPU secure access
  // bit  0. range 3 access control for HMASTER == 0   //CPU non secure.
#define SPIFC_RANGE4_STA                           ((0x001c  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 4  start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE4_EDA                           ((0x001d  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 4  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE4_CTRL                          ((0x001e  << 2) + 0xfe056000)
  // AHB security range 4 control.
  // bit  4. for other HMASTER
  // bit  3. range 4 access control for HMASTER == 3   //CPU instrunction non-secure access
  // bit  2. range 4 access control for HMASTER == 2   //cpu instrunction secure access
  // bit  1. range 4 access control for HMASTER == 1   //for CPU data non-secure access.
  // bit  0. range 4 access control for HMASTER == 0   //for CPU data secure access
#define SPIFC_RANGE5_STA                           ((0x001f  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 5 start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE5_EDA                           ((0x0021  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 5  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE5_CTRL                          ((0x0020  << 2) + 0xfe056000)
  // AHB security range 5 control.
  // bit  4. for other HMASTER
  // bit  3. range 4 access control for HMASTER == 3   //CPU instrunction non-secure access
  // bit  2. range 4 access control for HMASTER == 2   //cpu instrunction secure access
  // bit  1. range 4 access control for HMASTER == 1   //for CPU data non-secure access.
  // bit  0. range 4 access control for HMASTER == 0   //for CPU data secure access
#define SPIFC_RANGE6_STA                           ((0x0022  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 6 start address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE6_EDA                           ((0x0023  << 2) + 0xfe056000)
  //bit 28 :6.
  //AHB security range 6  end address in unit of 64Byte. related to HADDR bit 28:6.
  //bit 5:0.  always 0.
#define SPIFC_RANGE6_CTRL                          ((0x0024  << 2) + 0xfe056000)
  // AHB security range 6 control.
  // bit  4. for other HMASTER
  // bit  3. range 4 access control for HMASTER == 3   //CPU instrunction non-secure access
  // bit  2. range 4 access control for HMASTER == 2   //cpu instrunction secure access
  // bit  1. range 4 access control for HMASTER == 1   //for CPU data non-secure access.
  // bit  0. range 4 access control for HMASTER == 0   //for CPU data secure access
#define SPIFC_RANGE7_CTRL                          ((0x0025  << 2) + 0xfe056000)
  // AHB security range 7( default range) control.
  // bit  4. for other HMASTER
  // bit  3. range 4 access control for HMASTER == 3   //CPU instrunction non-secure access
  // bit  2. range 4 access control for HMASTER == 2   //cpu instrunction secure access
  // bit  1. range 4 access control for HMASTER == 1   //for CPU data non-secure access.
  // bit  0. range 4 access control for HMASTER == 0   //for CPU data secure access
#define SPIFC_AHB_WTCH_CTRL                        ((0x0026  << 2) + 0xfe056000)
  //bit 16.     Wtch dog enable.
  //bit 15:0.   ahb bus watch dog timer. if AHB bus not response, the timer over this number, the SPIFC will send back  a error response.
#define SPIFC_SEC_VIO0                             ((0x0027  << 2) + 0xfe056000)
  //bit 31:0  VIO ADDR
#define SPIFC_SEC_VIO1                             ((0x0028  << 2) + 0xfe056000)
  //bit  31.  AHB VIO status.  write 1 to clear the error info.
  //bit 30:6  Not used.
  //bit 5:1  HMASTER.
  //bit 0    HWRITE.
#define SPIFC_AHB_STS                              ((0x0029  << 2) + 0xfe056000)
  //bit 31.  AHB IDLE.  when ahb disabled, to show ahb status. 1,  no more ahb request or ahb frequent is holded.  0, ahb is still busy.
  //bit 30.  AHB data cycle status, when ahb disabled, to show ahb data cycle status. 1, data cycle is holded,  0 : not in data cycle or data cycle is processing.
  //bit 29.  AHB bus spi requst status. 1: still waiting for spi data. 0: idle.
  //bit 28.  WTCHDG_STS.  1: AHB BUS access watchdog triggered. 0: no watchdo triggered.
  //bit 27:21.  not used.
  //bit 20:16.  watchdog triggered AHB Master.
  //bit 15:0.  not used.
#define SPIFC_AHB_WTCH_ADDR                        ((0x0030  << 2) + 0xfe056000)
  //bit 27:0  WTCHDG triggered AHB ADDRESS
#define SPIFC_DES_KEY0                             ((0x0040  << 2) + 0xfe056000)
  //TDES key 31:0
#define SPIFC_DES_KEY1                             ((0x0041  << 2) + 0xfe056000)
  //key 63:32
#define SPIFC_DES_KEY2                             ((0x0042  << 2) + 0xfe056000)
  //key 95:64
#define SPIFC_DES_KEY3                             ((0x0043  << 2) + 0xfe056000)
  //key 127:96
#define SPIFC_KEY_CTRL                             ((0x0044  << 2) + 0xfe056000)
//SPI cts_spi_clk domain regsiter.
#define SPIFC_USER_CTRL0                           ((0x0080  << 2) + 0xfe056000)
  //bit 31.    user request enable.  write 1 to enable.  read 0, means user command accepted by the SPI_CTRL.
  //bit 30.    user request finish bit.  write 0 when enable user request.  read  1 means SPI_CTRL finished this user command.
  //bit 0.     user data updated.  write 0 when enable user request.   1 means there's datas/status read from SPI flash.
#define SPIFC_USER_CTRL1                           ((0x0081  << 2) + 0xfe056000)
  //bit 31.    not used.
  //bit 30.    user command cycle enable.   1) enable.  0) don't send command in usr command period.
  //bit 29:28. user command mode.  00 = SPI extend mode. 01 : dual mode.  10:  quad mode.
  //bit 27:20. user command code. the code need to send in command period.
  //bit 19.    user address cycle enable.
  //bit 18:17  user address mode:  00 = SPI extend mode. 01 : dual mode.  10:  quad mode.
  //bit 16:15  user address Byte length  00 = 1 byte.  01 = 2 bytes.  10 = 3 bytes. 11 = 4bytes.
  //bit 14     user datout enable.
  //bit 13     user dataout AES enable. 1: dataout through AES describe. 0 : original data.
  //bit 12     user data output source. 0: from data buffer.  1: from status register.
  //bit 11:10  user dataout mode: 00 SPI extend model. 01 : dual model. 10. quad mode.
  //bit 9:0    User data out bytes num.
#define SPIFC_USER_CTRL2                           ((0x0082  << 2) + 0xfe056000)
  //bit 31 usr_dummy_en  1: enable dummy cycles.  0 : no dummy cycles.
  //bit 30: 29 usr_dummy_mode  2'b00 = SPI extend mode. 01 dual mode. 10 Quad mode.
  //bit 28:23  user dummy clock cycle number.
  //bit 19:16. user command input/output direction control.  000000: right after the last output.
  //          1: after the first cycle of dummy cycle.
  //          .....
  //          4'hf:  right before the datin cycle.
  //bit 15:8.  data on the dummy cycle after the first byte.
  //bit 7:0   The first bytes data showed on dummy cycle. some flash may need special data for enhance performance mode or XIP mode.
#define SPIFC_USER_CTRL3                           ((0x0083  << 2) + 0xfe056000)
  //bit 31 usr_datin_en  1: datain cycle enabled.  0: no datain cycle.
  //bit 30: datin_dest.  1: save the input data to STATUS register.  0 save the input data to data buffer.
  //bit 29: 1: enable datain data AES describe. 0: not use AES.
  //bit 28:27.  datin mode.  2'b00 SPI extend mode. 01: dual mode. 10 Quad mode.
  //bit 25:16.  user data in data bytes.  how many bytes of user datain expected.
#define SPIFC_USER_ADDR                            ((0x0084  << 2) + 0xfe056000)
  //bit 31:0.  32bits user address.
#define SPIFC_AHB_REQ_CTRL                         ((0x0085  << 2) + 0xfe056000)
 //bit 31.  AHB request enable.
 //bit 30   AHB cmd_en.  command cycle enable.
 //bit 29:28. ahb command mode.   2'b00: spi mode. 01: dual mode. 10 Quad mode.
 //bit 27:20:.AHB command code.
 //bit 19.    ahb request address cycle enable.
 //bit 18:17  AHB ADDRESS  mode. 2'b00: spi mode. 01: dual mode. 10 Quad mode.
 //bit 16:15  AHB ADDRESS data width. 2'b00: 1byte. 2'b01 : 2bytes. 2'b10: 3bytes. 2'b11 4bytes.
 //bit 13:10   AHB request spi bus input switch time. 0 : after address cycle. 1: the first dummy cycles. ... 0xf. after dummy cycle.
 //bit 9:8     AHB DATAIN mode.   2'b00: spi mode. 01: dual mode. 10 Quad mode.
 //bit 7       DATA IN AES enable. 1: enable 0: disable.
 //bit 1:0     AHB REQ DATA size.  2'b00:  64bytes.  2'b01: 32 bytes. 2'b10 : 16 bytes. 2'b11: reserved. this bit setting should be same as RDBUF_SIZE setting.
#define SPIFC_AHB_REQ_CTRL1                        ((0x0086  << 2) + 0xfe056000)
  //bit 31.  ahb Dummy enable.
  //bit 30:29.  ahb dummy mode.
  //bit 28:23.  ahb request dummy clock cycles.
  //bit 15:0.   ahb dummy period output data.
#define SPIFC_AHB_REQ_CTRL2                        ((0x0087  << 2) + 0xfe056000)
  //bit 1:0  AHB address position. this setting depend on SPIFC_AHB_CTRL register CWF_EN bit and RDBUF_SIZE.
  // if CWF_EN is enabled. these bit should be set to 2'b10 (16BYTE boundary).
  // if CWF_EN is disabled. these bit should be set to same as the RDBUF_SIZE and AHB REQ DATA SIZE.
          //00 :  64byte boundary.
          //01 :  32byte boundary.
          //10 :  16byte boundary.
          //11 :  reserved.
#define SPIFC_ACTIMING0                            ((0x0088  << 2) + 0xfe056000)
  //bit 31:30.  tSLCH
  //bit 29:28   tCLSH
  //bit 20:16   tSHWL
  //bit 15:12   tSHSL2
  //bit 11:8    tSHSL1
  //bit 7:0     tWHSL
#define SPIFC_ACTIMING1                            ((0x0089  << 2) + 0xfe056000)
 //bit 31.  D2 pin WP_n function enable.
 //bit 30.  D2 Pin value in WP_n fucntion.
 //bit 29.  D3 Pin HOLD_n function enable.
 //bit 8.   DTR mode. not support.
 //bit 6:4. Clock turn around delay. use it to set the system SPI clock read data delay.
 //bit 3:0. not used.
#define SPIFC_ACTIMING2                            ((0x008a  << 2) + 0xfe056000)
 //bit 31.  spi clock input pin enable. SPIFC controller used this pin as clock to latch the input data.
 //bit 30.  spi clock input selection. 0 : from original SPI_CLK PIN.  1: from duplicated SPI_CLK pin.
 //bit [7:4]  spi clock output pin delay adjustment.
 //bit [3:0]  spi clock input  pin delay adjustment.
//SPI DATA BUFFER.  There's a total 512Byte + 64byte(organized as 36x128bits) SRAM .
// since each APB access is 32bits. So we use word address as APB read/write address.
// But for SPI side we have to use 128bit boundary. That's the first program/read SPI with data buffer must start at data buffer 128bit boundary.  that means the SPIFC_USE_DBUF_ADDR last 2 bits must be 0.
#define SPIFC_DBUF_CTRL                            ((0x0090  << 2) + 0xfe056000)
  //bit 31.    1 = write DBUF.  0 : read DBUF.
  //bit 30.    1. = auto update address. 0 don't change address.
  //bit 7:0   DBUF address unit 32bits.
#define SPIFC_DBUF_DATA                            ((0x0091  << 2) + 0xfe056000)
  //bit 31:0.   if SPIFC_DBUF_CTRL bit 31 = 1.  write to this register will trigger one write to DBUF. and the data will be writen to DBUF.
#define SPIFC_USER_DBUF_ADDR                       ((0x0092  << 2) + 0xfe056000)
  //bit 7:0.  the DBUF ADDRESS used to send to or receive from SPI FLASH. the last 2 bits must be 0.
#define SPIFC_FLASH_STATUS                         ((0x00a0  << 2) + 0xfe056000)
#define SPIFC_STATUS                               ((0x00a1  << 2) + 0xfe056000)
  //bit 1.  AES KEY valid. read only 1 : The aes key is ready to use. 0: the aes key is not ready.
  //bit 0.  SPI CTRL STATE IDLE.  read only. 1 = idle; 0 = busy.
#define SPIFC_CTRL                                 ((0x00a2  << 2) + 0xfe056000)
  //bit 15:14. mempd for DBUF MEMORY.
  //bit 13   spifc asynchronous buffer clock disable.  1 = disable. 0 = enable.
  //bit 12.  spifc controller clock disable. 1 = disable. 0 = enable.
  //bit 9.   spifc asynchronous bufer clock auto gate enable. 1 = enable. 0 = disable.
  //bit 8.   spifc controller clock auto gate enable. 1 = enable. 0 = disable.
  //bit 2.   spifc interface reset.  1 = RESET.  0 = normal working mode.
  //bit 1.   spifc asynchronous buffer spi clock side reset. 1 = RESET.  0 : normal working mode.
  //bit 0.   spifc controller reset.  1 = RESET. 0 : normal working mode.
//`endif
//
// Closing file:  ./spifc_reg.vh
//
//========================================================================
//  CEC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe044000
// -----------------------------------------------
#define CECA_GEN_CNTL                              ((0x0000  << 2) + 0xfe044000)
#define CECA_RW_REG                                ((0x0001  << 2) + 0xfe044000)
#define CECA_INTR_MASKN                            ((0x0002  << 2) + 0xfe044000)
#define CECA_INTR_CLR                              ((0x0003  << 2) + 0xfe044000)
#define CECA_INTR_STAT                             ((0x0004  << 2) + 0xfe044000)
#define CECB_GEN_CNTL                              ((0x0010  << 2) + 0xfe044000)
#define CECB_RW_REG                                ((0x0011  << 2) + 0xfe044000)
#define CECB_INTR_MASKN                            ((0x0012  << 2) + 0xfe044000)
#define CECB_INTR_CLR                              ((0x0013  << 2) + 0xfe044000)
#define CECB_INTR_STAT                             ((0x0014  << 2) + 0xfe044000)
//========================================================================
//  SMART CARD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe038000
// -----------------------------------------------
#define SMARTCARD_REG0                             ((0x0000  << 2) + 0xfe038000)
#define SMARTCARD_REG1                             ((0x0001  << 2) + 0xfe038000)
#define SMARTCARD_REG2                             ((0x0002  << 2) + 0xfe038000)
#define SMARTCARD_STATUS                           ((0x0003  << 2) + 0xfe038000)
#define SMARTCARD_INTR                             ((0x0004  << 2) + 0xfe038000)
#define SMARTCARD_REG5                             ((0x0005  << 2) + 0xfe038000)
#define SMARTCARD_REG6                             ((0x0006  << 2) + 0xfe038000)
#define SMARTCARD_FIFO                             ((0x0007  << 2) + 0xfe038000)
#define SMARTCARD_REG8                             ((0x0008  << 2) + 0xfe038000)
//========================================================================
//  CAPU
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe012000
// -----------------------------------------------
#define CAPU_ACCESS_EN_AHB_NNA                     ((0x00c3  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_ETH                     ((0x00c2  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_USB0                    ((0x00c1  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_AHB_USB1                    ((0x00c0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_16M_SLOT0                   ((0x00b0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_256K_SLOT1                  ((0x00a1  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_256K_SLOT0                  ((0x00a0  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT5                   ((0x0085  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT4                   ((0x0084  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT3                   ((0x0083  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT2                   ((0x0082  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT1                   ((0x0081  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_64K_SLOT0                   ((0x0080  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4F                   ((0x004f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4E                   ((0x004e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4D                   ((0x004d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4C                   ((0x004c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4B                   ((0x004b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT4A                   ((0x004a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT49                   ((0x0049  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT48                   ((0x0048  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT47                   ((0x0047  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT46                   ((0x0046  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT45                   ((0x0045  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT44                   ((0x0044  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT43                   ((0x0043  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT42                   ((0x0042  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT41                   ((0x0041  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT40                   ((0x0040  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3F                   ((0x003f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3E                   ((0x003e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3D                   ((0x003d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3C                   ((0x003c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3B                   ((0x003b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT3A                   ((0x003a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT39                   ((0x0039  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT38                   ((0x0038  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT37                   ((0x0037  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT36                   ((0x0036  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT35                   ((0x0035  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT34                   ((0x0034  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT33                   ((0x0033  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT32                   ((0x0032  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT31                   ((0x0031  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT30                   ((0x0030  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2F                   ((0x002f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2E                   ((0x002e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2D                   ((0x002d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2C                   ((0x002c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2B                   ((0x002b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT2A                   ((0x002a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT29                   ((0x0029  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT28                   ((0x0028  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT27                   ((0x0027  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT26                   ((0x0026  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT25                   ((0x0025  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT24                   ((0x0024  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT23                   ((0x0023  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT22                   ((0x0022  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT21                   ((0x0021  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT20                   ((0x0020  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1F                   ((0x001f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1E                   ((0x001e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1D                   ((0x001d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1C                   ((0x001c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1B                   ((0x001b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT1A                   ((0x001a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT19                   ((0x0019  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT18                   ((0x0018  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT17                   ((0x0017  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT16                   ((0x0016  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT15                   ((0x0015  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT14                   ((0x0014  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT13                   ((0x0013  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT12                   ((0x0012  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT11                   ((0x0011  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT10                   ((0x0010  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0F                   ((0x000f  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0E                   ((0x000e  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0D                   ((0x000d  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0C                   ((0x000c  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0B                   ((0x000b  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT0A                   ((0x000a  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT09                   ((0x0009  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT08                   ((0x0008  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT07                   ((0x0007  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT06                   ((0x0006  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT05                   ((0x0005  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT04                   ((0x0004  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT03                   ((0x0003  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT02                   ((0x0002  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT01                   ((0x0001  << 2) + 0xfe012000)
#define CAPU_ACCESS_EN_8K_SLOT00                   ((0x0000  << 2) + 0xfe012000)
//========================================================================
//  BT656
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe030000
// -----------------------------------------------
#define BT_CTRL                                    ((0x0000  << 2) + 0xfe030000)
    #define BT_SOFT_RESET           31      // Soft reset
    #define BT_JPEG_START           30
    #define BT_JPEG_IGNORE_BYTES    18     //20:18
    #define BT_JPEG_IGNORE_LAST     17
    #define BT_UPDATE_ST_SEL        16
    #define BT_COLOR_REPEAT         15
    #define BT_VIDEO_MODE           13     // 14:13
    #define BT_AUTO_FMT             12
    #define BT_PROG_MODE            11
    #define BT_JPEG_MODE            10
    #define BT_XCLK27_EN_BIT        9      // 1 : xclk27 is input.     0 : xclk27 is output.
    #define BT_FID_EN_BIT           8       // 1 : enable use FID port.
    #define BT_CLK27_SEL_BIT        7       // 1 : external xclk27      0 : internal clk27.
    #define BT_CLK27_PHASE_BIT      6       // 1 : no inverted          0 : inverted.
    #define BT_ACE_MODE_BIT         5       // 1 : auto cover error by hardware.
    #define BT_SLICE_MODE_BIT       4       // 1 : no ancillary flag     0 : with ancillary flag.
    #define BT_FMT_MODE_BIT         3       // 1 : ntsc                 0 : pal.
    #define BT_REF_MODE_BIT         2       // 1 : from bit stream.     0 : from ports.
    #define BT_MODE_BIT             1       // 1 : BT656 model          0 : SAA7118 mode.
    #define BT_EN_BIT               0       // 1 : enable.
#define BT_VBISTART                                ((0x0001  << 2) + 0xfe030000)
#define BT_VBIEND                                  ((0x0002  << 2) + 0xfe030000)
#define BT_FIELDSADR                               ((0x0003  << 2) + 0xfe030000)
#define BT_LINECTRL                                ((0x0004  << 2) + 0xfe030000)
#define BT_VIDEOSTART                              ((0x0005  << 2) + 0xfe030000)
#define BT_VIDEOEND                                ((0x0006  << 2) + 0xfe030000)
#define BT_SLICELINE0                              ((0x0007  << 2) + 0xfe030000)
#define BT_SLICELINE1                              ((0x0008  << 2) + 0xfe030000)
#define BT_PORT_CTRL                               ((0x0009  << 2) + 0xfe030000)
  #define BT_HSYNC_PHASE           0
  #define BT_VSYNC_PHASE           1
  #define BT_HSYNC_PULSE           2
  #define BT_VSYNC_PULSE           3
  #define BT_FID_PHASE             4
  #define BT_FID_HSVS              5
  #define BT_IDQ_EN                6
  #define BT_IDQ_PHASE             7
  #define BT_D8B                   8
  #define BT_10BTO8B               9
  #define BT_FID_DELAY            10    //12:10
  #define BT_VSYNC_DELAY          13    //
  #define BT_HSYNC_DELAY          16
  #define BT_FID_HSVS_PCNT        19
  #define BT_FID_HSVS_VS_RISING   20
  #define BT_FID_HSVS_VS_FALLING  21
  #define BT_VREF_FROM_VS_ONLY    22
  #define BT_PORT_ACTIVE_HMODE    23
  #define BT_DUAL_EDGE_CLK_EN     24
  #define BT_CLK_INV_SEL          25
  #define BT_DATA_ENDIAN          26
#define BT_SWAP_CTRL                               ((0x000a  << 2) + 0xfe030000)
#define BT_601_CTRL0                               ((0x000e  << 2) + 0xfe030000)
#define BT_601_CTRL1                               ((0x000f  << 2) + 0xfe030000)
#define BT_601_CTRL2                               ((0x0010  << 2) + 0xfe030000)
#define BT_601_CTRL3                               ((0x0011  << 2) + 0xfe030000)
#define BT_FIELD_LUMA                              ((0x0012  << 2) + 0xfe030000)
#define BT_RAW_CTRL                                ((0x0013  << 2) + 0xfe030000)
#define BT_STATUS                                  ((0x0014  << 2) + 0xfe030000)
#define BT_INT_CTRL                                ((0x0015  << 2) + 0xfe030000)
#define BT_VLINE_STATUS                            ((0x0017  << 2) + 0xfe030000)
#define BT_ERR_CNT                                 ((0x0019  << 2) + 0xfe030000)
#define BT_LCNT_STATUS                             ((0x001a  << 2) + 0xfe030000)
#define BT_PCNT_STATUS                             ((0x001c  << 2) + 0xfe030000)
#define BT_DELAY_CTRL                              ((0x001d  << 2) + 0xfe030000)
#define BT_REF_000                                 ((0x0020  << 2) + 0xfe030000)
#define BT_REF_001                                 ((0x0021  << 2) + 0xfe030000)
#define BT_REF_010                                 ((0x0022  << 2) + 0xfe030000)
#define BT_REF_011                                 ((0x0023  << 2) + 0xfe030000)
#define BT_REF_100                                 ((0x0024  << 2) + 0xfe030000)
#define BT_REF_101                                 ((0x0025  << 2) + 0xfe030000)
#define BT_REF_110                                 ((0x0026  << 2) + 0xfe030000)
#define BT_REF_111                                 ((0x0027  << 2) + 0xfe030000)
//========================================================================
//  PDM
//========================================================================
//`include "../audio/rtl/pdm_reg.vh"
//
// Reading file:  ./REG_LIST_AUDIO_RTL.h
//
//========================================================================
//  AUDIO - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe330000
// -----------------------------------------------
#define EE_AUDIO_CLK_GATE_EN0                      ((0x0000  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_GATE_EN1                      ((0x0001  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_A_CTRL                       ((0x0002  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_B_CTRL                       ((0x0003  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_C_CTRL                       ((0x0004  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_D_CTRL                       ((0x0005  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_E_CTRL                       ((0x0006  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_F_CTRL                       ((0x0007  << 2) + 0xfe330000)
#define EE_AUDIO_SW_RESET0                         ((0x000a  << 2) + 0xfe330000)
#define EE_AUDIO_SW_RESET1                         ((0x000b  << 2) + 0xfe330000)
#define EE_AUDIO_CLK81_CTRL                        ((0x000c  << 2) + 0xfe330000)
#define EE_AUDIO_CLK81_EN                          ((0x000d  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_CTRL                         ((0x000e  << 2) + 0xfe330000)
#define EE_AUDIO_MST_A_SCLK_CTRL0                  ((0x0010  << 2) + 0xfe330000)
#define EE_AUDIO_MST_A_SCLK_CTRL1                  ((0x0011  << 2) + 0xfe330000)
#define EE_AUDIO_MST_B_SCLK_CTRL0                  ((0x0012  << 2) + 0xfe330000)
#define EE_AUDIO_MST_B_SCLK_CTRL1                  ((0x0013  << 2) + 0xfe330000)
#define EE_AUDIO_MST_C_SCLK_CTRL0                  ((0x0014  << 2) + 0xfe330000)
#define EE_AUDIO_MST_C_SCLK_CTRL1                  ((0x0015  << 2) + 0xfe330000)
#define EE_AUDIO_MST_D_SCLK_CTRL0                  ((0x0016  << 2) + 0xfe330000)
#define EE_AUDIO_MST_D_SCLK_CTRL1                  ((0x0017  << 2) + 0xfe330000)
#define EE_AUDIO_MST_E_SCLK_CTRL0                  ((0x0018  << 2) + 0xfe330000)
#define EE_AUDIO_MST_E_SCLK_CTRL1                  ((0x0019  << 2) + 0xfe330000)
#define EE_AUDIO_MST_F_SCLK_CTRL0                  ((0x001a  << 2) + 0xfe330000)
#define EE_AUDIO_MST_F_SCLK_CTRL1                  ((0x001b  << 2) + 0xfe330000)
#define EE_AUDIO_MST_DLY_CTRL0                     ((0x001c  << 2) + 0xfe330000)
#define EE_AUDIO_MST_DLY_CTRL1                     ((0x001d  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_A_CTRL                  ((0x0020  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_B_CTRL                  ((0x0021  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_C_CTRL                  ((0x0022  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_LB_CTRL                 ((0x0023  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_A_CTRL                 ((0x0024  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_B_CTRL                 ((0x0025  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_C_CTRL                 ((0x0026  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFIN_CTRL                  ((0x0027  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFOUT_CTRL                 ((0x0028  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_RESAMPLEA_CTRL                ((0x0029  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_LOCKER_CTRL                   ((0x002a  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL0                   ((0x002b  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL1                   ((0x002c  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFOUT_B_CTRL               ((0x002d  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_RESAMPLEB_CTRL                ((0x002e  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_SPDIFIN_LB_CTRL               ((0x002f  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_EQDRC_CTRL0                   ((0x0030  << 2) + 0xfe330000)
#define EE_AUDIO_VAD_CLK_CTRL                      ((0x0031  << 2) + 0xfe330000)
#define EE_AUDIO_EARCTX_CMDC_CLK_CTRL              ((0x0032  << 2) + 0xfe330000)
#define EE_AUDIO_EARCTX_DMAC_CLK_CTRL              ((0x0033  << 2) + 0xfe330000)
#define EE_AUDIO_EARCRX_CMDC_CLK_CTRL              ((0x0034  << 2) + 0xfe330000)
#define EE_AUDIO_EARCRX_DMAC_CLK_CTRL              ((0x0035  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_LOCKERB_CTRL                  ((0x0036  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMINB_LB_CTRL                ((0x0037  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL2                   ((0x0038  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_PDMIN_CTRL3                   ((0x0039  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMIN_D_CTRL                  ((0x003a  << 2) + 0xfe330000)
#define EE_AUDIO_CLK_TDMOUT_D_CTRL                 ((0x003b  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL0                     ((0x0040  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL1                     ((0x0041  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_START_ADDR                ((0x0042  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_FINISH_ADDR               ((0x0043  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_INT_ADDR                  ((0x0044  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_STATUS1                   ((0x0045  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_STATUS2                   ((0x0046  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_START_ADDRB               ((0x0047  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_FINISH_ADDRB              ((0x0048  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_INIT_ADDR                 ((0x0049  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CTRL2                     ((0x004a  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL0                     ((0x0050  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL1                     ((0x0051  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_START_ADDR                ((0x0052  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_FINISH_ADDR               ((0x0053  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_INT_ADDR                  ((0x0054  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_STATUS1                   ((0x0055  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_STATUS2                   ((0x0056  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_START_ADDRB               ((0x0057  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_FINISH_ADDRB              ((0x0058  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_INIT_ADDR                 ((0x0059  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CTRL2                     ((0x005a  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL0                     ((0x0060  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL1                     ((0x0061  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_START_ADDR                ((0x0062  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_FINISH_ADDR               ((0x0063  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_INT_ADDR                  ((0x0064  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_STATUS1                   ((0x0065  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_STATUS2                   ((0x0066  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_START_ADDRB               ((0x0067  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_FINISH_ADDRB              ((0x0068  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_INIT_ADDR                 ((0x0069  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CTRL2                     ((0x006a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL0                     ((0x0070  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL1                     ((0x0071  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_START_ADDR                ((0x0072  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_FINISH_ADDR               ((0x0073  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_INT_ADDR                  ((0x0074  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_STATUS1                   ((0x0075  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_STATUS2                   ((0x0076  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_START_ADDRB               ((0x0077  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_FINISH_ADDRB              ((0x0078  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_INIT_ADDR                 ((0x0079  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_A_CTRL2                     ((0x007a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL0                     ((0x0080  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL1                     ((0x0081  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_START_ADDR                ((0x0082  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_FINISH_ADDR               ((0x0083  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_INT_ADDR                  ((0x0084  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_STATUS1                   ((0x0085  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_STATUS2                   ((0x0086  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_START_ADDRB               ((0x0087  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_FINISH_ADDRB              ((0x0088  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_INIT_ADDR                 ((0x0089  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_B_CTRL2                     ((0x008a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL0                     ((0x0090  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL1                     ((0x0091  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_START_ADDR                ((0x0092  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_FINISH_ADDR               ((0x0093  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_INT_ADDR                  ((0x0094  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_STATUS1                   ((0x0095  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_STATUS2                   ((0x0096  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_START_ADDRB               ((0x0097  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_FINISH_ADDRB              ((0x0098  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_INIT_ADDR                 ((0x0099  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_C_CTRL2                     ((0x009a  << 2) + 0xfe330000)
//`define EE_AUDIO_ARB_CTRL0              10'ha0
//`define EE_AUDIO_ARB_CTRL1              10'ha1
//`define EE_AUDIO_ARB_STS                10'ha8
#define EE_AUDIO_AM2AXI_CTRL0                      ((0x00a2  << 2) + 0xfe330000)
#define EE_AUDIO_AM2AXI_CTRL1                      ((0x00a3  << 2) + 0xfe330000)
#define EE_AUDIO_AXI_ASYNC_CTRL0                   ((0x00a4  << 2) + 0xfe330000)
#define EE_AUDIO_AM2AXI_STS                        ((0x00a9  << 2) + 0xfe330000)
#define EE_AUDIO_AXI_ASYNC_STS                     ((0x00aa  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL0                        ((0x00b0  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL1                        ((0x00b1  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL2                        ((0x00b2  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL3                        ((0x00b3  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID0                   ((0x00b4  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID1                   ((0x00b5  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID2                   ((0x00b6  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_DAT_CH_ID3                   ((0x00b7  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID0                    ((0x00b8  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID1                    ((0x00b9  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID2                    ((0x00ba  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_LB_CH_ID3                    ((0x00bb  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_STS                          ((0x00bc  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CHSYNC_CTRL_INSERT           ((0x00bd  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CHSYNC_CTRL_ORIG             ((0x00be  << 2) + 0xfe330000)
#define EE_AUDIO_LB_A_CTRL4                        ((0x00bf  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_CTRL                      ((0x00c0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_SWAP0                     ((0x00c1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK0                     ((0x00c2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK1                     ((0x00c3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK2                     ((0x00c4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK3                     ((0x00c5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_STAT                      ((0x00c6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE_VAL                  ((0x00c7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE0                     ((0x00c8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE1                     ((0x00c9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE2                     ((0x00ca  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE3                     ((0x00cb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_CTRL                      ((0x00d0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_SWAP0                     ((0x00d1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK0                     ((0x00d2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK1                     ((0x00d3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK2                     ((0x00d4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK3                     ((0x00d5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_STAT                      ((0x00d6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE_VAL                  ((0x00d7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE0                     ((0x00d8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE1                     ((0x00d9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE2                     ((0x00da  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE3                     ((0x00db  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_CTRL                      ((0x00e0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_SWAP0                     ((0x00e1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK0                     ((0x00e2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK1                     ((0x00e3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK2                     ((0x00e4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK3                     ((0x00e5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_STAT                      ((0x00e6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE_VAL                  ((0x00e7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE0                     ((0x00e8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE1                     ((0x00e9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE2                     ((0x00ea  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE3                     ((0x00eb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_CTRL                     ((0x00f0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_SWAP0                    ((0x00f1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK0                    ((0x00f2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK1                    ((0x00f3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK2                    ((0x00f4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK3                    ((0x00f5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_STAT                     ((0x00f6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE_VAL                 ((0x00f7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE0                    ((0x00f8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE1                    ((0x00f9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE2                    ((0x00fa  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE3                    ((0x00fb  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL0                     ((0x0100  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL1                     ((0x0101  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL2                     ((0x0102  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL3                     ((0x0103  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL4                     ((0x0104  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL5                     ((0x0105  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL6                     ((0x0106  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT0                     ((0x0107  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT1                     ((0x0108  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_STAT2                     ((0x0109  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_MUTE_VAL                  ((0x010a  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_CTRL7                     ((0x010b  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL0                   ((0x0110  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL1                   ((0x0111  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL2                   ((0x0112  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_CTRL3                   ((0x0113  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF0                   ((0x0114  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF1                   ((0x0115  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF2                   ((0x0116  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF3                   ((0x0117  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_COEF4                   ((0x0118  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEA_STATUS1                 ((0x0119  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_STAT                     ((0x0120  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN0                    ((0x0121  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN1                    ((0x0122  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CTRL0                    ((0x0123  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CTRL1                    ((0x0124  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_PREAMB                   ((0x0125  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_SWAP                     ((0x0126  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS0                   ((0x0127  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS1                   ((0x0128  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS2                   ((0x0129  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS3                   ((0x012a  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS4                   ((0x012b  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS5                   ((0x012c  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS6                   ((0x012d  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS7                   ((0x012e  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS8                   ((0x012f  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTS9                   ((0x0130  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTSA                   ((0x0131  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_CHSTSB                   ((0x0132  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_MUTE_VAL                 ((0x0133  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN2                    ((0x0134  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN3                    ((0x0135  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN_EN                  ((0x0136  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_GAIN_CTRL                ((0x0137  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL0                    ((0x0140  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL1                    ((0x0141  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_SWAP0                    ((0x0142  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK0                    ((0x0143  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK1                    ((0x0144  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK2                    ((0x0145  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK3                    ((0x0146  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_STAT                     ((0x0147  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN0                    ((0x0148  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN1                    ((0x0149  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE_VAL                 ((0x014a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE0                    ((0x014b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE1                    ((0x014c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE2                    ((0x014d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE3                    ((0x014e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK_VAL                 ((0x014f  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL0                    ((0x0150  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL1                    ((0x0151  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_SWAP0                    ((0x0152  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK0                    ((0x0153  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK1                    ((0x0154  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK2                    ((0x0155  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK3                    ((0x0156  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_STAT                     ((0x0157  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN0                    ((0x0158  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN1                    ((0x0159  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE_VAL                 ((0x015a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE0                    ((0x015b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE1                    ((0x015c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE2                    ((0x015d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE3                    ((0x015e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK_VAL                 ((0x015f  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL0                    ((0x0160  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL1                    ((0x0161  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_SWAP0                    ((0x0162  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK0                    ((0x0163  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK1                    ((0x0164  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK2                    ((0x0165  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK3                    ((0x0166  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_STAT                     ((0x0167  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN0                    ((0x0168  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN1                    ((0x0169  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE_VAL                 ((0x016a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE0                    ((0x016b  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE1                    ((0x016c  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE2                    ((0x016d  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE3                    ((0x016e  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK_VAL                 ((0x016f  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_CTRL                    ((0x0170  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_SWAP0                   ((0x0171  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK0                   ((0x0172  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK1                   ((0x0173  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK2                   ((0x0174  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK3                   ((0x0175  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_STAT                    ((0x0176  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE_VAL                ((0x0177  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE0                   ((0x0178  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE1                   ((0x0179  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE2                   ((0x017a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE3                   ((0x017b  << 2) + 0xfe330000)
//`define EE_AUDIO_POW_DET_CTRL0          10'h180
//`define EE_AUDIO_POW_DET_CTRL1          10'h181
//`define EE_AUDIO_POW_DET_TH_HI          10'h182
//`define EE_AUDIO_POW_DET_TH_LO          10'h183
//`define EE_AUDIO_POW_DET_VALUE          10'h184
#define EE_AUDIO_SECURITY_CTRL0                    ((0x0190  << 2) + 0xfe330000)
#define EE_AUDIO_SECURITY_CTRL1                    ((0x0191  << 2) + 0xfe330000)
#define EE_AUDIO_SECURITY_CTRL2                    ((0x0192  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_STAT                   ((0x01a0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN0                  ((0x01a1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN1                  ((0x01a2  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CTRL0                  ((0x01a3  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CTRL1                  ((0x01a4  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_PREAMB                 ((0x01a5  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_SWAP                   ((0x01a6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS0                 ((0x01a7  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS1                 ((0x01a8  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS2                 ((0x01a9  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS3                 ((0x01aa  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS4                 ((0x01ab  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS5                 ((0x01ac  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS6                 ((0x01ad  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS7                 ((0x01ae  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS8                 ((0x01af  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTS9                 ((0x01b0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTSA                 ((0x01b1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_CHSTSB                 ((0x01b2  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_MUTE_VAL               ((0x01b3  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN2                  ((0x01b4  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN3                  ((0x01b5  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN_EN                ((0x01b6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFOUT_B_GAIN_CTRL              ((0x01b7  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_CTRL0                       ((0x01c0  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_CTRL1                       ((0x01c1  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_START_ADDR                  ((0x01c2  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_FINISH_ADDR                 ((0x01c3  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_INT_ADDR                    ((0x01c4  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_STATUS1                     ((0x01c5  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_STATUS2                     ((0x01c6  << 2) + 0xfe330000)
#define EE_AUDIO_TORAM_INIT_ADDR                   ((0x01c7  << 2) + 0xfe330000)
#define EE_AUDIO_TOACODEC_CTRL0                    ((0x01d0  << 2) + 0xfe330000)
#define EE_AUDIO_TOHDMITX_CTRL0                    ((0x01d1  << 2) + 0xfe330000)
#define EE_AUDIO_TOVAD_CTRL0                       ((0x01d2  << 2) + 0xfe330000)
#define EE_AUDIO_FRATV_CTRL0                       ((0x01d3  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL0                   ((0x01e0  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL1                   ((0x01e1  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL2                   ((0x01e2  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_CTRL3                   ((0x01e3  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF0                   ((0x01e4  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF1                   ((0x01e5  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF2                   ((0x01e6  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF3                   ((0x01e7  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_COEF4                   ((0x01e8  << 2) + 0xfe330000)
#define EE_AUDIO_RESAMPLEB_STATUS1                 ((0x01e9  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL0                  ((0x01f0  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL1                  ((0x01f1  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_CTRL6                  ((0x01f6  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_STAT0                  ((0x01f7  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_STAT1                  ((0x01f8  << 2) + 0xfe330000)
#define EE_AUDIO_SPDIFIN_LB_MUTE_VAL               ((0x01fa  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL0                    ((0x0200  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL1                    ((0x0201  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL2                    ((0x0202  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL3                    ((0x0203  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL4                    ((0x0204  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL5                    ((0x0205  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL6                    ((0x0206  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_CTRL7                    ((0x0207  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT0                    ((0x020a  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT1                    ((0x020b  << 2) + 0xfe330000)
#define EE_AUDIO_FRHDMIRX_STAT2                    ((0x020c  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL0                     ((0x0210  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL1                     ((0x0211  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_START_ADDR                ((0x0212  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_FINISH_ADDR               ((0x0213  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_INT_ADDR                  ((0x0214  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_STATUS1                   ((0x0215  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_STATUS2                   ((0x0216  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_START_ADDRB               ((0x0217  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_FINISH_ADDRB              ((0x0218  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_INIT_ADDR                 ((0x0219  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CTRL2                     ((0x021a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL0                     ((0x0220  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL1                     ((0x0221  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_START_ADDR                ((0x0222  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_FINISH_ADDR               ((0x0223  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_INT_ADDR                  ((0x0224  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_STATUS1                   ((0x0225  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_STATUS2                   ((0x0226  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_START_ADDRB               ((0x0227  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_FINISH_ADDRB              ((0x0228  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_INIT_ADDR                 ((0x0229  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_D_CTRL2                     ((0x022a  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL0                        ((0x0230  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL1                        ((0x0231  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL2                        ((0x0232  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL3                        ((0x0233  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID0                   ((0x0234  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID1                   ((0x0235  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID2                   ((0x0236  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_DAT_CH_ID3                   ((0x0237  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID0                    ((0x0238  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID1                    ((0x0239  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID2                    ((0x023a  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_LB_CH_ID3                    ((0x023b  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_STS                          ((0x023c  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CHSYNC_CTRL_INSERT           ((0x023d  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CHSYNC_CTRL_ORIG             ((0x023e  << 2) + 0xfe330000)
#define EE_AUDIO_LB_B_CTRL4                        ((0x023f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL0                     ((0x0240  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL1                     ((0x0241  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_START_ADDR                ((0x0242  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_FINISH_ADDR               ((0x0243  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_INT_ADDR                  ((0x0244  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_STATUS1                   ((0x0245  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_STATUS2                   ((0x0246  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_START_ADDRB               ((0x0247  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_FINISH_ADDRB              ((0x0248  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_INIT_ADDR                 ((0x0249  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CTRL2                     ((0x024a  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL0                     ((0x0250  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL1                     ((0x0251  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_START_ADDR                ((0x0252  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_FINISH_ADDR               ((0x0253  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_INT_ADDR                  ((0x0254  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_STATUS1                   ((0x0255  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_STATUS2                   ((0x0256  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_START_ADDRB               ((0x0257  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_FINISH_ADDRB              ((0x0258  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_INIT_ADDR                 ((0x0259  << 2) + 0xfe330000)
#define EE_AUDIO_FRDDR_E_CTRL2                     ((0x025a  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_SWAP1                     ((0x0260  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK4                     ((0x0261  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK5                     ((0x0262  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK6                     ((0x0263  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MASK7                     ((0x0264  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE4                     ((0x0265  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE5                     ((0x0266  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE6                     ((0x0267  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_A_MUTE7                     ((0x0268  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_SWAP1                     ((0x0270  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK4                     ((0x0271  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK5                     ((0x0272  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK6                     ((0x0273  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MASK7                     ((0x0274  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE4                     ((0x0275  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE5                     ((0x0276  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE6                     ((0x0277  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_B_MUTE7                     ((0x0278  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_SWAP1                     ((0x0280  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK4                     ((0x0281  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK5                     ((0x0282  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK6                     ((0x0283  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MASK7                     ((0x0284  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE4                     ((0x0285  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE5                     ((0x0286  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE6                     ((0x0287  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_C_MUTE7                     ((0x0288  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_SWAP1                    ((0x0290  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK4                    ((0x0291  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK5                    ((0x0292  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK6                    ((0x0293  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MASK7                    ((0x0294  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE4                    ((0x0295  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE5                    ((0x0296  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE6                    ((0x0297  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_LB_MUTE7                    ((0x0298  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_CTRL2                    ((0x02a0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_SWAP1                    ((0x02a1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN2                    ((0x02a2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN3                    ((0x02a3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK4                    ((0x02a4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK5                    ((0x02a5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK6                    ((0x02a6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MASK7                    ((0x02a7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE4                    ((0x02a8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE5                    ((0x02a9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE6                    ((0x02aa  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_MUTE7                    ((0x02ab  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN_EN                  ((0x02ac  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_A_GAIN_CTRL                ((0x02ad  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_CTRL2                    ((0x02b0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_SWAP1                    ((0x02b1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN2                    ((0x02b2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN3                    ((0x02b3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK4                    ((0x02b4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK5                    ((0x02b5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK6                    ((0x02b6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MASK7                    ((0x02b7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE4                    ((0x02b8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE5                    ((0x02b9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE6                    ((0x02ba  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_MUTE7                    ((0x02bb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN_EN                  ((0x02bc  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_B_GAIN_CTRL                ((0x02bd  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_CTRL2                    ((0x02c0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_SWAP1                    ((0x02c1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN2                    ((0x02c2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN3                    ((0x02c3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK4                    ((0x02c4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK5                    ((0x02c5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK6                    ((0x02c6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MASK7                    ((0x02c7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE4                    ((0x02c8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE5                    ((0x02c9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE6                    ((0x02ca  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_MUTE7                    ((0x02cb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN_EN                  ((0x02cc  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_C_GAIN_CTRL                ((0x02cd  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_SWAP1                   ((0x02d0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK4                   ((0x02d1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK5                   ((0x02d2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK6                   ((0x02d3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MASK7                   ((0x02d4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE4                   ((0x02d5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE5                   ((0x02d6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE6                   ((0x02d7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMINB_LB_MUTE7                   ((0x02d8  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID0                 ((0x0300  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID1                 ((0x0301  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID2                 ((0x0302  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID3                 ((0x0303  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID4                 ((0x0304  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID5                 ((0x0305  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID6                 ((0x0306  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHNUM_ID7                 ((0x0307  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_A_CHSYNC_CTRL               ((0x030f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID0                 ((0x0310  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID1                 ((0x0311  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID2                 ((0x0312  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID3                 ((0x0313  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID4                 ((0x0314  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID5                 ((0x0315  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID6                 ((0x0316  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHNUM_ID7                 ((0x0317  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_B_CHSYNC_CTRL               ((0x031f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID0                 ((0x0320  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID1                 ((0x0321  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID2                 ((0x0322  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID3                 ((0x0323  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID4                 ((0x0324  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID5                 ((0x0325  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID6                 ((0x0326  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHNUM_ID7                 ((0x0327  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_C_CHSYNC_CTRL               ((0x032f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID0                 ((0x0330  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID1                 ((0x0331  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID2                 ((0x0332  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID3                 ((0x0333  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID4                 ((0x0334  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID5                 ((0x0335  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID6                 ((0x0336  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHNUM_ID7                 ((0x0337  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_D_CHSYNC_CTRL               ((0x033f  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID0                 ((0x0340  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID1                 ((0x0341  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID2                 ((0x0342  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID3                 ((0x0343  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID4                 ((0x0344  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID5                 ((0x0345  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID6                 ((0x0346  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHNUM_ID7                 ((0x0347  << 2) + 0xfe330000)
#define EE_AUDIO_TODDR_E_CHSYNC_CTRL               ((0x034f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID0                 ((0x0350  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID1                 ((0x0351  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID2                 ((0x0352  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID3                 ((0x0353  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID4                 ((0x0354  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID5                 ((0x0355  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID6                 ((0x0356  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHNUM_ID7                 ((0x0357  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_CHSYNC_MASK                 ((0x035e  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_A_CHSYNC_CTRL               ((0x035f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID0                 ((0x0360  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID1                 ((0x0361  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID2                 ((0x0362  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID3                 ((0x0363  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID4                 ((0x0364  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID5                 ((0x0365  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID6                 ((0x0366  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHNUM_ID7                 ((0x0367  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_B_CHSYNC_CTRL               ((0x036f  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID0                 ((0x0370  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID1                 ((0x0371  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID2                 ((0x0372  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID3                 ((0x0373  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID4                 ((0x0374  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID5                 ((0x0375  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID6                 ((0x0376  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHNUM_ID7                 ((0x0377  << 2) + 0xfe330000)
#define EE_AUDIO_RSAMP_C_CHSYNC_CTRL               ((0x037f  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_STS0                ((0x0380  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_STS1                ((0x0381  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MASK0               ((0x0382  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MASK1               ((0x0383  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MODE0               ((0x0384  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_MODE1               ((0x0385  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_CLR0                ((0x0386  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_CLR1                ((0x0387  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_INV0                ((0x0388  << 2) + 0xfe330000)
#define EE_AUDIO_EXCEPTION_IRQ_INV1                ((0x0389  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL0                     ((0x0390  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL1                     ((0x0391  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL2                     ((0x0392  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL3                     ((0x0393  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL4                     ((0x0394  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL5                     ((0x0395  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL6                     ((0x0396  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL7                     ((0x0397  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL8                     ((0x0398  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRL9                     ((0x0399  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLA                     ((0x039a  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLB                     ((0x039b  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLC                     ((0x039c  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLD                     ((0x039d  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLE                     ((0x039e  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLF                     ((0x039f  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_PAD_CTRL0                    ((0x03a0  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_PAD_CTRL1                    ((0x03a1  << 2) + 0xfe330000)
#define EE_AUDIO_SCLK_PAD_CTRL0                    ((0x03a2  << 2) + 0xfe330000)
#define EE_AUDIO_LRCLK_PAD_CTRL0                   ((0x03a3  << 2) + 0xfe330000)
#define EE_AUDIO_MCLK_PAD_CTRL2                    ((0x03a4  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLG                     ((0x03a5  << 2) + 0xfe330000)
#define EE_AUDIO_DAT_PAD_CTRLH                     ((0x03a6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_CTRL                      ((0x03b0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_SWAP0                     ((0x03b1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK0                     ((0x03b2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK1                     ((0x03b3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK2                     ((0x03b4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK3                     ((0x03b5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_STAT                      ((0x03b6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE_VAL                  ((0x03b7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE0                     ((0x03b8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE1                     ((0x03b9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE2                     ((0x03ba  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE3                     ((0x03bb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_SWAP1                     ((0x03c0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK4                     ((0x03c1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK5                     ((0x03c2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK6                     ((0x03c3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MASK7                     ((0x03c4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE4                     ((0x03c5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE5                     ((0x03c6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE6                     ((0x03c7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMIN_D_MUTE7                     ((0x03c8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_CTRL0                    ((0x03d0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_CTRL1                    ((0x03d1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_SWAP0                    ((0x03d2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK0                    ((0x03d3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK1                    ((0x03d4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK2                    ((0x03d5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK3                    ((0x03d6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_STAT                     ((0x03d7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN0                    ((0x03d8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN1                    ((0x03d9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE_VAL                 ((0x03da  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE0                    ((0x03db  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE1                    ((0x03dc  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE2                    ((0x03dd  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE3                    ((0x03de  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK_VAL                 ((0x03df  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_CTRL2                    ((0x03e0  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_SWAP1                    ((0x03e1  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN2                    ((0x03e2  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN3                    ((0x03e3  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK4                    ((0x03e4  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK5                    ((0x03e5  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK6                    ((0x03e6  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MASK7                    ((0x03e7  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE4                    ((0x03e8  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE5                    ((0x03e9  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE6                    ((0x03ea  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_MUTE7                    ((0x03eb  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN_EN                  ((0x03ec  << 2) + 0xfe330000)
#define EE_AUDIO_TDMOUT_D_GAIN_CTRL                ((0x03ed  << 2) + 0xfe330000)
//========================================================================
//  PDM - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331000
// -----------------------------------------------
#define PDM_CTRL                                   ((0x0000  << 2) + 0xfe331000)
  //bit 31:   PDM enable.
  //bit 30:   invert the PDM_DCLK.
  //bit 29:   output mode:  1: 24bits. 0: 32 bits.
  //bit 28:   bypass mode. 1: bypass all filter. directly output the PDM input to DDR. 0: normal mode.
  //bit 27~9: not used.
  //bit 16:.   PDM Asynchronous FIFO soft reset.  write 1 to soft reset AFIFO.
  //bit 15:8   PDM channel reset.  0: to reset each PDM channel.  1: normal mode.
  //bit 7:0.  PDM channel enable. each bit for one channel.
#define PDM_HCIC_CTRL1                             ((0x0001  << 2) + 0xfe331000)
  //bit 31      hcic filter enable.  1 use sinc filter. 0 bypass input to output.
  //bit 29:24.  hcic final gain shift parameter.
  //bit 23:16   hcic final gain multiplier.
  //bit 8:4     hcic  down sample rate.
  //bit 3:0     hcic  stage number. must be between 3 to 9.
#define PDM_HCIC_CTRL2                             ((0x0002  << 2) + 0xfe331000)
  //Not used.
#define PDM_F1_CTRL                                ((0x0003  << 2) + 0xfe331000)
  //bit 31 .   filter 1 enable.
  //bit 16:15. f1 round mode.  2'b00 : sign bit at bit 49.  28bits output [49:22] round at bit 21. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b01 : sign bit at bit 50.  28bits output [50:23] round at bit 22. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b10 : sign bit at bit 51.  28bits output [51:24] round at bit 23 32bits output [49:18]. 24bits output [49:26].
  //bit 15:12. filter 1 down sample rate.
  //bit 8:0.   filter 1 stage number.
#define PDM_F2_CTRL                                ((0x0004  << 2) + 0xfe331000)
  //bit 31 .   filter 2 enable.
  //bit 16:15. f2 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 2 down sample rate.
  //bit 8:0.   filter 2 stage number.
#define PDM_F3_CTRL                                ((0x0005  << 2) + 0xfe331000)
  //bit 31 .   filter 3 enable.
  //bit 16:15. f3 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 3 down sample rate.
  //bit 8:0.   filter 3 stage number.
#define PDM_HPF_CTRL                               ((0x0006  << 2) + 0xfe331000)
  //bit 31  High pass filter enable.
  //bit 20:16 high pass filter shift steps. 6~19 steps.
  //bit 15:0 high pass filter output factor.
#define PDM_CHAN_CTRL                              ((0x0007  << 2) + 0xfe331000)
  //bit 31:24.  chan3 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan2 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan1 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan0 data sample pointer vs edge of the PDM_DCLK.
#define PDM_CHAN_CTRL1                             ((0x0008  << 2) + 0xfe331000)
  //bit 31:24.  chan7 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan6 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan5 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan4 data sample pointer vs edge of the PDM_DCLK.
#define PDM_COEFF_ADDR                             ((0x0009  << 2) + 0xfe331000)
  // address of the write/read of coeff data.
#define PDM_COEFF_DATA                             ((0x000a  << 2) + 0xfe331000)
  //write/read data to coeff memory.
#define PDM_CLKG_CTRL                              ((0x000b  << 2) + 0xfe331000)
  // auto clock gating control.  1: disable the clock gating function. the clock will awlays enabled. 0 : use RTL auto clock gating.
  //31:7 not used.
  //bit 6  filt_ctrl module auto clock gating control.
  //bit 5  sinc fifo module auto clock gating control.
  //bit 4  filter module auto clock gating control.
  //bit 3  apb module auto clock gating control.
  //bit 2  coeff memory module auto clock gating control.
  //bit 1  each channel module auto clock gating control.
  //bit 0 cts_pdm_clk   auto clock gating control.
#define PDM_STS                                    ((0x000c  << 2) + 0xfe331000)
//bit 1  HPF filter output overflow.  means the PCLK is too slow.
//bit 0  HCIC filter output overflow. means the CTS_PDM_CLK is too slow. can't finished the filter function.
#define PDM_MUTE_VALUE                             ((0x000d  << 2) + 0xfe331000)
#define PDM_MASK_NUM                               ((0x000e  << 2) + 0xfe331000)
#define PDM_CHAN_CTRL2                             ((0x000f  << 2) + 0xfe331000)
  //bit 7:0    second sample and start FSM point vs rise edge of PDM_DCLK
#define PDM_HPF_GAIN_CTRL                          ((0x0010  << 2) + 0xfe331000)
//bit 31   Bypass hpf gain (HPF to async fifo directly)
//bit 19:0 unsigned gain on pdm_dout (after HPF so that mic DC bias would not be amplified) u20.7
//========================================================================
//  PDMB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334800
// -----------------------------------------------
#define PDMB_CTRL                                  ((0x0000  << 2) + 0xfe334800)
  //bit 31:   PDM enable.
  //bit 30:   invert the PDM_DCLK.
  //bit 29:   output mode:  1: 24bits. 0: 32 bits.
  //bit 28:   bypass mode. 1: bypass all filter. directly output the PDM input to DDR. 0: normal mode.
  //bit 27~9: not used.
  //bit 16:.   PDM Asynchronous FIFO soft reset.  write 1 to soft reset AFIFO.
  //bit 15:8   PDM channel reset.  0: to reset each PDM channel.  1: normal mode.
  //bit 7:0.  PDM channel enable. each bit for one channel.
#define PDMB_HCIC_CTRL1                            ((0x0001  << 2) + 0xfe334800)
  //bit 31      hcic filter enable.  1 use sinc filter. 0 bypass input to output.
  //bit 29:24.  hcic final gain shift parameter.
  //bit 23:16   hcic final gain multiplier.
  //bit 8:4     hcic  down sample rate.
  //bit 3:0     hcic  stage number. must be between 3 to 9.
#define PDMB_HCIC_CTRL2                            ((0x0002  << 2) + 0xfe334800)
  //Not used.
#define PDMB_F1_CTRL                               ((0x0003  << 2) + 0xfe334800)
  //bit 31 .   filter 1 enable.
  //bit 16:15. f1 round mode.  2'b00 : sign bit at bit 49.  28bits output [49:22] round at bit 21. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b01 : sign bit at bit 50.  28bits output [50:23] round at bit 22. 32bits output [49:18]. 24bits output [49:26]
         //                    2'b10 : sign bit at bit 51.  28bits output [51:24] round at bit 23 32bits output [49:18]. 24bits output [49:26].
  //bit 15:12. filter 1 down sample rate.
  //bit 8:0.   filter 1 stage number.
#define PDMB_F2_CTRL                               ((0x0004  << 2) + 0xfe334800)
  //bit 31 .   filter 2 enable.
  //bit 16:15. f2 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 2 down sample rate.
  //bit 8:0.   filter 2 stage number.
#define PDMB_F3_CTRL                               ((0x0005  << 2) + 0xfe334800)
  //bit 31 .   filter 3 enable.
  //bit 16:15. f3 round mode.  2'b00 : round at bit 21. 2'b01 : round at bit 22.  2'b10 : round at bit 23.
  //bit 15:12. filter 3 down sample rate.
  //bit 8:0.   filter 3 stage number.
#define PDMB_HPF_CTRL                              ((0x0006  << 2) + 0xfe334800)
  //bit 31  High pass filter enable.
  //bit 20:16 high pass filter shift steps. 6~19 steps.
  //bit 15:0 high pass filter output factor.
#define PDMB_CHAN_CTRL                             ((0x0007  << 2) + 0xfe334800)
  //bit 31:24.  chan3 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan2 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan1 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan0 data sample pointer vs edge of the PDM_DCLK.
#define PDMB_CHAN_CTRL1                            ((0x0008  << 2) + 0xfe334800)
  //bit 31:24.  chan7 data sample pointer vs edge of the PDM_DCLK.
  //bit 23:16   chan6 data sample pointer vs edge of the PDM_DCLK.
  //bit 15:8.   chan5 data sample pointer vs edge of the PDM_DCLK.
  //bit 7:0     chan4 data sample pointer vs edge of the PDM_DCLK.
#define PDMB_COEFF_ADDR                            ((0x0009  << 2) + 0xfe334800)
  // address of the write/read of coeff data.
#define PDMB_COEFF_DATA                            ((0x000a  << 2) + 0xfe334800)
  //write/read data to coeff memory.
#define PDMB_CLKG_CTRL                             ((0x000b  << 2) + 0xfe334800)
  // auto clock gating control.  1: disable the clock gating function. the clock will awlays enabled. 0 : use RTL auto clock gating.
  //31:7 not used.
  //bit 6  filt_ctrl module auto clock gating control.
  //bit 5  sinc fifo module auto clock gating control.
  //bit 4  filter module auto clock gating control.
  //bit 3  apb module auto clock gating control.
  //bit 2  coeff memory module auto clock gating control.
  //bit 1  each channel module auto clock gating control.
  //bit 0 cts_pdm_clk   auto clock gating control.
#define PDMB_STS                                   ((0x000c  << 2) + 0xfe334800)
//bit 1  HPF filter output overflow.  means the PCLK is too slow.
//bit 0  HCIC filter output overflow. means the CTS_PDM_CLK is too slow. can't finished the filter function.
#define PDMB_MUTE_VALUE                            ((0x000d  << 2) + 0xfe334800)
#define PDMB_MASK_NUM                              ((0x000e  << 2) + 0xfe334800)
#define PDMB_CHAN_CTRL2                            ((0x000f  << 2) + 0xfe334800)
  //bit 7:0    second sample and start FSM point vs rise edge of PDM_DCLK
#define PDMB_HPF_GAIN_CTRL                         ((0x0010  << 2) + 0xfe334800)
//bit 31   Bypass hpf gain (HPF to async fifo directly)
//bit 19:0 unsigned gain on pdm_dout (after HPF so that mic DC bias would not be amplified) u20.7
//========================================================================
//  EQ DRC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe332000
// -----------------------------------------------
#define AED_COEF_RAM_CNTL                          ((0x0000  << 2) + 0xfe332000)
#define AED_COEF_RAM_DATA                          ((0x0001  << 2) + 0xfe332000)
#define AED_EQ_EN                                  ((0x0002  << 2) + 0xfe332000)
#define AED_EQ_TAP_CNTL                            ((0x0003  << 2) + 0xfe332000)
#define AED_EQ_VOLUME                              ((0x0004  << 2) + 0xfe332000)
#define AED_EQ_VOLUME_SLEW_CNT                     ((0x0005  << 2) + 0xfe332000)
#define AED_MUTE                                   ((0x0006  << 2) + 0xfe332000)
#define AED_DRC_CNTL                               ((0x0007  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF0                          ((0x0008  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF1                          ((0x0009  << 2) + 0xfe332000)
#define AED_DRC_THD0                               ((0x000a  << 2) + 0xfe332000)
#define AED_DRC_THD1                               ((0x000b  << 2) + 0xfe332000)
#define AED_DRC_THD2                               ((0x000c  << 2) + 0xfe332000)
#define AED_DRC_THD3                               ((0x000d  << 2) + 0xfe332000)
#define AED_DRC_THD4                               ((0x000e  << 2) + 0xfe332000)
#define AED_DRC_K0                                 ((0x000f  << 2) + 0xfe332000)
#define AED_DRC_K1                                 ((0x0010  << 2) + 0xfe332000)
#define AED_DRC_K2                                 ((0x0011  << 2) + 0xfe332000)
#define AED_DRC_K3                                 ((0x0012  << 2) + 0xfe332000)
#define AED_DRC_K4                                 ((0x0013  << 2) + 0xfe332000)
#define AED_DRC_K5                                 ((0x0014  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT0                           ((0x0015  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT1                           ((0x0016  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT2                           ((0x0017  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT3                           ((0x0018  << 2) + 0xfe332000)
#define AED_DRC_OFFSET                             ((0x0019  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF00                     ((0x001a  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF01                     ((0x001b  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF10                     ((0x001c  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF11                     ((0x001d  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF20                     ((0x001e  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF21                     ((0x001f  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF30                     ((0x0020  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF31                     ((0x0021  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF40                     ((0x0022  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF41                     ((0x0023  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF50                     ((0x0024  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF51                     ((0x0025  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF00                      ((0x0026  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF01                      ((0x0027  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF10                      ((0x0028  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF11                      ((0x0029  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF20                      ((0x002a  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF21                      ((0x002b  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF30                      ((0x002c  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF31                      ((0x002d  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF40                      ((0x002e  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF41                      ((0x002f  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF50                      ((0x0030  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF51                      ((0x0031  << 2) + 0xfe332000)
#define AED_DRC_LOOPBACK_CNTL                      ((0x0032  << 2) + 0xfe332000)
#define AED_MDRC_CNTL                              ((0x0033  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF00                        ((0x0034  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF01                        ((0x0035  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF00                    ((0x0036  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF01                    ((0x0037  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF00                     ((0x0038  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF01                     ((0x0039  << 2) + 0xfe332000)
#define AED_MDRC_THD0                              ((0x003a  << 2) + 0xfe332000)
#define AED_MDRC_K0                                ((0x003b  << 2) + 0xfe332000)
#define AED_MDRC_LOW_GAIN                          ((0x003c  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET0                           ((0x003d  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF10                        ((0x003e  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF11                        ((0x003f  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF10                    ((0x0040  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF11                    ((0x0041  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF10                     ((0x0042  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF11                     ((0x0043  << 2) + 0xfe332000)
#define AED_MDRC_THD1                              ((0x0044  << 2) + 0xfe332000)
#define AED_MDRC_K1                                ((0x0045  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET1                           ((0x0046  << 2) + 0xfe332000)
#define AED_MDRC_MID_GAIN                          ((0x0047  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF20                        ((0x0048  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF21                        ((0x0049  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF20                    ((0x004a  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF21                    ((0x004b  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF20                     ((0x004c  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF21                     ((0x004d  << 2) + 0xfe332000)
#define AED_MDRC_THD2                              ((0x004e  << 2) + 0xfe332000)
#define AED_MDRC_K2                                ((0x004f  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET2                           ((0x0050  << 2) + 0xfe332000)
#define AED_MDRC_HIGH_GAIN                         ((0x0051  << 2) + 0xfe332000)
#define AED_ED_CNTL                                ((0x0052  << 2) + 0xfe332000)
#define AED_DC_EN                                  ((0x0053  << 2) + 0xfe332000)
#define AED_ND_LOW_THD                             ((0x0054  << 2) + 0xfe332000)
#define AED_ND_HIGH_THD                            ((0x0055  << 2) + 0xfe332000)
#define AED_ND_CNT_THD                             ((0x0056  << 2) + 0xfe332000)
#define AED_ND_SUM_NUM                             ((0x0057  << 2) + 0xfe332000)
#define AED_ND_CZ_NUM                              ((0x0058  << 2) + 0xfe332000)
#define AED_ND_SUM_THD0                            ((0x0059  << 2) + 0xfe332000)
#define AED_ND_SUM_THD1                            ((0x005a  << 2) + 0xfe332000)
#define AED_ND_CZ_THD0                             ((0x005b  << 2) + 0xfe332000)
#define AED_ND_CZ_THD1                             ((0x005c  << 2) + 0xfe332000)
#define AED_ND_COND_CNTL                           ((0x005d  << 2) + 0xfe332000)
#define AED_ND_RELEASE_COEF0                       ((0x005e  << 2) + 0xfe332000)
#define AED_ND_RELEASE_COEF1                       ((0x005f  << 2) + 0xfe332000)
#define AED_ND_ATTACK_COEF0                        ((0x0060  << 2) + 0xfe332000)
#define AED_ND_ATTACK_COEF1                        ((0x0061  << 2) + 0xfe332000)
#define AED_ND_CNTL                                ((0x0062  << 2) + 0xfe332000)
#define AED_MIX0_LL                                ((0x0063  << 2) + 0xfe332000)
#define AED_MIX0_RL                                ((0x0064  << 2) + 0xfe332000)
#define AED_MIX0_LR                                ((0x0065  << 2) + 0xfe332000)
#define AED_MIX0_RR                                ((0x0066  << 2) + 0xfe332000)
#define AED_CLIP_THD                               ((0x0067  << 2) + 0xfe332000)
#define AED_CH1_ND_SUM_OUT                         ((0x0068  << 2) + 0xfe332000)
#define AED_CH2_ND_SUM_OUT                         ((0x0069  << 2) + 0xfe332000)
#define AED_CH1_ND_CZ_OUT                          ((0x006a  << 2) + 0xfe332000)
#define AED_CH2_ND_CZ_OUT                          ((0x006b  << 2) + 0xfe332000)
#define AED_NOISE_STATUS                           ((0x006c  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S0                         ((0x006d  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S1                         ((0x006e  << 2) + 0xfe332000)
#define AED_POW_CURRENT_S2                         ((0x006f  << 2) + 0xfe332000)
#define AED_POW_OUT0                               ((0x0070  << 2) + 0xfe332000)
#define AED_POW_OUT1                               ((0x0071  << 2) + 0xfe332000)
#define AED_POW_OUT2                               ((0x0072  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX0                         ((0x0073  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX1                         ((0x0074  << 2) + 0xfe332000)
#define AED_POW_ADJ_INDEX2                         ((0x0075  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX0                        ((0x0076  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX1                        ((0x0077  << 2) + 0xfe332000)
#define AED_DRC_GAIN_INDEX2                        ((0x0078  << 2) + 0xfe332000)
#define AED_CH1_VOLUME_STATE                       ((0x0079  << 2) + 0xfe332000)
#define AED_CH2_VOLUME_STATE                       ((0x007a  << 2) + 0xfe332000)
#define AED_CH1_VOLUME_GAIN                        ((0x007b  << 2) + 0xfe332000)
#define AED_CH2_VOLUME_GAIN                        ((0x007c  << 2) + 0xfe332000)
#define AED_FULL_POW_CURRENT                       ((0x007d  << 2) + 0xfe332000)
#define AED_FULL_POW_OUT                           ((0x007e  << 2) + 0xfe332000)
#define AED_FULL_POW_ADJ                           ((0x007f  << 2) + 0xfe332000)
#define AED_FULL_DRC_GAIN                          ((0x0080  << 2) + 0xfe332000)
#define AED_MASTER_VOLUME_STATE                    ((0x0081  << 2) + 0xfe332000)
#define AED_MASTER_VOLUME_GAIN                     ((0x0082  << 2) + 0xfe332000)
#define AED_TOP_CTL0                               ((0x0083  << 2) + 0xfe332000)
#define AED_TOP_CTL1                               ((0x0084  << 2) + 0xfe332000)
#define AED_TOP_CTL2                               ((0x0085  << 2) + 0xfe332000)
#define AED_TOP_ST0                                ((0x0086  << 2) + 0xfe332000)
#define AED_TOP_ST1                                ((0x0087  << 2) + 0xfe332000)
#define AED_EQDRC_DYNAMIC_CNTL                     ((0x0090  << 2) + 0xfe332000)
#define AED_COEF_RAM_CNTL_B                        ((0x0091  << 2) + 0xfe332000)
#define AED_COEF_RAM_DATA_B                        ((0x0092  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF0_B                        ((0x0093  << 2) + 0xfe332000)
#define AED_DRC_RMS_COEF1_B                        ((0x0094  << 2) + 0xfe332000)
#define AED_DRC_THD0_B                             ((0x0095  << 2) + 0xfe332000)
#define AED_DRC_THD1_B                             ((0x0096  << 2) + 0xfe332000)
#define AED_DRC_THD2_B                             ((0x0097  << 2) + 0xfe332000)
#define AED_DRC_THD3_B                             ((0x0098  << 2) + 0xfe332000)
#define AED_DRC_THD4_B                             ((0x0099  << 2) + 0xfe332000)
#define AED_DRC_K0_B                               ((0x009a  << 2) + 0xfe332000)
#define AED_DRC_K1_B                               ((0x009b  << 2) + 0xfe332000)
#define AED_DRC_K2_B                               ((0x009c  << 2) + 0xfe332000)
#define AED_DRC_K3_B                               ((0x009d  << 2) + 0xfe332000)
#define AED_DRC_K4_B                               ((0x009e  << 2) + 0xfe332000)
#define AED_DRC_K5_B                               ((0x009f  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT0_B                         ((0x00a0  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT1_B                         ((0x00a1  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT2_B                         ((0x00a2  << 2) + 0xfe332000)
#define AED_DRC_THD_OUT3_B                         ((0x00a3  << 2) + 0xfe332000)
#define AED_DRC_OFFSET_B                           ((0x00a4  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF00_B                   ((0x00a5  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF01_B                   ((0x00a6  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF10_B                   ((0x00a7  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF11_B                   ((0x00a8  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF20_B                   ((0x00a9  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF21_B                   ((0x00aa  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF30_B                   ((0x00ab  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF31_B                   ((0x00ac  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF40_B                   ((0x00ad  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF41_B                   ((0x00ae  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF50_B                   ((0x00af  << 2) + 0xfe332000)
#define AED_DRC_RELEASE_COEF51_B                   ((0x00b0  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF00_B                    ((0x00b1  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF01_B                    ((0x00b2  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF10_B                    ((0x00b3  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF11_B                    ((0x00b4  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF20_B                    ((0x00b5  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF21_B                    ((0x00b6  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF30_B                    ((0x00b7  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF31_B                    ((0x00b8  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF40_B                    ((0x00b9  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF41_B                    ((0x00ba  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF50_B                    ((0x00bb  << 2) + 0xfe332000)
#define AED_DRC_ATTACK_COEF51_B                    ((0x00bc  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF00_B                      ((0x00bd  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF01_B                      ((0x00be  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF10_B                      ((0x00bf  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF11_B                      ((0x00c0  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF20_B                      ((0x00c1  << 2) + 0xfe332000)
#define AED_MDRC_RMS_COEF21_B                      ((0x00c2  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF00_B                  ((0x00c3  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF01_B                  ((0x00c4  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF10_B                  ((0x00c5  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF11_B                  ((0x00c6  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF20_B                  ((0x00c7  << 2) + 0xfe332000)
#define AED_MDRC_RELEASE_COEF21_B                  ((0x00c8  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF00_B                   ((0x00c9  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF01_B                   ((0x00ca  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF10_B                   ((0x00cb  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF11_B                   ((0x00cc  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF20_B                   ((0x00cd  << 2) + 0xfe332000)
#define AED_MDRC_ATTACK_COEF21_B                   ((0x00ce  << 2) + 0xfe332000)
#define AED_MDRC_THD0_B                            ((0x00cf  << 2) + 0xfe332000)
#define AED_MDRC_THD1_B                            ((0x00d0  << 2) + 0xfe332000)
#define AED_MDRC_THD2_B                            ((0x00d1  << 2) + 0xfe332000)
#define AED_MDRC_K0_B                              ((0x00d2  << 2) + 0xfe332000)
#define AED_MDRC_K1_B                              ((0x00d3  << 2) + 0xfe332000)
#define AED_MDRC_K2_B                              ((0x00d4  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET0_B                         ((0x00d5  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET1_B                         ((0x00d6  << 2) + 0xfe332000)
#define AED_MDRC_OFFSET2_B                         ((0x00d7  << 2) + 0xfe332000)
#define AED_MDRC_LOW_GAIN_B                        ((0x00d8  << 2) + 0xfe332000)
#define AED_MDRC_MID_GAIN_B                        ((0x00d9  << 2) + 0xfe332000)
#define AED_MDRC_HIGH_GAIN_B                       ((0x00da  << 2) + 0xfe332000)
#define AED_DRC_CNTL_B                             ((0x00db  << 2) + 0xfe332000)
#define AED_DRC_LOOPBACK_CNTL_B                    ((0x00dc  << 2) + 0xfe332000)
#define AED_MDRC_CNTL_B                            ((0x00dd  << 2) + 0xfe332000)
#define AED_STATUS_REG                             ((0x00de  << 2) + 0xfe332000)
//========================================================================
//  AUDIO locker - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331400
// -----------------------------------------------
#define AUD_LOCK_EN                                ((0x0000  << 2) + 0xfe331400)
#define AUD_LOCK_SW_RESET                          ((0x0001  << 2) + 0xfe331400)
#define AUD_LOCK_SW_LATCH                          ((0x0002  << 2) + 0xfe331400)
#define AUD_LOCK_HW_LATCH                          ((0x0003  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_SRC                        ((0x0004  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_LAT_INT                    ((0x0005  << 2) + 0xfe331400)
#define AUD_LOCK_IMCLK_LAT_INT                     ((0x0006  << 2) + 0xfe331400)
#define AUD_LOCK_OMCLK_LAT_INT                     ((0x0007  << 2) + 0xfe331400)
#define AUD_LOCK_REFCLK_DS_INT                     ((0x0008  << 2) + 0xfe331400)
#define AUD_LOCK_IMCLK_DS_INT                      ((0x0009  << 2) + 0xfe331400)
#define AUD_LOCK_OMCLK_DS_INT                      ((0x000a  << 2) + 0xfe331400)
#define AUD_LOCK_INT_CLR                           ((0x000b  << 2) + 0xfe331400)
#define AUD_LOCK_GCLK_CTRL                         ((0x000c  << 2) + 0xfe331400)
#define AUD_LOCK_INT_CTRL                          ((0x000d  << 2) + 0xfe331400)
#define RO_REF2IMCLK_CNT_L                         ((0x0010  << 2) + 0xfe331400)
#define RO_REF2IMCLK_CNT_H                         ((0x0011  << 2) + 0xfe331400)
#define RO_REF2OMCLK_CNT_L                         ((0x0012  << 2) + 0xfe331400)
#define RO_REF2OMCLK_CNT_H                         ((0x0013  << 2) + 0xfe331400)
#define RO_IMCLK2REF_CNT_L                         ((0x0014  << 2) + 0xfe331400)
#define RO_IMCLK2REF_CNT_H                         ((0x0015  << 2) + 0xfe331400)
#define RO_OMCLK2REF_CNT_L                         ((0x0016  << 2) + 0xfe331400)
#define RO_OMCLK2REF_CNT_H                         ((0x0017  << 2) + 0xfe331400)
#define RO_REFCLK_PKG_CNT                          ((0x0018  << 2) + 0xfe331400)
#define RO_IMCLK_PKG_CNT                           ((0x0019  << 2) + 0xfe331400)
#define RO_OMCLK_PKG_CNT                           ((0x001a  << 2) + 0xfe331400)
#define RO_AUD_LOCK_INT_STATUS                     ((0x001b  << 2) + 0xfe331400)
//========================================================================
//  AUDIO lockerB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334400
// -----------------------------------------------
#define AUD_LOCKB_EN                               ((0x0000  << 2) + 0xfe334400)
#define AUD_LOCKB_SW_RESET                         ((0x0001  << 2) + 0xfe334400)
#define AUD_LOCKB_SW_LATCH                         ((0x0002  << 2) + 0xfe334400)
#define AUD_LOCKB_HW_LATCH                         ((0x0003  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_SRC                       ((0x0004  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_LAT_INT                   ((0x0005  << 2) + 0xfe334400)
#define AUD_LOCKB_IMCLK_LAT_INT                    ((0x0006  << 2) + 0xfe334400)
#define AUD_LOCKB_OMCLK_LAT_INT                    ((0x0007  << 2) + 0xfe334400)
#define AUD_LOCKB_REFCLK_DS_INT                    ((0x0008  << 2) + 0xfe334400)
#define AUD_LOCKB_IMCLK_DS_INT                     ((0x0009  << 2) + 0xfe334400)
#define AUD_LOCKB_OMCLK_DS_INT                     ((0x000a  << 2) + 0xfe334400)
#define AUD_LOCKB_INT_CLR                          ((0x000b  << 2) + 0xfe334400)
#define AUD_LOCKB_GCLK_CTRL                        ((0x000c  << 2) + 0xfe334400)
#define AUD_LOCKB_INT_CTRL                         ((0x000d  << 2) + 0xfe334400)
#define ROB_REF2IMCLK_CNT_L                        ((0x0010  << 2) + 0xfe334400)
#define ROB_REF2IMCLK_CNT_H                        ((0x0011  << 2) + 0xfe334400)
#define ROB_REF2OMCLK_CNT_L                        ((0x0012  << 2) + 0xfe334400)
#define ROB_REF2OMCLK_CNT_H                        ((0x0013  << 2) + 0xfe334400)
#define ROB_IMCLK2REF_CNT_L                        ((0x0014  << 2) + 0xfe334400)
#define ROB_IMCLK2REF_CNT_H                        ((0x0015  << 2) + 0xfe334400)
#define ROB_OMCLK2REF_CNT_L                        ((0x0016  << 2) + 0xfe334400)
#define ROB_OMCLK2REF_CNT_H                        ((0x0017  << 2) + 0xfe334400)
#define ROB_REFCLK_PKG_CNT                         ((0x0018  << 2) + 0xfe334400)
#define ROB_IMCLK_PKG_CNT                          ((0x0019  << 2) + 0xfe334400)
#define ROB_OMCLK_PKG_CNT                          ((0x001a  << 2) + 0xfe334400)
#define ROB_AUD_LOCK_INT_STATUS                    ((0x001b  << 2) + 0xfe334400)
//========================================================================
//  AUDIO VAD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331800
// -----------------------------------------------
//
// Reading file:  ./VAD_REG.h
//
#define VAD_TOP_CTRL0                              ((0x0000  << 2) + 0xfe331800)
#define VAD_TOP_CTRL1                              ((0x0001  << 2) + 0xfe331800)
#define VAD_TOP_CTRL2                              ((0x0002  << 2) + 0xfe331800)
#define VAD_FIR_CTRL                               ((0x0003  << 2) + 0xfe331800)
#define VAD_FIR_EMP                                ((0x0004  << 2) + 0xfe331800)
#define VAD_FIR_COEF0                              ((0x0005  << 2) + 0xfe331800)
#define VAD_FIR_COEF1                              ((0x0006  << 2) + 0xfe331800)
#define VAD_FIR_COEF2                              ((0x0007  << 2) + 0xfe331800)
#define VAD_FIR_COEF3                              ((0x0008  << 2) + 0xfe331800)
#define VAD_FIR_COEF4                              ((0x0009  << 2) + 0xfe331800)
#define VAD_FIR_COEF5                              ((0x000a  << 2) + 0xfe331800)
#define VAD_FIR_COEF6                              ((0x000b  << 2) + 0xfe331800)
#define VAD_FIR_COEF7                              ((0x000c  << 2) + 0xfe331800)
#define VAD_FIR_COEF8                              ((0x000d  << 2) + 0xfe331800)
#define VAD_FIR_COEF9                              ((0x000e  << 2) + 0xfe331800)
#define VAD_FIR_COEF10                             ((0x000f  << 2) + 0xfe331800)
#define VAD_FIR_COEF11                             ((0x0010  << 2) + 0xfe331800)
#define VAD_FIR_COEF12                             ((0x0011  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL0                            ((0x0012  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL1                            ((0x0013  << 2) + 0xfe331800)
#define VAD_FRAME_CTRL2                            ((0x0014  << 2) + 0xfe331800)
#define VAD_CEP_CTRL0                              ((0x0015  << 2) + 0xfe331800)
#define VAD_CEP_CTRL1                              ((0x0016  << 2) + 0xfe331800)
#define VAD_CEP_CTRL2                              ((0x0017  << 2) + 0xfe331800)
#define VAD_CEP_CTRL3                              ((0x0018  << 2) + 0xfe331800)
#define VAD_CEP_CTRL4                              ((0x0019  << 2) + 0xfe331800)
#define VAD_CEP_CTRL5                              ((0x001a  << 2) + 0xfe331800)
#define VAD_DEC_CTRL                               ((0x001b  << 2) + 0xfe331800)
#define VAD_TOP_STS0                               ((0x001c  << 2) + 0xfe331800)
#define VAD_TOP_STS1                               ((0x001d  << 2) + 0xfe331800)
#define VAD_TOP_STS2                               ((0x001e  << 2) + 0xfe331800)
#define VAD_FIR_STS0                               ((0x001f  << 2) + 0xfe331800)
#define VAD_FIR_STS1                               ((0x0020  << 2) + 0xfe331800)
#define VAD_POW_STS0                               ((0x0021  << 2) + 0xfe331800)
#define VAD_POW_STS1                               ((0x0022  << 2) + 0xfe331800)
#define VAD_POW_STS2                               ((0x0023  << 2) + 0xfe331800)
#define VAD_FFT_STS0                               ((0x0024  << 2) + 0xfe331800)
#define VAD_FFT_STS1                               ((0x0025  << 2) + 0xfe331800)
#define VAD_SPE_STS0                               ((0x0026  << 2) + 0xfe331800)
#define VAD_SPE_STS1                               ((0x0027  << 2) + 0xfe331800)
#define VAD_SPE_STS2                               ((0x0028  << 2) + 0xfe331800)
#define VAD_SPE_STS3                               ((0x0029  << 2) + 0xfe331800)
#define VAD_DEC_STS0                               ((0x002a  << 2) + 0xfe331800)
#define VAD_DEC_STS1                               ((0x002b  << 2) + 0xfe331800)
#define VAD_LUT_CTRL                               ((0x002c  << 2) + 0xfe331800)
#define VAD_LUT_WR                                 ((0x002d  << 2) + 0xfe331800)
#define VAD_LUT_RD                                 ((0x002e  << 2) + 0xfe331800)
#define VAD_IN_SEL0                                ((0x002f  << 2) + 0xfe331800)
#define VAD_IN_SEL1                                ((0x0030  << 2) + 0xfe331800)
#define VAD_TO_DDR                                 ((0x0031  << 2) + 0xfe331800)
#define VAD_SYNC_CTRL0                             ((0x0032  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID0                         ((0x0033  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID1                         ((0x0034  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID2                         ((0x0035  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID3                         ((0x0036  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID4                         ((0x0037  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID5                         ((0x0038  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID6                         ((0x0039  << 2) + 0xfe331800)
#define VAD_SYNC_CHNUM_ID7                         ((0x003a  << 2) + 0xfe331800)
//
// Closing file:  ./VAD_REG.h
//
//========================================================================
//  AUDIO RESAMPLEA - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe331c00
// -----------------------------------------------
//
// Reading file:  ./RESAMPLE.h
//
#define AUDIO_RSAMP_CTRL0                          ((0x0000  << 2) + 0xfe331c00)
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define AUDIO_RSAMP_CTRL1                          ((0x0001  << 2) + 0xfe331c00)
//Bit   31:27      reg_in_lsb        //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:5        reserved          //unsigned  , default =2;
//Bit   4:0        reg_inp_mux       //unsigned  , default =0;
#define AUDIO_RSAMP_CTRL2                          ((0x0002  << 2) + 0xfe331c00)
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define AUDIO_RSAMP_PHSINIT                        ((0x0003  << 2) + 0xfe331c00)
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define AUDIO_RSAMP_PHSSTEP                        ((0x0004  << 2) + 0xfe331c00)
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define AUDIO_RSAMP_SHIFT                          ((0x0005  << 2) + 0xfe331c00)
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define AUDIO_RSAMP_ADJ_CTRL0                      ((0x0006  << 2) + 0xfe331c00)
//Bit   31:7        reserved                //unsigned
//Bit   6           reg_lock_vld_sel        //unsigned , default = 0;
//Bit   5           reg_loop_dif_clr_en     //unsigned , default = 0;
//Bit   4           reg_aout_force_en       //unsigned , default = 0;
//Bit   3           reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define AUDIO_RSAMP_ADJ_CTRL1                      ((0x0007  << 2) + 0xfe331c00)
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define AUDIO_RSAMP_ADJ_SFT                        ((0x0008  << 2) + 0xfe331c00)
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define AUDIO_RSAMP_ADJ_IDET_LEN                   ((0x0009  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define AUDIO_RSAMP_ADJ_FORCE                      ((0x000a  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define AUDIO_RSAMP_ADJ_KI_FORCE                   ((0x000b  << 2) + 0xfe331c00)
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define AUDIO_RSAMP_WATCHDOG_THRD                  ((0x000c  << 2) + 0xfe331c00)
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define AUDIO_RSAMP_DBG_INFO                       ((0x000d  << 2) + 0xfe331c00)
//Bit   31:16      reg_aout_force_hi        //unsigned , default = 0;
//Bit   15:7       reserved                 //unsigned , default = 0;
//Bit   6          reg_rsamp_dbgcnt_clr     //unsigned , default = 0;
//Bit   5          reg_rsamp_dbgcnt_vldsel  //unsigned , default = 0;
//Bit   4          reg_rsamp_dbgcnt_en      //unsigned , default = 0;
//Bit   3          reserved                 //unsigned , default = 0;
//Bit   2:0        reg_watchdog_rstsel      //unsigned , default = 4;
#define AUDIO_RSAMP_AOUT_FORCE                     ((0x000e  << 2) + 0xfe331c00)
//Bit   31:0       reg_aout_force_lo        //unsigned , default = 0;
#define AUDIO_RSAMP_IRQ_CTRL                       ((0x000f  << 2) + 0xfe331c00)
//Bit   31:16      reg_irq_thrd             //unsigned , default = 0;
//Bit   15:12      reserved                 //unsigned , default = 0;
//Bit   11:8       reg_irq_sel              //unsigned , default = 0;
//Bit   7:4        reg_irq_clr              //unsigned , default = 0;
//Bit   3:0        reg_irq_en               //unsigned , default = 0;
#define AUDIO_RSAMP_RO_STATUS                      ((0x0010  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define AUDIO_RSAMP_RO_ADJ_FREQ                    ((0x0011  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_adj_freq
#define AUDIO_RSAMP_RO_ADJ_DIFF_BAK                ((0x0012  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_diff_bak
#define AUDIO_RSAMP_RO_ADJ_DIFF_DLT                ((0x0013  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_diff_dlt
#define AUDIO_RSAMP_RO_ADJ_PHS_ERR                 ((0x0014  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_phase_err
#define AUDIO_RSAMP_RO_ADJ_KI_OUT                  ((0x0015  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_ki_out
#define AUDIO_RSAMP_RO_IN_CNT                      ((0x0016  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_in_cnt
#define AUDIO_RSAMP_RO_OUT_CNT                     ((0x0017  << 2) + 0xfe331c00)
//Bit   31:0       ro_rsamp_out_cnt
#define AUDIO_RSAMP_RO_ADJ_PHS_ERR_VAR             ((0x0018  << 2) + 0xfe331c00)
//Bit   31:0       ro_det_phase_err_var
#define AUDIO_RSAMP_POST_COEF0                     ((0x0020  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF1                     ((0x0021  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF2                     ((0x0022  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF3                     ((0x0023  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define AUDIO_RSAMP_POST_COEF4                     ((0x0024  << 2) + 0xfe331c00)
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define AUDIO_RSAMP_AA_COEF_ADDR                   ((0x0030  << 2) + 0xfe331c00)
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define AUDIO_RSAMP_AA_COEF_DATA                   ((0x0031  << 2) + 0xfe331c00)
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define AUDIO_RSAMP_SINC_COEF_ADDR                 ((0x0040  << 2) + 0xfe331c00)
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define AUDIO_RSAMP_SINC_COEF_DATA                 ((0x0041  << 2) + 0xfe331c00)
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  ./RESAMPLE.h
//
//========================================================================
//  AUDIO EARCTX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333000
// -----------------------------------------------
//
// Reading file:  ./earc_tx_cmdc.h
//
#define EARC_TX_CMDC_TOP_CTRL0                     ((0x0030  << 2) + 0xfe333000)
//Bit   31   ,      idle2_int          unsigned, default = 0, 1: enable
//Bit   30   ,      idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,      disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,      disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,      earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,      hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,      losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,      timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,      status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,      int_recv_finished  unsigned, default = 0, 1: enable
//Bit   21   ,      int_rdata          unsigned, default = 0, 1: enable
//Bit   20   ,      int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,      int_recv_norsp     unsigned, default = 0, 1: enable
//Bit   18   ,      int_recv_unexp     unsigned, default = 0, 1: enable
//Bit   17   ,      int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,      int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,      int_recv_ecc_err   unsigned, default = 0, 1: enable
//Bit   14   ,      int_recv_packet    unsigned, default = 0, 1: enable
//Bit   13:0 ,      reserved
#define EARC_TX_CMDC_TOP_CTRL1                     ((0x0031  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_top_ctrl1     //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TOP_CTRL2                     ((0x0032  << 2) + 0xfe333000)
//Bit   31   ,     reset_idle2_int              unsigned, default = 0, 1: enable
//Bit   30   ,     reset_idle1_int            unsigned, default = 0, 1: enable
//Bit   29   ,     reset_disc2_int            unsigned, default = 0, 1: enable
//Bit   28   ,     reset_disc1_int            unsigned, default = 0, 1: enable
//Bit   27   ,     reset_earc_int             unsigned, default = 0, 1: enable
//Bit   26   ,     reset_hb_status_int        unsigned, default = 0, 1: enable
//Bit   25   ,     reset_losthb_int           unsigned, default = 0, 1: enable
//Bit   24   ,     reset_timeout_int          unsigned, default = 0, 1: enable
//Bit   23   ,     reset_status_ch_int        unsigned, default = 0, 1: enable
//Bit   22   ,     reset_int_recv_finished        unsigned, default = 0, 1: enable
//Bit   21   ,     reset_int_rdata              unsigned, default = 0, 1: enable
//Bit   20   ,     reset_int_recv_nack       unsigned, default = 0, 1: enable
//Bit   19   ,     reset_int_recv_norsp         unsigned, default = 0, 1: enable
//Bit   18   ,     reset_int_recv_unexp         unsigned, default = 0, 1: enable
//Bit   17   ,     reset_int_recv_data       unsigned, default = 0, 1: enable
//Bit   16   ,     reset_int_recv_ack       unsigned, default = 0, 1: enable
//Bit   15   ,     reset_int_recv_ecc_err       unsigned, default = 0, 1: enable
//Bit   14   ,     reset_int_recv_packet        unsigned, default = 0, 1: enable
//Bit 13:0   ,     reserved
#define EARC_TX_CMDC_TIMER_CTRL0                   ((0x0033  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl0   //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL1                   ((0x0034  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl1  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL2                   ((0x0035  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl2  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_TIMER_CTRL3                   ((0x0036  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_timer_ctrl3  //unsigned, RW, default = 0,
#define EARC_TX_CMDC_VSM_CTRL0                     ((0x0037  << 2) + 0xfe333000)
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state                 unsigned, default = 0,  XX
//Bit      27,      arc_initiated             unsigned, default = 0,  XX
//Bit      26,      arc_terminated             unsigned, default = 0,  XX
//Bit      25,      arc_enable                 unsigned, default = 1,  XX
//Bit      24,      man_hpd                 unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel                 unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state_en           unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en             unsigned, default = 0,  XX
//Bit      13,      noack_repeat_en            unsigned, default = 0,  XX
//Bit    12:0,      reserved
#define EARC_TX_CMDC_VSM_CTRL1                     ((0x0038  << 2) + 0xfe333000)
//Bit    31:9,      reserved
//Bit       8,      cntl_hpd_sel            unsigned, default = 0, 0:sel hd_hpd,1:sel hdmirx_hpd
//Bit     7:0,      comma_cnt_th            unsigned, default = 0, should bigger than 3 and small than 10
#define EARC_TX_CMDC_VSM_CTRL2                     ((0x0039  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc1 hpd_val timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc1 hpd_val timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc1 hpd_val timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc1 hpd_val timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc1 hpd_val timing
#define EARC_TX_CMDC_VSM_CTRL3                     ((0x003a  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  disc2 heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  disc2 heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  disc2 heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  disc2 heartbeat act timing
#define EARC_TX_CMDC_VSM_CTRL4                     ((0x003b  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc2, no heartbeat ack timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc2, no heartbeat ack timing
#define EARC_TX_CMDC_VSM_CTRL5                     ((0x003c  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      6:4,      time_sel              unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in disc1 and disc2 timing out
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in disc1 and disc2 timing out
#define EARC_TX_CMDC_VSM_CTRL6                     ((0x003d  << 2) + 0xfe333000)
//Bit    31:12,      max_count_th          unsigned, default = 0,  in earc heartbeat act timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat act timing
//Bit      6:4,      time_sel              unsigned, default = 0,  in earc heartbeat act timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat act timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat act timing
#define EARC_TX_CMDC_VSM_CTRL7                     ((0x003e  << 2) + 0xfe333000)
//Bit    31:16,      reserved
//Bit     15:8,      status_soft_val       unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define EARC_TX_CMDC_VSM_CTRL8                     ((0x003f  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_vsm_ctrl8        //unsigned, RW, default = 0,
#define EARC_TX_CMDC_VSM_CTRL9                     ((0x0041  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_vsm_ctrl9        //unsigned, RW, default = 0
#define EARC_TX_CMDC_SENDER_CTRL0                  ((0x0042  << 2) + 0xfe333000)
//Bit      31:2,     sender_ctrl0                 unsigned,  default = 0,
//Bit      1,        hb_chg_conf_auto             unsigned,  default = 1,
//Bit      0,        hb_chg_auto                  unsigned,  default = 0,
#define EARC_TX_CMDC_PACKET_CTRL0                  ((0x0043  << 2) + 0xfe333000)
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst                    unsigned, default = 0,  packet control
//Bit     28:24,      tx_ready_threshold          unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_threshold          unsigned, default = 0,  packet control
//Bit       7:6,      reserved
//Bit         5,      state_auto_en               unsigned, default = 0, packet control
//Bit         4,      sw_state_update_en          unsigned, default = 0,  packet control
//Bit       3:0,      sw_state_value              unsigned, default = 0,  packet control
#define EARC_TX_CMDC_PACKET_CTRL1                  ((0x0044  << 2) + 0xfe333000)
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_start_value             unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_threshold              unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_threshold               unsigned, default = 0,  XX
//Bit       7:0,      post_flag                   unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL2                  ((0x0045  << 2) + 0xfe333000)
//Bit      31:0,      pre_flag                    unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL3                  ((0x0046  << 2) + 0xfe333000)
//Bit      31,       recv_en                      unsigned, default = 0,  XX
//Bit      30,       recv_parity_mask             unsigned, default = 0,  XX
//Bit      29,       recv_timeout_en              unsigned, default = 0,  XX
//Bit      28,       bch_ecc_en                   unsigned, default = 0, xx
//Bit     27:16,     reserved
//Bit      15:0,     recv_timeout_threshold       unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL4                  ((0x0047  << 2) + 0xfe333000)
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head             unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL5                  ((0x0048  << 2) + 0xfe333000)
//Bit     31:20,     reserved
//Bit      19:0,     recv_packet_head_mask        unsigned, default = 0,  XX
#define EARC_TX_CMDC_PACKET_CTRL6                  ((0x0049  << 2) + 0xfe333000)
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:7,     reserved
//Bit         6,     recv_finished_int            unsigned, default = 0,  XX
//Bit         5,     recv_ecc_err_int             unsigned, default = 0,  XX
//Bit         4,     recv_ack_int                 unsigned, default = 0,  XX
//Bit         3,     recv_data_int                unsigned, default = 0,  XX
//Bit         2,     recv_unexp_int               unsigned, default = 0,  XX
//Bit         1,     recv_norsp_int               unsigned, default = 0,  XX
//Bit         0,     recv_nack_int                unsigned, default = 0,  XX
#define EARC_TX_CMDC_BIPHASE_CTRL0                 ((0x004a  << 2) + 0xfe333000)
//Bit     31:24,     reserved
//Bit     23:16,     ack delay threshold           unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define EARC_TX_CMDC_BIPHASE_CTRL1                 ((0x004b  << 2) + 0xfe333000)
//Bit     31:16,     reserved
//Bit        15,     ack_enable                    unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     wait_threshold before ack     unsigned, default = 0,  send
#define EARC_TX_CMDC_BIPHASE_CTRL2                 ((0x004c  << 2) + 0xfe333000)
//Bit        31,     comma_detection_enable        unsigned, default = 0, comma detection
//Bit        30,     manual_reset_enable           unsigned, default = 0, manual reset select, 1: manual
//Bit        29,     manual_reset_value            unsigned, default = 0, manual reset control
//Bit     28:16,     reserved
//Bit      15:0,     comma_detection_threshold     unsigned, default = 0,
#define EARC_TX_CMDC_BIPHASE_CTRL3                 ((0x004d  << 2) + 0xfe333000)
//Bit      31:0,     cmdc_biphase_ctrl3            unsigned, default = 0,
#define EARC_TX_CMDC_DEVICE_ID_CTRL                ((0x004e  << 2) + 0xfe333000)
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_rw_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_rw_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:17,     reserved
//Bit        16,     hpb_rst_enable               unsigned, default = 1, hpd rst enable
//Bit      15:8,     apb_rwid                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apbrw_start_addr            unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_DEVICE_WDATA                  ((0x004f  << 2) + 0xfe333000)
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_DEVICE_RDATA                  ((0x0050  << 2) + 0xfe333000)
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/read
#define EARC_TX_CMDC_MASTER_CTRL                   ((0x0051  << 2) + 0xfe333000)
//Bit        31,     master_cmd_rw                 unsigned, default = 0, 1 write 0 read
//Bit        30,     master_hb_ignore              unsigned, default =0, 0:wait hb issued before pkt cmd, 1: pkt cmd issued immediately
//Bit        29,     master_idle                   unsigned, default = 0, master status
//Bit        28,     master_cmd_soft_rst           unsigned, default= 0,
//Bit     27:24,     hb_cmd_cal_th                 unsigned, default= 0,
//Bit     23:16,     master_cmd_count              unsigned, default = 0, cmd count -1
//Bit      15:8,     master_cmd_id                 unsigned, default = 0,
//Bit       7:0,     master_cmd_address            unsigned, default = 0,
#define EARC_TX_ANA_CTRL0                          ((0x0052  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl0       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL1                          ((0x0053  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl1       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL2                          ((0x0054  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl2       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL3                          ((0x0055  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl3       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL4                          ((0x0056  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl4       //unsigned, RW, default = 0,
#define EARC_TX_ANA_CTRL5                          ((0x0057  << 2) + 0xfe333000)
//Bit      31:0,      reg_earctx_ana_ctrl5       //unsigned, RW, default = 0,
#define EARC_TX_ANA_STAT0                          ((0x0058  << 2) + 0xfe333000)
//Bit      31:0,     ro_ANA_status0              //unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS0                       ((0x0059  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status0              //unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS1                       ((0x005a  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status1              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS2                       ((0x005b  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status2              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS3                       ((0x005c  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status3              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS4                       ((0x005d  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status4              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS5                       ((0x005e  << 2) + 0xfe333000)
//Bit      31:0,     ro_cmdc_status5              ///unsigned, RO, default = 0,
#define EARC_TX_CMDC_STATUS6                       ((0x005f  << 2) + 0xfe333000)
//Bit   31   ,     ro_idle2_int            unsigned, RO, default = 0
//Bit   30   ,     ro_idle1_int            unsigned, RO, default = 0
//Bit   29   ,     ro_disc2_int            unsigned, RO, default = 0
//Bit   28   ,     ro_disc1_int            unsigned, RO, default = 0
//Bit   27   ,     ro_earc_int             unsigned, RO, default = 0
//Bit   26   ,     ro_hb_status_int        unsigned, RO, default = 0
//Bit   25   ,     ro_losthb_int           unsigned, RO, default = 0
//Bit   24   ,     ro_timeout_int          unsigned, RO, default = 0
//Bit   23   ,     ro_status_ch_int        unsigned, RO, default = 0
//Bit   22   ,     ro_int_recv_finished    unsigned, RO, default = 0
//Bit   21   ,     ro_int_rdata            unsigned, RO, default = 0
//Bit   20   ,     ro_int_recv_nack        unsigned, RO, default = 0
//Bit   19   ,     ro_int_recv_norsp       unsigned, RO, default = 0
//Bit   18   ,     ro_int_recv_unexp       unsigned, RO, default = 0
//Bit   17   ,     ro_int_recv_data        unsigned, RO, default = 0
//Bit   16   ,     ro_int_recv_ack         unsigned, RO, default = 0
//Bit   15   ,     ro_int_recv_ecc_err     unsigned, RO, default = 0
//Bit   14   ,     ro_int_recv_packet      unsigned, RO, default = 0
//Bit 13:0   ,     reserved
//
// Closing file:  ./earc_tx_cmdc.h
//
//========================================================================
//  AUDIO EARCTX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333400
// -----------------------------------------------
//
// Reading file:  ./earctx_dmac.h
//
#define EARCTX_DMAC_TOP_CTRL0                      ((0x0000  << 2) + 0xfe333400)
//Bit 31,       reg_top_reg_sync             ,default = 0,Bit 3:0 sync to clk10m,pluse auto clear
//Bit 30,       reg_top_soft_rst             ,default = 0
//Bit 29:26,    reserved
//Bit 25:24,    reg_debug_mux                ,default = 0
//Bit 23:21,    reserved
//Bit 20,       reg_slow_sync_scan_reg       ,default = 0
//Bit 19,       reg_fe_sf_scan_reg           ,default = 0
//Bit 18,       reg_fe_slow_sync_scan_reg    ,default = 0
//Bit 17,       reg_top_sf_scan_reg          ,default = 0
//Bit 16,       reg_top_slow_sync_scan_reg   ,default = 0
//Bit 15:4,     reserved
//Bit 3,        reg_spdif_tx_en_force        ,default = 0,spdif_tx_en force enable
//Bit 2,        reg_spdif_tx_en_force_value  ,default = 0,spdif_tx_en force value
//Bit 1,        reg_dmac_tx_en_force         ,default = 0,dmac_tx_en force enable
//Bit 0,        reg_dmac_tx_en_force_value   ,default = 0,dmac_tx_en force value
#define EARCTX_MUTE_VAL                            ((0x0001  << 2) + 0xfe333400)
//Bit 31:0,     reg_spdif_mute_val     ,default = 0,when biahpase encode mute,the channel value,with reg_mute_l/reg_mute_r
#define EARCTX_SPDIFOUT_GAIN0                      ((0x0002  << 2) + 0xfe333400)
//Bit 31:24,    reg_gain_ch3     ,default = 0,channel 3 gain
//Bit 23:16,    reg_gain_ch2     ,default = 0,channel 2 gain
//Bit 15:8,     reg_gain_ch1     ,default = 0,channel 1 gain
//Bit 7:0,      reg_gain_ch0     ,default = 0,channel 0 gain
#define EARCTX_SPDIFOUT_GAIN1                      ((0x0003  << 2) + 0xfe333400)
//Bit 31:24,    reg_gain_ch7     ,default = 0,channel 7 gain
//Bit 23:16,    reg_gain_ch6     ,default = 0,channel 6 gain
//Bit 15:8,     reg_gain_ch5     ,default = 0,channel 5 gain
//Bit 7:0,      reg_gain_ch4     ,default = 0,channel 4 gain
#define EARCTX_SPDIFOUT_CTRL0                      ((0x0004  << 2) + 0xfe333400)
//Bit 31,     reg_work_start      ,default = 0,biphase work start,pluse
//Bit 30,     reg_work_clr        ,default = 0,biphase work clear,pluse
//Bit 29,     reg_rst_afifo_out_n ,default = 0,afifo out reset
//Bit 28,     reg_rst_afifo_in_n  ,default = 0,afifo in reset
//Bit 27,     reg_hold_for_tdm    ,default = 0,add delay to mathc TDM out when share buff
//Bit 26,     reg_userdata_sel    ,default = 0,user Bit select : 0 from reg_userdata_set 1 from data[29]
//Bit 25,     reg_userdata_set    ,default = 0
//Bit 24,     reg_chdata_sel      ,default = 0,0 :from reg_chstst 1 from data[30]
//Bit 23,     reserved
//Bit 22,     reg_mute_l          ,default = 0,r channel mute ,with reg_mute_val
//Bit 21,     reg_mute_r          ,default = 0,l channel mute ,with reg_mute_val
//Bit 20,     reg_data_sel        ,default = 0,0 data from 31Bit 1 data from 27bit
//Bit 19,     reg_out_msb_first   ,default = 0,0 lsb first 1 msb first
//Bit 18,     reg_valid_sel       ,default = 0,biphase encode valid Bit value sel : 0 from data 1 from reg_valid_set
//Bit 17,     reg_valid_set       ,default = 0,biphase encode valid Bit value
//Bit 16,     reg_mute_hold_init_en  ,default = 0,when c_mute_hold_last_err_corrt valid,clear work enable, initial biphase encode
//Bit 15:12,  reserved
//Bit 0,      reg_parity_mask     ,default = 0,Bit 0 is initial parity value
#define EARCTX_SPDIFOUT_CTRL1                      ((0x0005  << 2) + 0xfe333400)
//Bit 31,     reg_eq_drc_sel      ,default = 0,set 1 select eq_drc data
//Bit 30,     reg_keep_req_ddr_init ,default = 0,reg_keep_req_ddr_init
//Bit 29:28,  reserved
//Bit 27,     reg_gain_en         ,default = 0,gain enable
//Bit 26:24,  reg_frddr_sel       ,default = 0,from ddr select
//Bit 23:16,  reg_wait_cnt        ,default = 0,wait some time when enable set to 1
//Bit 15:13,  reserved
//Bit 12:8,   reg_frddr_msb       ,default = 0,msb position of data
//Bit 7,      reg_force_start     ,default = 0,set 1 no need ack from frddr to transmit channel status
//Bit 6:4,    reg_frddr_type      ,default = 0
//Bit 3:0,    reserved
#define EARCTX_SPDIFOUT_PREAMB                     ((0x0006  << 2) + 0xfe333400)
//Bit 31,     reg_premable_Z_set      ,default = 0,user 8'b11101000 1 user 7:0
//Bit 30,     reg_premable_Y_set      ,default = 0,user 8'b11100100 1 user 15:8
//Bit 29,     reg_premable_X_set      ,default = 0,user 8'b11100010 1 user 23:16
//Bit 28:24,  reserved
//Bit 23:16,  reg_premable_X_value    ,default = 0
//Bit 15:8,   reg_premable_Y_value    ,default = 0
//Bit 7:0,    reg_premable_Z_value    ,default = 0
#define EARCTX_SPDIFOUT_SWAP                       ((0x0007  << 2) + 0xfe333400)
//Bit 31:16,  reg_hold_cnt        ,default = 0,hold start cnt ,valid when reg_hold_for_tdm set 1
//Bit 15,     reg_init_send_en    ,default = 0,send 01 sequence some times after intial done from frddr set
//Bit 14:0,   reg_init_send_cnt   ,default = 0,send 01 sequence time ,valid when reg_init_send_en set 1
#define EARCTX_ERR_CORRT_CTRL0                     ((0x0008  << 2) + 0xfe333400)
//Bit 31:24,  reserved
//Bit 23,     reg_bch_in_reverse       ,default = 0,bch input data generate in 24it data reverse
//Bit 22,     reg_bch_out_ecc_reverse  ,default = 0,bch output ecc  reverse
//Bit 21,     reg_bch_out_data_reverse ,default = 0,bch output data reverse
//Bit 20,     reg_bch_out_ecc_msb      ,default = 0,bch output ecc position
//Bit 19:17,  reserved
//Bit 16,     reg_ubit_fifo_init_n,default = 0,fifo in  initial
//Bit 15:14,  reserved
//Bit 13:12,  reg_gain_shift      ,default = 0,gain x 1/2/4/8
//Bit 11,     reg_mix_lr          ,default = 0,l/r mix
//Bit 10:8,   reg_spdifout_r_sel  ,default = 0,r channel select
//Bit 7,      reserved
//Bit 6:4,    reg_spdifout_l_sel  ,default = 0,l channel select
//Bit 3:0,    reg_iu_interval     ,default = 0,iu transmit interval
#define EARCTX_ERR_CORRT_CTRL1                     ((0x0009  << 2) + 0xfe333400)
//Bit 31,     reg_ubit_fifo_wr    ,default = 0,iu data write enable,pluse,auto clr in reg.v
//Bit 30:8,   reserved
//Bit 7:0,    reg_ubit_fifo_wdata ,default = 0,iu data
#define EARCTX_ERR_CORRT_CTRL2                     ((0x000a  << 2) + 0xfe333400)
//Bit 31,     reg_mute_clear       ,default = 0,mute clear,pluse,auto clr in reg.v
//Bit 30,     reg_mute_start       ,default = 0,mute start,pluse,auto clr in reg.v
//Bit 29:28,  reserved
//Bit 27:16,  reg_mute_block_num   ,default = 0,mute block number
//Bit 15:8,   reg_mute_ch_Bit      ,default = 0,mute Bit at channel statue which bit
//Bit 7:3,    reserved
//Bit 2,      reg_mute_data_sel    ,default = 0,mute data sel: 0 data 1 reg_mute_data_value
//Bit 1:0,    reg_mute_mode        ,default = 0,0:always mute 1:mute block number and dis mute 2:mute block number and hold bus
#define EARCTX_ERR_CORRT_CTRL3                     ((0x000b  << 2) + 0xfe333400)
//Bit 31:30,  reserved
//Bit 29,     reg_bch_en           ,default = 0,bch generate enable
//Bit 28:24,  reg_bch_msb          ,default = 0,bch data msb position in audio data
//Bit 23:0,   reg_mute_data_value  ,default = 0,mute value,only for audio data part
#define EARCTX_ERR_CORRT_CTRL4                     ((0x000c  << 2) + 0xfe333400)
//Bit 31,    reg_ubit_fifo_lr_swap        ,default = 0,//user Bit lr swap
//Bit 30,    reg_ubit_fifo_lr_same        ,default = 0,//l/r channel use same Bit user bit
//Bit 29:25, reg_data_msb                 ,default = 0,audio data msb postion in input data
//Bit 24,    reg_data_rsv                 ,default = 0,audio data msb/lsb
//Bit 23,    reg_ubit_value               ,default = 0,user Bit value
//Bit 22,    reg_vbit_value               ,default = 0,valid Bit value
//Bit 21,    reg_data_sel                 ,default = 0,//data sel: 0 data 1 reg_mute_data_value
//Bit 20:19, reg_ubit_sel                 ,default = 0,//userBit sel: 0 data 1 reg_value 2 fifo data
//Bit 18,    reg_vbit_sel                 ,default = 0,//validBit sel: 0 data 1 reg_value
//Bit 17,    reg_chst_sel                 ,default = 0,//channel status sel: 0 data 1 reg_value
//Bit 16,    reg_ubit_fifo_less_irq_en    ,default = 0,fifo_less_thd irq enable
//Bit 15:8,  reg_ubit_fifo_start_thd      ,default = 0,start transmit iu after fifo level greater than this value
//Bit 7:0,   reg_ubit_fifo_less_thd       ,default = 0,generate irq,when fifo level less than this value
#define EARCTX_ERR_CORRT_STAT0                     ((0x000d  << 2) + 0xfe333400)
//Bit 31:0,  ro_err_corrt_stat0          ,default = 0,
#define EARCTX_SPDIFOUT_CHSTS0                     ((0x000e  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[31:0]
#define EARCTX_SPDIFOUT_CHSTS1                     ((0x000f  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[63:32]
#define EARCTX_SPDIFOUT_CHSTS2                     ((0x0010  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[95:64]
#define EARCTX_SPDIFOUT_CHSTS3                     ((0x0011  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[127:96]
#define EARCTX_SPDIFOUT_CHSTS4                     ((0x0012  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[159:128]
#define EARCTX_SPDIFOUT_CHSTS5                     ((0x0013  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_a_status         ,default =0,channel A status[191:160]
#define EARCTX_SPDIFOUT_CHSTS6                     ((0x0014  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[31:0]
#define EARCTX_SPDIFOUT_CHSTS7                     ((0x0015  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[63:32]
#define EARCTX_SPDIFOUT_CHSTS8                     ((0x0016  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[95:64]
#define EARCTX_SPDIFOUT_CHSTS9                     ((0x0017  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[127:96]
#define EARCTX_SPDIFOUT_CHSTSA                     ((0x0018  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[159:128]
#define EARCTX_SPDIFOUT_CHSTSB                     ((0x0019  << 2) + 0xfe333400)
//Bit 31:0,  reg_changel_b_status         ,default =0,channel B status[191:160]
#define EARCTX_FE_CTRL0                            ((0x001a  << 2) + 0xfe333400)
//Bit 31,    reg_mute_hold_clr      ,default = 0,clear mute hold statues,pluse, auto clr
//Bit 30,    reg_work_enable        ,default = 0,wore enable
//Bit 29,    reg_dmac_invt          ,default = 0,fe out invent
//Bit 28,    reg_hold_time_en       ,default = 0,hold min time enable
//Bit 27,    reg_hold_soft_clr_en   ,default = 0,0 auto clear hold at next valid 1 clear hold with reg_mute_hold_clr
//Bit 26:24, reg_hold_time_tick_sel ,default = 0,hold min time tick select
//Bit 23:0,  reg_hold_min_time      ,default = 0,hold min time
#define EARCTX_FE_STAT0                            ((0x001b  << 2) + 0xfe333400)
//Bit 31:0,  ro_fe_stat0          ,default = 0,
#define EARCTX_SPDIFOUT_STAT                       ((0x001c  << 2) + 0xfe333400)
//Bit 31:0,  ro_spdifout_stat     ,default = 0,
#define EARCTX_SPDIFOUT_CTRL2                      ((0x001d  << 2) + 0xfe333400)
//Bit 31:28,  reserved
//Bit 27:16,  reg_clr_by_init      ,default = 0,reg_clr_by_init
//Bit 15:0 ,  reg_mask             ,default = 0,reg_mask
#define EARCTX_SPDIFOUT_GAIN2                      ((0x001e  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain2        ,default = 0,spdifout gain2
#define EARCTX_SPDIFOUT_GAIN3                      ((0x001f  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain3        ,default = 0,spdifout gain3
#define EARCTX_SPDIFOUT_GAIN4                      ((0x0020  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain4        ,default = 0,spdifout gain4
#define EARCTX_SPDIFOUT_GAIN5                      ((0x0021  << 2) + 0xfe333400)
//Bit 31:0,  spdifout_gain5        ,default = 0,spdifout gain5
//
//
// Closing file:  ./earctx_dmac.h
//
//========================================================================
//  AUDIO EARCTX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333600
// -----------------------------------------------
//
// Reading file:  ./earctx_top.h
//
#define EARCTX_TOP_CTRL0                           ((0x0000  << 2) + 0xfe333600)
//Bit   31:18,   reserved
//Bit   17:16,   reg_earctx_debug_mux     unsigned, default = 0, debug mux
//Bit   15,      reg_slow_sync_scan_reg   unsigned, default = 0, reg_slow_sync_scan_reg
//Bit   14:12,   reserved
//Bit   11,      reg_hdmi_hpd_invt        unsigned, default = 0, hdmi_hpd invent
//Bit   10,      reg_hdmi_hpd_value       unsigned, default = 0, hdmi_hpd mux = 3,register value
//Bit   9:8,     reg_hdmi_hpd_mux         unsigned, default = 0, hdmi_hpd mux
//Bit   7,       reg_earctx_hd_hpd_invt   unsigned, default = 0, earctx_hd_hdp invent
//Bit   6,       reg_earctx_hd_hpd_value  unsigned, default = 0, earctx_hd_hdp mux = 3,register value
//Bit   5:4,     reg_earctx_hd_hdp_mux    unsigned, default = 0, earctx_hd_hdp mux
//Bit   3:2,     reserved
//Bit   1,       reg_earctx_force_mode_en unsigned, default = 0, force mode enale
//Bit   0,       reg_earctx_force_mode    unsigned, default = 0, force mode value
#define EARCTX_DMAC_INT_MASK                       ((0x0001  << 2) + 0xfe333600)
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define EARCTX_DMAC_INT_PENDING                    ((0x0002  << 2) + 0xfe333600)
//Bit   31:6,  reserved
//Bit   5:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define EARCTX_CMDC_INT_MASK                       ((0x0003  << 2) + 0xfe333600)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define EARCTX_CMDC_INT_PENDING                    ((0x0004  << 2) + 0xfe333600)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define EARCTX_ANA_CTRL0                           ((0x0005  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_CTRL1                           ((0x0006  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_CTRL2                           ((0x0007  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
#define EARCTX_ANA_STAT0                           ((0x0008  << 2) + 0xfe333600)
//Bit   31:0,   reg_earctx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  ./earctx_top.h
//
//========================================================================
//  AUDIO EARCRX_CMDC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333800
// -----------------------------------------------
//
// Reading file:  ./earc_rx_cmdc.h
//
#define EARC_RX_CMDC_TOP_CTRL0                     ((0x0000  << 2) + 0xfe333800)
//Bit   31   ,     idle2_int                 unsigned, default = 0, 1: enable
//Bit   30   ,     idle1_int     	         unsigned, default = 0, 1: enable
//Bit   29   ,     disc2_int     	         unsigned, default = 0, 1: enable
//Bit   28   ,     disc1_int     	         unsigned, default = 0, 1: enable
//Bit   27   ,     earc_int      	         unsigned, default = 0, 1: enable
//Bit   26   ,     hb_status_int 	         unsigned, default = 0, 1: enable
//Bit   25   ,     losthb_int    	         unsigned, default = 0, 1: enable
//Bit   24   ,     timeout_int   	         unsigned, default = 0, 1: enable
//Bit   23   ,     status_ch_int 	         unsigned, default = 0, 1: enable
//Bit   22   ,     int_rec_invalid_id        unsigned, default = 0, 1: enable
//Bit   21   ,     int_rec_invalid_offset    unsigned, default = 0, 1: enable
//Bit   20   ,     int_rec_unexp             unsigned, default = 0, 1: enable
//Bit   19   ,     int_rec_ecc_err           unsigned, default = 0, 1: enable
//Bit   18   ,     int_rec_parity_err        unsigned, default = 0, 1: enable
//Bit   17   ,     int_recv_packet           unsigned, default = 0, 1: enable
//Bit   16   ,     int_rec_time_out          unsigned, default = 0, 1: enable
//Bit   15   ,     cmdc_debug0               unsigned, default = 0, 1: enable
//Bit   14   ,     cmdc_debug1               unsigned, default = 0, 1: enable
//Bit   13   ,     cmdc_debug2               unsigned, default = 0, 1: enable
//Bit   12:7 ,     reserved
//Bit    6   ,     mute_select               unsigned, default = 0, 1: use bit5, 0: earc off
//Bit    5   ,     mute_contrl               unsigned, default = 0, value of manul mute control
//Bit    4:0 ,     reserved
#define EARC_RX_CMDC_TOP_CTRL1                     ((0x0001  << 2) + 0xfe333800)
//Bit      31:13,  reserved
//Bit      12:8,   reg_scan_reg             unsigned, RW, default = 0,
//Bit      7:5,    reserved
//Bit      4:0,    reg_top_soft_rst         unsigned, RW, default = 0,
#define EARC_RX_CMDC_TOP_CTRL2                     ((0x0002  << 2) + 0xfe333800)
//Bit      31,         reset_idle2_int                unsigned, default =0
//Bit      30,         reset_idle1_int                unsigned, default =0
//Bit      29,         reset_disc2_int                unsigned, default =0
//Bit      28,         reset_disc1_int                unsigned, default =0
//Bit      27,         reset_earc_int                 unsigned, default =0
//Bit      26,         reset_hb_status_int            unsigned, default =0
//Bit      25,         reset_losthb_int               unsigned, default =0
//Bit      24,         reset_timeout_int              unsigned, default =0
//Bit      23,         reset_status_ch_int            unsigned, default =0
//Bit      22,         reset_int_rec_invalid_id       unsigned, default =0
//Bit      21,         reset_int_rec_invalid_offset   unsigned, default =0
//Bit      20,         reset_int_rec_unexp            unsigned, default =0
//Bit      19,         reset_int_rec_ecc_err          unsigned, default =0
//Bit      18,         reset_int_rec_parity_err       unsigned, default =0
//Bit      17,         reset_int_recv_packet          unsigned, default =0
//Bit      16,         reset_int_rec_time_out         unsigned, default =0
//Bit      15:0,       reserved
#define EARC_RX_CMDC_TIMER_CTRL0                   ((0x0003  << 2) + 0xfe333800)
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL1                   ((0x0004  << 2) + 0xfe333800)
//Bit      31:0,   ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL2                   ((0x0005  << 2) + 0xfe333800)
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_TIMER_CTRL3                   ((0x0006  << 2) + 0xfe333800)
//Bit      31:0,    ro_cmdc_status0         unsigned, RO, default = 0,
#define EARC_RX_CMDC_VSM_CTRL0                     ((0x0007  << 2) + 0xfe333800)
//Bit      31,      sw_state_update         unsigned, default = 0,  XX
//Bit      30:28,   sw_state 		        unsigned, default = 0,  XX
//Bit      27,      arc_initiated 	        unsigned, default = 0,  XX
//Bit      26,      arc_terminated 	        unsigned, default = 0,  XX
//Bit      25,      arc_enable 		        unsigned, default = 0,  XX
//Bit      24,      man_hpd 		        unsigned, default = 0,  XX
//Bit      23:22,   hpd_sel 		        unsigned, default = 0,  XX
//Bit      21:20,   hpd_sel_earc            unsigned, default = 0,  XX
//Bit      19,      comma_cnt_rst           unsigned, default = 0,  XX
//Bit      18,      timeout_status_rst      unsigned, default = 0,  XX
//Bit      17,      losthb_status_rst       unsigned, default = 0,  XX
//Bit      16,      force_rst               unsigned, default = 0,  XX
//Bit      15,      auto_state              unsigned, default = 0,  XX
//Bit      14,      cmdc_state_en 	        unsigned, default = 0,  XX
//Bit    13:0,      reserved
#define EARC_RX_CMDC_VSM_CTRL1                     ((0x0008  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  idle done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  idle done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  idle done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  idle done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  idle done timing
#define EARC_RX_CMDC_VSM_CTRL2                     ((0x0009  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  comma off done timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  comma off done timing
//Bit      6:4,      time_sel              unsigned, default = 0,  comma off done timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  comma off done timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  comma off done timing
#define EARC_RX_CMDC_VSM_CTRL3                     ((0x000a  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  earc_time out timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  earc_time out timing
//Bit      6:4,      time_sel              unsigned, default = 0,  earc_time out timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  earc_time out timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  earc_time out timing
#define EARC_RX_CMDC_VSM_CTRL4                     ((0x000b  << 2) + 0xfe333800)
//Bit    31:12,      max_count_th          unsigned, default = 0,  heartbeat lost timing
//Bit     11:8,      reserved
//Bit        7,      reg_soft_rst          unsigned, default = 0,  heartbeat lost timing
//Bit      6:4,      time_sel              unsigned, default = 0,  heartbeat lost timing
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  heartbeat lost timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  heartbeat lost timing
#define EARC_RX_CMDC_VSM_CTRL5                     ((0x000c  << 2) + 0xfe333800)
//Bit    31:16,      reserved
//Bit     15:8,      status_soft           unsigned, default = 0,  in earc heartbeat det timing
//Bit        7,      reg_soft_rst          unsigned, default = 0,  in earc heartbeat det timing
//Bit        6,      status_rst            unsigned, default = 0,  in earc heartbeat det timing
//Bit      5:4,      reserved
//Bit      3:2,      soft_rst_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      1:0,      enable_ctrl           unsigned, default = 0,  in earc heartbeat det timing
#define EARC_RX_CMDC_VSM_CTRL6                     ((0x000d  << 2) + 0xfe333800)
//Bit    31:17,      reserved
//Bit        16,     cntl_hpd_sel          unsigned, default = 0,  in earc heartbeat det timing
//Bit      15:4,     cntl_hpd_valid_width  unsigned, default = 0,  in earc heartbeat det timing
//Bit      3:0,      cntl_hpd_glitch_width unsigned, default = 0,  in earc heartbeat det timing
#define EARC_RX_CMDC_VSM_CTRL7                     ((0x000e  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl7             unsigned,  default = 0,
#define EARC_RX_CMDC_VSM_CTRL8                     ((0x000f  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl8             unsigned,  default = 0,
#define EARC_RX_CMDC_VSM_CTRL9                     ((0x0010  << 2) + 0xfe333800)
//Bit      31:0,     vsm_ctrl9             unsigned,  default = 0,
#define EARC_RX_CMDC_SENDER_CTRL0                  ((0x0011  << 2) + 0xfe333800)
//Bit      31:2,     reserved
//Bit      1,        hb_chg_conf_auto          unsigned,  default = 0,
//Bit      0,        hb_chg_auto               unsigned,  default = 1,
#define EARC_RX_CMDC_PACKET_CTRL0                  ((0x0012  << 2) + 0xfe333800)
//Bit        31,      packet_mode_enable          unsigned, default = 0,  packet control
//Bit        30,      free_enable                 unsigned, default = 0,  packet control
//Bit        29,      soft_rst_man                unsigned, default = 0,  packet control
//Bit     28:24,      ready_th                    unsigned, default = 0,  packet control
//Bit     23:20,      reserved
//Bit      19:8,      send_pre_th                 unsigned, default = 0,  packet control
//Bit       7:5,      reserved
//Bit         4,      sw_state_update             unsigned, default = 0,  packet control
//Bit       3:0,      sw_state                    unsigned, default = 0,  packet control
#define EARC_RX_CMDC_PACKET_CTRL1                  ((0x0013  << 2) + 0xfe333800)
//Bit        31,      ecc_endian                  unsigned, default = 0,  send
//Bit        30,      pre_reg_st                  unsigned, default = 0,  send
//Bit     29:21,      reserved
//Bit     20:16,      post_th                     unsigned, default = 0,  send
//Bit     15:14,      reserved
//Bit      13:8,      pre_th                      unsigned, default = 0,
//Bit       7:0,      post_flag                   unsigned, default = 0,
#define EARC_RX_CMDC_PACKET_CTRL2                  ((0x0014  << 2) + 0xfe333800)
//Bit      31:0,      pre_flag                    unsigned, default = 0,  X
#define EARC_RX_CMDC_PACKET_CTRL3                  ((0x0015  << 2) + 0xfe333800)
//Bit      31,       cmdc_en                      unsigned, default = 0,  XX
//Bit      30,       cmdc_parity_mask             unsigned, default = 0,  XX
//Bit      29,       imeout_en                    unsigned, default = 0,  XX
//Bit      28,       ecc_check_en                 unsigned, default = 0,  XX
//Bit      27,       rev_debug_en                 unsigned, default = 0,  XX
//Bit     26:16,     reserved
//Bit      15:0,     timeout_th                   unsigned, default = 0,  X
#define EARC_RX_CMDC_PACKET_CTRL4                  ((0x0016  << 2) + 0xfe333800)
//Bit      31,       ack_ignore                   unsigned, default = 0,  XX
//Bit      30,       cmdc_tail_check_mask         unsigned, default = 0,  XX
//Bit     29:20,     reserved
//Bit      19:0,     cmdc_packet_head             unsigned, default = 0,  XX
#define EARC_RX_CMDC_PACKET_CTRL5                  ((0x0017  << 2) + 0xfe333800)
//Bit     31:24,     rev_debug_mask               unsigned, default = 0,  XX
//Bit     23:20,     reserved
//Bit      19:0,     cmdc_packet_head_mask        unsigned, default = 0,  XX
#define EARC_RX_CMDC_PACKET_CTRL6                  ((0x0018  << 2) + 0xfe333800)
//Bit     31:20,     recv_pre_threshold          unsigned, default = 0,  packet control
//Bit      19:9,     reserved
//Bit         8,     rec_packet_d                 unsigned, default = 0,  XX
//Bit         7,     rec_parity_err_cnt		      unsigned, default = 0,  XX
//Bit         6,     rec_ecc_err_cnt		      unsigned, default = 0,  XX
//Bit         5,     rec_unexp_cnt			      unsigned, default = 0,  XX
//Bit         4,     rec_invalid_offset_cnt	      unsigned, default = 0,  XX
//Bit         3,     rec_invalid_id_cnt		      unsigned, default = 0,  XX
//Bit         2,     rec_timeout_cnt		      unsigned, default = 0,  XX
//Bit         1,     rec_w_cnt				      unsigned, default = 0,  XX
//Bit         0,     rec_r_cnt				      unsigned, default = 0,  X
#define EARC_RX_CMDC_BIPHASE_CTRL0                 ((0x0019  << 2) + 0xfe333800)
//Bit     31:24,     reg_tns                       unsigned, default = 7, xx
//Bit     23:16,     delay_th                      unsigned, default = 0, xx
//Bit     15:10,     reserved
//Bit         9,     send_ack_en                   unsigned, default = 0,  xx
//Bit         8,     sq_val_en                     unsigned, default = 0,  XX
//Bit         7,     biphase_send_soft_rst         unsigned, default = 0,  XX
//Bit         6,     comma_soft_rst                unsigned, default = 0,  XX
//Bit         5,     fifo_rst                      unsigned, default = 0,  XX
//Bit         4,     receiver_no_sender            unsigned, default = 0,  XX
//Bit         3,     sender_free                   unsigned, default = 0,  XX
//Bit         2,     receiver_send                 unsigned, default = 0,  XX
//Bit         1,     receiver_earc                 unsigned, default = 0,  XX
//Bit         0,     receiver_free                 unsigned, default = 0,  XX
#define EARC_RX_CMDC_BIPHASE_CTRL1                 ((0x001a  << 2) + 0xfe333800)
//Bit     31:16,     reserved
//Bit        15,     ack_val_en                      unsigned, default = 0,  send
//Bit      14:8,     reserved
//Bit       7:0,     width                        unsigned, default = 0,  send
#define EARC_RX_CMDC_BIPHASE_CTRL2                 ((0x001b  << 2) + 0xfe333800)
//Bit      31,        ack_val_en                  unsigned, default = 0,  send
//Bit      30:20,     reserved
//Bit       19:16,    ack_rate                   unsigned, default = 0,  comma send
//Bit       15:0,     width                         unsigned, default = 0,  comma sen
#define EARC_RX_CMDC_BIPHASE_CTRL3                 ((0x001c  << 2) + 0xfe333800)
//Bit      31:0,     biphase_ctrl3                 unsigned, default = 0,
#define EARC_RX_CMDC_DEVICE_ID_CTRL                ((0x001d  << 2) + 0xfe333800)
//Bit        31,     apb_write                     unsigned, default = 0, apb bus wr/read
//Bit        30,     apb_read                      unsigned, default = 0, apb bus wr/read
//Bit        29,     apb_w_r_done                  unsigned, default = 0, apb bus wr/read
//Bit        28,     apb_w_r_reset                 unsigned, default = 0, apb bus wr/read
//Bit     27:16,     reserved
//Bit      15:8,     apb_w_r_id                    unsigned, default = 0, apb bus wr/read
//Bit       7:0,     apb_w_r_start_addr            unsigned, default = 0, apb bus wr/read
#define EARC_RX_CMDC_DEVICE_WDATA                  ((0x001e  << 2) + 0xfe333800)
//Bit      31:8,     reserved
//Bit       7:0,     apb_write_data                unsigned, default = 0, apb bus wr/rea
#define EARC_RX_CMDC_DEVICE_RDATA                  ((0x001f  << 2) + 0xfe333800)
//Bit      31:8,     reserved
//Bit       7:0,     apb_read_data                 unsigned, default = 0, apb bus wr/rea
#define EARC_RX_ANA_CTRL0                          ((0x0020  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl0                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL1                          ((0x0021  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl1                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL2                          ((0x0022  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl2                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL3                          ((0x0023  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl3                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL4                          ((0x0024  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl4                     unsigned, default = 0,
#define EARC_RX_ANA_CTRL5                          ((0x0025  << 2) + 0xfe333800)
//Bit      31:0,     ana_ctrl5                     unsigned, default = 0,
#define EARC_RX_ANA_STAT0                          ((0x0026  << 2) + 0xfe333800)
//Bit      31:0,     ro_ANA_status0              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS0                       ((0x0027  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status0              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS1                       ((0x0028  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status1              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS2                       ((0x0029  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status2              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS3                       ((0x002a  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status3              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS4                       ((0x002b  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status4              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS5                       ((0x002c  << 2) + 0xfe333800)
//Bit      31:0,     ro_cmdc_status5              unsigned, RO, default = 0,
#define EARC_RX_CMDC_STATUS6                       ((0x002d  << 2) + 0xfe333800)
//Bit      31,         ro_idle2_int                unsigned, RO, dfault =0
//Bit      30,         ro_idle1_int                unsigned, RO, dfault =0
//Bit      29,         ro_disc2_int                unsigned, RO, dfault =0
//Bit      28,         ro_disc1_int                unsigned, RO, dfault =0
//Bit      27,         ro_earc_int                 unsigned, RO, dfault =0
//Bit      26,         ro_hb_status_int            unsigned, RO, dfault =0
//Bit      25,         ro_losthb_int               unsigned, RO, dfault =0
//Bit      24,         ro_timeout_int              unsigned, RO, dfault =0
//Bit      23,         ro_status_ch_int            unsigned, RO, dfault =0
//Bit      22,         ro_int_rec_invalid_id       unsigned, RO, dfault =0
//Bit      21,         ro_int_rec_invalid_offset   unsigned, RO, dfault =0
//Bit      20,         ro_int_rec_unexp            unsigned, RO, dfault =0
//Bit      19,         ro_int_rec_ecc_err          unsigned, RO, dfault =0
//Bit      18,         ro_int_rec_parity_err       unsigned, RO, dfault =0
//Bit      17,         ro_int_recv_packet          unsigned, RO, dfault =0
//Bit      16,         ro_int_rec_time_out         unsigned, RO, dfault =0
//Bit      15:0,       reserved
//
// Closing file:  ./earc_rx_cmdc.h
//
//========================================================================
//  AUDIO EARCRX_DMAC - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333c00
// -----------------------------------------------
//
// Reading file:  ./earcrx_dmac.h
//
#define EARCRX_DMAC_TOP_CTRL0                      ((0x0000  << 2) + 0xfe333c00)
//Bit   31,     reg_top_work_en               unsigned, default = 0, top work enable
//Bit   30,     reg_top_soft_rst              unsigned, default = 0, top soft reset
//Bit   29:23,  reserved
//Bit   22:20,  reg_dmac_debug_sel            unsigned, default = 0, dmac debug select
//Bit   19:18,  reserved
//Bit   17,     reg_dmac_valid_sel            unsigned, default = 0, dmac sync without clk
//Bit   16,     reg_dmac_without_clk          unsigned, default = 0, dmac sync without clk
//Bit   15,     reg_sf_sync_scan_reg          unsigned, default = 0, rst_n soft reset scan reg
//Bit   14,     reserved
//Bit   13,     reg_slow_sync_scan_reg        unsigned, default = 0, rst_n sync clk_slow scan reg
//Bit   12,     reg_a_sync_scan_reg           unsigned, default = 0, rst_n sync clk_analog scan reg
//Bit   11,     reg_slow_auto_gate            unsigned, default = 0, clk_slow auto gate
//Bit   10,     reg_a_auto_gate               unsigned, default = 0, clk_analog auto gate
//Bit   9:0,    reserved
#define EARCRX_DMAC_SYNC_CTRL0                     ((0x0001  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac sync module work enable
//Bit   30,     reg_rst_afifo_out_n           unsigned, default = 0, afifo out reset
//Bit   29,     reg_rst_afifo_in_n            unsigned, default = 0, afifo in reset
//Bit   28:17,  reserved
//Bit   16,     reg_ana_buf_data_sel_en       unsigned, default = 0, data from analog delay enable
//Bit   15,     reserved
//Bit   14:12,  reg_ana_buf_data_sel          unsigned, default = 0, delay cycles
//Bit   11,     reserved
//Bit   10:8,   reg_ana_clr_cnt               unsigned, default = 0, valid last how many 0 will clear
//Bit   7,      reserved
//Bit   6:4,    reg_ana_set_cnt               unsigned, default = 0, valid last how may 1 will set
//Bit   3:1,    reserved
//Bit   0,      reg_dmacin_phase              unsigned, default = 0, dmac data invert
#define EARCRX_DMAC_SYNC_STAT0                     ((0x0002  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat0           unsigned, default = 0
#define EARCRX_SPDIFIN_SAMPLE_CTRL0                ((0x0003  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, spdif in sample enable
//Bit   30,     reg_spdifin_phase             unsigned, default = 0, spdif in invert
//Bit   29,     reg_debug_en                  unsigned, default = 0, debug single enable
//Bit   28,     reg_width_sel                 unsigned, default = 0, 0 detect by max_width 1 detect by min_width
//Bit   27:23,  reserved
//Bit   22:20,  reg_sample_mode               unsigned, default = 0, value
//Bit   19:0,   reg_base_timer                unsigned, default = 0, base timer to detect sample mode change
#define EARCRX_SPDIFIN_SAMPLE_CTRL1                ((0x0004  << 2) + 0xfe333c00)
//Bit   31,     reg_force_sample_mode         unsigned, default = 0, 0 auto detect sample mode 1 force a fixed sample mode with reg_sample_mode
//Bit   30,     reserved
//Bit   29:20,  reg_sample_mode0_timer_th     unsigned, default = 0, mode0 threathold time
//Bit   19:10,  reg_sample_mode1_timer_th     unsigned, default = 0, mode1 threathold time
//Bit   9:0,    reg_sample_mode2_timer_th     unsigned, default = 0, mode2 threathold time
#define EARCRX_SPDIFIN_SAMPLE_CTRL2                ((0x0005  << 2) + 0xfe333c00)
//Bit   31:30,  reserved
//Bit   29:20,  reg_sample_mode3_timer_th     unsigned, default = 0, mode3 threathold time
//Bit   19:10,  reg_sample_mode4_timer_th     unsigned, default = 0, mode4 threathold time
//Bit   9:0,    reg_sample_mode5_timer_th     unsigned, default = 0, mode5 threathold time
#define EARCRX_SPDIFIN_SAMPLE_CTRL3                ((0x0006  << 2) + 0xfe333c00)
//Bit   31:24,  reg_sample_mode0_timer        unsigned, default = 0, mode0 sample time
//Bit   23:16,  reg_sample_mode1_timer        unsigned, default = 0, mode1 sample time
//Bit   15:8,   reg_sample_mode2_timer        unsigned, default = 0, mode2 sample time
//Bit   7:0,    reg_sample_mode3_timer        unsigned, default = 0, mode3 sample time
#define EARCRX_SPDIFIN_SAMPLE_CTRL4                ((0x0007  << 2) + 0xfe333c00)
//Bit   31:24,  reg_sample_mode4_timer        unsigned, default = 0, mode4 sample time
//Bit   23:16,  reg_sample_mode5_timer        unsigned, default = 0, mode5 sample time
//Bit   15:8,   reg_sample_mode6_timer        unsigned, default = 0, mode6 sample time
//Bit   7:0,    reserved
#define EARCRX_SPDIFIN_SAMPLE_CTRL5                ((0x0008  << 2) + 0xfe333c00)
//Bit   31,     reg_sq_filt_en                unsigned, default = 0, dmac_sqout filter enable
//Bit   30,     reg_spdif_sqout_phase         unsigned, default = 0, dmac_sqout invert
//Bit   29:27,  reg_filter_tick_sel           unsigned, default = 0, dmac_sqout filter tick select
//Bit   26:24,  reg_filter_sel                unsigned, default = 0, dmac_sqout filter select
//Bit   23:20,  reserved
//Bit   19:0,   reg_sq_filt_timer             unsigned, default = 0, dmac_sqout filter tick
#define EARCRX_SPDIFIN_SAMPLE_STAT0                ((0x0009  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_sample_stat0      unsigned, default = 0
#define EARCRX_SPDIFIN_SAMPLE_STAT1                ((0x000a  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_sample_stat1      unsigned, default = 0
#define EARCRX_SPDIFIN_MUTE_VAL                    ((0x000b  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_mute_val          unsigned, default = 0, spdif in mute value
#define EARCRX_SPDIFIN_CTRL0                       ((0x000c  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, spdifin wore enable
//Bit   30,     reg_chnum_sel                 unsigned, default = 0, 0 ch_num = 0~383  1 ch_num = 0~1
//Bit   29:28,  reserved
//Bit   27,     reg_debug_en                  unsigned, default = 0, debug enable
//Bit   26,     reg_chnum_en                  unsigned, default = 0, star add ch_cnt to ch_num
//Bit   25,     reg_findpapb_en               unsigned, default = 0, papb check enalbe
//Bit   24,     reg_nonpcm2pcm_en             unsigned, default = 0, nonpcm2pcm_th enable
//Bit   23:12,  reg_nonpcm2pcm_th             unsigned, default = 0, if long time didn't detect PaPb again,will generate irq
//Bit   11:8,   reg_ch_status_sel             unsigned, default = 0, for stat1/stat2
//Bit   7,      reg_mute_l                    unsigned, default = 0, mute channel l
//Bit   6,      reg_mute_r                    unsigned, default = 0, mute channel r
//Bit   5:4,    reserved
//Bit   3,      reg_check_valid               unsigned, default = 0, valid check enable
//Bit   2,      reg_check_parity              unsigned, default = 0, parity check enable
//Bit   1,      reg_invert_data               unsigned, default = 0, spdif data invert
//Bit   0,      reserved
#define EARCRX_SPDIFIN_CTRL1                       ((0x000d  << 2) + 0xfe333c00)
//Bit   31:24,  reserved
//Bit   31:24,  reg_clr_internal_sts          unsigned, default = 0, internal irq status clear
//Bit   23:12,  reg_mute_block_check_thd      unsigned, default = 0, mute block check time thd
//Bit   11:9,   reg_mute_block_check_tick_sel unsigned, default = 0, mute block check tick sel
//Bit   8,      reg_papb_ext_sync             unsigned, default = 0, ext 0 sync check for papb
//Bit   7:0,    reg_papb_ext_mask             unsigned, default = 0, sync 0 mask
#define EARCRX_SPDIFIN_CTRL2                       ((0x000e  << 2) + 0xfe333c00)
//Bit   31:24,  reg_mute_bit                   unsigned, default = 0, mute bit in channel st
//Bit   23:19,  reg_mute_block_num             unsigned, default = 0, mute min block number to declare
//Bit   18,     reg_mute_lr_ch_sel             unsigned, default = 0, mute bit in channel st L or R
//Bit   17,     reg_mute_block_check_en        unsigned, default = 0, mute block number check enable
//Bit   16,     reg_earc_cps_chst_clr_en       unsigned, default = 0, auto clear compress mode when channel status not compress
//Bit   15,     reg_earc_cps_nonpcm2pcm_clr_en unsigned, default = 0, auto clear compress mode when nonpcm2pcm
//Bit   14,     reg_earc_auto                  unsigned, default = 0, auto change earc/arc
//Bit   13,     reg_earcin_papb_lr             unsigned, default = 0, user l or r channle status to check papb
//Bit   12,     reg_earcin_check_papb          unsigned, default = 0, 0:data valid after 1 block;1: in 1st block if exit papb ,data valid after papb
//Bit   11,     reg_earcin_start_papb          unsigned, default = 0, start write toddr 1:from papb check,0 from preamble Z,valid when reg_earcin_check_papb set
//Bit   10,     reg_formatchange_auto_rst      unsigned, default = 0, auto reset will detect format change
//Bit   9,      reg_earcin_cpsb_pcpd_sel      unsigned, default = 0, compress B pcpd select : 1:next 4th subframe data 0:next sub frame data
//Bit   8:4,    reg_earc_papb_msb             unsigned, default = 0, papb msb position in data
//Bit   3,      reg_earcin_spdif_force        unsigned, default = 0, when in arc mode,spdif on force enable
//Bit   2,      reg_earcin_spdif_force_set    unsigned, default = 0, force value
//Bit   1,      reg_earcin_mode_force         unsigned, default = 0, earc mode force enable
//Bit   0,      reg_earcin_mode_force_set     unsigned, default = 0, force value
#define EARCRX_SPDIFIN_CTRL3                       ((0x000f  << 2) + 0xfe333c00)
//Bit   31:16,  reg_earc_pa_value             unsigned, default = 0, earc mode pa value
//Bit   15:0,   reg_earc_pb_value             unsigned, default = 0, earc mode pb value
#define EARCRX_SPDIFIN_STAT0                       ((0x0010  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat0             unsigned, default = 0
#define EARCRX_SPDIFIN_STAT1                       ((0x0011  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat1             unsigned, default = 0
#define EARCRX_SPDIFIN_STAT2                       ((0x0012  << 2) + 0xfe333c00)
//Bit   31:0,   reg_spdifin_stat2             unsigned, default = 0
#define EARCRX_DMAC_UBIT_CTRL0                     ((0x0013  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, dmac user bit decode enable
//Bit   30:24,  reg_iu_sync                   unsigned, default = 0, iu sync value
//Bit   23:16,  reg_fifo_thd                  unsigned, default = 0, generate irq when fifo level pass some threshold
//Bit   15,     reg_max_dist_en               unsigned, default = 0, max distance bewteen IUs to set lost
//Bit   14,     reg_iu_sync_en                unsigned, default = 0, iu sync code enable 0 : all iu to fifo 1 only sync iu packet to fifo
//Bit   13:12,  reg_user_lr                   unsigned, default = 0, 00 off 01 use l channel userbit 10 use r channel userbit 11 user lr channel userbit
//Bit   11:8,   reg_max_dist                  unsigned, default = 0, max distance bewteen IUs value
//Bit   7,      reg_fifo_thd_en               unsigned, default = 0, fifo_thd irq enable
//Bit   6,      reg_fifo_lost_init_en         unsigned, default = 0, when lost,initial fifo
//Bit   5,      reg_fifo_init                 unsigned, default = 0, fifo initial
//Bit   4:0,    reg_data_bit                  unsigned, default = 0, user bit position in data
#define EARCRX_IU_RDATA                            ((0x0014  << 2) + 0xfe333c00)
//Bit   31:8,   reserved
//Bit   7:0,    i_iu_rdata                    unsigned, default = 0, iu data,read only
#define EARCRX_DMAC_UBIT_STAT0                     ((0x0015  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_ubit_stat0           unsigned, default = 0
#define EARCRX_ERR_CORRECT_CTRL0                   ((0x0016  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, err correct work enable
//Bit   30,     reserved
//Bit   29,     reg_rst_afifo_out_n           unsigned, default = 0, reset afifo out side
//Bit   28,     reg_rst_afifo_in_n            unsigned, default = 0, reset afifo in side
//Bit   27,     reg_lr_check                  unsigned, default = 0, enable lr_check
//Bit   26:7,   reserved
//Bit   6,      reg_bchout_data_ml            unsigned, default = 0, bch output 16bit data msb is 27 or 19
//Bit   5,      reg_bchout_data_rsv           unsigned, default = 0, bch output data revers
//Bit   4,      reg_bchin_ecc_ml              unsigned, default = 0, bch input ecc msb/lsb
//Bit   3,      reg_bchin_ecc_rsv             unsigned, default = 0, bch input ecc revers
//Bit   2,      reg_bchin_data_rsv            unsigned, default = 0, bch input data revers
//Bit   1,      reg_force_set                 unsigned, default = 0, 0 off 1 compress audio mode
//Bit   0,      reg_force_en                  unsigned, default = 0, force work mode enable
#define EARCRX_ERR_CORRECT_STAT0                   ((0x0017  << 2) + 0xfe333c00)
//Bit   31:0,   reg_err_correct_stat0         unsigned, default = 0
#define EARCRX_ANA_RST_CTRL0                       ((0x0018  << 2) + 0xfe333c00)
//Bit   31,     reg_work_enable               unsigned, default = 0, analog reset check work enable
//Bit   30,     reg_ana_rst_sf_en             unsigned, default = 0, analog reset from register enable
//Bit   29,     reg_ana_rst_sf                unsigned, default = 0, soft reset value
//Bit   28,     reserved
//Bit   27:23,  reg_new_format_pos_num        unsigned, default = 0, when new format data in, hold reset after N posedge
//Bit   22:20,  reg_dmacrx_div2_thd_tick_sel  unsigned, default = 0, earcrx_div2 hold threshold tick select
//Bit   19:0,   reg_earcrx_div2_thd           unsigned, default = 0, earcrx_div2 hold threshold
#define EARCRX_ANA_RST_CTRL1                       ((0x0019  << 2) + 0xfe333c00)
//Bit   31,     reg_dmacrx_data_filt_en       unsigned, default = 0, filter enable
//Bit   30:28,  reg_dmacrx_data_filter_sel    unsigned, default = 0, filter select
//Bit   27:25,  reg_dmacrx_data_tick_sel      unsigned, default = 0, filter tick sel
//Bit   24:16,  reg_dmacrx_data_time          unsigned, default = 0, filter tick time
//Bit   15,     reg_dmacrx_sqout_filt_en      unsigned, default = 0, filter enable
//Bit   14:12,  reg_dmacrx_sqout_filter_sel   unsigned, default = 0, filter select
//Bit   11:9,   reg_dmacrx_sqout_tick_sel     unsigned, default = 0, filter tick sel
//Bit   8:0,    reg_dmacrx_sqout_time         unsigned, default = 0, filter tick time
#define EARCRX_SPDIFIN_CTRL4                       ((0x0020  << 2) + 0xfe333c00)
//Bit   31,     reserved
//Bit   30,     reg_add_ch_r                        unsigned, default = 0, reg_add_ch_r
//Bit   29,     reg_bc_val0_en                      unsigned, default = 0, reg_bc_val0_en
//Bit   28:20,  reg_stable_mask                     unsigned, default = 0, reg_stable_mask
//Bit   19:16,  reg_stable_zcnt                     unsigned, default = 0, reg_stable_zcnt
//Bit   15:0 ,  reserved
#define EARCRX_SPDIFIN_CTRL5                       ((0x0021  << 2) + 0xfe333c00)
//Bit   31,     reg_st_timeout_sts_clr              unsigned, default = 0, reg_st_timeout_sts_clr
//Bit   30:28,  reserved
//Bit   27:16,  reg_st_timeout_check_thd            unsigned, default = 0, reg_st_timeout_check_thd
//Bit   15,     reserved
//Bit   14:12,  reg_st_timeout_check_tick_sel       unsigned, default = 0, reg_st_timeout_check_tick_sel
//Bit   11,     reg_st_timeout_check_en             unsigned, default = 0, reg_st_timeout_check_en
//Bit   10:9,   reserved
//Bit   8:0,    reg_stable_int_mask                 unsigned, default = 0, reg_stable_int_mask
#define EARCRX_SPDIFIN_CTRL6                       ((0x0022  << 2) + 0xfe333c00)
//Bit   31:17,  reserved
//Bit   16,     reg_check_time_en                   unsigned, default = 0, reg_check_time_en
//Bit   15:0,   reg_check_time_thd                  unsigned, default = 0, reg_check_time_thd
#define EARCRX_DMAC_SYNC_CTRL1                     ((0x0023  << 2) + 0xfe333c00)
//Bit   31:19,  reserved
//Bit   18,     reg_auto_neg_int_en                 unsigned, default = 0, reg_auto_neg_int_en
//Bit   17,     reg_auto_stable_clr                 unsigned, default = 0, reg_auto_stable_clr
//Bit   16,     reg_auto_stable_en                  unsigned, default = 0, reg_auto_stable_en
//Bit   15:0,   reg_auto_stable_thd                 unsigned, default = 0, reg_auto_stable_thd
#define EARCRX_SPDIFIN_SAMPLE_CTRL6                ((0x0024  << 2) + 0xfe333c00)
//Bit   31:18,  reserved
//Bit   17,     reg_hold_tri_sample                 unsigned, default = 0, reg_hold_tri_sample
//Bit   16,     reg_sample_mode_filter_en           unsigned, default = 0, reg_sample_mode_filter_en
//Bit   15:8,   reg_stable_cyc_min                  unsigned, default = 0, reg_stable_cyc_min
//Bit   7:0,    reg_stable_cyc_max                  unsigned, default = 0, reg_stable_cyc_max
#define EARCRX_DMAC_SYNC_CTRL2                     ((0x0025  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t0_err_clr             unsigned, default = 0, reg_unstable_t0_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t0_check_en            unsigned, default = 0, reg_unstable_t0_check_en
//Bit   18:16,  reg_unstable_t0_tick_sel            unsigned, default = 0, reg_unstable_t0_tick_sel
//Bit   15:0,   reg_unstable_t0_thd                 unsigned, default = 0, reg_unstable_t0_thd
#define EARCRX_DMAC_SYNC_CTRL3                     ((0x0026  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t1_err_clr             unsigned, default = 0, reg_unstable_t1_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t1_check_en            unsigned, default = 0, reg_unstable_t1_check_en
//Bit   18:16,  reg_unstable_t1_tick_sel            unsigned, default = 0, reg_unstable_t1_tick_sel
//Bit   15:0,   reg_unstable_t1_thd                 unsigned, default = 0, reg_unstable_t1_thd
#define EARCRX_DMAC_SYNC_CTRL4                     ((0x0027  << 2) + 0xfe333c00)
//Bit   31,     reg_unstable_t2_err_clr             unsigned, default = 0, reg_unstable_t2_err_clr
//Bit   30:20,  reserved
//Bit   19,     reg_unstable_t2_check_en            unsigned, default = 0, reg_unstable_t2_check_en
//Bit   18:16,  reg_unstable_t2_tick_sel            unsigned, default = 0, reg_unstable_t2_tick_sel
//Bit   15:0,   reg_unstable_t2_thd                 unsigned, default = 0, reg_unstable_t2_thd
#define EARCRX_DMAC_SYNC_STAT1                     ((0x0028  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat1           unsigned, default = 0
#define EARCRX_DMAC_SYNC_STAT2                     ((0x0029  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat2           unsigned, default = 0
#define EARCRX_DMAC_SYNC_STAT3                     ((0x002a  << 2) + 0xfe333c00)
//Bit   31:0,   reg_dmac_sync_stat3           unsigned, default = 0
//
// Closing file:  ./earcrx_dmac.h
//
//========================================================================
//  AUDIO EARCRX_TOP  - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe333e00
// -----------------------------------------------
//
// Reading file:  ./earcrx_top.h
//
#define EARCRX_TOP_CTRL0                           ((0x0000  << 2) + 0xfe333e00)
//Bit   31:10,  reserved
//Bit   9:8,    reg_top_debug_sel             unsigned, default = 0, top debug select
//Bit   7,      reg_spdif_rx_en_force         unsigned, default = 0, force spdif_rx_en to reg_spdif_rx_en_force_value
//Bit   6,      reg_spdif_rx_en_force_value   unsigned, default = 0, value
//Bit   5,      reg_spdif_rx_sqen_force       unsigned, default = 0, force spdif_rx_sqen to reg_spdif_rx_sqe
//Bit   4,      reg_spdif_rx_sqen_force_value unsigned, default = 0, value
//Bit   3,      reg_dmacrx_en_force           unsigned, default = 0, force dmacrx_en to reg_dmacrx_en_force_value
//Bit   2,      reg_dmacrx_en_force_value     unsigned, default = 0, value
//Bit   1,      reg_dmacrx_sqen_force         unsigned, default = 0, force dmacrx_sqen to reg_dmacrx_sqen_force_value
//Bit   0,      reg_dmacrx_sqen_force_value   unsigned, default = 0, value
#define EARCRX_DMAC_INT_MASK                       ((0x0001  << 2) + 0xfe333e00)
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int mask
#define EARCRX_DMAC_INT_PENDING                    ((0x0002  << 2) + 0xfe333e00)
//Bit   31:30,  reserved
//Bit   29:0,   reg_dmac_int_mask             unsigned, default = 0, dmac int pending,read only
#define EARCRX_CMDC_INT_MASK                       ((0x0003  << 2) + 0xfe333e00)
//Bit   31:16,  reserved
//Bit   15:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int mask
#define EARCRX_CMDC_INT_PENDING                    ((0x0004  << 2) + 0xfe333e00)
//Bit   31:18,  reserved
//Bit   17:0,   reg_cmdc_int_mask             unsigned, default = 0, cmdc int pending,read only
#define EARCRX_ANA_CTRL0                           ((0x0005  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_ANA_CTRL1                           ((0x0006  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_ANA_STAT0                           ((0x0007  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL0                           ((0x0008  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL1                           ((0x0009  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL2                           ((0x000a  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_CTRL3                           ((0x000b  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
#define EARCRX_PLL_STAT0                           ((0x000c  << 2) + 0xfe333e00)
//Bit   31:0,   reg_earcrx_ana_ctrl0          unsigned, default = 0
//
// Closing file:  ./earcrx_top.h
//
//========================================================================
//  AUDIO RESAMPLEB - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe334000
// -----------------------------------------------
//
// Reading file:  ./RESAMPLEB.h
//
#define AUDIO_RSAMPB_CTRL0                         ((0x0000  << 2) + 0xfe334000)
//Bit   31:3      reserved
//Bit   2         reg_lock_rst      //unsigned  , default =0;
//Bit   1         reg_rsamp_rst     //unsigned  , default =0;
//Bit   0         reg_sw_rst        //unsigned  , default =0;
#define AUDIO_RSAMPB_CTRL1                         ((0x0001  << 2) + 0xfe334000)
//Bit   31:27      reserved          //unsigned  , default =0;
//Bit   26         reg_watchdog_en   //unsigned  , default =0;
//Bit   25         reg_rsamp_rst_sel //unsigned  , default =0;
//Bit   24         reg_module_bypas  //unsigned  , default =0;
//Bit   23:18      reg_gclk_ctrl     //unsigned  , default =0;
//Bit   17:13      reg_in_msb        //unsigned  , default =23;
//Bit   12         reg_output_en     //unsigned  , default =0;
//Bit   11         reg_rsamp_en      //unsigned  , default =0;
//Bit   10         reg_filt_en       //unsigned  , default =0;
//Bit   9          reg_post_en       //unsigned  , default =0;
//Bit   8          reg_inp_mux_mode  //unsigned  , default =0;
//Bit   7:4        reserved          //unsigned  , default =2;
//Bit   3:0        reg_inp_mux       //unsigned  , default =0;
#define AUDIO_RSAMPB_CTRL2                         ((0x0002  << 2) + 0xfe334000)
//Bit 31:30    reserved              //unsigned  , default =0;
//Bit 29:24    reg_chx_size          //unsigned  , default =2;
//Bit 23:18    reserved              //unsigned  , default =0;
//Bit 17:16    reg_scl_step          //unsigned  , default =0; 0: 1/1  1: 1/2  2: 1/4
//Bit 15:8     reg_filt_tap          //unsigned  , default =63;
//Bit 7:0      reg_intp_tap          //unsigned  , default =63;
#define AUDIO_RSAMPB_PHSINIT                       ((0x0003  << 2) + 0xfe334000)
//Bit   31:28      reserved          //unsigned  , default = 0;
//Bit   27:0       reg_init_phs      //unsigned  , default = 0;
#define AUDIO_RSAMPB_PHSSTEP                       ((0x0004  << 2) + 0xfe334000)
//Bit   31         reserved          //unsigned  , default = 0;
//Bit   30:0       reg_rsamp_step    //unsigned  , default = 134217728;//'h800_0000
#define AUDIO_RSAMPB_SHIFT                         ((0x0005  << 2) + 0xfe334000)
//Bit   31:24       reg_rsft_iir    //unsigned  , default = 23;
//Bit   23:16       reg_rsft_blnd   //unsigned  , default = 21;
//Bit   15:8        reg_rsft_sinc   //unsigned  , default = 31;
//Bit   7:0         reg_rsft_aa     //unsigned  , default = 31;
#define AUDIO_RSAMPB_ADJ_CTRL0                     ((0x0006  << 2) + 0xfe334000)
//Bit   31:3        reserved                //unsigned
//Bit   2           reg_rsamp_adj_out_inv   //unsigned , default = 0;
//Bit   1           reg_rsamp_adj_force_en  //unsigned , default = 0;
//Bit   0           reg_rsamp_adj_en        //unsigned , default = 0;
#define AUDIO_RSAMPB_ADJ_CTRL1                     ((0x0007  << 2) + 0xfe334000)
//Bit   31:16       reg_rsamp_adj_odet_step     //unsigned , default = 8;
//Bit   15:0        reg_rsamp_adj_kmax          //unsigned , default = 32768;
#define AUDIO_RSAMPB_ADJ_SFT                       ((0x0008  << 2) + 0xfe334000)
//Bit   31:30       reserved                //unsigned , default = 0;
//Bit   29          reg_rsamp_adj_dif_sel   //unsigned , default = 0;
//Bit   28:24       reg_rsamp_adj_ki        //unsigned , default = 9;
//Bit   23:21       reserved                //unsigned , default = 0;
//Bit   20:16       reg_rsamp_adj_kp        //unsigned , default = 1;
//Bit   15:13       reserved                //unsigned , default = 0;
//Bit   12:8        reg_rsamp_adj_ki_sft    //unsigned , default = 6;
//Bit   7:6         reserved                //unsigned , default = 0;
//Bit   5:0         reg_rsamp_adj_out_sft   //unsigned , default = 12;
#define AUDIO_RSAMPB_ADJ_IDET_LEN                  ((0x0009  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_idet_len       //unsigned , default = 10000;
#define AUDIO_RSAMPB_ADJ_FORCE                     ((0x000a  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_force_err      //signed , default = 8;
#define AUDIO_RSAMPB_ADJ_KI_FORCE                  ((0x000b  << 2) + 0xfe334000)
//Bit   31:0       reg_rsamp_adj_ki_force //signed , default = 0;
#define AUDIO_RSAMPB_WATCHDOG_THRD                 ((0x000c  << 2) + 0xfe334000)
//Bit   31:0       reg_watchdog_thrd      //signed , default = 32'h1000;
#define AUDIO_RSAMPB_RO_STATUS                     ((0x0010  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_stat  //{din_chx_chk_err,is_idle_st,rsamp_fifo_over_cnt[7:0]}
#define AUDIO_RSAMPB_RO_ADJ_FREQ                   ((0x0011  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_adj_freq
#define AUDIO_RSAMPB_RO_ADJ_DIFF_BAK               ((0x0012  << 2) + 0xfe334000)
//Bit   31:0       ro_det_diff_bak
#define AUDIO_RSAMPB_RO_ADJ_DIFF_DLT               ((0x0013  << 2) + 0xfe334000)
//Bit   31:0       ro_det_diff_dlt
#define AUDIO_RSAMPB_RO_ADJ_PHS_ERR                ((0x0014  << 2) + 0xfe334000)
//Bit   31:0       ro_det_phase_err
#define AUDIO_RSAMPB_RO_ADJ_KI_OUT                 ((0x0015  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_ki_out
#define AUDIO_RSAMPB_RO_IN_CNT                     ((0x0016  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_in_cnt
#define AUDIO_RSAMPB_RO_OUT_CNT                    ((0x0017  << 2) + 0xfe334000)
//Bit   31:0       ro_rsamp_out_cnt
#define AUDIO_RSAMPB_RO_ADJ_PHS_ERR_VAR            ((0x0018  << 2) + 0xfe334000)
//Bit   31:0       ro_det_phase_err_var
#define AUDIO_RSAMPB_POST_COEF0                    ((0x0020  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef0 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF1                    ((0x0021  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef1 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF2                    ((0x0022  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef2 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF3                    ((0x0023  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef3 //signed  , default = 0;
#define AUDIO_RSAMPB_POST_COEF4                    ((0x0024  << 2) + 0xfe334000)
//Bit   31:0       reg_post_coef4 //signed  , default = 0;
#define AUDIO_RSAMPB_AA_COEF_ADDR                  ((0x0030  << 2) + 0xfe334000)
//Bit   31:0       reg_aa_coef_addr     //unsigned, default = 0;
#define AUDIO_RSAMPB_AA_COEF_DATA                  ((0x0031  << 2) + 0xfe334000)
//Bit   31:0       reg_aa_coef_data     //signed  , default = 0;
#define AUDIO_RSAMPB_SINC_COEF_ADDR                ((0x0040  << 2) + 0xfe334000)
//Bit   31:0       reg_sinc_coef_addr   //unsigned, default = 0;
#define AUDIO_RSAMPB_SINC_COEF_DATA                ((0x0041  << 2) + 0xfe334000)
//Bit   31:0       reg_sinc_coef_data   //signed  , default = 0;
//
// Closing file:  ./RESAMPLEB.h
//
//========================================================================
//  AUDIO TOP_VAD - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  APB0_BASE_ADDR = 0xfe334c00
// -----------------------------------------------
#define EE_AUDIO2_CLK81_CTRL                       ((0x0000  << 2) + 0xfe334c00)
#define EE_AUDIO2_CLK81_EN                         ((0x0001  << 2) + 0xfe334c00)
#define EE_AUDIO2_SW_RESET0                        ((0x0002  << 2) + 0xfe334c00)
#define EE_AUDIO2_CLK_GATE_EN0                     ((0x0003  << 2) + 0xfe334c00)
#define EE_AUDIO2_SECURITY_CTRL0                   ((0x0004  << 2) + 0xfe334c00)
#define EE_AUDIO2_SECURITY_CTRL1                   ((0x0005  << 2) + 0xfe334c00)
#define EE_AUDIO2_MCLK_VAD_CTRL                    ((0x0010  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_CLK_CTRL                     ((0x0011  << 2) + 0xfe334c00)
#define EE_AUDIO2_MST_DLY_CTRL0                    ((0x0012  << 2) + 0xfe334c00)
#define EE_AUDIO2_MST_VAD_SCLK_CTRL0               ((0x0013  << 2) + 0xfe334c00)
#define EE_AUDIO2_MST_VAD_SCLK_CTRL1               ((0x0014  << 2) + 0xfe334c00)
#define EE_AUDIO2_CLK_TDMIN_VAD_CTRL               ((0x0015  << 2) + 0xfe334c00)
#define EE_AUDIO2_CLK_PDMIN_CTRL0                  ((0x0016  << 2) + 0xfe334c00)
#define EE_AUDIO2_CLK_PDMIN_CTRL1                  ((0x0017  << 2) + 0xfe334c00)
#define EE_AUDIO2_AUD_VAD_PAD_CTRL0                ((0x0018  << 2) + 0xfe334c00)
#define EE_AUDIO2_TOVAD_CTRL0                      ((0x0020  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CTRL0                  ((0x0030  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CTRL1                  ((0x0031  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CTRL2                  ((0x0032  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_START_ADDR             ((0x0033  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_INIT_ADDR              ((0x0034  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_FINISH_ADDR            ((0x0035  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_START_ADDRB            ((0x0036  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_FINISH_ADDRB           ((0x0037  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_INT_ADDR               ((0x0038  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_STATUS1                ((0x0039  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_STATUS2                ((0x003a  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_CTRL                   ((0x0040  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_SWAP0                  ((0x0041  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_SWAP1                  ((0x0042  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE_VAL               ((0x0043  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_STAT                   ((0x0044  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE0                  ((0x0050  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE1                  ((0x0051  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE2                  ((0x0052  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE3                  ((0x0053  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE4                  ((0x0054  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE5                  ((0x0055  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE6                  ((0x0056  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MUTE7                  ((0x0057  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK0                  ((0x0058  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK1                  ((0x0059  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK2                  ((0x005a  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK3                  ((0x005b  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK4                  ((0x005c  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK5                  ((0x005d  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK6                  ((0x005e  << 2) + 0xfe334c00)
#define EE_AUDIO2_TDMIN_VAD_MASK7                  ((0x005f  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_DAT_PAD_CTRL0                ((0x0060  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_DAT_PAD_CTRL1                ((0x0061  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID0              ((0x0070  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID1              ((0x0071  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID2              ((0x0072  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID3              ((0x0073  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID4              ((0x0074  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID5              ((0x0075  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID6              ((0x0076  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHNUM_ID7              ((0x0077  << 2) + 0xfe334c00)
#define EE_AUDIO2_TODDR_VAD_CHSYNC_CTRL            ((0x007f  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_AM2AXI_CTRL0                 ((0x0080  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_AXIWR_ASYNC_CTRL0            ((0x0081  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_AM2AXI_STAT                  ((0x0088  << 2) + 0xfe334c00)
#define EE_AUDIO2_VAD_AXIWR_ASYNC_STAT             ((0x0089  << 2) + 0xfe334c00)
#define EE_AUDIO2_EXCEPTION_IRQ_STS0               ((0x0090  << 2) + 0xfe334c00)
#define EE_AUDIO2_EXCEPTION_IRQ_MASK0              ((0x0091  << 2) + 0xfe334c00)
#define EE_AUDIO2_EXCEPTION_IRQ_MODE0              ((0x0092  << 2) + 0xfe334c00)
#define EE_AUDIO2_EXCEPTION_IRQ_CLR0               ((0x0093  << 2) + 0xfe334c00)
#define EE_AUDIO2_EXCEPTION_IRQ_INV0               ((0x0094  << 2) + 0xfe334c00)
//
// Closing file:  ./REG_LIST_AUDIO_RTL.h
//
//`include "REG_LIST_DSP_RTL.h"
//
// Reading file:  ./REG_LIST_SECURITY_RTL.h
//
//
//***************************************************************************
// Title:      REG_LIST_SECURITY_RTL.h
//
// Author:     shan.luan
//
// Created:    23:09:44 28/02/2020
//
// Description:
//
// Note:
//
// History:
//
//***************************************************************************
//========================================================================
//  TS_DEMUX_REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe444000
// -----------------------------------------------
#define RCH_READY_CHANNEL_0                        ((0x0000  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_1                        ((0x0008  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_2                        ((0x0010  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_3                        ((0x0018  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_4                        ((0x0020  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_5                        ((0x0028  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_6                        ((0x0030  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_7                        ((0x0038  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_8                        ((0x0040  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_9                        ((0x0048  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_10                       ((0x0050  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_11                       ((0x0058  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_12                       ((0x0060  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_13                       ((0x0068  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_14                       ((0x0070  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_15                       ((0x0078  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_16                       ((0x0080  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_17                       ((0x0088  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_18                       ((0x0090  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_19                       ((0x0098  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_20                       ((0x00a0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_21                       ((0x00a8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_22                       ((0x00b0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_23                       ((0x00b8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_24                       ((0x00c0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_25                       ((0x00c8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_26                       ((0x00d0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_27                       ((0x00d8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_28                       ((0x00e0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_29                       ((0x00e8  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_30                       ((0x00f0  << 2) + 0xfe444000)
#define RCH_READY_CHANNEL_31                       ((0x00f8  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_0                       ((0x0001  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_1                       ((0x0009  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_2                       ((0x0011  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_3                       ((0x0019  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_4                       ((0x0021  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_5                       ((0x0029  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_6                       ((0x0031  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_7                       ((0x0039  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_8                       ((0x0041  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_9                       ((0x0049  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_10                      ((0x0051  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_11                      ((0x0059  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_12                      ((0x0061  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_13                      ((0x0069  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_14                      ((0x0071  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_15                      ((0x0079  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_16                      ((0x0081  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_17                      ((0x0089  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_18                      ((0x0091  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_19                      ((0x0099  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_20                      ((0x00a1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_21                      ((0x00a9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_22                      ((0x00b1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_23                      ((0x00b9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_24                      ((0x00c1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_25                      ((0x00c9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_26                      ((0x00d1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_27                      ((0x00d9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_28                      ((0x00e1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_29                      ((0x00e9  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_30                      ((0x00f1  << 2) + 0xfe444000)
#define RCH_STATUS_CHANNEL_31                      ((0x00f9  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_0                          ((0x0002  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_1                          ((0x000a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_2                          ((0x0012  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_3                          ((0x001a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_4                          ((0x0022  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_5                          ((0x002a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_6                          ((0x0032  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_7                          ((0x003a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_8                          ((0x0042  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_9                          ((0x004a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_10                         ((0x0052  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_11                         ((0x005a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_12                         ((0x0062  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_13                         ((0x006a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_14                         ((0x0072  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_15                         ((0x007a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_16                         ((0x0082  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_17                         ((0x008a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_18                         ((0x0092  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_19                         ((0x009a  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_20                         ((0x00a2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_21                         ((0x00aa  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_22                         ((0x00b2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_23                         ((0x00ba  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_24                         ((0x00c2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_25                         ((0x00ca  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_26                         ((0x00d2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_27                         ((0x00da  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_28                         ((0x00e2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_29                         ((0x00ea  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_30                         ((0x00f2  << 2) + 0xfe444000)
#define RCH_CFG_CHANNEL_31                         ((0x00fa  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_0                         ((0x0003  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_1                         ((0x000b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_2                         ((0x0013  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_3                         ((0x001b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_4                         ((0x0023  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_5                         ((0x002b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_6                         ((0x0033  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_7                         ((0x003b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_8                         ((0x0043  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_9                         ((0x004b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_10                        ((0x0053  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_11                        ((0x005b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_12                        ((0x0063  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_13                        ((0x006b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_14                        ((0x0073  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_15                        ((0x007b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_16                        ((0x0083  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_17                        ((0x008b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_18                        ((0x0093  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_19                        ((0x009b  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_20                        ((0x00a3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_21                        ((0x00ab  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_22                        ((0x00b3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_23                        ((0x00bb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_24                        ((0x00c3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_25                        ((0x00cb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_26                        ((0x00d3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_27                        ((0x00db  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_28                        ((0x00e3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_29                        ((0x00eb  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_30                        ((0x00f3  << 2) + 0xfe444000)
#define RCH_ADDR_CHANNEL_31                        ((0x00fb  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_0                          ((0x0004  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_1                          ((0x000c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_2                          ((0x0014  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_3                          ((0x001c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_4                          ((0x0024  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_5                          ((0x002c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_6                          ((0x0034  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_7                          ((0x003c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_8                          ((0x0044  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_9                          ((0x004c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_10                         ((0x0054  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_11                         ((0x005c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_12                         ((0x0064  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_13                         ((0x006c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_14                         ((0x0074  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_15                         ((0x007c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_16                         ((0x0084  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_17                         ((0x008c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_18                         ((0x0094  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_19                         ((0x009c  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_20                         ((0x00a4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_21                         ((0x00ac  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_22                         ((0x00b4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_23                         ((0x00bc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_24                         ((0x00c4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_25                         ((0x00cc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_26                         ((0x00d4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_27                         ((0x00dc  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_28                         ((0x00e4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_29                         ((0x00ec  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_30                         ((0x00f4  << 2) + 0xfe444000)
#define RCH_LEN_CHANNEL_31                         ((0x00fc  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_0                       ((0x0005  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_1                       ((0x000d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_2                       ((0x0015  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_3                       ((0x001d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_4                       ((0x0025  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_5                       ((0x002d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_6                       ((0x0035  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_7                       ((0x003d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_8                       ((0x0045  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_9                       ((0x004d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_10                      ((0x0055  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_11                      ((0x005d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_12                      ((0x0065  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_13                      ((0x006d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_14                      ((0x0075  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_15                      ((0x007d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_16                      ((0x0085  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_17                      ((0x008d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_18                      ((0x0095  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_19                      ((0x009d  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_20                      ((0x00a5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_21                      ((0x00ad  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_22                      ((0x00b5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_23                      ((0x00bd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_24                      ((0x00c5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_25                      ((0x00cd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_26                      ((0x00d5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_27                      ((0x00dd  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_28                      ((0x00e5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_29                      ((0x00ed  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_30                      ((0x00f5  << 2) + 0xfe444000)
#define RCH_RD_LEN_CHANNEL_31                      ((0x00fd  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_0                          ((0x0006  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_1                          ((0x000e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_2                          ((0x0016  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_3                          ((0x001e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_4                          ((0x0026  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_5                          ((0x002e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_6                          ((0x0036  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_7                          ((0x003e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_8                          ((0x0046  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_9                          ((0x004e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_10                         ((0x0056  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_11                         ((0x005e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_12                         ((0x0066  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_13                         ((0x006e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_14                         ((0x0076  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_15                         ((0x007e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_16                         ((0x0086  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_17                         ((0x008e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_18                         ((0x0096  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_19                         ((0x009e  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_20                         ((0x00a6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_21                         ((0x00ae  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_22                         ((0x00b6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_23                         ((0x00be  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_24                         ((0x00c6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_25                         ((0x00ce  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_26                         ((0x00d6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_27                         ((0x00de  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_28                         ((0x00e6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_29                         ((0x00ee  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_30                         ((0x00f6  << 2) + 0xfe444000)
#define RCH_PTR_CHANNEL_31                         ((0x00fe  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_0              ((0x0007  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_1              ((0x000f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_2              ((0x0017  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_3              ((0x001f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_4              ((0x0027  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_5              ((0x002f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_6              ((0x0037  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_7              ((0x003f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_8              ((0x0047  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_9              ((0x004f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_10             ((0x0057  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_11             ((0x005f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_12             ((0x0067  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_13             ((0x006f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_14             ((0x0077  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_15             ((0x007f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_16             ((0x0087  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_17             ((0x008f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_18             ((0x0097  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_19             ((0x009f  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_20             ((0x00a7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_21             ((0x00af  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_22             ((0x00b7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_23             ((0x00bf  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_24             ((0x00c7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_25             ((0x00cf  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_26             ((0x00d7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_27             ((0x00df  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_28             ((0x00e7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_29             ((0x00ef  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_30             ((0x00f7  << 2) + 0xfe444000)
#define RCH_PKT_SYNC_STATUS_CHANNEL_31             ((0x00ff  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_0                        ((0x0400  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_1                        ((0x0408  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_2                        ((0x0410  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_3                        ((0x0418  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_4                        ((0x0420  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_5                        ((0x0428  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_6                        ((0x0430  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_7                        ((0x0438  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_8                        ((0x0440  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_9                        ((0x0448  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_10                       ((0x0450  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_11                       ((0x0458  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_12                       ((0x0460  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_13                       ((0x0468  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_14                       ((0x0470  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_15                       ((0x0478  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_16                       ((0x0480  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_17                       ((0x0488  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_18                       ((0x0490  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_19                       ((0x0498  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_20                       ((0x04a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_21                       ((0x04a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_22                       ((0x04b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_23                       ((0x04b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_24                       ((0x04c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_25                       ((0x04c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_26                       ((0x04d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_27                       ((0x04d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_28                       ((0x04e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_29                       ((0x04e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_30                       ((0x04f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_31                       ((0x04f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_32                       ((0x0500  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_33                       ((0x0508  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_34                       ((0x0510  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_35                       ((0x0518  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_36                       ((0x0520  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_37                       ((0x0528  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_38                       ((0x0530  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_39                       ((0x0538  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_40                       ((0x0540  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_41                       ((0x0548  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_42                       ((0x0550  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_43                       ((0x0558  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_44                       ((0x0560  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_45                       ((0x0568  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_46                       ((0x0570  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_47                       ((0x0578  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_48                       ((0x0580  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_49                       ((0x0588  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_50                       ((0x0590  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_51                       ((0x0598  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_52                       ((0x05a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_53                       ((0x05a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_54                       ((0x05b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_55                       ((0x05b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_56                       ((0x05c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_57                       ((0x05c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_58                       ((0x05d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_59                       ((0x05d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_60                       ((0x05e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_61                       ((0x05e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_62                       ((0x05f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_63                       ((0x05f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_64                       ((0x0600  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_65                       ((0x0608  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_66                       ((0x0610  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_67                       ((0x0618  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_68                       ((0x0620  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_69                       ((0x0628  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_70                       ((0x0630  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_71                       ((0x0638  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_72                       ((0x0640  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_73                       ((0x0648  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_74                       ((0x0650  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_75                       ((0x0658  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_76                       ((0x0660  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_77                       ((0x0668  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_78                       ((0x0670  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_79                       ((0x0678  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_80                       ((0x0680  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_81                       ((0x0688  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_82                       ((0x0690  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_83                       ((0x0698  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_84                       ((0x06a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_85                       ((0x06a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_86                       ((0x06b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_87                       ((0x06b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_88                       ((0x06c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_89                       ((0x06c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_90                       ((0x06d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_91                       ((0x06d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_92                       ((0x06e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_93                       ((0x06e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_94                       ((0x06f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_95                       ((0x06f8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_96                       ((0x0700  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_97                       ((0x0708  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_98                       ((0x0710  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_99                       ((0x0718  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_100                      ((0x0720  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_101                      ((0x0728  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_102                      ((0x0730  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_103                      ((0x0738  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_104                      ((0x0740  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_105                      ((0x0748  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_106                      ((0x0750  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_107                      ((0x0758  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_108                      ((0x0760  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_109                      ((0x0768  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_110                      ((0x0770  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_111                      ((0x0778  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_112                      ((0x0780  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_113                      ((0x0788  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_114                      ((0x0790  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_115                      ((0x0798  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_116                      ((0x07a0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_117                      ((0x07a8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_118                      ((0x07b0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_119                      ((0x07b8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_120                      ((0x07c0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_121                      ((0x07c8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_122                      ((0x07d0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_123                      ((0x07d8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_124                      ((0x07e0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_125                      ((0x07e8  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_126                      ((0x07f0  << 2) + 0xfe444000)
#define WCH_READY_CHANNEL_127                      ((0x07f8  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_0                        ((0x0401  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_1                        ((0x0409  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_2                        ((0x0411  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_3                        ((0x0419  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_4                        ((0x0421  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_5                        ((0x0429  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_6                        ((0x0431  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_7                        ((0x0439  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_8                        ((0x0441  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_9                        ((0x0449  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_10                       ((0x0451  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_11                       ((0x0459  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_12                       ((0x0461  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_13                       ((0x0469  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_14                       ((0x0471  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_15                       ((0x0479  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_16                       ((0x0481  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_17                       ((0x0489  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_18                       ((0x0491  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_19                       ((0x0499  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_20                       ((0x04a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_21                       ((0x04a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_22                       ((0x04b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_23                       ((0x04b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_24                       ((0x04c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_25                       ((0x04c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_26                       ((0x04d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_27                       ((0x04d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_28                       ((0x04e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_29                       ((0x04e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_30                       ((0x04f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_31                       ((0x04f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_32                       ((0x0501  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_33                       ((0x0509  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_34                       ((0x0511  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_35                       ((0x0519  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_36                       ((0x0521  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_37                       ((0x0529  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_38                       ((0x0531  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_39                       ((0x0539  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_40                       ((0x0541  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_41                       ((0x0549  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_42                       ((0x0551  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_43                       ((0x0559  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_44                       ((0x0561  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_45                       ((0x0569  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_46                       ((0x0571  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_47                       ((0x0579  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_48                       ((0x0581  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_49                       ((0x0589  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_50                       ((0x0591  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_51                       ((0x0599  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_52                       ((0x05a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_53                       ((0x05a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_54                       ((0x05b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_55                       ((0x05b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_56                       ((0x05c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_57                       ((0x05c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_58                       ((0x05d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_59                       ((0x05d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_60                       ((0x05e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_61                       ((0x05e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_62                       ((0x05f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_63                       ((0x05f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_64                       ((0x0601  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_65                       ((0x0609  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_66                       ((0x0611  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_67                       ((0x0619  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_68                       ((0x0621  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_69                       ((0x0629  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_70                       ((0x0631  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_71                       ((0x0639  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_72                       ((0x0641  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_73                       ((0x0649  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_74                       ((0x0651  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_75                       ((0x0659  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_76                       ((0x0661  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_77                       ((0x0669  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_78                       ((0x0671  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_79                       ((0x0679  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_80                       ((0x0681  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_81                       ((0x0689  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_82                       ((0x0691  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_83                       ((0x0699  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_84                       ((0x06a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_85                       ((0x06a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_86                       ((0x06b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_87                       ((0x06b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_88                       ((0x06c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_89                       ((0x06c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_90                       ((0x06d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_91                       ((0x06d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_92                       ((0x06e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_93                       ((0x06e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_94                       ((0x06f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_95                       ((0x06f9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_96                       ((0x0701  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_97                       ((0x0709  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_98                       ((0x0711  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_99                       ((0x0719  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_100                      ((0x0721  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_101                      ((0x0729  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_102                      ((0x0731  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_103                      ((0x0739  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_104                      ((0x0741  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_105                      ((0x0749  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_106                      ((0x0751  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_107                      ((0x0759  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_108                      ((0x0761  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_109                      ((0x0769  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_110                      ((0x0771  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_111                      ((0x0779  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_112                      ((0x0781  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_113                      ((0x0789  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_114                      ((0x0791  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_115                      ((0x0799  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_116                      ((0x07a1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_117                      ((0x07a9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_118                      ((0x07b1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_119                      ((0x07b9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_120                      ((0x07c1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_121                      ((0x07c9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_122                      ((0x07d1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_123                      ((0x07d9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_124                      ((0x07e1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_125                      ((0x07e9  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_126                      ((0x07f1  << 2) + 0xfe444000)
#define WCH_DEBUG_CHANNEL_127                      ((0x07f9  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_0                          ((0x0402  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_1                          ((0x040a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_2                          ((0x0412  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_3                          ((0x041a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_4                          ((0x0422  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_5                          ((0x042a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_6                          ((0x0432  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_7                          ((0x043a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_8                          ((0x0442  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_9                          ((0x044a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_10                         ((0x0452  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_11                         ((0x045a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_12                         ((0x0462  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_13                         ((0x046a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_14                         ((0x0472  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_15                         ((0x047a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_16                         ((0x0482  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_17                         ((0x048a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_18                         ((0x0492  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_19                         ((0x049a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_20                         ((0x04a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_21                         ((0x04aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_22                         ((0x04b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_23                         ((0x04ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_24                         ((0x04c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_25                         ((0x04ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_26                         ((0x04d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_27                         ((0x04da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_28                         ((0x04e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_29                         ((0x04ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_30                         ((0x04f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_31                         ((0x04fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_32                         ((0x0502  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_33                         ((0x050a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_34                         ((0x0512  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_35                         ((0x051a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_36                         ((0x0522  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_37                         ((0x052a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_38                         ((0x0532  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_39                         ((0x053a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_40                         ((0x0542  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_41                         ((0x054a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_42                         ((0x0552  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_43                         ((0x055a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_44                         ((0x0562  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_45                         ((0x056a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_46                         ((0x0572  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_47                         ((0x057a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_48                         ((0x0582  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_49                         ((0x058a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_50                         ((0x0592  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_51                         ((0x059a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_52                         ((0x05a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_53                         ((0x05aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_54                         ((0x05b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_55                         ((0x05ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_56                         ((0x05c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_57                         ((0x05ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_58                         ((0x05d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_59                         ((0x05da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_60                         ((0x05e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_61                         ((0x05ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_62                         ((0x05f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_63                         ((0x05fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_64                         ((0x0602  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_65                         ((0x060a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_66                         ((0x0612  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_67                         ((0x061a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_68                         ((0x0622  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_69                         ((0x062a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_70                         ((0x0632  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_71                         ((0x063a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_72                         ((0x0642  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_73                         ((0x064a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_74                         ((0x0652  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_75                         ((0x065a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_76                         ((0x0662  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_77                         ((0x066a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_78                         ((0x0672  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_79                         ((0x067a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_80                         ((0x0682  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_81                         ((0x068a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_82                         ((0x0692  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_83                         ((0x069a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_84                         ((0x06a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_85                         ((0x06aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_86                         ((0x06b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_87                         ((0x06ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_88                         ((0x06c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_89                         ((0x06ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_90                         ((0x06d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_91                         ((0x06da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_92                         ((0x06e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_93                         ((0x06ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_94                         ((0x06f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_95                         ((0x06fa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_96                         ((0x0702  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_97                         ((0x070a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_98                         ((0x0712  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_99                         ((0x071a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_100                        ((0x0722  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_101                        ((0x072a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_102                        ((0x0732  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_103                        ((0x073a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_104                        ((0x0742  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_105                        ((0x074a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_106                        ((0x0752  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_107                        ((0x075a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_108                        ((0x0762  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_109                        ((0x076a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_110                        ((0x0772  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_111                        ((0x077a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_112                        ((0x0782  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_113                        ((0x078a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_114                        ((0x0792  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_115                        ((0x079a  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_116                        ((0x07a2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_117                        ((0x07aa  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_118                        ((0x07b2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_119                        ((0x07ba  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_120                        ((0x07c2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_121                        ((0x07ca  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_122                        ((0x07d2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_123                        ((0x07da  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_124                        ((0x07e2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_125                        ((0x07ea  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_126                        ((0x07f2  << 2) + 0xfe444000)
#define WCH_CFG_CHANNEL_127                        ((0x07fa  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_0                         ((0x0403  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_1                         ((0x040b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_2                         ((0x0413  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_3                         ((0x041b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_4                         ((0x0423  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_5                         ((0x042b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_6                         ((0x0433  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_7                         ((0x043b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_8                         ((0x0443  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_9                         ((0x044b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_10                        ((0x0453  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_11                        ((0x045b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_12                        ((0x0463  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_13                        ((0x046b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_14                        ((0x0473  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_15                        ((0x047b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_16                        ((0x0483  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_17                        ((0x048b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_18                        ((0x0493  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_19                        ((0x049b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_20                        ((0x04a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_21                        ((0x04ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_22                        ((0x04b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_23                        ((0x04bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_24                        ((0x04c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_25                        ((0x04cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_26                        ((0x04d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_27                        ((0x04db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_28                        ((0x04e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_29                        ((0x04eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_30                        ((0x04f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_31                        ((0x04fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_32                        ((0x0503  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_33                        ((0x050b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_34                        ((0x0513  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_35                        ((0x051b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_36                        ((0x0523  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_37                        ((0x052b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_38                        ((0x0533  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_39                        ((0x053b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_40                        ((0x0543  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_41                        ((0x054b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_42                        ((0x0553  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_43                        ((0x055b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_44                        ((0x0563  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_45                        ((0x056b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_46                        ((0x0573  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_47                        ((0x057b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_48                        ((0x0583  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_49                        ((0x058b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_50                        ((0x0593  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_51                        ((0x059b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_52                        ((0x05a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_53                        ((0x05ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_54                        ((0x05b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_55                        ((0x05bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_56                        ((0x05c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_57                        ((0x05cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_58                        ((0x05d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_59                        ((0x05db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_60                        ((0x05e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_61                        ((0x05eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_62                        ((0x05f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_63                        ((0x05fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_64                        ((0x0603  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_65                        ((0x060b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_66                        ((0x0613  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_67                        ((0x061b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_68                        ((0x0623  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_69                        ((0x062b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_70                        ((0x0633  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_71                        ((0x063b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_72                        ((0x0643  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_73                        ((0x064b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_74                        ((0x0653  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_75                        ((0x065b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_76                        ((0x0663  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_77                        ((0x066b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_78                        ((0x0673  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_79                        ((0x067b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_80                        ((0x0683  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_81                        ((0x068b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_82                        ((0x0693  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_83                        ((0x069b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_84                        ((0x06a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_85                        ((0x06ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_86                        ((0x06b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_87                        ((0x06bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_88                        ((0x06c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_89                        ((0x06cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_90                        ((0x06d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_91                        ((0x06db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_92                        ((0x06e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_93                        ((0x06eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_94                        ((0x06f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_95                        ((0x06fb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_96                        ((0x0703  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_97                        ((0x070b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_98                        ((0x0713  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_99                        ((0x071b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_100                       ((0x0723  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_101                       ((0x072b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_102                       ((0x0733  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_103                       ((0x073b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_104                       ((0x0743  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_105                       ((0x074b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_106                       ((0x0753  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_107                       ((0x075b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_108                       ((0x0763  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_109                       ((0x076b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_110                       ((0x0773  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_111                       ((0x077b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_112                       ((0x0783  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_113                       ((0x078b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_114                       ((0x0793  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_115                       ((0x079b  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_116                       ((0x07a3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_117                       ((0x07ab  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_118                       ((0x07b3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_119                       ((0x07bb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_120                       ((0x07c3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_121                       ((0x07cb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_122                       ((0x07d3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_123                       ((0x07db  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_124                       ((0x07e3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_125                       ((0x07eb  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_126                       ((0x07f3  << 2) + 0xfe444000)
#define WCH_ADDR_CHANNEL_127                       ((0x07fb  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_0                          ((0x0404  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_1                          ((0x040c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_2                          ((0x0414  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_3                          ((0x041c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_4                          ((0x0424  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_5                          ((0x042c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_6                          ((0x0434  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_7                          ((0x043c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_8                          ((0x0444  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_9                          ((0x044c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_10                         ((0x0454  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_11                         ((0x045c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_12                         ((0x0464  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_13                         ((0x046c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_14                         ((0x0474  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_15                         ((0x047c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_16                         ((0x0484  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_17                         ((0x048c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_18                         ((0x0494  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_19                         ((0x049c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_20                         ((0x04a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_21                         ((0x04ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_22                         ((0x04b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_23                         ((0x04bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_24                         ((0x04c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_25                         ((0x04cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_26                         ((0x04d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_27                         ((0x04dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_28                         ((0x04e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_29                         ((0x04ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_30                         ((0x04f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_31                         ((0x04fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_32                         ((0x0504  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_33                         ((0x050c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_34                         ((0x0514  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_35                         ((0x051c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_36                         ((0x0524  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_37                         ((0x052c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_38                         ((0x0534  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_39                         ((0x053c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_40                         ((0x0544  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_41                         ((0x054c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_42                         ((0x0554  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_43                         ((0x055c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_44                         ((0x0564  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_45                         ((0x056c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_46                         ((0x0574  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_47                         ((0x057c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_48                         ((0x0584  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_49                         ((0x058c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_50                         ((0x0594  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_51                         ((0x059c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_52                         ((0x05a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_53                         ((0x05ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_54                         ((0x05b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_55                         ((0x05bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_56                         ((0x05c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_57                         ((0x05cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_58                         ((0x05d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_59                         ((0x05dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_60                         ((0x05e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_61                         ((0x05ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_62                         ((0x05f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_63                         ((0x05fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_64                         ((0x0604  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_65                         ((0x060c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_66                         ((0x0614  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_67                         ((0x061c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_68                         ((0x0624  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_69                         ((0x062c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_70                         ((0x0634  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_71                         ((0x063c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_72                         ((0x0644  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_73                         ((0x064c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_74                         ((0x0654  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_75                         ((0x065c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_76                         ((0x0664  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_77                         ((0x066c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_78                         ((0x0674  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_79                         ((0x067c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_80                         ((0x0684  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_81                         ((0x068c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_82                         ((0x0694  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_83                         ((0x069c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_84                         ((0x06a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_85                         ((0x06ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_86                         ((0x06b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_87                         ((0x06bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_88                         ((0x06c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_89                         ((0x06cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_90                         ((0x06d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_91                         ((0x06dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_92                         ((0x06e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_93                         ((0x06ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_94                         ((0x06f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_95                         ((0x06fc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_96                         ((0x0704  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_97                         ((0x070c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_98                         ((0x0714  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_99                         ((0x071c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_100                        ((0x0724  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_101                        ((0x072c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_102                        ((0x0734  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_103                        ((0x073c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_104                        ((0x0744  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_105                        ((0x074c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_106                        ((0x0754  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_107                        ((0x075c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_108                        ((0x0764  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_109                        ((0x076c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_110                        ((0x0774  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_111                        ((0x077c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_112                        ((0x0784  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_113                        ((0x078c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_114                        ((0x0794  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_115                        ((0x079c  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_116                        ((0x07a4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_117                        ((0x07ac  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_118                        ((0x07b4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_119                        ((0x07bc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_120                        ((0x07c4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_121                        ((0x07cc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_122                        ((0x07d4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_123                        ((0x07dc  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_124                        ((0x07e4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_125                        ((0x07ec  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_126                        ((0x07f4  << 2) + 0xfe444000)
#define WCH_LEN_CHANNEL_127                        ((0x07fc  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_0                       ((0x0405  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_1                       ((0x040d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_2                       ((0x0415  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_3                       ((0x041d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_4                       ((0x0425  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_5                       ((0x042d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_6                       ((0x0435  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_7                       ((0x043d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_8                       ((0x0445  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_9                       ((0x044d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_10                      ((0x0455  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_11                      ((0x045d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_12                      ((0x0465  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_13                      ((0x046d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_14                      ((0x0475  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_15                      ((0x047d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_16                      ((0x0485  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_17                      ((0x048d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_18                      ((0x0495  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_19                      ((0x049d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_20                      ((0x04a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_21                      ((0x04ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_22                      ((0x04b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_23                      ((0x04bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_24                      ((0x04c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_25                      ((0x04cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_26                      ((0x04d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_27                      ((0x04dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_28                      ((0x04e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_29                      ((0x04ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_30                      ((0x04f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_31                      ((0x04fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_32                      ((0x0505  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_33                      ((0x050d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_34                      ((0x0515  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_35                      ((0x051d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_36                      ((0x0525  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_37                      ((0x052d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_38                      ((0x0535  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_39                      ((0x053d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_40                      ((0x0545  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_41                      ((0x054d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_42                      ((0x0555  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_43                      ((0x055d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_44                      ((0x0565  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_45                      ((0x056d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_46                      ((0x0575  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_47                      ((0x057d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_48                      ((0x0585  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_49                      ((0x058d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_50                      ((0x0595  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_51                      ((0x059d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_52                      ((0x05a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_53                      ((0x05ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_54                      ((0x05b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_55                      ((0x05bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_56                      ((0x05c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_57                      ((0x05cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_58                      ((0x05d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_59                      ((0x05dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_60                      ((0x05e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_61                      ((0x05ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_62                      ((0x05f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_63                      ((0x05fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_64                      ((0x0605  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_65                      ((0x060d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_66                      ((0x0615  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_67                      ((0x061d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_68                      ((0x0625  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_69                      ((0x062d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_70                      ((0x0635  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_71                      ((0x063d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_72                      ((0x0645  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_73                      ((0x064d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_74                      ((0x0655  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_75                      ((0x065d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_76                      ((0x0665  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_77                      ((0x066d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_78                      ((0x0675  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_79                      ((0x067d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_80                      ((0x0685  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_81                      ((0x068d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_82                      ((0x0695  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_83                      ((0x069d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_84                      ((0x06a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_85                      ((0x06ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_86                      ((0x06b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_87                      ((0x06bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_88                      ((0x06c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_89                      ((0x06cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_90                      ((0x06d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_91                      ((0x06dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_92                      ((0x06e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_93                      ((0x06ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_94                      ((0x06f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_95                      ((0x06fd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_96                      ((0x0705  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_97                      ((0x070d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_98                      ((0x0715  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_99                      ((0x071d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_100                     ((0x0725  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_101                     ((0x072d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_102                     ((0x0735  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_103                     ((0x073d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_104                     ((0x0745  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_105                     ((0x074d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_106                     ((0x0755  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_107                     ((0x075d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_108                     ((0x0765  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_109                     ((0x076d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_110                     ((0x0775  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_111                     ((0x077d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_112                     ((0x0785  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_113                     ((0x078d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_114                     ((0x0795  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_115                     ((0x079d  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_116                     ((0x07a5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_117                     ((0x07ad  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_118                     ((0x07b5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_119                     ((0x07bd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_120                     ((0x07c5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_121                     ((0x07cd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_122                     ((0x07d5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_123                     ((0x07dd  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_124                     ((0x07e5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_125                     ((0x07ed  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_126                     ((0x07f5  << 2) + 0xfe444000)
#define WCH_WR_LEN_CHANNEL_127                     ((0x07fd  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_0                          ((0x0406  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_1                          ((0x040e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_2                          ((0x0416  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_3                          ((0x041e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_4                          ((0x0426  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_5                          ((0x042e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_6                          ((0x0436  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_7                          ((0x043e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_8                          ((0x0446  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_9                          ((0x044e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_10                         ((0x0456  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_11                         ((0x045e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_12                         ((0x0466  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_13                         ((0x046e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_14                         ((0x0476  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_15                         ((0x047e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_16                         ((0x0486  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_17                         ((0x048e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_18                         ((0x0496  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_19                         ((0x049e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_20                         ((0x04a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_21                         ((0x04ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_22                         ((0x04b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_23                         ((0x04be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_24                         ((0x04c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_25                         ((0x04ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_26                         ((0x04d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_27                         ((0x04de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_28                         ((0x04e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_29                         ((0x04ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_30                         ((0x04f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_31                         ((0x04fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_32                         ((0x0506  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_33                         ((0x050e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_34                         ((0x0516  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_35                         ((0x051e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_36                         ((0x0526  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_37                         ((0x052e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_38                         ((0x0536  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_39                         ((0x053e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_40                         ((0x0546  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_41                         ((0x054e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_42                         ((0x0556  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_43                         ((0x055e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_44                         ((0x0566  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_45                         ((0x056e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_46                         ((0x0576  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_47                         ((0x057e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_48                         ((0x0586  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_49                         ((0x058e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_50                         ((0x0596  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_51                         ((0x059e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_52                         ((0x05a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_53                         ((0x05ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_54                         ((0x05b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_55                         ((0x05be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_56                         ((0x05c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_57                         ((0x05ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_58                         ((0x05d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_59                         ((0x05de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_60                         ((0x05e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_61                         ((0x05ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_62                         ((0x05f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_63                         ((0x05fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_64                         ((0x0606  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_65                         ((0x060e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_66                         ((0x0616  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_67                         ((0x061e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_68                         ((0x0626  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_69                         ((0x062e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_70                         ((0x0636  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_71                         ((0x063e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_72                         ((0x0646  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_73                         ((0x064e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_74                         ((0x0656  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_75                         ((0x065e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_76                         ((0x0666  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_77                         ((0x066e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_78                         ((0x0676  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_79                         ((0x067e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_80                         ((0x0686  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_81                         ((0x068e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_82                         ((0x0696  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_83                         ((0x069e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_84                         ((0x06a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_85                         ((0x06ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_86                         ((0x06b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_87                         ((0x06be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_88                         ((0x06c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_89                         ((0x06ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_90                         ((0x06d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_91                         ((0x06de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_92                         ((0x06e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_93                         ((0x06ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_94                         ((0x06f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_95                         ((0x06fe  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_96                         ((0x0706  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_97                         ((0x070e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_98                         ((0x0716  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_99                         ((0x071e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_100                        ((0x0726  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_101                        ((0x072e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_102                        ((0x0736  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_103                        ((0x073e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_104                        ((0x0746  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_105                        ((0x074e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_106                        ((0x0756  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_107                        ((0x075e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_108                        ((0x0766  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_109                        ((0x076e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_110                        ((0x0776  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_111                        ((0x077e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_112                        ((0x0786  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_113                        ((0x078e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_114                        ((0x0796  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_115                        ((0x079e  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_116                        ((0x07a6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_117                        ((0x07ae  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_118                        ((0x07b6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_119                        ((0x07be  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_120                        ((0x07c6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_121                        ((0x07ce  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_122                        ((0x07d6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_123                        ((0x07de  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_124                        ((0x07e6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_125                        ((0x07ee  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_126                        ((0x07f6  << 2) + 0xfe444000)
#define WCH_PTR_CHANNEL_127                        ((0x07fe  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_0                         ((0x0407  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_1                         ((0x040f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_2                         ((0x0417  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_3                         ((0x041f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_4                         ((0x0427  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_5                         ((0x042f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_6                         ((0x0437  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_7                         ((0x043f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_8                         ((0x0447  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_9                         ((0x044f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_10                        ((0x0457  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_11                        ((0x045f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_12                        ((0x0467  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_13                        ((0x046f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_14                        ((0x0477  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_15                        ((0x047f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_16                        ((0x0487  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_17                        ((0x048f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_18                        ((0x0497  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_19                        ((0x049f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_20                        ((0x04a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_21                        ((0x04af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_22                        ((0x04b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_23                        ((0x04bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_24                        ((0x04c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_25                        ((0x04cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_26                        ((0x04d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_27                        ((0x04df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_28                        ((0x04e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_29                        ((0x04ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_30                        ((0x04f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_31                        ((0x04ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_32                        ((0x0507  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_33                        ((0x050f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_34                        ((0x0517  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_35                        ((0x051f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_36                        ((0x0527  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_37                        ((0x052f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_38                        ((0x0537  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_39                        ((0x053f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_40                        ((0x0547  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_41                        ((0x054f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_42                        ((0x0557  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_43                        ((0x055f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_44                        ((0x0567  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_45                        ((0x056f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_46                        ((0x0577  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_47                        ((0x057f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_48                        ((0x0587  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_49                        ((0x058f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_50                        ((0x0597  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_51                        ((0x059f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_52                        ((0x05a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_53                        ((0x05af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_54                        ((0x05b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_55                        ((0x05bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_56                        ((0x05c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_57                        ((0x05cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_58                        ((0x05d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_59                        ((0x05df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_60                        ((0x05e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_61                        ((0x05ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_62                        ((0x05f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_63                        ((0x05ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_64                        ((0x0607  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_65                        ((0x060f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_66                        ((0x0617  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_67                        ((0x061f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_68                        ((0x0627  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_69                        ((0x062f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_70                        ((0x0637  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_71                        ((0x063f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_72                        ((0x0647  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_73                        ((0x064f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_74                        ((0x0657  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_75                        ((0x065f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_76                        ((0x0667  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_77                        ((0x066f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_78                        ((0x0677  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_79                        ((0x067f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_80                        ((0x0687  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_81                        ((0x068f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_82                        ((0x0697  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_83                        ((0x069f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_84                        ((0x06a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_85                        ((0x06af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_86                        ((0x06b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_87                        ((0x06bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_88                        ((0x06c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_89                        ((0x06cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_90                        ((0x06d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_91                        ((0x06df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_92                        ((0x06e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_93                        ((0x06ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_94                        ((0x06f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_95                        ((0x06ff  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_96                        ((0x0707  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_97                        ((0x070f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_98                        ((0x0717  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_99                        ((0x071f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_100                       ((0x0727  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_101                       ((0x072f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_102                       ((0x0737  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_103                       ((0x073f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_104                       ((0x0747  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_105                       ((0x074f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_106                       ((0x0757  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_107                       ((0x075f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_108                       ((0x0767  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_109                       ((0x076f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_110                       ((0x0777  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_111                       ((0x077f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_112                       ((0x0787  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_113                       ((0x078f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_114                       ((0x0797  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_115                       ((0x079f  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_116                       ((0x07a7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_117                       ((0x07af  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_118                       ((0x07b7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_119                       ((0x07bf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_120                       ((0x07c7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_121                       ((0x07cf  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_122                       ((0x07d7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_123                       ((0x07df  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_124                       ((0x07e7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_125                       ((0x07ef  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_126                       ((0x07f7  << 2) + 0xfe444000)
#define WCMD_CNT_CHANNEL_127                       ((0x07ff  << 2) + 0xfe444000)
#define DMX_RDMA_INT_MASK                          ((0x0800  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_0                        ((0x0801  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_1                        ((0x0802  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_2                        ((0x0803  << 2) + 0xfe444000)
#define DMX_WDMA_INT_MASK_3                        ((0x0804  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_0                        ((0x0805  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_1                        ((0x0806  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_2                        ((0x0807  << 2) + 0xfe444000)
#define DMX_CLEAN_W_BATCH_3                        ((0x0808  << 2) + 0xfe444000)
#define DMX_CLEAN_RDMA                             ((0x0809  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_0                           ((0x080a  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_1                           ((0x080b  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_2                           ((0x080c  << 2) + 0xfe444000)
#define DMX_CLEAN_WDMA_3                           ((0x080d  << 2) + 0xfe444000)
#define DMX_RDMA_ACTIVE                            ((0x080e  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_0                          ((0x080f  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_1                          ((0x0810  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_2                          ((0x0811  << 2) + 0xfe444000)
#define DMX_WDMA_ACTIVE_3                          ((0x0812  << 2) + 0xfe444000)
#define DMX_DMA_RDONE                              ((0x0813  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_0                            ((0x0814  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_1                            ((0x0815  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_2                            ((0x0816  << 2) + 0xfe444000)
#define DMX_DMA_WDONE_3                            ((0x0817  << 2) + 0xfe444000)
#define DMX_RDES_ERR                               ((0x0818  << 2) + 0xfe444000)
#define DMX_RDES_LEN_ERR                           ((0x0819  << 2) + 0xfe444000)
#define DMX_WDES_ERR_0                             ((0x081a  << 2) + 0xfe444000)
#define DMX_WDES_ERR_1                             ((0x081b  << 2) + 0xfe444000)
#define DMX_WDES_ERR_2                             ((0x081c  << 2) + 0xfe444000)
#define DMX_WDES_ERR_3                             ((0x081d  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_0                        ((0x081e  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_1                        ((0x081f  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_2                        ((0x0820  << 2) + 0xfe444000)
#define DMX_DMA_BATCH_END_3                        ((0x0821  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_0                        ((0x0822  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_1                        ((0x0823  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_2                        ((0x0824  << 2) + 0xfe444000)
#define DMX_WDES_EOC_DONE_3                        ((0x0825  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR0                          ((0x0826  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR1                          ((0x0827  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR2                          ((0x0828  << 2) + 0xfe444000)
#define DMX_WCH_RESP_ERR3                          ((0x0829  << 2) + 0xfe444000)
#define DMX_UPDT_PKT_SYNC                          ((0x0830  << 2) + 0xfe444000)
#define DMX_RCHN_CFG                               ((0x0831  << 2) + 0xfe444000)
#define DMX_WCHN_CFG                               ((0x0832  << 2) + 0xfe444000)
#define DMX_MEM_PD_CRTL                            ((0x0833  << 2) + 0xfe444000)
#define DMX_DMA_BUS_CFG                            ((0x0834  << 2) + 0xfe444000)
#define DMX_DMA_GMW_CFG                            ((0x0835  << 2) + 0xfe444000)
#define DMX_DMA_GMR_CFG                            ((0x0836  << 2) + 0xfe444000)
//========================================================================
//  TS OUTPUT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442c00
// -----------------------------------------------
#define TS_OUTPUT_PID_RDY                          ((0x0000  << 2) + 0xfe442c00)
#define TS_OUTPUT_TEE_LOCK                         ((0x0001  << 2) + 0xfe442c00)
#define TS_OUTPUT_PID_CFG                          ((0x0002  << 2) + 0xfe442c00)
#define TS_OUTPUT_PID_DAT                          ((0x0003  << 2) + 0xfe442c00)
#define TS_OUTPUT_OUT_CFG                          ((0x0004  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_0                  ((0x0010  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_1                  ((0x0011  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_2                  ((0x0012  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_3                  ((0x0013  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_4                  ((0x0014  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_5                  ((0x0015  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_6                  ((0x0016  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_7                  ((0x0017  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_8                  ((0x0018  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_9                  ((0x0019  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_10                 ((0x001a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_11                 ((0x001b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_12                 ((0x001c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_13                 ((0x001d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_14                 ((0x001e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_TAB_ENTRY_15                 ((0x001f  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_0_1                      ((0x0020  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_2_3                      ((0x0021  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_4_5                      ((0x0022  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_6_7                      ((0x0023  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_8_9                      ((0x0024  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_10_11                    ((0x0025  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_12_13                    ((0x0026  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_14_15                    ((0x0027  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_16_17                    ((0x0028  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_18_19                    ((0x0029  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_20_21                    ((0x002a  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_22_23                    ((0x002b  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_24_25                    ((0x002c  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_26_27                    ((0x002d  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_28_29                    ((0x002e  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_30_31                    ((0x002f  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_32_33                    ((0x0030  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_34_35                    ((0x0031  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_36_37                    ((0x0032  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_38_39                    ((0x0033  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_40_41                    ((0x0034  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_42_43                    ((0x0035  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_44_45                    ((0x0036  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_46_47                    ((0x0037  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_48_49                    ((0x0038  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_50_51                    ((0x0039  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_52_53                    ((0x003a  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_54_55                    ((0x003b  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_56_57                    ((0x003c  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_58_59                    ((0x003d  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_60_61                    ((0x003e  << 2) + 0xfe442c00)
#define TS_OUTPUT_SID_TAB_62_63                    ((0x003f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_0                         ((0x0040  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_1                         ((0x0041  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_2                         ((0x0042  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_3                         ((0x0043  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_4                         ((0x0044  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_5                         ((0x0045  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_6                         ((0x0046  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_7                         ((0x0047  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_8                         ((0x0048  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_9                         ((0x0049  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_10                        ((0x004a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_11                        ((0x004b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_12                        ((0x004c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_13                        ((0x004d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_14                        ((0x004e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_15                        ((0x004f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_16                        ((0x0050  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_17                        ((0x0051  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_18                        ((0x0052  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_19                        ((0x0053  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_20                        ((0x0054  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_21                        ((0x0055  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_22                        ((0x0056  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_23                        ((0x0057  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_24                        ((0x0058  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_25                        ((0x0059  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_26                        ((0x005a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_27                        ((0x005b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_28                        ((0x005c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_29                        ((0x005d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_30                        ((0x005e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_31                        ((0x005f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_32                        ((0x0060  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_33                        ((0x0061  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_34                        ((0x0062  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_35                        ((0x0063  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_36                        ((0x0064  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_37                        ((0x0065  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_38                        ((0x0066  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_39                        ((0x0067  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_40                        ((0x0068  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_41                        ((0x0069  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_42                        ((0x006a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_43                        ((0x006b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_44                        ((0x006c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_45                        ((0x006d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_46                        ((0x006e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_47                        ((0x006f  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_48                        ((0x0070  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_49                        ((0x0071  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_50                        ((0x0072  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_51                        ((0x0073  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_52                        ((0x0074  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_53                        ((0x0075  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_54                        ((0x0076  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_55                        ((0x0077  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_56                        ((0x0078  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_57                        ((0x0079  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_58                        ((0x007a  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_59                        ((0x007b  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_60                        ((0x007c  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_61                        ((0x007d  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_62                        ((0x007e  << 2) + 0xfe442c00)
#define TS_OUTPUT_ES_TAB_63                        ((0x007f  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_0                    ((0x0080  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_0                    ((0x0081  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_1                    ((0x0082  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_1                    ((0x0083  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_2                    ((0x0084  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_2                    ((0x0085  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_3                    ((0x0086  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_3                    ((0x0087  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_4                    ((0x0088  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_4                    ((0x0089  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_5                    ((0x008a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_5                    ((0x008b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_6                    ((0x008c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_6                    ((0x008d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_7                    ((0x008e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_7                    ((0x008f  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_8                    ((0x0090  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_8                    ((0x0091  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_9                    ((0x0092  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_9                    ((0x0093  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_10                   ((0x0094  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_10                   ((0x0095  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_11                   ((0x0096  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_11                   ((0x0097  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_12                   ((0x0098  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_12                   ((0x0099  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_13                   ((0x009a  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_13                   ((0x009b  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_14                   ((0x009c  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_14                   ((0x009d  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_LSB_15                   ((0x009e  << 2) + 0xfe442c00)
#define TS_OUTPUT_PCR_REG_MSB_15                   ((0x009f  << 2) + 0xfe442c00)
//========================================================================
//  TSD DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442000
// -----------------------------------------------
#define TSD_PID_RDY                                ((0x0000  << 2) + 0xfe442000)
#define TSD_TEE_LOCK                               ((0x0001  << 2) + 0xfe442000)
#define TSD_PID_STS                                ((0x0003  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_0                        ((0x0004  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_0                        ((0x0005  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_1                        ((0x0006  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_1                        ((0x0007  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_2                        ((0x0008  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_2                        ((0x0009  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_3                        ((0x000a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_3                        ((0x000b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_4                        ((0x000c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_4                        ((0x000d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_5                        ((0x000e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_5                        ((0x000f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_6                        ((0x0010  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_6                        ((0x0011  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_7                        ((0x0012  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_7                        ((0x0013  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_8                        ((0x0014  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_8                        ((0x0015  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_9                        ((0x0016  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_9                        ((0x0017  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_10                       ((0x0018  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_10                       ((0x0019  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_11                       ((0x001a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_11                       ((0x001b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_12                       ((0x001c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_12                       ((0x001d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_13                       ((0x001e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_13                       ((0x001f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_14                       ((0x0020  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_14                       ((0x0021  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_15                       ((0x0022  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_15                       ((0x0023  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_16                       ((0x0024  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_16                       ((0x0025  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_17                       ((0x0026  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_17                       ((0x0027  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_18                       ((0x0028  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_18                       ((0x0029  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_19                       ((0x002a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_19                       ((0x002b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_20                       ((0x002c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_20                       ((0x002d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_21                       ((0x002e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_21                       ((0x002f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_22                       ((0x0030  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_22                       ((0x0031  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_23                       ((0x0032  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_23                       ((0x0033  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_24                       ((0x0034  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_24                       ((0x0035  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_25                       ((0x0036  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_25                       ((0x0037  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_26                       ((0x0038  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_26                       ((0x0039  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_27                       ((0x003a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_27                       ((0x003b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_28                       ((0x003c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_28                       ((0x003d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_29                       ((0x003e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_29                       ((0x003f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_30                       ((0x0040  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_30                       ((0x0041  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_31                       ((0x0042  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_31                       ((0x0043  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_32                       ((0x0044  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_32                       ((0x0045  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_33                       ((0x0046  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_33                       ((0x0047  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_34                       ((0x0048  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_34                       ((0x0049  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_35                       ((0x004a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_35                       ((0x004b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_36                       ((0x004c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_36                       ((0x004d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_37                       ((0x004e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_37                       ((0x004f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_38                       ((0x0050  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_38                       ((0x0051  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_39                       ((0x0052  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_39                       ((0x0053  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_40                       ((0x0054  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_40                       ((0x0055  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_41                       ((0x0056  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_41                       ((0x0057  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_42                       ((0x0058  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_42                       ((0x0059  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_43                       ((0x005a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_43                       ((0x005b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_44                       ((0x005c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_44                       ((0x005d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_45                       ((0x005e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_45                       ((0x005f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_46                       ((0x0060  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_46                       ((0x0061  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_47                       ((0x0062  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_47                       ((0x0063  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_48                       ((0x0064  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_48                       ((0x0065  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_49                       ((0x0066  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_49                       ((0x0067  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_50                       ((0x0068  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_50                       ((0x0069  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_51                       ((0x006a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_51                       ((0x006b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_52                       ((0x006c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_52                       ((0x006d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_53                       ((0x006e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_53                       ((0x006f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_54                       ((0x0070  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_54                       ((0x0071  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_55                       ((0x0072  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_55                       ((0x0073  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_56                       ((0x0074  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_56                       ((0x0075  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_57                       ((0x0076  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_57                       ((0x0077  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_58                       ((0x0078  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_58                       ((0x0079  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_59                       ((0x007a  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_59                       ((0x007b  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_60                       ((0x007c  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_60                       ((0x007d  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_61                       ((0x007e  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_61                       ((0x007f  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_62                       ((0x0080  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_62                       ((0x0081  << 2) + 0xfe442000)
#define TSD_PID_TABLE_LSB_63                       ((0x0082  << 2) + 0xfe442000)
#define TSD_PID_TABLE_MSB_63                       ((0x0083  << 2) + 0xfe442000)
//========================================================================
// SECURE TOP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440300
// -----------------------------------------------
#define SEC_TOP_CFG_LOCKABLE                       ((0x0000  << 2) + 0xfe440300)
#define SEC_TOP_CFG_LOCK                           ((0x0001  << 2) + 0xfe440300)
#define SEC_TOP_CFG_WTO                            ((0x0002  << 2) + 0xfe440300)
#define SEC_TOP_N2_GENOUT                          ((0x0003  << 2) + 0xfe440300)
#define SEC_TOP_CFG_REG                            ((0x0004  << 2) + 0xfe440300)
#define SEC_TOP_NSK_CTRL                           ((0x0005  << 2) + 0xfe440300)
#define SEC_TOP_AKL_STS                            ((0x0006  << 2) + 0xfe440300)
#define SEC_TOP_ND_STATUS                          ((0x0007  << 2) + 0xfe440300)
#define SEC_TOP_CFG_DEMUX                          ((0x0008  << 2) + 0xfe440300)
#define SEC_TOP_CFG_DIF                            ((0x000c  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH0                          ((0x0010  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH1                          ((0x0011  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH2                          ((0x0012  << 2) + 0xfe440300)
#define SEC_TOP_NSK_HASH3                          ((0x0013  << 2) + 0xfe440300)
#define SEC_TOP_PATH0_CTRL                         ((0x0028  << 2) + 0xfe440300)
#define SEC_TOP_PATH1_CTRL                         ((0x0029  << 2) + 0xfe440300)
#define SEC_TOP_PATH2_CTRL                         ((0x002a  << 2) + 0xfe440300)
#define SEC_TOP_PATH3_CTRL                         ((0x002b  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG0                     ((0x002c  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG1                     ((0x002d  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG2                     ((0x002e  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_PKT_CFG3                     ((0x002f  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_FIFO_CFG0                    ((0x0030  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_FIFO_CFG1                    ((0x0031  << 2) + 0xfe440300)
#define SEC_TOP_TS_O_PATH_CTRL                     ((0x0032  << 2) + 0xfe440300)
#define SEC_TOP_CLEAN_DEMOD_INT                    ((0x0033  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_INT_MASK                     ((0x0034  << 2) + 0xfe440300)
#define SEC_TOP_DEMOD_INT_STATUS                   ((0x0035  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN0_ERR_STATUS                 ((0x0036  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN1_ERR_STATUS                 ((0x0037  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN2_ERR_STATUS                 ((0x0038  << 2) + 0xfe440300)
#define SEC_TOP_TS_CHN3_ERR_STATUS                 ((0x0039  << 2) + 0xfe440300)
//========================================================================
// TSE DESC AES REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442800
// -----------------------------------------------
#define TSE_PID_RDY                                ((0x0000  << 2) + 0xfe442800)
#define TSE_TEE_LOCK                               ((0x0001  << 2) + 0xfe442800)
#define TSE_PID_STS                                ((0x0003  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_0                        ((0x0004  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_0                        ((0x0005  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_1                        ((0x0006  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_1                        ((0x0007  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_2                        ((0x0008  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_2                        ((0x0009  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_3                        ((0x000a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_3                        ((0x000b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_4                        ((0x000c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_4                        ((0x000d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_5                        ((0x000e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_5                        ((0x000f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_6                        ((0x0010  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_6                        ((0x0011  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_7                        ((0x0012  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_7                        ((0x0013  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_8                        ((0x0014  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_8                        ((0x0015  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_9                        ((0x0016  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_9                        ((0x0017  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_10                       ((0x0018  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_10                       ((0x0019  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_11                       ((0x001a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_11                       ((0x001b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_12                       ((0x001c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_12                       ((0x001d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_13                       ((0x001e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_13                       ((0x001f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_14                       ((0x0020  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_14                       ((0x0021  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_15                       ((0x0022  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_15                       ((0x0023  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_16                       ((0x0024  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_16                       ((0x0025  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_17                       ((0x0026  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_17                       ((0x0027  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_18                       ((0x0028  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_18                       ((0x0029  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_19                       ((0x002a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_19                       ((0x002b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_20                       ((0x002c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_20                       ((0x002d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_21                       ((0x002e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_21                       ((0x002f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_22                       ((0x0030  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_22                       ((0x0031  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_23                       ((0x0032  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_23                       ((0x0033  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_24                       ((0x0034  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_24                       ((0x0035  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_25                       ((0x0036  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_25                       ((0x0037  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_26                       ((0x0038  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_26                       ((0x0039  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_27                       ((0x003a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_27                       ((0x003b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_28                       ((0x003c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_28                       ((0x003d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_29                       ((0x003e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_29                       ((0x003f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_30                       ((0x0040  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_30                       ((0x0041  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_31                       ((0x0042  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_31                       ((0x0043  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_32                       ((0x0044  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_32                       ((0x0045  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_33                       ((0x0046  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_33                       ((0x0047  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_34                       ((0x0048  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_34                       ((0x0049  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_35                       ((0x004a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_35                       ((0x004b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_36                       ((0x004c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_36                       ((0x004d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_37                       ((0x004e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_37                       ((0x004f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_38                       ((0x0050  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_38                       ((0x0051  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_39                       ((0x0052  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_39                       ((0x0053  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_40                       ((0x0054  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_40                       ((0x0055  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_41                       ((0x0056  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_41                       ((0x0057  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_42                       ((0x0058  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_42                       ((0x0059  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_43                       ((0x005a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_43                       ((0x005b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_44                       ((0x005c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_44                       ((0x005d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_45                       ((0x005e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_45                       ((0x005f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_46                       ((0x0060  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_46                       ((0x0061  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_47                       ((0x0062  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_47                       ((0x0063  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_48                       ((0x0064  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_48                       ((0x0065  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_49                       ((0x0066  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_49                       ((0x0067  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_50                       ((0x0068  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_50                       ((0x0069  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_51                       ((0x006a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_51                       ((0x006b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_52                       ((0x006c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_52                       ((0x006d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_53                       ((0x006e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_53                       ((0x006f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_54                       ((0x0070  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_54                       ((0x0071  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_55                       ((0x0072  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_55                       ((0x0073  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_56                       ((0x0074  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_56                       ((0x0075  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_57                       ((0x0076  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_57                       ((0x0077  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_58                       ((0x0078  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_58                       ((0x0079  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_59                       ((0x007a  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_59                       ((0x007b  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_60                       ((0x007c  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_60                       ((0x007d  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_61                       ((0x007e  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_61                       ((0x007f  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_62                       ((0x0080  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_62                       ((0x0081  << 2) + 0xfe442800)
#define TSE_PID_TABLE_LSB_63                       ((0x0082  << 2) + 0xfe442800)
#define TSE_PID_TABLE_MSB_63                       ((0x0083  << 2) + 0xfe442800)
//========================================================================
// TSN DESC REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe442400
// -----------------------------------------------
#define TSN_PID_RDY                                ((0x0000  << 2) + 0xfe442400)
#define TSN_TEE_LOCK                               ((0x0001  << 2) + 0xfe442400)
#define TSN_PID_STS                                ((0x0003  << 2) + 0xfe442400)
#define TSN_PID_TABLE_0                            ((0x0004  << 2) + 0xfe442400)
#define TSN_PID_TABLE_1                            ((0x0005  << 2) + 0xfe442400)
#define TSN_PID_TABLE_2                            ((0x0006  << 2) + 0xfe442400)
#define TSN_PID_TABLE_3                            ((0x0007  << 2) + 0xfe442400)
#define TSN_PID_TABLE_4                            ((0x0008  << 2) + 0xfe442400)
#define TSN_PID_TABLE_5                            ((0x0009  << 2) + 0xfe442400)
#define TSN_PID_TABLE_6                            ((0x000a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_7                            ((0x000b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_8                            ((0x000c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_9                            ((0x000d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_10                           ((0x000e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_11                           ((0x000f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_12                           ((0x0010  << 2) + 0xfe442400)
#define TSN_PID_TABLE_13                           ((0x0011  << 2) + 0xfe442400)
#define TSN_PID_TABLE_14                           ((0x0012  << 2) + 0xfe442400)
#define TSN_PID_TABLE_15                           ((0x0013  << 2) + 0xfe442400)
#define TSN_PID_TABLE_16                           ((0x0014  << 2) + 0xfe442400)
#define TSN_PID_TABLE_17                           ((0x0015  << 2) + 0xfe442400)
#define TSN_PID_TABLE_18                           ((0x0016  << 2) + 0xfe442400)
#define TSN_PID_TABLE_19                           ((0x0017  << 2) + 0xfe442400)
#define TSN_PID_TABLE_20                           ((0x0018  << 2) + 0xfe442400)
#define TSN_PID_TABLE_21                           ((0x0019  << 2) + 0xfe442400)
#define TSN_PID_TABLE_22                           ((0x001a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_23                           ((0x001b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_24                           ((0x001c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_25                           ((0x001d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_26                           ((0x001e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_27                           ((0x001f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_28                           ((0x0020  << 2) + 0xfe442400)
#define TSN_PID_TABLE_29                           ((0x0021  << 2) + 0xfe442400)
#define TSN_PID_TABLE_30                           ((0x0022  << 2) + 0xfe442400)
#define TSN_PID_TABLE_31                           ((0x0023  << 2) + 0xfe442400)
#define TSN_PID_TABLE_32                           ((0x0024  << 2) + 0xfe442400)
#define TSN_PID_TABLE_33                           ((0x0025  << 2) + 0xfe442400)
#define TSN_PID_TABLE_34                           ((0x0026  << 2) + 0xfe442400)
#define TSN_PID_TABLE_35                           ((0x0027  << 2) + 0xfe442400)
#define TSN_PID_TABLE_36                           ((0x0028  << 2) + 0xfe442400)
#define TSN_PID_TABLE_37                           ((0x0029  << 2) + 0xfe442400)
#define TSN_PID_TABLE_38                           ((0x002a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_39                           ((0x002b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_40                           ((0x002c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_41                           ((0x002d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_42                           ((0x002e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_43                           ((0x002f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_44                           ((0x0030  << 2) + 0xfe442400)
#define TSN_PID_TABLE_45                           ((0x0031  << 2) + 0xfe442400)
#define TSN_PID_TABLE_46                           ((0x0032  << 2) + 0xfe442400)
#define TSN_PID_TABLE_47                           ((0x0033  << 2) + 0xfe442400)
#define TSN_PID_TABLE_48                           ((0x0034  << 2) + 0xfe442400)
#define TSN_PID_TABLE_49                           ((0x0035  << 2) + 0xfe442400)
#define TSN_PID_TABLE_50                           ((0x0036  << 2) + 0xfe442400)
#define TSN_PID_TABLE_51                           ((0x0037  << 2) + 0xfe442400)
#define TSN_PID_TABLE_52                           ((0x0038  << 2) + 0xfe442400)
#define TSN_PID_TABLE_53                           ((0x0039  << 2) + 0xfe442400)
#define TSN_PID_TABLE_54                           ((0x003a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_55                           ((0x003b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_56                           ((0x003c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_57                           ((0x003d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_58                           ((0x003e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_59                           ((0x003f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_60                           ((0x0040  << 2) + 0xfe442400)
#define TSN_PID_TABLE_61                           ((0x0041  << 2) + 0xfe442400)
#define TSN_PID_TABLE_62                           ((0x0042  << 2) + 0xfe442400)
#define TSN_PID_TABLE_63                           ((0x0043  << 2) + 0xfe442400)
#define TSN_PID_TABLE_64                           ((0x0044  << 2) + 0xfe442400)
#define TSN_PID_TABLE_65                           ((0x0045  << 2) + 0xfe442400)
#define TSN_PID_TABLE_66                           ((0x0046  << 2) + 0xfe442400)
#define TSN_PID_TABLE_67                           ((0x0047  << 2) + 0xfe442400)
#define TSN_PID_TABLE_68                           ((0x0048  << 2) + 0xfe442400)
#define TSN_PID_TABLE_69                           ((0x0049  << 2) + 0xfe442400)
#define TSN_PID_TABLE_70                           ((0x004a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_71                           ((0x004b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_72                           ((0x004c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_73                           ((0x004d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_74                           ((0x004e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_75                           ((0x004f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_76                           ((0x0050  << 2) + 0xfe442400)
#define TSN_PID_TABLE_77                           ((0x0051  << 2) + 0xfe442400)
#define TSN_PID_TABLE_78                           ((0x0052  << 2) + 0xfe442400)
#define TSN_PID_TABLE_79                           ((0x0053  << 2) + 0xfe442400)
#define TSN_PID_TABLE_80                           ((0x0054  << 2) + 0xfe442400)
#define TSN_PID_TABLE_81                           ((0x0055  << 2) + 0xfe442400)
#define TSN_PID_TABLE_82                           ((0x0056  << 2) + 0xfe442400)
#define TSN_PID_TABLE_83                           ((0x0057  << 2) + 0xfe442400)
#define TSN_PID_TABLE_84                           ((0x0058  << 2) + 0xfe442400)
#define TSN_PID_TABLE_85                           ((0x0059  << 2) + 0xfe442400)
#define TSN_PID_TABLE_86                           ((0x005a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_87                           ((0x005b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_88                           ((0x005c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_89                           ((0x005d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_90                           ((0x005e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_91                           ((0x005f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_92                           ((0x0060  << 2) + 0xfe442400)
#define TSN_PID_TABLE_93                           ((0x0061  << 2) + 0xfe442400)
#define TSN_PID_TABLE_94                           ((0x0062  << 2) + 0xfe442400)
#define TSN_PID_TABLE_95                           ((0x0063  << 2) + 0xfe442400)
#define TSN_PID_TABLE_96                           ((0x0064  << 2) + 0xfe442400)
#define TSN_PID_TABLE_97                           ((0x0065  << 2) + 0xfe442400)
#define TSN_PID_TABLE_98                           ((0x0066  << 2) + 0xfe442400)
#define TSN_PID_TABLE_99                           ((0x0067  << 2) + 0xfe442400)
#define TSN_PID_TABLE_100                          ((0x0068  << 2) + 0xfe442400)
#define TSN_PID_TABLE_101                          ((0x0069  << 2) + 0xfe442400)
#define TSN_PID_TABLE_102                          ((0x006a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_103                          ((0x006b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_104                          ((0x006c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_105                          ((0x006d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_106                          ((0x006e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_107                          ((0x006f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_108                          ((0x0070  << 2) + 0xfe442400)
#define TSN_PID_TABLE_109                          ((0x0071  << 2) + 0xfe442400)
#define TSN_PID_TABLE_110                          ((0x0072  << 2) + 0xfe442400)
#define TSN_PID_TABLE_111                          ((0x0073  << 2) + 0xfe442400)
#define TSN_PID_TABLE_112                          ((0x0074  << 2) + 0xfe442400)
#define TSN_PID_TABLE_113                          ((0x0075  << 2) + 0xfe442400)
#define TSN_PID_TABLE_114                          ((0x0076  << 2) + 0xfe442400)
#define TSN_PID_TABLE_115                          ((0x0077  << 2) + 0xfe442400)
#define TSN_PID_TABLE_116                          ((0x0078  << 2) + 0xfe442400)
#define TSN_PID_TABLE_117                          ((0x0079  << 2) + 0xfe442400)
#define TSN_PID_TABLE_118                          ((0x007a  << 2) + 0xfe442400)
#define TSN_PID_TABLE_119                          ((0x007b  << 2) + 0xfe442400)
#define TSN_PID_TABLE_120                          ((0x007c  << 2) + 0xfe442400)
#define TSN_PID_TABLE_121                          ((0x007d  << 2) + 0xfe442400)
#define TSN_PID_TABLE_122                          ((0x007e  << 2) + 0xfe442400)
#define TSN_PID_TABLE_123                          ((0x007f  << 2) + 0xfe442400)
#define TSN_PID_TABLE_124                          ((0x0080  << 2) + 0xfe442400)
#define TSN_PID_TABLE_125                          ((0x0081  << 2) + 0xfe442400)
#define TSN_PID_TABLE_126                          ((0x0082  << 2) + 0xfe442400)
#define TSN_PID_TABLE_127                          ((0x0083  << 2) + 0xfe442400)
//========================================================================
// RNG REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440700
// -----------------------------------------------
#define RNG_TEE_READY                              ((0x0000  << 2) + 0xfe440700)
#define RNG_TEE_LOCK                               ((0x0001  << 2) + 0xfe440700)
#define RNG_TEE_CFG                                ((0x0002  << 2) + 0xfe440700)
#define RNG_TEE_NIST_OUT                           ((0x0003  << 2) + 0xfe440700)
#define RNG_TEE_OUT0                               ((0x0004  << 2) + 0xfe440700)
#define RNG_TEE_OUT1                               ((0x0005  << 2) + 0xfe440700)
#define RNG_TEE_OUT2                               ((0x0006  << 2) + 0xfe440700)
#define RNG_TEE_OUT3                               ((0x0007  << 2) + 0xfe440700)
#define RNG_CFG_RING                               ((0x0010  << 2) + 0xfe440700)
#define RNG_CFG_RESEED                             ((0x0011  << 2) + 0xfe440700)
#define RNG_CFG_HEALTH                             ((0x0012  << 2) + 0xfe440700)
#define RNG_CFG_MISC                               ((0x0013  << 2) + 0xfe440700)
#define RNG_REE_READY                              ((0x0020  << 2) + 0xfe440700)
#define RNG_REE_DEBUG                              ((0x0021  << 2) + 0xfe440700)
#define RNG_REE_CFG                                ((0x0022  << 2) + 0xfe440700)
#define RNG_REE_OUT0                               ((0x0024  << 2) + 0xfe440700)
#define RNG_REE_OUT1                               ((0x0025  << 2) + 0xfe440700)
#define RNG_REE_OUT2                               ((0x0026  << 2) + 0xfe440700)
#define RNG_REE_OUT3                               ((0x0027  << 2) + 0xfe440700)
//========================================================================
// OTP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440000
// -----------------------------------------------
#define OTP_TEE_RDY                                ((0x0000  << 2) + 0xfe440000)
#define OTP_TEE_DEBUG                              ((0x0001  << 2) + 0xfe440000)
#define OTP_TEE_CFG                                ((0x0002  << 2) + 0xfe440000)
#define OTP_TEE_WR_DAT                             ((0x0004  << 2) + 0xfe440000)
#define OTP_TEE_RD_DAT                             ((0x0008  << 2) + 0xfe440000)
#define OTP_LIC_A                                  ((0x0010  << 2) + 0xfe440000)
#define OTP_AML_ID_L                               ((0x0020  << 2) + 0xfe440000)
#define OTP_AML_ID_H                               ((0x0021  << 2) + 0xfe440000)
#define OTP_ACGK_ID_L                              ((0x0022  << 2) + 0xfe440000)
#define OTP_ACGK_ID_H                              ((0x0023  << 2) + 0xfe440000)
#define OTP_DVGK_ID_L                              ((0x0024  << 2) + 0xfe440000)
#define OTP_DVGK_ID_H                              ((0x0025  << 2) + 0xfe440000)
#define OTP_DVUK_ID_L                              ((0x0026  << 2) + 0xfe440000)
#define OTP_DVUK_ID_H                              ((0x0027  << 2) + 0xfe440000)
#define OTP_DGPK_ID_L                              ((0x0028  << 2) + 0xfe440000)
#define OTP_DGPK_ID_H                              ((0x0029  << 2) + 0xfe440000)
#define OTP_SECPU_ID_L                             ((0x002a  << 2) + 0xfe440000)
#define OTP_SECPU_ID_H                             ((0x002b  << 2) + 0xfe440000)
#define OTP_ETSI012_ID_L                           ((0x002c  << 2) + 0xfe440000)
#define OTP_ETSI012_ID_H                           ((0x002d  << 2) + 0xfe440000)
#define OTP_ETSI3_ID_L                             ((0x002e  << 2) + 0xfe440000)
#define OTP_ETSI3_ID_H                             ((0x002f  << 2) + 0xfe440000)
#define OTP_MSR_ID_L                               ((0x0030  << 2) + 0xfe440000)
#define OTP_MSR_ID_H                               ((0x0031  << 2) + 0xfe440000)
#define OTP_VO_ID_L                                ((0x0032  << 2) + 0xfe440000)
#define OTP_VO_ID_H                                ((0x0033  << 2) + 0xfe440000)
#define OTP_NUID_ID_L                              ((0x0034  << 2) + 0xfe440000)
#define OTP_NUID_ID_H                              ((0x0035  << 2) + 0xfe440000)
#define OTP_CONAX_ID_L                             ((0x0036  << 2) + 0xfe440000)
#define OTP_CONAX_ID_H                             ((0x0037  << 2) + 0xfe440000)
#define OTP_NSK_ID_L                               ((0x0038  << 2) + 0xfe440000)
#define OTP_NSK_ID_H                               ((0x0039  << 2) + 0xfe440000)
#define OTP_REE_RDY                                ((0x0040  << 2) + 0xfe440000)
#define OTP_REE_DEBUG                              ((0x0041  << 2) + 0xfe440000)
#define OTP_REE_CFG                                ((0x0042  << 2) + 0xfe440000)
#define OTP_MRK_CHKNUM                             ((0x0043  << 2) + 0xfe440000)
#define OTP_REE_RD_DAT                             ((0x0048  << 2) + 0xfe440000)
//========================================================================
// KL REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440200
// -----------------------------------------------
#define MKL_TEE_RDY                                ((0x0000  << 2) + 0xfe440200)
#define MKL_TEE_DEBUG                              ((0x0001  << 2) + 0xfe440200)
#define MKL_TEE_CFG                                ((0x0002  << 2) + 0xfe440200)
#define MKL_TEE_CMD                                ((0x0003  << 2) + 0xfe440200)
#define MKL_TEE_EK                                 ((0x0004  << 2) + 0xfe440200)
#define MKL_TEE_CR_0                               ((0x001c  << 2) + 0xfe440200)
#define MKL_TEE_CR_1                               ((0x001d  << 2) + 0xfe440200)
#define MKL_TEE_CR_2                               ((0x001e  << 2) + 0xfe440200)
#define MKL_TEE_CR_3                               ((0x001f  << 2) + 0xfe440200)
#define MKL_REE_RDY                                ((0x0020  << 2) + 0xfe440200)
#define MKL_REE_DEBUG                              ((0x0021  << 2) + 0xfe440200)
#define MKL_REE_CFG                                ((0x0022  << 2) + 0xfe440200)
#define MKL_REE_CMD                                ((0x0023  << 2) + 0xfe440200)
#define MKL_REE_EK                                 ((0x0024  << 2) + 0xfe440200)
//========================================================================
// DMA REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440400
// -----------------------------------------------
#define DMA_CORE_DSC_0                             ((0x0000  << 2) + 0xfe440400)
#define DMA_CORE_DSC_1                             ((0x0001  << 2) + 0xfe440400)
#define DMA_CORE_DSC_2                             ((0x0002  << 2) + 0xfe440400)
#define DMA_CORE_DSC_3                             ((0x0003  << 2) + 0xfe440400)
#define DMA_CORE_DSC_4                             ((0x0004  << 2) + 0xfe440400)
#define DMA_CORE_DSC_5                             ((0x0005  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_0                         ((0x0008  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_1                         ((0x0009  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_2                         ((0x000a  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_3                         ((0x000b  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_4                         ((0x000c  << 2) + 0xfe440400)
#define DMA_CORE_IRQ_STS_5                         ((0x000d  << 2) + 0xfe440400)
#define DMA_CORE_CFG_REG                           ((0x0010  << 2) + 0xfe440400)
#define DMA_CORE_CFG_SEC_LSB                       ((0x0011  << 2) + 0xfe440400)
#define DMA_CORE_CFG_SEC_MSB                       ((0x0012  << 2) + 0xfe440400)
//========================================================================
// KT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440500
// -----------------------------------------------
#define KT_TEE_RDY                                 ((0x0000  << 2) + 0xfe440500)
#define KT_TEE_RDY2                                ((0x0001  << 2) + 0xfe440500)
#define KT_TEE_CFG                                 ((0x0002  << 2) + 0xfe440500)
#define KT_TEE_STS                                 ((0x0003  << 2) + 0xfe440500)
#define KT_TEE_KEY0                                ((0x0004  << 2) + 0xfe440500)
#define KT_TEE_KEY1                                ((0x0005  << 2) + 0xfe440500)
#define KT_TEE_KEY2                                ((0x0006  << 2) + 0xfe440500)
#define KT_TEE_KEY3                                ((0x0007  << 2) + 0xfe440500)
#define KT_REE_RDY                                 ((0x0020  << 2) + 0xfe440500)
#define KT_REE_RDY2                                ((0x0021  << 2) + 0xfe440500)
#define KT_REE_CFG                                 ((0x0022  << 2) + 0xfe440500)
#define KT_REE_STS                                 ((0x0023  << 2) + 0xfe440500)
#define KT_REE_KEY0                                ((0x0024  << 2) + 0xfe440500)
#define KT_REE_KEY1                                ((0x0025  << 2) + 0xfe440500)
#define KT_REE_KEY2                                ((0x0026  << 2) + 0xfe440500)
#define KT_REE_KEY3                                ((0x0027  << 2) + 0xfe440500)
//========================================================================
// CERT REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe440600
// -----------------------------------------------
//========================================================================
// SP REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe441000
// -----------------------------------------------
//ree domain
#define REE_SCPU2REE_CSR_ADDR                      ((0x0300  << 2) + 0xfe441000)
#define REE_SCPU2REE_DATA_ST_ADDR                  ((0x0380  << 2) + 0xfe441000)
#define REE_SCPU2REE_DATA_ED_ADDR                  ((0x039f  << 2) + 0xfe441000)
#define REE_REE2SCPU_CSR_ADDR                      ((0x0200  << 2) + 0xfe441000)
#define REE_REE2SCPU_DATA_ST_ADDR                  ((0x0280  << 2) + 0xfe441000)
#define REE_REE2SCPU_DATA_ED_ADDR                  ((0x029f  << 2) + 0xfe441000)
//tee domain
#define TEE_SCPU2TEE_CSR_ADDR                      ((0x0100  << 2) + 0xfe441000)
#define TEE_SCPU2TEE_DATA_ST_ADDR                  ((0x0180  << 2) + 0xfe441000)
#define TEE_SCPU2TEE_DATA_ED_ADDR                  ((0x019f  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_CSR_ADDR                      ((0x0000  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_DATA_ST_ADDR                  ((0x0080  << 2) + 0xfe441000)
#define TEE_TEE2SCPU_DATA_ED_ADDR                  ((0x009f  << 2) + 0xfe441000)
//========================================================================
// NSK REG - Registers
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe450000
// -----------------------------------------------
//
// Closing file:  ./REG_LIST_SECURITY_RTL.h
//
//`include "REG_LIST_DEMUX_RTL.h"
//========================================================================
//  MIPI_DSI_HOST
//========================================================================
//
// Reading file:  ./dsi_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
// MIPI DSI HOST A CONTROLLER Registers 0xfe01e000 - 0xfe01efff
//===========================================================================
//------------------------------------------------------------------------------
// DWC IP registers: Synopsys IP, please refer to MIPI DSI HOST Databook
//------------------------------------------------------------------------------
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe01e000
// -----------------------------------------------
#define MIPI_DSI_DWC_VERSION_OS                    ((0x0000  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PWR_UP_OS                     ((0x0001  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_CLKMGR_CFG_OS                 ((0x0002  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_DPI_VCID_OS                   ((0x0003  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_DPI_COLOR_CODING_OS           ((0x0004  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_DPI_CFG_POL_OS                ((0x0005  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_DPI_LP_CMD_TIM_OS             ((0x0006  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PCKHDL_CFG_OS                 ((0x000b  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_GEN_VCID_OS                   ((0x000c  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_MODE_CFG_OS                   ((0x000d  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_MODE_CFG_OS               ((0x000e  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_PKT_SIZE_OS               ((0x000f  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_NUM_CHUNKS_OS             ((0x0010  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_NULL_SIZE_OS              ((0x0011  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_HSA_TIME_OS               ((0x0012  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_HBP_TIME_OS               ((0x0013  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_HLINE_TIME_OS             ((0x0014  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_VSA_LINES_OS              ((0x0015  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_VBP_LINES_OS              ((0x0016  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_VFP_LINES_OS              ((0x0017  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_VID_VACTIVE_LINES_OS          ((0x0018  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_EDPI_CMD_SIZE_OS              ((0x0019  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_CMD_MODE_CFG_OS               ((0x001a  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_GEN_HDR_OS                    ((0x001b  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_GEN_PLD_DATA_OS               ((0x001c  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_CMD_PKT_STATUS_OS             ((0x001d  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_TO_CNT_CFG_OS                 ((0x001e  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_HS_RD_TO_CNT_OS               ((0x001f  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_LP_RD_TO_CNT_OS               ((0x0020  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_HS_WR_TO_CNT_OS               ((0x0021  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_LP_WR_TO_CNT_OS               ((0x0022  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_BTA_TO_CNT_OS                 ((0x0023  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_SDF_3D_OS                     ((0x0024  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_LPCLK_CTRL_OS                 ((0x0025  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_TMR_LPCLK_CFG_OS          ((0x0026  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_TMR_CFG_OS                ((0x0027  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_RSTZ_OS                   ((0x0028  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_IF_CFG_OS                 ((0x0029  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_ULPS_CTRL_OS              ((0x002a  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_TX_TRIGGERS_OS            ((0x002b  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_STATUS_OS                 ((0x002c  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_TST_CTRL0_OS              ((0x002d  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_PHY_TST_CTRL1_OS              ((0x002e  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_INT_ST0_OS                    ((0x002f  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_INT_ST1_OS                    ((0x0030  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_INT_MSK0_OS                   ((0x0031  << 2) + 0xfe01e000)
#define MIPI_DSI_DWC_INT_MSK1_OS                   ((0x0032  << 2) + 0xfe01e000)
//------------------------------------------------------------------------------
// Top-level registers: AmLogic proprietary
//------------------------------------------------------------------------------
#define MIPI_DSI_TOP_SHADOW_HSA_TIME               ((0x00e8  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_HBP_TIME               ((0x00e9  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_HLINE_TIME             ((0x00ea  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_VSA_LINES              ((0x00eb  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_VBP_LINES              ((0x00ec  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_VFP_LINES              ((0x00ed  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_VACTIVE_LINES          ((0x00ee  << 2) + 0xfe01e000)
#define MIPI_DSI_TOP_SHADOW_TIME_CTRL              ((0x00ef  << 2) + 0xfe01e000)
// 31: 4    Reserved.                                                                           Default 0.
//     3 RW ~tim_rst_n:  1=Assert SW reset on mipi_dsi_host_timing block.   0=Release reset.    Default 1.
//     2 RW ~dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.      0=Release reset.    Default 1.
//     1 RW ~intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.     0=Release reset.    Default 1.
//     0 RW ~dwc_rst_n:  1=Assert SW reset on IP core.                      0=Release reset.    Default 1.
#define MIPI_DSI_TOP_SW_RESET                      ((0x00f0  << 2) + 0xfe01e000)
// 31: 5    Reserved.                                                                                                       Default 0.
//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
//                          0=Default, use auto-clock gating to save power;
//                          1=use free-run clock, disable auto-clock gating, for debug mode.
//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
#define MIPI_DSI_TOP_CLK_CNTL                      ((0x00f1  << 2) + 0xfe01e000)
// 31:27    Reserved.                                                                       Default 0.
//    26 RW de_dpi_pol:     1= Invert DE polarity from mipi_dsi_host_dpi.                   Default 0.
//    25 RW hsync_dpi_pol:  1= Invert HS polarity from mipi_dsi_host_dpi.                   Default 0.
//    24 RW vsync_dpi_pol:  1= Invert VS polarity from mipi_dsi_host_dpi.                   Default 0.
// 23:20 RW dpi_color_mode: Define DPI pixel format.                                        Default 0.
//                           0=16-bit RGB565 config 1;
//                           1=16-bit RGB565 config 2;
//                           2=16-bit RGB565 config 3;
//                           3=18-bit RGB666 config 1;
//                           4=18-bit RGB666 config 2;
//                           5=24-bit RGB888;
//                           6=20-bit YCbCr 4:2:2;
//                           7=24-bit YCbCr 4:2:2;
//                           8=16-bit YCbCr 4:2:2;
//                           9=30-bit RGB;
//                          10=36-bit RGB;
//                          11=12-bit YCbCr 4:2:0.
//    19    Reserved.                                                                       Default 0.
// 18:16 RW in_color_mode:  Define VENC data width.                                         Default 0.
//                          0=30-bit pixel;
//                          1=24-bit pixel;
//                          2=18-bit pixel, RGB666;
//                          3=16-bit pixel, RGB565.
// 15:14 RW chroma_subsample: Define method of chroma subsampling.                          Default 0.
//                            Applicable to YUV422 or YUV420 only.
//                            0=Use even pixel's chroma;
//                            1=Use odd pixel's chroma;
//                            2=Use averaged value between even and odd pair.
// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.    Default 2.
// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.    Default 1.
//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.    Default 0.
//     7    Reserved.                                                                       Default 0.
//     6 RW de_venc_pol:    1= Invert DE polarity from VENC.                                Default 0.
//     5 RW hsync_venc_pol: 1= Invert HS polarity from VENC.                                Default 0.
//     4 RW vsync_venc_pol: 1= Invert VS polarity from VENC.                                Default 0.
//     3 RW dpicolorm:      Signal to IP.                                                   Default 0.
//     2 RW dpishutdn:      Signal to IP.                                                   Default 0.
//     1    Reserved.                                                                       Default 0.
//     0    Reserved.                                                                       Default 0.
#define MIPI_DSI_TOP_CNTL                          ((0x00f2  << 2) + 0xfe01e000)
// 31:16    Reserved.                                                                                                           Default 0.
// 15: 8 RW suspend_frame_rate: Define rate of timed-suspend.                                                                   Default 0.
//                              0=Execute suspend every frame; 1=Every other frame; ...; 255=Every 256 frame.
//  7: 4    Reserved.                                                                                                           Default 0.
//     3 RW disable suspend venc:   1=don`t support suspend VencL. 0=support suspend venc                                       Default 0.
//     2 RW timed_suspend_en:   1=Enable timed suspend VencL. 0=Disable timed suspend.                                          Default 0.
//     1 RW manual_suspend_en:  1=Enable manual suspend VencL. 1=Cancel manual suspend VencL.                                   Default 0.
//     0 RW suspend_on_edpihalt:1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL.   Default 1.
#define MIPI_DSI_TOP_SUSPEND_CNTL                  ((0x00f3  << 2) + 0xfe01e000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_line_end:   Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_line_start: Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_TOP_SUSPEND_LINE                  ((0x00f4  << 2) + 0xfe01e000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_pix_end:    Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_pix_start:  Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_TOP_SUSPEND_PIX                   ((0x00f5  << 2) + 0xfe01e000)
// 31:20    Reserved.                                                                                                           Default 0.
// 19:10 RW meas_vsync:     Control on measuring Host Controller's vsync.                                                       Default 0.
//                          [   19] meas_en:        1=Enable measurement
//                          [   18] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [17:10] vsync_span:     Define the duration of a measure is to last for how many Vsyncs.
//  9: 0 RW meas_edpite:    Control on measuring Display Slave's edpite.                                                        Default 0.
//                          [    9] meas_en:        1=Enable measurement
//                          [    8] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [ 7: 0] edpite_span:    Define the duration of a measure is to last for how many edpite.
#define MIPI_DSI_TOP_MEAS_CNTL                     ((0x00f6  << 2) + 0xfe01e000)
//    31 R  stat_edpihalt:  status of edpihalt signal from IP.              Default 0.
// 30:29    Reserved.                                                       Default 0.
// 28:16 R  stat_te_line:   Snapshot of Host's line position at edpite.     Default 0.
// 15:13    Reserved.                                                       Default 0.
// 12: 0 R  stat_te_pix:    Snapshot of Host's pixel position at edpite.    Default 0.
#define MIPI_DSI_TOP_STAT                          ((0x00f7  << 2) + 0xfe01e000)
// To measure display slave's frame rate, we can use a reference clock to measure the duration of one of more edpite pulse(s).
// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[9:0].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_TE0 and MIPI_DSI_TOP_MEAS_STAT_TE1, as below:
// edpite_meas_count[47:0]: Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// edpite_meas_count_n[3:0]:Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  edpite_meas_count[31:0].    Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_TE0                 ((0x00f8  << 2) + 0xfe01e000)
// 19:16 R  edpite_meas_count_n.        Default 0.
// 15: 0 R  edpite_meas_count[47:32].   Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_TE1                 ((0x00f9  << 2) + 0xfe01e000)
// To measure Host's frame rate, we can use a reference clock to measure the duration of one of more Vsync pulse(s).
// Measurement control is by register MIPI_DSI_TOP_MEAS_CNTL bit[19:10].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_TOP_MEAS_STAT_VS0 and MIPI_DSI_TOP_MEAS_STAT_VS1, as below:
// vsync_meas_count[47:0]:  Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// vsync_meas_count_n[3:0]: Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  vsync_meas_count[31:0].     Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_VS0                 ((0x00fa  << 2) + 0xfe01e000)
// 19:16 R  vsync_meas_count_n.         Default 0.
// 15: 0 R  vsync_meas_count[47:32].    Default 0.
#define MIPI_DSI_TOP_MEAS_STAT_VS1                 ((0x00fb  << 2) + 0xfe01e000)
// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
//                         Note: To clear the interrupt level, simply write 1 to the specific bit, no need to write 0 afterwards.
//          [31:22] Reserved
//          [   21] stat/clr of EOF interrupt
//          [   20] stat/clr of de_fall interrupt
//          [   19] stat/clr of de_rise interrupt
//          [   18] stat/clr of vs_fall interrupt
//          [   17] stat/clr of vs_rise interrupt
//          [   16] stat/clr of dwc_edpite interrupt
// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
//          [15: 6] Reserved
//          [    5] EOF (End_Of_Field) interrupt
//          [    4] de_fall interrupt
//          [    3] de_rise interrupt
//          [    2] vs_fall interrupt
//          [    1] vs_rise interrupt
//          [    0] dwc_edpite interrupt
#define MIPI_DSI_TOP_INTR_CNTL_STAT                ((0x00fc  << 2) + 0xfe01e000)
// 31: 2    Reserved.   Default 0.
//  1: 0 RW mem_pd.     Default 3.
#define MIPI_DSI_TOP_MEM_PD                        ((0x00fd  << 2) + 0xfe01e000)
//===========================================================================
// MIPI DSI HOST B CONTROLLER Registers 0xfe072000 - 0xfe072fff
//===========================================================================
//------------------------------------------------------------------------------
// DWC IP registers: Synopsys IP, please refer to MIPI DSI HOST Databook
//------------------------------------------------------------------------------
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe072000
// -----------------------------------------------
#define MIPI_DSI_B_DWC_VERSION_OS                  ((0x0000  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PWR_UP_OS                   ((0x0001  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CLKMGR_CFG_OS               ((0x0002  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_VCID_OS                 ((0x0003  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_COLOR_CODING_OS         ((0x0004  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_CFG_POL_OS              ((0x0005  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_DPI_LP_CMD_TIM_OS           ((0x0006  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PCKHDL_CFG_OS               ((0x000b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_VCID_OS                 ((0x000c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_MODE_CFG_OS                 ((0x000d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_MODE_CFG_OS             ((0x000e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_PKT_SIZE_OS             ((0x000f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_NUM_CHUNKS_OS           ((0x0010  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_NULL_SIZE_OS            ((0x0011  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HSA_TIME_OS             ((0x0012  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HBP_TIME_OS             ((0x0013  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_HLINE_TIME_OS           ((0x0014  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VSA_LINES_OS            ((0x0015  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VBP_LINES_OS            ((0x0016  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VFP_LINES_OS            ((0x0017  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_VID_VACTIVE_LINES_OS        ((0x0018  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_EDPI_CMD_SIZE_OS            ((0x0019  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CMD_MODE_CFG_OS             ((0x001a  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_HDR_OS                  ((0x001b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_GEN_PLD_DATA_OS             ((0x001c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_CMD_PKT_STATUS_OS           ((0x001d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_TO_CNT_CFG_OS               ((0x001e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_HS_RD_TO_CNT_OS             ((0x001f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LP_RD_TO_CNT_OS             ((0x0020  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_HS_WR_TO_CNT_OS             ((0x0021  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LP_WR_TO_CNT_OS             ((0x0022  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_BTA_TO_CNT_OS               ((0x0023  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_SDF_3D_OS                   ((0x0024  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_LPCLK_CTRL_OS               ((0x0025  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TMR_LPCLK_CFG_OS        ((0x0026  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TMR_CFG_OS              ((0x0027  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_RSTZ_OS                 ((0x0028  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_IF_CFG_OS               ((0x0029  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_ULPS_CTRL_OS            ((0x002a  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TX_TRIGGERS_OS          ((0x002b  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_STATUS_OS               ((0x002c  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TST_CTRL0_OS            ((0x002d  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_PHY_TST_CTRL1_OS            ((0x002e  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_ST0_OS                  ((0x002f  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_ST1_OS                  ((0x0030  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_MSK0_OS                 ((0x0031  << 2) + 0xfe072000)
#define MIPI_DSI_B_DWC_INT_MSK1_OS                 ((0x0032  << 2) + 0xfe072000)
//------------------------------------------------------------------------------
// Top-level registers: AmLogic proprietary
//------------------------------------------------------------------------------
#define MIPI_DSI_B_TOP_SHADOW_HSA_TIME             ((0x00e8  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_HBP_TIME             ((0x00e9  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_HLINE_TIME           ((0x00ea  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VSA_LINES            ((0x00eb  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VBP_LINES            ((0x00ec  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VFP_LINES            ((0x00ed  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_VACTIVE_LINES        ((0x00ee  << 2) + 0xfe072000)
#define MIPI_DSI_B_TOP_SHADOW_TIME_CTRL            ((0x00ef  << 2) + 0xfe072000)
// 31: 4    Reserved.                                                                           Default 0.
//     3 RW ~tim_rst_n:  1=Assert SW reset on mipi_dsi_host_timing block.   0=Release reset.    Default 1.
//     2 RW ~dpi_rst_n:  1=Assert SW reset on mipi_dsi_host_dpi block.      0=Release reset.    Default 1.
//     1 RW ~intr_rst_n: 1=Assert SW reset on mipi_dsi_host_intr block.     0=Release reset.    Default 1.
//     0 RW ~dwc_rst_n:  1=Assert SW reset on IP core.                      0=Release reset.    Default 1.
#define MIPI_DSI_B_TOP_SW_RESET                    ((0x00f0  << 2) + 0xfe072000)
// 31: 5    Reserved.                                                                                                       Default 0.
//     4 RW manual_edpihalt:  1=Manual suspend VencL; 0=do not suspend VencL.                                               Default 0.
//     3 RW auto_edpihalt_en: 1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL. Default 0.
//     2 RW clock_freerun: Apply to auto-clock gate only.                                                                   Default 0.
//                          0=Default, use auto-clock gating to save power;
//                          1=use free-run clock, disable auto-clock gating, for debug mode.
//     1 RW enable_pixclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable pixclk.      Default 0.
//     0 RW enable_sysclk: A manual clock gate option, due to DWC IP does not have auto-clock gating. 1=Enable sysclk.      Default 0.
#define MIPI_DSI_B_TOP_CLK_CNTL                    ((0x00f1  << 2) + 0xfe072000)
// 31:27    Reserved.                                                                       Default 0.
//    26 RW de_dpi_pol:     1= Invert DE polarity from mipi_dsi_host_dpi.                   Default 0.
//    25 RW hsync_dpi_pol:  1= Invert HS polarity from mipi_dsi_host_dpi.                   Default 0.
//    24 RW vsync_dpi_pol:  1= Invert VS polarity from mipi_dsi_host_dpi.                   Default 0.
// 23:20 RW dpi_color_mode: Define DPI pixel format.                                        Default 0.
//                           0=16-bit RGB565 config 1;
//                           1=16-bit RGB565 config 2;
//                           2=16-bit RGB565 config 3;
//                           3=18-bit RGB666 config 1;
//                           4=18-bit RGB666 config 2;
//                           5=24-bit RGB888;
//                           6=20-bit YCbCr 4:2:2;
//                           7=24-bit YCbCr 4:2:2;
//                           8=16-bit YCbCr 4:2:2;
//                           9=30-bit RGB;
//                          10=36-bit RGB;
//                          11=12-bit YCbCr 4:2:0.
//    19    Reserved.                                                                       Default 0.
// 18:16 RW in_color_mode:  Define VENC data width.                                         Default 0.
//                          0=30-bit pixel;
//                          1=24-bit pixel;
//                          2=18-bit pixel, RGB666;
//                          3=16-bit pixel, RGB565.
// 15:14 RW chroma_subsample: Define method of chroma subsampling.                          Default 0.
//                            Applicable to YUV422 or YUV420 only.
//                            0=Use even pixel's chroma;
//                            1=Use odd pixel's chroma;
//                            2=Use averaged value between even and odd pair.
// 13:12 RW comp2_sel:  Select which component to be Cr or B: 0=comp0; 1=comp1; 2=comp2.    Default 2.
// 11:10 RW comp1_sel:  Select which component to be Cb or G: 0=comp0; 1=comp1; 2=comp2.    Default 1.
//  9: 8 RW comp0_sel:  Select which component to be Y  or R: 0=comp0; 1=comp1; 2=comp2.    Default 0.
//     7    Reserved.                                                                       Default 0.
//     6 RW de_venc_pol:    1= Invert DE polarity from VENC.                                Default 0.
//     5 RW hsync_venc_pol: 1= Invert HS polarity from VENC.                                Default 0.
//     4 RW vsync_venc_pol: 1= Invert VS polarity from VENC.                                Default 0.
//     3 RW dpicolorm:      Signal to IP.                                                   Default 0.
//     2 RW dpishutdn:      Signal to IP.                                                   Default 0.
//     1    Reserved.                                                                       Default 0.
//     0    Reserved.                                                                       Default 0.
#define MIPI_DSI_B_TOP_CNTL                        ((0x00f2  << 2) + 0xfe072000)
// 31:16    Reserved.                                                                                                           Default 0.
// 15: 8 RW suspend_frame_rate: Define rate of timed-suspend.                                                                   Default 0.
//                              0=Execute suspend every frame; 1=Every other frame; ...; 255=Every 256 frame.
//  7: 4    Reserved.                                                                                                           Default 0.
//     3 RW disable suspend venc:   1=don`t support suspend VencL. 0=support suspend venc                                       Default 0.
//     2 RW timed_suspend_en:   1=Enable timed suspend VencL. 0=Disable timed suspend.                                          Default 0.
//     1 RW manual_suspend_en:  1=Enable manual suspend VencL. 1=Cancel manual suspend VencL.                                   Default 0.
//     0 RW suspend_on_edpihalt:1=Enable IP's edpihalt signal to suspend VencL; 0=IP's edpihalt signal does not affect VencL.   Default 1.
#define MIPI_DSI_B_TOP_SUSPEND_CNTL                ((0x00f3  << 2) + 0xfe072000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_line_end:   Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_line_start: Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_B_TOP_SUSPEND_LINE                ((0x00f4  << 2) + 0xfe072000)
// 31:29    Reserved.                                                                                                           Default 0.
// 28:16 RW suspend_pix_end:    Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
// 15:13    Reserved.                                                                                                           Default 0.
// 12: 0 RW suspend_pix_start:  Define timed-suspend region. Suspend from [pix_start,line_start] to [pix_end,line_end].         Default 0.
#define MIPI_DSI_B_TOP_SUSPEND_PIX                 ((0x00f5  << 2) + 0xfe072000)
// 31:20    Reserved.                                                                                                           Default 0.
// 19:10 RW meas_vsync:     Control on measuring Host Controller's vsync.                                                       Default 0.
//                          [   19] meas_en:        1=Enable measurement
//                          [   18] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [17:10] vsync_span:     Define the duration of a measure is to last for how many Vsyncs.
//  9: 0 RW meas_edpite:    Control on measuring Display Slave's edpite.                                                        Default 0.
//                          [    9] meas_en:        1=Enable measurement
//                          [    8] accum_meas_en:  0=meas_count is cleared at the end of each measure;
//                                                  1=meas_count is accumulated at the end of each measure.
//                          [ 7: 0] edpite_span:    Define the duration of a measure is to last for how many edpite.
#define MIPI_DSI_B_TOP_MEAS_CNTL                   ((0x00f6  << 2) + 0xfe072000)
//    31 R  stat_edpihalt:  status of edpihalt signal from IP.              Default 0.
// 30:29    Reserved.                                                       Default 0.
// 28:16 R  stat_te_line:   Snapshot of Host's line position at edpite.     Default 0.
// 15:13    Reserved.                                                       Default 0.
// 12: 0 R  stat_te_pix:    Snapshot of Host's pixel position at edpite.    Default 0.
#define MIPI_DSI_B_TOP_STAT                        ((0x00f7  << 2) + 0xfe072000)
// To measure display slave's frame rate, we can use a reference clock to measure the duration of one of more edpite pulse(s).
// Measurement control is by register MIPI_DSI_B_TOP_MEAS_CNTL bit[9:0].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_B_TOP_MEAS_STAT_TE0 and MIPI_DSI_B_TOP_MEAS_STAT_TE1, as below:
// edpite_meas_count[47:0]: Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// edpite_meas_count_n[3:0]:Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  edpite_meas_count[31:0].    Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_TE0               ((0x00f8  << 2) + 0xfe072000)
// 19:16 R  edpite_meas_count_n.        Default 0.
// 15: 0 R  edpite_meas_count[47:32].   Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_TE1               ((0x00f9  << 2) + 0xfe072000)
// To measure Host's frame rate, we can use a reference clock to measure the duration of one of more Vsync pulse(s).
// Measurement control is by register MIPI_DSI_B_TOP_MEAS_CNTL bit[19:10].
// Reference clock comes from clk_rst_tst.cts_dsi_meas_clk, and is defined by HIU register HHI_VDIN_MEAS_CLK_CNTL bit[23:12].
// Mesurement result is in MIPI_DSI_B_TOP_MEAS_STAT_VS0 and MIPI_DSI_B_TOP_MEAS_STAT_VS1, as below:
// vsync_meas_count[47:0]:  Number of reference clock cycles counted during one measure period (non-incremental measure), or
//                          during all measure periods so far (incremental measure).
// vsync_meas_count_n[3:0]: Number of measure periods has been done. Number can wrap over.
//
// 31: 0 R  vsync_meas_count[31:0].     Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_VS0               ((0x00fa  << 2) + 0xfe072000)
// 19:16 R  vsync_meas_count_n.         Default 0.
// 15: 0 R  vsync_meas_count[47:32].    Default 0.
#define MIPI_DSI_B_TOP_MEAS_STAT_VS1               ((0x00fb  << 2) + 0xfe072000)
// 31:16 RW intr_stat/clr. For each bit, read as this interrupt level status, write 1 to clear. Default 0.
//                         Note: To clear the interrupt level, simply write 1 to the specific bit, no need to write 0 afterwards.
//          [31:22] Reserved
//          [   21] stat/clr of EOF interrupt
//          [   20] stat/clr of de_fall interrupt
//          [   19] stat/clr of de_rise interrupt
//          [   18] stat/clr of vs_fall interrupt
//          [   17] stat/clr of vs_rise interrupt
//          [   16] stat/clr of dwc_edpite interrupt
// 15: 0 RW intr_enable. For each bit, 1=enable this interrupt, 0=disable.                      Default 0.
//          [15: 6] Reserved
//          [    5] EOF (End_Of_Field) interrupt
//          [    4] de_fall interrupt
//          [    3] de_rise interrupt
//          [    2] vs_fall interrupt
//          [    1] vs_rise interrupt
//          [    0] dwc_edpite interrupt
#define MIPI_DSI_B_TOP_INTR_CNTL_STAT              ((0x00fc  << 2) + 0xfe072000)
// 31: 2    Reserved.   Default 0.
//  1: 0 RW mem_pd.     Default 3.
#define MIPI_DSI_B_TOP_MEM_PD                      ((0x00fd  << 2) + 0xfe072000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./dsi_regs.h
//
//========================================================================
//  CVE
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe046400
// -----------------------------------------------
//
// Reading file:  ./cve_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_TOP_CTRL_REG0                          ((0x0000  << 2) + 0xfe046400)
//Bit 31: 1        reserved
//Bit  0           reg_cve_start             // unsigned ,    RW, default = 0  rising edge start cve core, need to implement this functionality
#define CVE_TOP_CTRL_REG1                          ((0x0001  << 2) + 0xfe046400)
//Bit 31: 0        reserved
#define CVE_COMMON_CTRL_REG0                       ((0x0002  << 2) + 0xfe046400)
//Bit 31:24        reg_cve_ops               // unsigned ,    RW, default = 0  which ops,default: 1
//Bit 23:21        reserved
//Bit 20:16        reg_src_image_type        // unsigned ,    RW, default = 0  1:S8C1,  2:YUV420SP,      3:YUV422SP,    4:YUV420P, 5:YUV422P, 6:S8C2_PACKAGE,  7:S8C2_PLANAR, 8:S16C1,
//Bit 15:13        reserved
//Bit 12: 8        reg_dst_image_type        // unsigned ,    RW, default = 0  same as reg_src_image_type
//Bit  7: 5        reserved
//Bit  4           reg_yuv_image_type        // unsigned ,    RW, default = 0  0: NV21, 1:Nv12, default: 0
//Bit  3: 2        reserved
//Bit  1           reg_compat_input_mode     // unsigned ,    RW, default = 0  0: input data is u8 0 or 255 , 1: input data is u1, 0 or 1
//Bit  0           reg_compat_output_mode    // unsigned ,    RW, default = 0  0: output data is u8 0 or 255, 1: output data is u1, 0 or 1
#define CVE_COMMON_CTRL_REG1_0                     ((0x0003  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_0             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_1                     ((0x0004  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_1             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_2                     ((0x0005  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_2             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_3                     ((0x0006  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_3             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_4                     ((0x0007  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_4             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_5                     ((0x0008  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_5             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_6                     ((0x0009  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_6             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG1_7                     ((0x000a  << 2) + 0xfe046400)
//Bit 31: 0        reg_src_ptr_7             // unsigned ,    RW, default = 32'hffffffff)  array to src image,data or mem
#define CVE_COMMON_CTRL_REG2_0                     ((0x000b  << 2) + 0xfe046400)
//Bit 31: 0        reg_dst_ptr_0             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_1                     ((0x000c  << 2) + 0xfe046400)
//Bit 31: 0        reg_dst_ptr_1             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_2                     ((0x000d  << 2) + 0xfe046400)
//Bit 31: 0        reg_dst_ptr_2             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_3                     ((0x000e  << 2) + 0xfe046400)
//Bit 31: 0        reg_dst_ptr_3             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG2_4                     ((0x000f  << 2) + 0xfe046400)
//Bit 31: 0        reg_dst_ptr_4             // unsigned ,    RW, default = 32'hffffffff)  array to dst image,data or mem
#define CVE_COMMON_CTRL_REG3_0                     ((0x0010  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_0          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_1          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_1                     ((0x0011  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_2          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_3          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_2                     ((0x0012  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_4          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_5          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG3_3                     ((0x0013  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_src_stride_6          // unsigned ,    RW, default = 1920  to src image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_src_stride_7          // unsigned ,    RW, default = 1920  to src image stride
#define CVE_COMMON_CTRL_REG4_0                     ((0x0014  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_0          // unsigned ,    RW, default = 1920  to dst image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_dst_stride_1          // unsigned ,    RW, default = 1920  to dst image stride
#define CVE_COMMON_CTRL_REG4_1                     ((0x0015  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_2          // unsigned ,    RW, default = 1920  to dst image stride
//Bit 15:13        reserved
//Bit 12: 0        reg_dst_stride_3          // unsigned ,    RW, default = 1920  to dst image stride
#define CVE_COMMON_CTRL_REG5                       ((0x0016  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28:16        reg_dst_stride_4          // unsigned ,    RW, default = 1920
//Bit 15: 0        reserved
#define CVE_COMMON_CTRL_REG6                       ((0x0017  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:16        reg_src_width             // unsigned ,    RW, default = 1920  src image width , default:1920,use in dma
//Bit 15:14        reserved
//Bit 13: 0        reg_src_height            // unsigned ,    RW, default = 1080  src image height, default:1080,use in dma
#define CVE_COMMON_CTRL_REG7                       ((0x0018  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:16        reg_dst_width             // unsigned ,    RW, default = 1920  dst image width , default:1920,use in dma
//Bit 15:14        reserved
//Bit 13: 0        reg_dst_height            // unsigned ,    RW, default = 1080  dst image height, default:1080,use in dma
#define CVE_COMMON_CTRL_REG8                       ((0x0019  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:16        reg_cve_crop_xstart       // unsigned ,    RW, default = 0  crop image, start x, image size:1920x1080(2^11=2048),default : 0
//Bit 15:14        reserved
//Bit 13: 0        reg_cve_crop_ystart       // unsigned ,    RW, default = 0  start y,default:0
#define CVE_COMMON_CTRL_REG9                       ((0x001a  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:16        reg_cve_crop_xsize        // unsigned ,    RW, default = 1920  crop image, size  x,default:1920
//Bit 15:14        reserved
//Bit 13: 0        reg_cve_crop_ysize        // unsigned ,    RW, default = 1080  crop image, size  y,default:1080
#define CVE_DMA_REG0                               ((0x001b  << 2) + 0xfe046400)
//Bit 31            reserved
//Bit 30:28        reg_dma_mode_ctrl         // unsigned ,    RW, default = 0  0:direct memory copy, 1:copy with interval bytes; 2,memset using 3 bytes; 3:memset using 8 bytes; 4:not; 5:luma; default:0
//Bit 27:25        reserved
//Bit 24           reg_dma_set_endmode       // unsigned ,    RW, default = 0  or smallend, 0,set 3byte,  u64val = 0x12345678,char[0]=0x78,char[1]=0x56,char[2]=0x34,char[3]=0x12,
//Bit 23:16        reg_dma_interval_elemsize // unsigned ,    RW, default = 1  default:1
//Bit 15: 8        reg_dma_interval_hsegsize // unsigned ,    RW, default = 2  default:2
//Bit  7: 0        reg_dma_interval_vsegsize // unsigned ,    RW, default = 1  default:1
#define CVE_DMA_REG1                               ((0x001c  << 2) + 0xfe046400)
//Bit 31: 0        reg_dma_set_u64val_lsb    // unsigned ,    RW, default = 32'h11223344
#define CVE_DMA_REG2                               ((0x001d  << 2) + 0xfe046400)
//Bit 31: 0        reg_dma_set_u64val_msb    // unsigned ,    RW, default = 32'h55667788
#define CVE_DMA_REG3                               ((0x001e  << 2) + 0xfe046400)
//Bit 31:30        reg_cve_caption_stat_step // unsigned ,    RW, default = 0  step: 0,1,2,3;  model:1/1, 1/2, 1/3,1/4
//Bit 29:16        reg_dma_interval_xlength  // unsigned ,    RW, default = 960
//Bit 15: 8        reg_cve_caption_stat_winidx // unsigned ,    RW, default = 0  [0,254], current window idx, reg_cve_caption_stat_winidx < reg_cve_caption_stat_wincnt
//Bit  7: 0        reg_cve_caption_stat_wincnt // unsigned ,    RW, default = 255  [1,255], maximum 255 windows
#define CVE_FILTER_REG2                            ((0x001f  << 2) + 0xfe046400)
//Bit 31:25        reserved
//Bit 24           reg_filter_uv             // unsigned ,    RW, default = 0  uv, 1:filter, 0:no
//Bit 23:22        reserved
//Bit 21:16        reg_filter_norm_uv        // unsigned ,    RW, default = 0  then right shift for norm.
//Bit 15: 0        reserved
#define CVE_FILTER_REG1_0                          ((0x0020  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_uv_3      // signed ,    RW, default = 0  fitter weight
//Bit 23:16        reg_filter_coef_uv_2      // signed ,    RW, default = 0  fitter weight
//Bit 15: 8        reg_filter_coef_uv_1      // signed ,    RW, default = 0  fitter weight
//Bit  7: 0        reg_filter_coef_uv_0      // signed ,    RW, default = 0  fitter weight
#define CVE_FILTER_REG1_1                          ((0x0021  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_uv_7      // signed ,    RW, default = 0  fitter weight
//Bit 23:16        reg_filter_coef_uv_6      // signed ,    RW, default = 0  fitter weight
//Bit 15: 8        reg_filter_coef_uv_5      // signed ,    RW, default = 0  fitter weight
//Bit  7: 0        reg_filter_coef_uv_4      // signed ,    RW, default = 0  fitter weight
#define CVE_FILTER_REG2_3                          ((0x0022  << 2) + 0xfe046400)
//Bit 31: 8        reserved
//Bit  7: 0        reg_filter_coef_uv_8      // signed ,    RW, default = 0  fitter weight
#define CVE_CSC_REG0                               ((0x0023  << 2) + 0xfe046400)
//Bit 31            reserved
//Bit 30:28        reg_csc_mode              // unsigned ,    RW, default = 0  1:YUV2HSV,2:YUV2LAB, 3:RGB2YUV, 4:RGB2HSV,5:RGB2LAB
//Bit 27:25        reserved
//Bit 24           reg_csc_gamma             // unsigned ,    RW, default = 1  gamma 1:have gamma
//Bit 23            reserved
//Bit 22:20        reg_csc_yuv422toyuv444_mode // unsigned ,    RW, default = 0  yuv4222yuv444,  0:repeat, 1:even repeat, odd avg, 2:even avg, odd repeat, 3:1:2:1, 4:3:1 5:3:1
//Bit 19            reserved
//Bit 18:16        reg_csc_yuv420toyuv422_mode // unsigned ,    RW, default = 0  yuv4202yuv422, 0:repeat, 1:even repeat, odd avg, 2:even avg, odd repeat, 3:1:3, 4:3:1
//Bit 15            reserved
//Bit 14:12        reg_csc_yuv444toyuv422_mode // unsigned ,    RW, default = 0  yuv4442yuv422, 0:even repeat, 1:odd repeat, 2:avg, 3:1:2:1 left center right, 4:1:2:1 center right right+1
//Bit 11            reserved
//Bit 10: 8        reg_csc_yuv422toyuv420_mode // unsigned ,    RW, default = 0  yuv4222yuv420,0:even repeat, 1:odd repeat, 2:1:2:1 even, 3:1:2:1 odd,  4:even avg, 5:odd avg
//Bit  7: 0        reserved
#define CVE_CSC_REG                                ((0x0024  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_src_u6order           // unsigned ,    RW, default = 6'h24
//Bit 23:22        reserved
//Bit 21:16        reg_dst_u6order           // unsigned ,    RW, default = 6'h24
//Bit 15: 0        reserved
#define CVE_SOBEL_REG0                             ((0x0025  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_sobel_output_mode     // unsigned ,    RW, default = 0  0: output  horizontal and vertical; 1:output horizontal; 2:output vertical, default:0
//Bit 23: 0        reserved
#define CVE_MAGANDANG_REG0                         ((0x0026  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_magandang_output_ctrl // unsigned ,    RW, default = 0  0: only magnitude output; 1:magnitude and angle output, 2: hog
//Bit 23:17        reserved
//Bit 16           reg_magandang_mode        // unsigned ,    RW, default = 0  0:8 directions, 1: 9 directions, default :0
//Bit 15: 0        reg_magandang_u16thr      // unsigned ,    RW, default = 1024
#define CVE_BGMODE_REG0                            ((0x0027  << 2) + 0xfe046400)
//Bit 31:28        reserved
//Bit 27:16        reg_bgmodel_u8q4dist_thr  // unsigned ,    RW, default = 400  Threshold
//Bit 15: 8        reg_bgmodel_u8gray_thr    // unsigned ,    RW, default = 20  for current frame subtract background
//Bit  7: 6        reserved
//Bit  5: 4        reg_bgmodel_output_ctrl   // unsigned ,    RW, default = 2  fg;1:output fg and bg; 2:output fg,bg and fg_gray; 3:output fg,bg,fg_gray and two frame diff
//Bit  3: 2        reserved
//Bit  1: 0        reg_bgmodel_ds_mode       // unsigned ,    RW, default = 0  sample mode;0:not downsampling;1:2*2;2:4*4. default:0
#define CVE_BGMODE_REG1                            ((0x0028  << 2) + 0xfe046400)
//Bit 31: 0        ro_bgmodel_fg_pix_num     // unsigned ,    RO, default = 0  of foreground pixel
#define CVE_BGMODE_REG2                            ((0x0029  << 2) + 0xfe046400)
//Bit 31: 0        ro_bgmodel_sum_lum        // unsigned ,    RO, default = 0  of all pixel value
#define CVE_UPDATEBGMODE_REG0                      ((0x002a  << 2) + 0xfe046400)
//Bit 31:16        reg_updatebgmodel_u16del_thr // unsigned ,    RW, default = 1000  threshold
//Bit 15: 0        reg_updatebgmodel_u16frq_thr // unsigned ,    RW, default = 200  threshold
#define CVE_UPDATEBGMODE_REG1                      ((0x002b  << 2) + 0xfe046400)
//Bit 31:16        reg_updatebgmodel_u16interval_thr // unsigned ,    RW, default = 40  threshold
//Bit 15: 0        reg_updatebgmodel_u0q16lr // unsigned ,    RW, default = 1310  rate
#define CVE_UPDATEBGMODE_REG2                      ((0x002c  << 2) + 0xfe046400)
//Bit 31: 0        ro_updatebgmodel_bg_pix_num // unsigned ,    RO, default = 0  of background pixel
#define CVE_UPDATEBGMODE_REG3                      ((0x002d  << 2) + 0xfe046400)
//Bit 31: 0        ro_updatebgmodel_bg_sum_lum // unsigned ,    RO, default = 0  of background pixel value
#define CVE_ERODEDILATE_REG0                       ((0x002e  << 2) + 0xfe046400)
//Bit 31: 1        reserved
//Bit  0           reg_erodedilate_sel       // unsigned ,    RW, default = 0  ErodeOrDilate op sel, 0: do Erode op, 1: do Dilate op
#define CVE_THRESH_REG0                            ((0x002f  << 2) + 0xfe046400)
//Bit 31:27        reserved
//Bit 26:24        reg_thresh_mode           // unsigned ,    RW, default = 0  0:binary; 1:trunc; 2: TO_MINVAL, 3:MIN_MID_MAX; 4:ORI_MID_MAX; 5:MIN_MID_ORI; 6:MIN_ORI_MAX; 7: ORI_MID_ORI, default:0
//Bit 23:16        reg_thresh_u8max_val      // unsigned ,    RW, default = 128
//Bit 15: 0        reserved
#define CVE_THRESH_REG1                            ((0x0030  << 2) + 0xfe046400)
//Bit 31:24        reg_thresh_u8low_thr      // unsigned ,    RW, default = 128
//Bit 23:16        reg_thresh_u8high_thr     // unsigned ,    RW, default = 128
//Bit 15: 8        reg_thresh_u8min_val      // unsigned ,    RW, default = 128
//Bit  7: 0        reg_thresh_u8mid_val      // unsigned ,    RW, default = 128
#define CVE_ALU_REG0                               ((0x0031  << 2) + 0xfe046400)
//Bit 31:19        reserved
//Bit 18:16        reg_cve_alu_sel           // unsigned ,    RW, default = 0  0:sub, 1:or, 2:xor, 3:and, 4:add, 5:add_map_255to1
//Bit 15:10        reserved
//Bit  9: 8        reg_sub_output_mode       // unsigned ,    RW, default = 0  0:abs, 1:shift, 2: thresh, default:0
//Bit  7: 0        reserved
#define CVE_ALU_REG1                               ((0x0032  << 2) + 0xfe046400)
//Bit 31:16        reg_add_u0q16x            // unsigned ,    RW, default = 0
//Bit 15: 0        reg_add_u0q16y            // unsigned ,    RW, default = 65535
#define CVE_INTEG_REG0                             ((0x0033  << 2) + 0xfe046400)
//Bit 31:18        reserved
//Bit 17:16        reg_integ_out_ctrl        // unsigned ,    RW, default = 0  0: combine, 1:sum; 2:sqsum,default:0
//Bit 15: 1        reserved
//Bit  0           reg_eqhist_curv_mode      // unsigned ,    RW, default = 0  0:fw calc, 1:hw calc, default:0
#define CVE_EQHIST_REG0                            ((0x0034  << 2) + 0xfe046400)
//Bit 31: 0        reg_eqhist_norm           // unsigned ,    RW, default = 2071  (1<<32) / height /width
#define CVE_THRESHS16_REG0                         ((0x0035  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_thresh_s16tos8oru8_mode // unsigned ,    RW, default = 0  default:0, 0:THRESH_S16TOS8_MIN_MID_MAX,1:THRESH_S16TOS8_MIN_ORI_MAX,2:THRESH_S16TOU8_MIN_MID_MAX,3:THRESH_S16TOU8_MIN_ORI_MAX
//Bit 23:16        reg_thresh_min_val        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_thresh_mid_val        // unsigned ,    RW, default = 128
//Bit  7: 0        reg_thresh_max_val        // unsigned ,    RW, default = 255
#define CVE_THRESHS16_REG1                         ((0x0036  << 2) + 0xfe046400)
//Bit 31:16        reg_thresh_s16lowthr      // signed ,    RW, default = 0
//Bit 15: 0        reg_thresh_s16highthr     // signed ,    RW, default = 127
#define CVE_THRESHU16_REG0                         ((0x0037  << 2) + 0xfe046400)
//Bit 31:25        reserved
//Bit 24           reg_thresh_u16tou8_mode   // unsigned ,    RW, default = 0  0:u16 To U8 Min_Mid_Max; 1:U16 To U8 Min_Ori_Max
//Bit 23:16        reg_thresh_u16_u8min_val  // unsigned ,    RW, default = 0
//Bit 15: 8        reg_thresh_u16_u8mid_val  // unsigned ,    RW, default = 0
//Bit  7: 0        reg_thresh_u16_u8max_val  // unsigned ,    RW, default = 0
#define CVE_THRESHU16_REG1                         ((0x0038  << 2) + 0xfe046400)
//Bit 31:16        reg_thresh_u16_u16lowthr  // unsigned ,    RW, default = 0
//Bit 15: 0        reg_thresh_u16_u16highthr // unsigned ,    RW, default = 0
#define CVE_16BITTO8BIT_REG0                       ((0x0039  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_16bitto8bit_mode      // unsigned ,    RW, default = 0  1:S16TOU8_ABS; 2:S16TOU8_BIAS; 3:U16TOU8
//Bit 23: 0        reserved
#define CVE_16BITTO8BIT_REG1                       ((0x003a  << 2) + 0xfe046400)
//Bit 31:16        reg_16bitto8bit_u0q16norm // unsigned ,    RW, default = 65535
//Bit 15: 8        reserved
//Bit  7: 0        reg_16bitto8bit_s8bias    // signed ,    RW, default = 20
#define CVE_STATFILTER_REG0                        ((0x003b  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_stat_filter_outnum    // unsigned ,    RW, default = 1  1:output a result 2:output two results 3:output three results
//Bit 23:20        reserved
//Bit 19:16        reg_stat_filter_outidx0   // unsigned ,    RW, default = 0  0:filter mode min, 4:filter mode median, 8:filter mode max
//Bit 15:12        reserved
//Bit 11: 8        reg_stat_filter_outidx1   // unsigned ,    RW, default = 4  0:filter mode min, 4:filter mode median, 8:filter mode max
//Bit  7: 4        reserved
//Bit  3: 0        reg_stat_filter_outidx2   // unsigned ,    RW, default = 8  0:filter mode min, 4:filter mode median, 8:filter mode max
#define CVE_MAP_REG0                               ((0x003c  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_map_mode              // unsigned ,    RW, default = 0  0:U8, 1:S16; 2:U16,default:0
//Bit 23:16        reg_ncc_offset0           // unsigned ,    RW, default = 0  only CVE_NCC_SIMILAR mode need to add a offset  //CVE_NCC
//Bit 15: 8        reg_ncc_offset1           // unsigned ,    RW, default = 0  only CVE_NCC_SIMILAR mode need to add a offset
//Bit  7: 1        reserved
//Bit  0           reg_ncc_mode              // unsigned ,    RW, default = 0  0:CVE_NCC_COM, 1:CVE_NCC_SIMILAR
#define CVE_NCC_U64NUM_0                           ((0x003d  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32numerator_lsb   // unsigned ,    RO, default = 0
#define CVE_NCC_U64NUM_1                           ((0x003e  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32numerator_msb   // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM1_0                      ((0x003f  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32quadsum1_lsb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM1_1                      ((0x0040  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32quadsum1_msb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM2_0                      ((0x0041  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32quadsum2_lsb    // unsigned ,    RO, default = 0
#define CVE_NCC_U64QUADSUM2_1                      ((0x0042  << 2) + 0xfe046400)
//Bit 31: 0        ro_ncc_u32quadsum2_msb    // unsigned ,    RO, default = 0
#define CVE_CCL_REG0                               ((0x0043  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reserved
//Bit 15: 9        reserved
//Bit  8: 0        ro_ccl_sum                // unsigned ,    RO, default = 128  max = 383,output,ro
#define CVE_GMM_REG0                               ((0x0044  << 2) + 0xfe046400)
//Bit 31:16        reg_gmm_u0q16learnrate    // unsigned ,    RW, default = 1024  rate,default:1024
//Bit 15: 0        reg_gmm_u0q16initweight   // unsigned ,    RW, default = 1024  Weight,default:1024
#define CVE_GMM_REG1                               ((0x0045  << 2) + 0xfe046400)
//Bit 31:29        reserved
//Bit 28           reg_gmm_output_bg_en      // unsigned ,    RW, default = 0  0:output fg only; 1:output fg and bg,default:0
//Bit 27:26        reserved
//Bit 25:24        reg_gmm_ds_mode           // unsigned ,    RW, default = 0  Down sample mode; 0: not downsampling;1:2*2;2:4*4,default:0
//Bit 23:16        reserved
//Bit 15: 0        reg_gmm_u10q6sigma_init   // unsigned ,    RW, default = 6400  Initial noise variance
#define CVE_GMM_REG2                               ((0x0046  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 8        reg_gmm_u10q6sigma_max    // unsigned ,    RW, default = 12800  Maximum variance
//Bit  7            reserved
//Bit  6: 4        reg_gmm_u3modelnum        // unsigned ,    RW, default = 5  The number of models per pixel,1~5, 3 or 5 is recommended
//Bit  3: 2        reserved
//Bit  1: 0        reg_gmm_u2nchannels       // unsigned ,    RW, default = 3  input channel
#define CVE_GMM_REG3                               ((0x0047  << 2) + 0xfe046400)
//Bit 31:16        reg_gmm_u10q6sigma_min    // unsigned ,    RW, default = 3840  Minimum variance
//Bit 15:12        reserved
//Bit 11: 0        reg_gmm_modellen_in128b   // unsigned ,    RW, default = 0  much 16bytes is there in a row, rtl use, reg_gmm_modellen_in128b = (scale *xsize * (1 + reg_gmmu3modelnum*4) + 15 ) >> 4, scale = (reg_gmm_downsamplemode == 0) ? 1  : (reg_gmm_downsamplemode = 1) ? (1/2) : (1/4)
#define CVE_GMM_REG4                               ((0x0048  << 2) + 0xfe046400)
//Bit 31:16        reg_gmm_u0q16weight_sum_thr // unsigned ,    RW, default = 58900  Weights threshold,
//Bit 15:10        reserved
//Bit  9: 0        reg_gmm_u3q7sigma_scale   // unsigned ,    RW, default = 256  scale,default:256
#define CVE_GMM_REG5                               ((0x0049  << 2) + 0xfe046400)
//Bit 31           reg_gmm_sns_factor_mode_en // unsigned ,    RW, default = 0  0:global sensitivity mode; 1:pixel sensitivity mode
//Bit 30:24        reserved
//Bit 23           reg_gmm_acc_lr_en         // unsigned ,    RW, default = 1  1:Use fast learning; 0:not use                                                           //u1
//Bit 22:16        reserved
//Bit 15           reg_gmm_update_factor_mode_en // unsigned ,    RW, default = 0  0:global update mode; 1:pixel update mode
//Bit 14:12        reserved
//Bit 11: 0        reg_gmm_piclen_in128b     // unsigned ,    RW, default = 360  ceil(image_width*channel_num / 16)
#define CVE_CANNY_REG0                             ((0x004a  << 2) + 0xfe046400)
//Bit 31:16        reg_canny_u16lowthr       // unsigned ,    RW, default = 30  Low threshold,default:30
//Bit 15: 0        reg_canny_u16highthr      // unsigned ,    RW, default = 70  high threshold,default:70
#define CVE_CANNY_REG1                             ((0x004b  << 2) + 0xfe046400)
//Bit 31: 0        ro_canny_count            // unsigned ,    RO, default = 0  points count
#define CVE_CANNY_REG2                             ((0x004c  << 2) + 0xfe046400)
//Bit 31:25        reserved
//Bit 24           reg_canny_gauss_en        // unsigned ,    RW, default = 0  [0,1] 0: don't need to do gaussian filter, 1: need to do gaussian filter
//Bit 23: 0        reserved
#define CVE_LBP_REG0                               ((0x004d  << 2) + 0xfe046400)
//Bit 31:25        reserved
//Bit 24           reg_cmp_mode              // unsigned ,    RW, default = 0  0:P(x) - P(center) >= un8BitThr.s8Val, s(x) = 1 ;else s(x) = 0;  1:Abs(P(x) - P(center)) >= un8BitThr.u8Val, s(x) = 1; else s(x) = 0;
//Bit 23:16        reg_u8bitthr              // unsigned ,    RW, default = 40  thr, default:40
//Bit 15: 0        reserved
#define CVE_NORMGRAD_REG0                          ((0x004e  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:28        reg_normgrad_outmode      // unsigned ,    RW, default = 0  and ver out; 1:hor;  2: ver,  3:combine,default:0
//Bit 27:24        reserved
//Bit 23:16        reg_normgrad_u8norm       // unsigned ,    RW, default = 0
//Bit 15: 0        reserved
#define CVE_BDLK_REG0                              ((0x004f  << 2) + 0xfe046400)
//Bit 31:27        reserved
//Bit 26:24        reg_bdlk_maxLevel         // unsigned ,    RW, default = 3  height [0,3]
//Bit 23:16        reserved
//Bit 15:10        reserved
//Bit  9: 0        reserved
#define CVE_LK_REG0                                ((0x0050  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_lk_mode               // unsigned ,    RW, default = 0  output error or not,0:not,2:output error,default:0
//Bit 23:17        reserved
//Bit 16           reg_lk_buseinitflow       // unsigned ,    RW, default = 0  Whether to use initial flow
//Bit 15:10        reserved
//Bit  9: 0        reg_lk_u10pstnum          // unsigned ,    RW, default = 100  of feature points, <=500
#define CVE_LK_REG1                                ((0x0051  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_lk_u2maxlevel         // unsigned ,    RW, default = 3  height [0,3]
//Bit 23:16        reg_lk_u8itercnt          // unsigned ,    RW, default = 10  iteration times,<=20
//Bit 15: 8        reg_u0q8eps               // unsigned ,    RW, default = 10  for exit criteria, dx^2+dy^2< u0q8eps
//Bit  7: 0        reserved
#define CVE_LK_REG2_0                              ((0x0052  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_0          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_1                              ((0x0053  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_1          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_2                              ((0x0054  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_2          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_3                              ((0x0055  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_3          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_4                              ((0x0056  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_4          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_5                              ((0x0057  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_5          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_6                              ((0x0058  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_6          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_7                              ((0x0059  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_7          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_8                              ((0x005a  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_8          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_9                              ((0x005b  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_9          // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_10                             ((0x005c  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_10         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_11                             ((0x005d  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_11         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_12                             ((0x005e  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_12         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_13                             ((0x005f  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_13         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_14                             ((0x0060  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_14         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_15                             ((0x0061  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_15         // unsigned ,    RO, default = 32'hffffffff
#define CVE_LK_REG2_16                             ((0x0062  << 2) + 0xfe046400)
//Bit 31: 0        ro_lk_ststatus_16         // unsigned ,    RO, default = 32'hffffffff
#define CVE_STCORNER_REG0                          ((0x0063  << 2) + 0xfe046400)
//Bit 31: 0        ro_st_u32pointnum         // unsigned ,    RO, default = 0  max corner number in image
#define CVE_SAD_REG0                               ((0x0064  << 2) + 0xfe046400)
//Bit 31:16        reserved
//Bit 15:10        reserved
//Bit  9: 8        reg_sad_mode              // unsigned ,    RW, default = 0  0:4x4, 1:8x8, 2:16x16
//Bit  7: 0        reg_sad_u8minval          // unsigned ,    RW, default = 128
#define CVE_SAD_REG1                               ((0x0065  << 2) + 0xfe046400)
//Bit 31:16        reg_sad_u16thr            // unsigned ,    RW, default = 128
//Bit 15: 8        reg_sad_u8maxval          // unsigned ,    RW, default = 128
//Bit  7: 4        reserved
//Bit  3: 0        reg_sad_u4rightshift      // unsigned ,    RW, default = 2
#define CVE_GRADFG_REG0                            ((0x0066  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:24        reg_gradfg_mode           // unsigned ,    RW, default = 0  output control
//Bit 23: 8        reserved
//Bit  7: 0        reg_gradfg_u8minmagdiff   // unsigned ,    RW, default = 100  gradient magnitude difference threshold
#define CVE_FILTER_REG0_0                          ((0x0067  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_3         // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_2         // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_1         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_0         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_1                          ((0x0068  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_7         // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_6         // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_5         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_4         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_2                          ((0x0069  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_11        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_10        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_9         // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_8         // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_3                          ((0x006a  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_15        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_14        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_13        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_12        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_4                          ((0x006b  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_19        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_18        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_17        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_16        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_5                          ((0x006c  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_23        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reg_filter_coef_22        // signed ,    RW, default = 0  coef for filter
//Bit 15: 8        reg_filter_coef_21        // signed ,    RW, default = 0  coef for filter
//Bit  7: 0        reg_filter_coef_20        // signed ,    RW, default = 0  coef for filter
#define CVE_FILTER_REG0_6                          ((0x006d  << 2) + 0xfe046400)
//Bit 31:24        reg_filter_coef_24        // signed ,    RW, default = 0  coef for filter
//Bit 23:16        reserved
//Bit 15: 6        reserved
//Bit  5: 0        reg_filter_norm           // unsigned ,    RW, default = 0  filter then right shift for norm.
#define CVE_CSC_REG1                               ((0x006e  << 2) + 0xfe046400)
//Bit 31:20        reserved
//Bit 19:10        reg_csc_offset_inp_1      // signed ,    RW, default = 0
//Bit  9: 0        reg_csc_offset_inp_0      // signed ,    RW, default = 0
#define CVE_CSC_REG1_1                             ((0x006f  << 2) + 0xfe046400)
//Bit 31:10        reserved
//Bit  9: 0        reg_csc_offset_inp_2      // signed ,    RW, default = 0
#define CVE_CSC_REG2_0                             ((0x0070  << 2) + 0xfe046400)
//Bit 31:22        reg_csc_3x3matrix_0_0     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_0     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_0     // signed ,    RW, default = 0
#define CVE_CSC_REG2_1                             ((0x0071  << 2) + 0xfe046400)
//Bit 31:22        reg_csc_3x3matrix_0_1     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_1     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_1     // signed ,    RW, default = 0
#define CVE_CSC_REG2_2                             ((0x0072  << 2) + 0xfe046400)
//Bit 31:22        reg_csc_3x3matrix_0_2     // signed ,    RW, default = 0
//Bit 21            reserved
//Bit 20:11        reg_csc_3x3matrix_1_2     // signed ,    RW, default = 0
//Bit 10            reserved
//Bit  9: 0        reg_csc_3x3matrix_2_2     // signed ,    RW, default = 0
#define CVE_CSC_REG3                               ((0x0073  << 2) + 0xfe046400)
//Bit 31:20        reserved
//Bit 19:10        reg_csc_offset_oup_1      // signed ,    RW, default = 0
//Bit  9: 0        reg_csc_offset_oup_0      // signed ,    RW, default = 0
#define CVE_CSC_REG3_1                             ((0x0074  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:16        reg_csc_offset_oup_2      // signed ,    RW, default = 0
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
#define CVE_SOBEL_REG1_0                           ((0x0075  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_3        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_2        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_1        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_0        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_1                           ((0x0076  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_7        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_6        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_5        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_4        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_2                           ((0x0077  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_11       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_10       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_9        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_8        // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_3                           ((0x0078  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_15       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_14       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_13       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_12       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_4                           ((0x0079  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_19       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_18       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_17       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_16       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_5                           ((0x007a  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_h_23       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_h_22       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_h_21       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_20       // signed ,    RW, default = 0
#define CVE_SOBEL_REG1_6                           ((0x007b  << 2) + 0xfe046400)
//Bit 31: 6        reserved
//Bit  5: 0        reg_sobel_coef_h_24       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_0                           ((0x007c  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_3        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_2        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_1        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_0        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_1                           ((0x007d  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_7        // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_6        // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_5        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_4        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_2                           ((0x007e  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_11       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_10       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_9        // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_8        // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_3                           ((0x007f  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_15       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_14       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_13       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_12       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_4                           ((0x0080  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_19       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_18       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_17       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_16       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_5                           ((0x0081  << 2) + 0xfe046400)
//Bit 31:30        reserved
//Bit 29:24        reg_sobel_coef_v_23       // signed ,    RW, default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_sobel_coef_v_22       // signed ,    RW, default = 0
//Bit 15:14        reserved
//Bit 13: 8        reg_sobel_coef_v_21       // signed ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_20       // signed ,    RW, default = 0
#define CVE_SOBEL_REG2_6                           ((0x0082  << 2) + 0xfe046400)
//Bit 31: 6        reserved
//Bit  5: 0        reg_sobel_coef_v_24       // signed ,    RW, default = 0
#define CVE_TOF_REG0                               ((0x0083  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:16        reg_cve_tof_hist_x_start  // unsigned ,    RW, default = 0  range for calc hist,start x, default:0
//Bit 15:10        reserved
//Bit  9: 0        reg_cve_tof_hist_y_start  // unsigned ,    RW, default = 0  range for calc hist,start y, default:0
#define CVE_TOF_REG1                               ((0x0084  << 2) + 0xfe046400)
//Bit 31:26        reserved
//Bit 25:16        reg_cve_tof_hist_x_end    // unsigned ,    RW, default = 320  range for calc hist,end x, default:320
//Bit 15:10        reserved
//Bit  9: 0        reg_cve_tof_hist_y_end    // unsigned ,    RW, default = 240  range for calc hist,end y, default:240
#define CVE_TOF_REG3_0                             ((0x0085  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_0      // signed ,    RW, default = 0
#define CVE_TOF_REG3_1                             ((0x0086  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_1      // signed ,    RW, default = 0
#define CVE_TOF_REG3_2                             ((0x0087  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_2      // signed ,    RW, default = 0
#define CVE_TOF_REG3_3                             ((0x0088  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_3      // signed ,    RW, default = 0
#define CVE_TOF_REG3_4                             ((0x0089  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23: 0        reg_cve_tof_p_coef_4      // signed ,    RW, default = 0
#define CVE_TOF_REG4                               ((0x008a  << 2) + 0xfe046400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_t_coef1_0     // signed ,    RW, default = 0
//Bit 15: 9        reserved
//Bit  8: 0        reg_cve_tof_t_coef1_1     // signed ,    RW, default = 0  s7q2
#define CVE_TOF_REG5                               ((0x008b  << 2) + 0xfe046400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_t_coef1_2     // signed ,    RW, default = 0
//Bit 15: 9        reserved
//Bit  8: 0        reg_cve_tof_t_coef1_3     // signed ,    RW, default = 0
#define CVE_TOF_REG9_0                             ((0x008c  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_0    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_1    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_2    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_1                             ((0x008d  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_3    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_4    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_5    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_2                             ((0x008e  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_6    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_7    // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_8    // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_3                             ((0x008f  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_9    // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_10   // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_11   // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG9_4                             ((0x0090  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_spa_mask_12   // unsigned ,    RW, default = 0  mask
//Bit 15: 8        reg_cve_tof_spa_mask_13   // unsigned ,    RW, default = 0  mask
//Bit  7: 0        reg_cve_tof_spa_mask_14   // unsigned ,    RW, default = 0  mask
#define CVE_TOF_REG10                              ((0x0091  << 2) + 0xfe046400)
//Bit 31:27        reserved
//Bit 26:24        reg_cve_tof_raw_mode      // unsigned ,    RW, default = 4  0:RAW6,1:RAW7,2:RAW8,3:RWA10,4:RWA12,5:RAW14
//Bit 23:16        reg_cve_tof_spa_norm      // unsigned ,    RW, default = 0  coefficient,up to spa_mask
//Bit 15: 9        reserved
//Bit  8           reg_cve_tof_raw_shift_12bit_en // unsigned ,    RW, default = 0  1:convert pixel data to 12 bit,0:not
//Bit  7: 0        reg_cve_tof_bp_num        // unsigned ,    RW, default = 0  count of bad point
#define CVE_TOF_REG11                              ((0x0092  << 2) + 0xfe046400)
//Bit 31:24        reserved
//Bit 23:16        reg_cve_tof_temperature_int // signed ,    RW, default = 20  temperature
//Bit 15: 8        reserved
//Bit  7: 0        reg_cve_tof_temperature_ext // signed ,    RW, default = 20  temperature
#define CVE_TOF_REG12                              ((0x0093  << 2) + 0xfe046400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_q1_high_thr   // unsigned ,    RW, default = 0
//Bit 15:12        reserved
//Bit 11: 0        reg_cve_tof_q23_high_thr  // unsigned ,    RW, default = 0
#define CVE_TOF_REG13                              ((0x0094  << 2) + 0xfe046400)
//Bit 31:28        reserved
//Bit 27:16        reg_cve_tof_ir_high_thr   // unsigned ,    RW, default = 0
//Bit 15:12        reserved
//Bit 11: 0        reg_cve_tof_ir_low_thr    // unsigned ,    RW, default = 0
#define CVE_TOF_REG14                              ((0x0095  << 2) + 0xfe046400)
//Bit 31:16        reg_cve_tof_dis_max       // unsigned ,    RW, default = 0  depth
//Bit 15: 0        reg_cve_tof_dis_min       // unsigned ,    RW, default = 0  depth
#define CVE_TOF_REG15                              ((0x0096  << 2) + 0xfe046400)
//Bit 31:25        reserved
//Bit 24           reg_cve_tof_spa1_en       // unsigned ,    RW, default = 0  space filter ctrl
//Bit 23:17        reserved
//Bit 16           reg_cve_tof_spa2_en       // unsigned ,    RW, default = 0  space filter ctrl
//Bit 15:10        reserved
//Bit  9: 8        reg_cve_tof_fpn_cali_mode // unsigned ,    RW, default = 1  0:bypass,1;fpn mode,2:fd mode
//Bit  7: 1        reserved
//Bit  0           reg_cve_tof_bypass_en     // unsigned ,    RW, default = 0  bypass or not,1:bypass,0:not,default:0;if bypass_en == 1,spa2_en and dis_min must be 0,dis_max must be 65535
#define CVE_ADD_DSTSUM                             ((0x0097  << 2) + 0xfe046400)
//Bit 31: 0        ro_cve_add_dstsum         // unsigned ,    RO, default = 0
#define CVE_SUB_AREA                               ((0x0098  << 2) + 0xfe046400)
//Bit 31: 0        ro_cve_sub_front_area     // unsigned ,    RO, default = 0
#define CVE_SUB_THRESH_RATIO                       ((0x0099  << 2) + 0xfe046400)
//Bit 31:16        reg_sub_thresh_ratio      // unsigned ,    RW, default = 13107  norm 65536 to 1.0
//Bit 15: 0        reserved
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe046000
// -----------------------------------------------
//
// Reading file:  ./cve_top_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_TOP_HW_CTRL_REG0                       ((0x0000  << 2) + 0xfe046000)
//Bit 31:28        reserved
//Bit 27:24        reg_clk_gate_ctrl_intr       // unsigned ,    RW, default = 0
//Bit 23:22        reg_clk_gate_ctrl_lut        // unsigned ,    RW, default = 0
//Bit 21:20        reg_clk_gate_ctrl_reg_top_hw // unsigned ,    RW, default = 2
//Bit 19:18        reg_clk_gate_ctrl_reg_wrmif2 // unsigned ,    RW, default = 0
//Bit 17:16        reg_clk_gate_ctrl_reg_wrmif1 // unsigned ,    RW, default = 0
//Bit 15:14        reg_clk_gate_ctrl_reg_wrmif  // unsigned ,    RW, default = 0
//Bit 13:12        reg_clk_gate_ctrl_reg_rdmif2 // unsigned ,    RW, default = 0
//Bit 11:10        reg_clk_gate_ctrl_reg_rdmif1 // unsigned ,    RW, default = 0
//Bit 9:8          reg_clk_gate_ctrl_reg_rdmif  // unsigned ,    RW, default = 0
//Bit 7:6          reg_clk_gate_ctrl_reg_top    // unsigned ,    RW, default = 0
//Bit 5:4          reg_clk_gate_ctrl_cq         // unsigned ,    RW, default = 0
//Bit 3:3          reg_cve_sec_ctrl             // unsigned ,    RW, default = 0
//Bit 2:2          reg_cve_dbg_run_cycles_en // unsigned ,    RW, default = 0
//Bit 1:1          reg_ccl_dbg_dis_sec_pass // unsigned ,    RW, default = 0
//Bit 0:0          reg_sync_rst // unsigned ,    RW, default = 0
#define CVE_TOP_HW_CTRL_REG1                       ((0x0001  << 2) + 0xfe046000)
//Bit 31:0         reg_clk_gate_ctrl_ops_lsb // unsigned ,    RW, default = 0
#define CVE_TOP_HW_CTRL_REG2                       ((0x0002  << 2) + 0xfe046000)
//Bit 31:0         reg_clk_gate_ctrl_ops_msb // unsigned ,    RW, default = 0
#define CVE_CQ0                                    ((0x0003  << 2) + 0xfe046000)
//Bit 31: 0        reg_cq0_baddr       // unsigned ,    RW, default = 0
#define CVE_CQ1                                    ((0x0004  << 2) + 0xfe046000)
//Bit 31: 0        reg_cq1_baddr       // unsigned ,    RW, default = 0
#define CVE_CQ2                                    ((0x0005  << 2) + 0xfe046000)
//Bit 31: 29       reserved
//Bit 28: 28       ro_cq1_done          // unsigned ,    RO, default = 0
//Bit 27: 27       ro_cq0_done          // unsigned ,    RO, default = 0
//Bit 26: 26       reg_cq_en            // unsigned ,    RW, default = 0
//Bit 25: 25       reg_sw_cq1_rdy       // unsigned ,    RW, default = 0
//Bit 24: 24       reg_sw_cq0_rdy       // unsigned ,    RW, default = 0
//Bit 23: 12       reg_cq1_len          // unsigned ,    RW, default = 0
//Bit 11: 0        reg_cq0_len          // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_WRITE0                       ((0x0006  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_stat_write0       // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_WRITE1                       ((0x0007  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_stat_write1       // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_CLR_WRITE0                   ((0x0008  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_stat_clr_write0   // unsigned ,    RW, default = 0
#define CVE_INTR_STAT_CLR_WRITE1                   ((0x0009  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_stat_clr_write1   // unsigned ,    RW, default = 0
#define CVE_INTR_MASKN0                            ((0x000a  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_maskn0     // unsigned ,    RW, default = 0
#define CVE_INTR_MASKN1                            ((0x000b  << 2) + 0xfe046000)
//Bit 31: 0        reg_intr_maskn1     // unsigned ,    RW, default = 0
#define CVE_INTR_STATUS0                           ((0x000c  << 2) + 0xfe046000)
//Bit 31: 0        ro_intr_status0     // unsigned ,    RO, default = 0
#define CVE_INTR_STATUS1                           ((0x000d  << 2) + 0xfe046000)
//Bit 31: 0        ro_intr_status1     // unsigned ,    RO, default = 0
#define CVE_OP_ONCE_RUN_CYCLES                     ((0x000e  << 2) + 0xfe046000)
//Bit 31: 0        ro_op_once_run_cycles // unsigned ,RO, default = 0
#define CVE_CQ3                                    ((0x000f  << 2) + 0xfe046000)
//Bit 31: 25       reserved
//Bit 24: 24       reg_cq_pingpong_mode //unsigned, RW, default = 0
//Bit 23: 21       reserved
//Bit 20: 12       reg_cq1_op_num   // unsigned ,    RW, default = 1
//Bit 11: 9        reserved
//Bit  8: 0        reg_cq0_op_num   // unsigned ,    RW, default = 1
#define CVE_CQ4                                    ((0x0010  << 2) + 0xfe046000)
//Bit 31: 9        reserved
//Bit 8: 0         ro_cq_op_run_idx   // unsigned ,    RO, default = 0
#define CVE_ID_STA0                                ((0x0011  << 2) + 0xfe046000)
//Bit 31:2       reserved
//Bit 1: 1       reg_cve_id_sta_en     // unsigned ,    RW, default = 0
//Bit 0: 0       reg_cve_id_sta_clr    // unsigned ,    RW, default = 0
#define CVE_ID_STA1                                ((0x0012  << 2) + 0xfe046000)
//Bit 31:16      reserved
//Bit 15: 0      ro_cve_op_id          // unsigned ,    RO, default = 0
#define CVE_TIMEOUT0                               ((0x0013  << 2) + 0xfe046000)
//Bit 31:1       reserved
//Bit 0: 0       reg_cve_timeout_intr_en // unsigned ,   RW, default = 0
#define CVE_TIMEOUT1                               ((0x0014  << 2) + 0xfe046000)
//Bit 31: 0      reg_cve_op_time_thr     // unsigned ,   RW, default = 60000000
#define CVE_UTE0                                   ((0x0015  << 2) + 0xfe046000)
//Bit 31:2       reg_cve_ute_sta_total_cycles // unsigned ,  RW, default = 600000000
//Bit 1: 1       reserved
//Bit 0: 0       reg_cve_ute_sta_en           // unsigned ,  RW, default = 0
#define CVE_UTE1                                   ((0x0016  << 2) + 0xfe046000)
//Bit 31:30      reserved
//Bit 29: 0      ro_cve_ute_cycles_in_total // unsigned ,  RO, default = 0
#define CVE_STATUS                                 ((0x0017  << 2) + 0xfe046000)
//Bit 31:4       reserved
//Bit 3: 0       ro_cve_status           // unsigned ,  RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_hw_reg.h
//
//
// Reading file:  ./cve_top_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define CVE_WMIF0_CTRL1                            ((0x00c0  << 2) + 0xfe046000)
#define CVE_WMIF0_CTRL2                            ((0x00c1  << 2) + 0xfe046000)
#define CVE_WMIF0_CTRL3                            ((0x00c2  << 2) + 0xfe046000)
#define CVE_WMIF0_CTRL4                            ((0x00c3  << 2) + 0xfe046000)
#define CVE_WMIF0_SCOPE_X                          ((0x00c4  << 2) + 0xfe046000)
#define CVE_WMIF0_SCOPE_Y                          ((0x00c5  << 2) + 0xfe046000)
#define CVE_WMIF0_RO_STAT                          ((0x00c6  << 2) + 0xfe046000)
#define CVE_WMIF1_CTRL1                            ((0x00c8  << 2) + 0xfe046000)
#define CVE_WMIF1_CTRL2                            ((0x00c9  << 2) + 0xfe046000)
#define CVE_WMIF1_CTRL3                            ((0x00ca  << 2) + 0xfe046000)
#define CVE_WMIF1_CTRL4                            ((0x00cb  << 2) + 0xfe046000)
#define CVE_WMIF1_SCOPE_X                          ((0x00cc  << 2) + 0xfe046000)
#define CVE_WMIF1_SCOPE_Y                          ((0x00cd  << 2) + 0xfe046000)
#define CVE_WMIF1_RO_STAT                          ((0x00ce  << 2) + 0xfe046000)
#define CVE_WMIF2_CTRL1                            ((0x00d0  << 2) + 0xfe046000)
#define CVE_WMIF2_CTRL2                            ((0x00d1  << 2) + 0xfe046000)
#define CVE_WMIF2_CTRL3                            ((0x00d2  << 2) + 0xfe046000)
#define CVE_WMIF2_CTRL4                            ((0x00d3  << 2) + 0xfe046000)
#define CVE_WMIF2_SCOPE_X                          ((0x00d4  << 2) + 0xfe046000)
#define CVE_WMIF2_SCOPE_Y                          ((0x00d5  << 2) + 0xfe046000)
#define CVE_WMIF2_RO_STAT                          ((0x00d6  << 2) + 0xfe046000)
#define CVE_RMIF0_CTRL1                            ((0x00d8  << 2) + 0xfe046000)
#define CVE_RMIF0_CTRL2                            ((0x00d9  << 2) + 0xfe046000)
#define CVE_RMIF0_CTRL3                            ((0x00da  << 2) + 0xfe046000)
#define CVE_RMIF0_CTRL4                            ((0x00db  << 2) + 0xfe046000)
#define CVE_RMIF0_SCOPE_X                          ((0x00dc  << 2) + 0xfe046000)
#define CVE_RMIF0_SCOPE_Y                          ((0x00dd  << 2) + 0xfe046000)
#define CVE_RMIF0_RO_STAT                          ((0x00de  << 2) + 0xfe046000)
#define CVE_RMIF1_CTRL1                            ((0x00e0  << 2) + 0xfe046000)
#define CVE_RMIF1_CTRL2                            ((0x00e1  << 2) + 0xfe046000)
#define CVE_RMIF1_CTRL3                            ((0x00e2  << 2) + 0xfe046000)
#define CVE_RMIF1_CTRL4                            ((0x00e3  << 2) + 0xfe046000)
#define CVE_RMIF1_SCOPE_X                          ((0x00e4  << 2) + 0xfe046000)
#define CVE_RMIF1_SCOPE_Y                          ((0x00e5  << 2) + 0xfe046000)
#define CVE_RMIF1_RO_STAT                          ((0x00e6  << 2) + 0xfe046000)
#define CVE_RMIF2_CTRL1                            ((0x00e8  << 2) + 0xfe046000)
#define CVE_RMIF2_CTRL2                            ((0x00e9  << 2) + 0xfe046000)
#define CVE_RMIF2_CTRL3                            ((0x00ea  << 2) + 0xfe046000)
#define CVE_RMIF2_CTRL4                            ((0x00eb  << 2) + 0xfe046000)
#define CVE_RMIF2_SCOPE_X                          ((0x00ec  << 2) + 0xfe046000)
#define CVE_RMIF2_SCOPE_Y                          ((0x00ed  << 2) + 0xfe046000)
#define CVE_RMIF2_RO_STAT                          ((0x00ee  << 2) + 0xfe046000)
#define CVE_LUT_APB_ADDR                           ((0x00f0  << 2) + 0xfe046000)
#define CVE_LUT_APB_DATA                           ((0x00f1  << 2) + 0xfe046000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./cve_top_mif_reg.h
//
//========================================================================
//  MIPI_ISP
//========================================================================
//
// Reading file:  ./mipi_isp.h
//
// synopsys translate_off
// synopsys translate_on
//========================================================================
// MIPI_ISP_TOP_WRAPPER cfg unused
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff9a0000
// -----------------------------------------------
//========================================================================
// MIPI_ISP_TOP cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff010000
// -----------------------------------------------
#define MIPI_TOP_CTRL0                             ((0x0000  << 2) + 0xff010000)
#define MIPI_TOP_CTRL1                             ((0x0001  << 2) + 0xff010000)
#define MIPI_TOP_CTRL2                             ((0x0002  << 2) + 0xff010000)
#define MIPI_TOP_CTRL3                             ((0x0003  << 2) + 0xff010000)
#define MIPI_TOP_CTRL4                             ((0x0004  << 2) + 0xff010000)
#define MIPI_TOP_CTRL5                             ((0x0005  << 2) + 0xff010000)
#define MIPI_TOP_CTRL6                             ((0x0006  << 2) + 0xff010000)
#define MIPI_TOP_CTRL7                             ((0x0007  << 2) + 0xff010000)
#define MIPI_TOP_CTRL8                             ((0x0008  << 2) + 0xff010000)
#define MIPI_ADAPT_DE_CTRL0                        ((0x0010  << 2) + 0xff010000)
#define MIPI_ADAPT_DE_CTRL1                        ((0x0011  << 2) + 0xff010000)
#define MIPI_ADAPT_DE_CTRL2                        ((0x0012  << 2) + 0xff010000)
#define MIPI_ADAPT_DE_CTRL3                        ((0x0013  << 2) + 0xff010000)
#define MIPI_ADAPT_DE_STAT0                        ((0x0018  << 2) + 0xff010000)
#define MIPI_TOP_ISP_PENDING_MASK0                 ((0x0020  << 2) + 0xff010000)
#define MIPI_TOP_ISP_PENDING_MASK1                 ((0x0021  << 2) + 0xff010000)
#define MIPI_TOP_ISP_PENDING0                      ((0x0022  << 2) + 0xff010000)
#define MIPI_TOP_ISP_PENDING1                      ((0x0023  << 2) + 0xff010000)
//========================================================================
// MIPI_ISP  apb dma
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff010400
// -----------------------------------------------
//
// Reading file:  ./mipi_apb_dma.h
//
#define MIPI_DMA_AXI_CTL                           ((0x0000  << 2) + 0xff010400)
//Bit 31:28,     reg_axi_wr_prot_cntl       , default = 0, axi_wr_prot_cntl
//Bit 27:24,     reg_axi_rd_prot_cntl       , default = 0, axi_rd_prot_cntl
//Bit 23:22,     reg_axi_extra_addr         , default = 0, reg_axi_extra_addr
//Bit    21,     reg_axi_arugt              , default = 0, axi read urgent
//Bit    20,     reg_axi_awugt              , default = 0, axi write urgent
//Bit 19:12,     reserved
//Bit  11:8,     reg_axi_id                 , default = 0, axi id
//Bit   7:4,     reserved
//Bit   3:2,     reg_axi_wr_burst_type      , default = 0, axi wr burst type,00 single 01 incr2 10 incr4 11 incr8
//Bit   1:0,     reg_axi_rd_burst_type      , default = 0, axi rd burst type,00 single 01 incr2 10 incr4 11 incr8
#define MIPI_DMA_CTL0                              ((0x0001  << 2) + 0xff010400)
//Bit    31,     reg_dma_en                 , default = 0, dma enable
//Bit 30:28,     reserved
//Bit    27,     reg_soft_rst               , default = 0, soft reset
//Bit    26,     reg_trig_fifo_rst          , default = 0, trigger source fifo reset
//Bit    25,     reg_axi_rfifo_rst          , default = 0, axi rfifo reset
//Bit    24,     reg_axi_wfifo_rst          , default = 0, axi wfifo reset
//Bit 18:16,     reg_trig_fifo_stat_sel     , default = 0, reg_trig_fifo_stat_sel
//Bit  15:0,     reserved
#define MIPI_DMA_PENDING0                          ((0x0002  << 2) + 0xff010400)
//Bit    31,     bus_mon_fast_irq           , default = 0, apb arbit int
//Bit    30,     c_trig_fifo_overflow_set   , default = 0, trigger fifo overflow
//Bit 29:24,     reserved
//Bit 23:16,     c_no_valid_done_set        , default = 0, current source trig not valid
//Bit  15:8,     c_src_trig_overflow        , default = 0, when current source task not completed ,next same trigger source in
//Bit   7:0,     c_src_done_set             , default = 0, trigger source all task done
#define MIPI_DMA_IRQ_MASK0                         ((0x0004  << 2) + 0xff010400)
//Bit    31,     bus_mon_fast_irq_mask           , default = 0, interrupt mask
//Bit    30,     c_trig_fifo_overflow_set_mask   , default = 0, interrupt mask
//Bit 29:24,     reserved
//Bit 23:16,     c_no_valid_done_set_mask        , default = 0, interrupt mask
//Bit  15:8,     c_src_trig_overflow_mask        , default = 0, interrupt mask
//Bit   7:0,     c_src_done_set_mask             , default = 0, interrupt mask
#define MIPI_DMA_STAT0                             ((0x0010  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat0             , default = 0
#define MIPI_DMA_STAT1                             ((0x0011  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat1             , default = 0
#define MIPI_DMA_STAT2                             ((0x0012  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat2             , default = 0
#define MIPI_DMA_STAT3                             ((0x0013  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat3             , default = 0
#define MIPI_DMA_STAT4                             ((0x0014  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat4             , default = 0
#define MIPI_DMA_STAT5                             ((0x0015  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat5             , default = 0
#define MIPI_DMA_STAT6                             ((0x0016  << 2) + 0xff010400)
//Bit  31:0,     reg_dma_stat6             , default = 0
#define MIPI_DMA_TRIG_FIFO_STAT0                   ((0x0017  << 2) + 0xff010400)
//Bit  31:0,     reg_trig_fifo_stat0       , default = 0
#define MIPI_DMA_AXI_FIFO_STAT0                    ((0x0018  << 2) + 0xff010400)
//Bit  31:0,     reg_axi_fifo_stat0        , default = 0
#define MIPI_DMA_AXI_WR_PROT_STAT                  ((0x0019  << 2) + 0xff010400)
//Bit  31:0,     reg_axi_wr_prot_stat      , default = 0
#define MIPI_DMA_AXI_RD_PROT_STAT                  ((0x001a  << 2) + 0xff010400)
//Bit  31:0,     reg_axi_rd_prot_stat      , default = 0
#define MIPI_DMA_ARBIT_CNTL0                       ((0x0020  << 2) + 0xff010400)
//Bit  31:4,     reserved
//Bit   3:0,     bus_monitor_cntl          , default = 0,apb arbit bus_monitor_cntl
#define MIPI_DMA_ARBIT_CNTL1                       ((0x0021  << 2) + 0xff010400)
//Bit  31:0,     bus_mon_addr              , default = 0,apb arbit bus_mon_addr
#define MIPI_DMA_ARBIT_CNTL2                       ((0x0022  << 2) + 0xff010400)
//Bit  31:0,     bus_mon_data              , default = 0,apb arbit bus_mon_data
#define MIPI_DMA_ARBIT_CNTL3                       ((0x0023  << 2) + 0xff010400)
//Bit  31:0,     bus_mon_data_msk          , default = 0,apb arbit bus_mon_data_msk
#define MIPI_DMA_SRC0_CTL                          ((0x0030  << 2) + 0xff010400)
//Bit  3,     reg_src0_pingpong_force_val   , default = 0, src0 pingpong force sel
//Bit  2,     reg_src0_pingpong_force       , default = 0, src0 pingpong force enable
//Bit  1,     reg_src0_pingpong_ini         , default = 0, src0 pingpong initial sel
//Bit  0,     reg_src0_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC0_PING_CMD_ADDR0               ((0x0031  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC0_PING_DST_ADDR0               ((0x0032  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC0_PING_TASK0                   ((0x0033  << 2) + 0xff010400)
//Bit    31,     reg_src0_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src0_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PING_CMD_ADDR1               ((0x0034  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC0_PING_DST_ADDR1               ((0x0035  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC0_PING_TASK1                   ((0x0036  << 2) + 0xff010400)
//Bit    31,     reg_src0_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src0_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PONG_CMD_ADDR0               ((0x0037  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC0_PONG_DST_ADDR0               ((0x0038  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC0_PONG_TASK0                   ((0x0039  << 2) + 0xff010400)
//Bit    31,     reg_src0_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src0_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC0_PONG_CMD_ADDR1               ((0x003a  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC0_PONG_DST_ADDR1               ((0x003b  << 2) + 0xff010400)
//Bit  31:0,     reg_src0_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC0_PONG_TASK1                   ((0x003c  << 2) + 0xff010400)
//Bit    31,     reg_src0_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src0_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src0_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_CTL                          ((0x003d  << 2) + 0xff010400)
//Bit  3,     reg_src1_pingpong_force_val   , default = 0, src1 pingpong force sel
//Bit  2,     reg_src1_pingpong_force       , default = 0, src1 pingpong force enable
//Bit  1,     reg_src1_pingpong_ini         , default = 0, src1 pingpong initial sel
//Bit  0,     reg_src1_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC1_PING_CMD_ADDR0               ((0x003e  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC1_PING_DST_ADDR0               ((0x003f  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC1_PING_TASK0                   ((0x0040  << 2) + 0xff010400)
//Bit    31,     reg_src1_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src1_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PING_CMD_ADDR1               ((0x0041  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC1_PING_DST_ADDR1               ((0x0042  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC1_PING_TASK1                   ((0x0043  << 2) + 0xff010400)
//Bit    31,     reg_src1_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src1_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PONG_CMD_ADDR0               ((0x0044  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC1_PONG_DST_ADDR0               ((0x0045  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC1_PONG_TASK0                   ((0x0046  << 2) + 0xff010400)
//Bit    31,     reg_src1_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src1_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC1_PONG_CMD_ADDR1               ((0x0047  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC1_PONG_DST_ADDR1               ((0x0048  << 2) + 0xff010400)
//Bit  31:0,     reg_src1_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC1_PONG_TASK1                   ((0x0049  << 2) + 0xff010400)
//Bit    31,     reg_src1_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src1_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src1_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_CTL                          ((0x004a  << 2) + 0xff010400)
//Bit  3,     reg_src2_pingpong_force_val   , default = 0, src2 pingpong force sel
//Bit  2,     reg_src2_pingpong_force       , default = 0, src2 pingpong force enable
//Bit  1,     reg_src2_pingpong_ini         , default = 0, src2 pingpong initial sel
//Bit  0,     reg_src2_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC2_PING_CMD_ADDR0               ((0x004b  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC2_PING_DST_ADDR0               ((0x004c  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC2_PING_TASK0                   ((0x004d  << 2) + 0xff010400)
//Bit    31,     reg_src2_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src2_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PING_CMD_ADDR1               ((0x004e  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC2_PING_DST_ADDR1               ((0x004f  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC2_PING_TASK1                   ((0x0050  << 2) + 0xff010400)
//Bit    31,     reg_src2_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src2_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PONG_CMD_ADDR0               ((0x0051  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC2_PONG_DST_ADDR0               ((0x0052  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC2_PONG_TASK0                   ((0x0053  << 2) + 0xff010400)
//Bit    31,     reg_src2_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src2_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC2_PONG_CMD_ADDR1               ((0x0054  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC2_PONG_DST_ADDR1               ((0x0055  << 2) + 0xff010400)
//Bit  31:0,     reg_src2_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC2_PONG_TASK1                   ((0x0056  << 2) + 0xff010400)
//Bit    31,     reg_src2_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src2_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src2_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_CTL                          ((0x0057  << 2) + 0xff010400)
//Bit  3,     reg_src3_pingpong_force_val   , default = 0, src3 pingpong force sel
//Bit  2,     reg_src3_pingpong_force       , default = 0, src3 pingpong force enable
//Bit  1,     reg_src3_pingpong_ini         , default = 0, src3 pingpong initial sel
//Bit  0,     reg_src3_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC3_PING_CMD_ADDR0               ((0x0058  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC3_PING_DST_ADDR0               ((0x0059  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC3_PING_TASK0                   ((0x005a  << 2) + 0xff010400)
//Bit    31,     reg_src3_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src3_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PING_CMD_ADDR1               ((0x005b  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC3_PING_DST_ADDR1               ((0x005c  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC3_PING_TASK1                   ((0x005d  << 2) + 0xff010400)
//Bit    31,     reg_src3_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src3_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PONG_CMD_ADDR0               ((0x005e  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC3_PONG_DST_ADDR0               ((0x005f  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC3_PONG_TASK0                   ((0x0060  << 2) + 0xff010400)
//Bit    31,     reg_src3_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src3_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC3_PONG_CMD_ADDR1               ((0x0061  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC3_PONG_DST_ADDR1               ((0x0062  << 2) + 0xff010400)
//Bit  31:0,     reg_src3_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC3_PONG_TASK1                   ((0x0063  << 2) + 0xff010400)
//Bit    31,     reg_src3_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src3_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src3_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_CTL                          ((0x0064  << 2) + 0xff010400)
//Bit  3,     reg_src4_pingpong_force_val   , default = 0, src4 pingpong force sel
//Bit  2,     reg_src4_pingpong_force       , default = 0, src4 pingpong force enable
//Bit  1,     reg_src4_pingpong_ini         , default = 0, src4 pingpong initial sel
//Bit  0,     reg_src4_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC4_PING_CMD_ADDR0               ((0x0065  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC4_PING_DST_ADDR0               ((0x0066  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC4_PING_TASK0                   ((0x0067  << 2) + 0xff010400)
//Bit    31,     reg_src4_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src4_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PING_CMD_ADDR1               ((0x0068  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC4_PING_DST_ADDR1               ((0x0069  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC4_PING_TASK1                   ((0x006a  << 2) + 0xff010400)
//Bit    31,     reg_src4_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src4_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PONG_CMD_ADDR0               ((0x006b  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC4_PONG_DST_ADDR0               ((0x006c  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC4_PONG_TASK0                   ((0x006d  << 2) + 0xff010400)
//Bit    31,     reg_src4_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src4_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC4_PONG_CMD_ADDR1               ((0x006e  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC4_PONG_DST_ADDR1               ((0x006f  << 2) + 0xff010400)
//Bit  31:0,     reg_src4_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC4_PONG_TASK1                   ((0x0070  << 2) + 0xff010400)
//Bit    31,     reg_src4_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src4_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src4_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_CTL                          ((0x0071  << 2) + 0xff010400)
//Bit  3,     reg_src5_pingpong_force_val   , default = 0, src5 pingpong force sel
//Bit  2,     reg_src5_pingpong_force       , default = 0, src5 pingpong force enable
//Bit  1,     reg_src5_pingpong_ini         , default = 0, src5 pingpong initial sel
//Bit  0,     reg_src5_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC5_PING_CMD_ADDR0               ((0x0072  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC5_PING_DST_ADDR0               ((0x0073  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC5_PING_TASK0                   ((0x0074  << 2) + 0xff010400)
//Bit    31,     reg_src5_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src5_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PING_CMD_ADDR1               ((0x0075  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC5_PING_DST_ADDR1               ((0x0076  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC5_PING_TASK1                   ((0x0077  << 2) + 0xff010400)
//Bit    31,     reg_src5_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src5_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PONG_CMD_ADDR0               ((0x0078  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC5_PONG_DST_ADDR0               ((0x0079  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC5_PONG_TASK0                   ((0x007a  << 2) + 0xff010400)
//Bit    31,     reg_src5_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src5_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC5_PONG_CMD_ADDR1               ((0x007b  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC5_PONG_DST_ADDR1               ((0x007c  << 2) + 0xff010400)
//Bit  31:0,     reg_src5_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC5_PONG_TASK1                   ((0x007d  << 2) + 0xff010400)
//Bit    31,     reg_src5_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src5_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src5_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_CTL                          ((0x007e  << 2) + 0xff010400)
//Bit  3,     reg_src6_pingpong_force_val   , default = 0, src6 pingpong force sel
//Bit  2,     reg_src6_pingpong_force       , default = 0, src6 pingpong force enable
//Bit  1,     reg_src6_pingpong_ini         , default = 0, src6 pingpong initial sel
//Bit  0,     reg_src6_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC6_PING_CMD_ADDR0               ((0x007f  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC6_PING_DST_ADDR0               ((0x0080  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC6_PING_TASK0                   ((0x0081  << 2) + 0xff010400)
//Bit    31,     reg_src6_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src6_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PING_CMD_ADDR1               ((0x0082  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC6_PING_DST_ADDR1               ((0x0083  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC6_PING_TASK1                   ((0x0084  << 2) + 0xff010400)
//Bit    31,     reg_src6_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src6_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PONG_CMD_ADDR0               ((0x0085  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC6_PONG_DST_ADDR0               ((0x0086  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC6_PONG_TASK0                   ((0x0087  << 2) + 0xff010400)
//Bit    31,     reg_src6_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src6_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC6_PONG_CMD_ADDR1               ((0x0088  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC6_PONG_DST_ADDR1               ((0x0089  << 2) + 0xff010400)
//Bit  31:0,     reg_src6_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC6_PONG_TASK1                   ((0x008a  << 2) + 0xff010400)
//Bit    31,     reg_src6_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src6_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src6_pong_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_CTL                          ((0x008b  << 2) + 0xff010400)
//Bit  3,     reg_src7_pingpong_force_val   , default = 0, src7 pingpong force sel
//Bit  2,     reg_src7_pingpong_force       , default = 0, src7 pingpong force enable
//Bit  1,     reg_src7_pingpong_ini         , default = 0, src7 pingpong initial sel
//Bit  0,     reg_src7_en                  , default = 0, src0 enable
#define MIPI_DMA_SRC7_PING_CMD_ADDR0               ((0x008c  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_ping_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC7_PING_DST_ADDR0               ((0x008d  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_ping_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC7_PING_TASK0                   ((0x008e  << 2) + 0xff010400)
//Bit    31,     reg_src7_ping_task0_valid      , default = 0, task valid
//Bit    30,     reg_src7_ping_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_ping_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PING_CMD_ADDR1               ((0x008f  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_ping_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC7_PING_DST_ADDR1               ((0x0090  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_ping_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC7_PING_TASK1                   ((0x0091  << 2) + 0xff010400)
//Bit    31,     reg_src7_ping_task1_valid      , default = 0, task valid
//Bit    30,     reg_src7_ping_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_ping_len1             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PONG_CMD_ADDR0               ((0x0092  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_pong_cmd_addr0        , default = 0, source0/task0 cmd address
#define MIPI_DMA_SRC7_PONG_DST_ADDR0               ((0x0093  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_pong_dst_addr0        , default = 0, source0/task0 dst address,for apb read only
#define MIPI_DMA_SRC7_PONG_TASK0                   ((0x0094  << 2) + 0xff010400)
//Bit    31,     reg_src7_pong_task0_valid      , default = 0, task valid
//Bit    30,     reg_src7_pong_type0            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_pong_len0             , default = 0, cmd length,N-1 words
#define MIPI_DMA_SRC7_PONG_CMD_ADDR1               ((0x0095  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_pong_cmd_addr1        , default = 0, source0/task1 cmd address
#define MIPI_DMA_SRC7_PONG_DST_ADDR1               ((0x0096  << 2) + 0xff010400)
//Bit  31:0,     reg_src7_pong_dst_addr1        , default = 0, source0/task1 dst address,for apb read only
#define MIPI_DMA_SRC7_PONG_TASK1                   ((0x0097  << 2) + 0xff010400)
//Bit    31,     reg_src7_pong_task1_valid      , default = 0, task valid
//Bit    30,     reg_src7_pong_type1            , default = 0, task type,1 apb write 0 apb read
//Bit 29:16,     reserved
//Bit  15:0,     reg_src7_pong_len1             , default = 0, cmd length,N-1 words
//
//
// Closing file:  ./mipi_apb_dma.h
//
//========================================================================
// MIPI_ISP_TOP cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff018000
// -----------------------------------------------
#define MIPI_PROC_TOP_CTRL0                        ((0x0000  << 2) + 0xff018000)
#define MIPI_PROC_TOP_CTRL1                        ((0x0001  << 2) + 0xff018000)
#define MIPI_PROC_DPHY_CTRL0                       ((0x0011  << 2) + 0xff018000)
#define MIPI_PROC_DPHY_CTRL1                       ((0x0012  << 2) + 0xff018000)
#define MIPI_PROC_DPHY_CTRL2                       ((0x0013  << 2) + 0xff018000)
#define MIPI_PROC_DPHY_CTRL3                       ((0x0014  << 2) + 0xff018000)
#define MIPI_PROC_DPHY_STAT0                       ((0x0018  << 2) + 0xff018000)
//========================================================================
// MIPI_ISP  adapt fe0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff01b000
// -----------------------------------------------
//`include "csi2_regs.h"
//========================================================================
// MIPI_ISP  adapt cfg
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff01d000
// -----------------------------------------------
//
// Reading file:  ./mipi_adapt.h
//
#define MIPI_ADAPT_DDR_RD0_CNTL0                   ((0x0000  << 2) + 0xff01d000)
//Bit 31    frame_rd_start           //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29:28 burst_type               //unsigned ,RW, default = 0
//Bit 27:26 reg_sample_sel           //unsigned ,RW, default = 0
//Bit 25    soft_load                //unsigned ,RW, default = 0
//Bit 24    continue_mode            //unsigned ,RW, default = 0
//Bit 23    dol_mode                 //unsigned ,RW, default = 0
//Bit 22    pingpong_mode            //unsigned ,RW, default = 0
//Bit 21    dol_time_out_en          //unsigned ,RW, default = 0
//Bit 20    frame_wr_done_sel        //unsigned ,RW, default = 0
//Bit 19    line_wr_done_sel         //unsigned ,RW, default = 0
//Bit 18    dol_frame_end_en         //unsigned ,RW, default = 0
//Bit 17    dol_vblank_clr_sel       //unsigned ,RW, default = 0
//Bit 16    reserved
//Bit 15:14 dol_time_tick_sel        //unsigned ,RW, default = 0
//Bit 13:4  line_stride              //unsigned ,RW, default = 0
//Bit 3:2   lbuf_soft_rst_sel        //unsigned ,RW, default = 0
//Bit 1     frame_loop_enable        //unsigned ,RW, default = 0
//Bit 0     enable                   //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL1                   ((0x0001  << 2) + 0xff01d000)
//Bit 31:30 port_sel                 //unsigned ,RW, default = 0
//Bit   29  frame_vs_rst_en          //unsigned ,RW, default = 0
//Bit 28:16 line_number              //unsigned ,RW, default = 0
//Bit 15:12 dol_line_threshold       //unsigned ,RW, default = 0
//Bit 11:10 frame_vs_rst_sel         //unsigned ,RW, default = 0
//Bit 9:0   line_size                //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL2                   ((0x0002  << 2) + 0xff01d000)
//Bit 31:0  frame_base_address_0     //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL3                   ((0x0003  << 2) + 0xff01d000)
//Bit 31:0  frame_base_address_1     //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL4                   ((0x0004  << 2) + 0xff01d000)
//Bit 31:13 dol_time_out             //unsigned ,RW, default = 0
//Bit 12:0  line_threshold           //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL5                   ((0x0005  << 2) + 0xff01d000)
//Bit 31:0  frame_end_address_0      //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL6                   ((0x0006  << 2) + 0xff01d000)
//Bit 31:0  frame_end_address_1      //unsigned ,RW, default = 0
#define MIPI_ADAPT_LBUF_0_UGT_CNTL0                ((0x0007  << 2) + 0xff01d000)
//Bit 31    reg_ugt_auto_en          //unsigned ,RW, default = 0
//Bit 30:16 reg_ugt_th1              //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14: 0 reg_ugt_th0              //unsigned ,RW, default = 0
#define MIPI_ADAPT_LBUF_0_UGT_CNTL1                ((0x0008  << 2) + 0xff01d000)
//Bit 31    reg_sideband_auto_en     //unsigned ,RW, default = 0
//Bit 30:16 reg_sideband_th1         //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14: 0 reg_sideband_th0         //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_CNTL7                   ((0x0009  << 2) + 0xff01d000)
//Bit 31:17     reserved
//Bit 16:4      reg_wcnt_force_val //unsigned ,RW, default = 0
//Bit 3         reg_wcnt_force_en  //unsigned ,RW, default = 0
//Bit 2:1       reg_wcnt_rst_sel   //unsigned ,RW, default = 0
//Bit 0         reg_wcnt_sw_rst    //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD0_ST0                     ((0x000a  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st0   //unsigned ,RO, default = 0
#define MIPI_ADAPT_DDR_RD0_ST1                     ((0x000b  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st1   //unsigned ,RO, default = 0
#define MIPI_ADAPT_DDR_RD0_ST2                     ((0x000c  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st2   //unsigned ,RO, default = 0
#define MIPI_ADAPT_LBUF_0_UGT_ST                   ((0x000d  << 2) + 0xff01d000)
//Bit 31: 0 reg_rd0_qos_st ,         //unsigned ,RO, default = 0
#define DDR_RD0_LBUF_STATUS                        ((0x000f  << 2) + 0xff01d000)
//Bit 31:0  ddr_rd_0_lbuf_status      //unsigned ,RO, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL0                   ((0x0010  << 2) + 0xff01d000)
//Bit 31    frame_rd_start           //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29:28 burst_type               //unsigned ,RW, default = 0
//Bit 27:26 reg_sample_sel           //unsigned ,RW, default = 0
//Bit 25    soft_load                //unsigned ,RW, default = 0
//Bit 24    continue_mode            //unsigned ,RW, default = 0
//Bit 23    dol_mode                 //unsigned ,RW, default = 0
//Bit 22    pingpong_mode            //unsigned ,RW, default = 0
//Bit 21    dol_time_out_en          //unsigned ,RW, default = 0
//Bit 20    frame_wr_done_sel        //unsigned ,RW, default = 0
//Bit 19    line_wr_done_sel         //unsigned ,RW, default = 0
//Bit 18    dol_frame_end_en         //unsigned ,RW, default = 0
//Bit 17    dol_vblank_clr_sel       //unsigned ,RW, default = 0
//Bit 16    reserved
//Bit 15:14 dol_time_tick_sel        //unsigned ,RW, default = 0
//Bit 13:4  line_stride              //unsigned ,RW, default = 0
//Bit 3:2   lbuf_soft_rst_sel        //unsigned ,RW, default = 0
//Bit 1     frame_loop_enable        //unsigned ,RW, default = 0
//Bit 0     enable                   //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL1                   ((0x0011  << 2) + 0xff01d000)
//Bit 31:30 port_sel                 //unsigned ,RW, default = 0
//Bit   29  frame_vs_rst_en          //unsigned ,RW, default = 0
//Bit 28:16 line_number              //unsigned ,RW, default = 0
//Bit 15:12 dol_line_threshold       //unsigned ,RW, default = 0
//Bit 11:10 frame_vs_rst_sel         //unsigned ,RW, default = 0
//Bit 9:0   line_size                //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL2                   ((0x0012  << 2) + 0xff01d000)
//Bit 31:0  frame_base_address_0     //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL3                   ((0x0013  << 2) + 0xff01d000)
//Bit 31:0  frame_base_address_1     //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL4                   ((0x0014  << 2) + 0xff01d000)
//Bit 31:13 dol_time_out             //unsigned ,RW, default = 0
//Bit 12:0  line_threshold           //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL5                   ((0x0015  << 2) + 0xff01d000)
//Bit 31:0  frame_end_address_0      //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL6                   ((0x0016  << 2) + 0xff01d000)
//Bit 31:0  frame_end_address_1      //unsigned ,RW, default = 0
#define MIPI_ADAPT_LBUF_1_UGT_CNTL0                ((0x0017  << 2) + 0xff01d000)
//Bit 31    reg_ugt_auto_en          //unsigned ,RW, default = 0
//Bit 30:16 reg_ugt_th1              //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14: 0 reg_ugt_th0              //unsigned ,RW, default = 0
#define MIPI_ADAPT_LBUF_1_UGT_CNTL1                ((0x0018  << 2) + 0xff01d000)
//Bit 31    reg_sideband_auto_en     //unsigned ,RW, default = 0
//Bit 30:16 reg_sideband_th1         //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14: 0 reg_sideband_th0         //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_CNTL7                   ((0x0019  << 2) + 0xff01d000)
//Bit 31:17     reserved
//Bit 16:4      reg_wcnt_force_val //unsigned ,RW, default = 0
//Bit 3         reg_wcnt_force_en  //unsigned ,RW, default = 0
//Bit 2:1       reg_wcnt_rst_sel   //unsigned ,RW, default = 0
//Bit 0         reg_wcnt_sw_rst    //unsigned ,RW, default = 0
#define MIPI_ADAPT_DDR_RD1_ST0                     ((0x001a  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st0   //unsigned ,RO, default = 0
#define MIPI_ADAPT_DDR_RD1_ST1                     ((0x001b  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st1   //unsigned ,RO, default = 0
#define MIPI_ADAPT_DDR_RD1_ST2                     ((0x001c  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_ddr_rd0_st2   //unsigned ,RO, default = 0
#define MIPI_ADAPT_LBUF_1_UGT_ST                   ((0x001d  << 2) + 0xff01d000)
//Bit 31: 0 reg_rd0_qos_st ,         //unsigned ,RO, default = 0
#define DDR_RD1_LBUF_STATUS                        ((0x001f  << 2) + 0xff01d000)
//Bit 31:0  ddr_rd_1_lbuf_status      //unsigned ,RO, default = 0
#define MIPI_ADAPT_PIXEL0_CNTL0                    ((0x0020  << 2) + 0xff01d000)
//Bit 31    start_en                 //unsigned ,RW, default = 0
//Bit 30    soft_load                //unsigned ,RW, default = 0
//Bit 29:26 reserved
//Bit 25:20 data_type                //unsigned ,RW, default = 0
//Bit 19:18 reserved
//Bit 17:16 data_mode                //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14    color_expand             //unsigned ,RW, default = 0
//Bit 13    reserved
//Bit 12:0  fifo_threshold           //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL0_CNTL1                    ((0x0021  << 2) + 0xff01d000)
//Bit 31:16 pixel_x_start            //unsigned ,RW, default = 0
//Bit 15:0  pixel_x_end              //unsigned ,RW, default = 16'hffff
#define MIPI_ADAPT_PIXEL0_CNTL2                    ((0x0022  << 2) + 0xff01d000)
//Bit 31:28 reserved
//Bit 27:15 pixel_num                //unsigned ,RW, default = 0
//Bit 14:10 reserved
//Bit 9:0   fifo_rd_size             //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL0_CNTL3                    ((0x0023  << 2) + 0xff01d000)
//Bit 31    frame_sync_dely_en       //unsigned ,RW, default = 0
//Bit 30:16 frame_sync_dely_time     //unsigned ,RW, default = 0
//Bit 15:3  reserved
//Bit 2     frame_sync_en            //unsigned ,RW, default = 0
//Bit 1     frame_sync_rst_en        //unsigned ,RW, default = 0
//Bit 0     frame_sync_load_en       //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL0_ST0                      ((0x002a  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_pixel0_st0    //unsigned ,RO, default = 0
#define MIPI_ADAPT_PIXEL0_ST1                      ((0x002b  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_pixel0_st1    //unsigned ,RO, default = 0
#define MIPI_ADAPT_PIXEL1_CNTL0                    ((0x0030  << 2) + 0xff01d000)
//Bit 31    start_en                 //unsigned ,RW, default = 0
//Bit 30    soft_load                //unsigned ,RW, default = 0
//Bit 29:26 reserved
//Bit 25:20 data_type                //unsigned ,RW, default = 0
//Bit 19:18 reserved
//Bit 17:16 data_mode                //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14    color_expand             //unsigned ,RW, default = 0
//Bit 13    reserved
//Bit 12:0  fifo_threshold           //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL1_CNTL1                    ((0x0031  << 2) + 0xff01d000)
//Bit 31:16 pixel_x_start            //unsigned ,RW, default = 0
//Bit 15:0  pixel_x_end              //unsigned ,RW, default = 16'hffff
#define MIPI_ADAPT_PIXEL1_CNTL2                    ((0x0032  << 2) + 0xff01d000)
//Bit 31:28 reserved
//Bit 27:15 pixel_num                //unsigned ,RW, default = 0
//Bit 14:10 reserved
//Bit 9:0   fifo_rd_size             //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL1_CNTL3                    ((0x0033  << 2) + 0xff01d000)
//Bit 31    frame_sync_dely_en       //unsigned ,RW, default = 0
//Bit 30:16 frame_sync_dely_time     //unsigned ,RW, default = 0
//Bit 15:3  reserved
//Bit 2     frame_sync_en            //unsigned ,RW, default = 0
//Bit 1     frame_sync_rst_en        //unsigned ,RW, default = 0
//Bit 0     frame_sync_load_en       //unsigned ,RW, default = 0
#define MIPI_ADAPT_PIXEL1_ST0                      ((0x003a  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_pixel0_st0    //unsigned ,RO, default = 0
#define MIPI_ADAPT_PIXEL1_ST1                      ((0x003b  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_pixel0_st1    //unsigned ,RO, default = 0
#define MIPI_ADAPT_ALIG_CNTL0                      ((0x0040  << 2) + 0xff01d000)
//Bit 31:16 v_num_a                   //unsigned ,RW, default = 0
//Bit 15:0  h_num_a                   //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL1                      ((0x0041  << 2) + 0xff01d000)
//Bit 31:16 hpe_num_a                 //unsigned ,RW, default = 0
//Bit 15:0  hps_num_a                 //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL2                      ((0x0042  << 2) + 0xff01d000)
//Bit 31:16 vpe_num_a                 //unsigned ,RW, default = 0
//Bit 15:0  vps_num_a                 //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL3                      ((0x0043  << 2) + 0xff01d000)
//Bit 31:16 frame_start_line          //unsigned ,RW, default = 0
//Bit 15:0  frame_start_pixel         //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL4                      ((0x0044  << 2) + 0xff01d000)
//Bit 31:30 reserved
//Bit 29:0  fill_data                 //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL5                      ((0x0045  << 2) + 0xff01d000)
//Bit 31:22 reserved
//Bit 21:20 flow_done_src_en          //unsigned ,RW, default = 0
//Bit 19:2  reserved
//Bit 1     frame_end_int_final_sel_pre //unsigned ,RW, default = 0
//Bit 0     dst_hold_gate_force       //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL6                      ((0x0046  << 2) + 0xff01d000)
//Bit 31    yuvrgb_mode               //unsigned ,RW, default = 0
//Bit 30    frame_end_load_en         //unsigned ,RW, default = 0
//Bit 29:16 reserved
//Bit 15    vdata3_en                 //unsigned ,RW, default = 0
//Bit 14    vdata2_en                 //unsigned ,RW, default = 0
//Bit 13    vdata1_en                 //unsigned ,RW, default = 0
//Bit 12    vdata0_en                 //unsigned ,RW, default = 0
//Bit 11    vdata3_sel                //unsigned ,RW, default = 0
//Bit 10    vdata2_sel                //unsigned ,RW, default = 0
//Bit 9     vdata1_sel                //unsigned ,RW, default = 0
//Bit 8     vdata0_sel                //unsigned ,RW, default = 0
//Bit 7:6   reserved
//Bit 5     pix_datamode_1            //unsigned ,RW, default = 0
//Bit 4     pix_datamode_0            //unsigned ,RW, default = 0
//Bit 3     lane1_sel                 //unsigned ,RW, default = 0
//Bit 2     lane1_en                  //unsigned ,RW, default = 0
//Bit 1     lane0_sel                 //unsigned ,RW, default = 0
//Bit 0     lane0_en                  //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL7                      ((0x0047  << 2) + 0xff01d000)
//Bit 31:16 inc_mask_timeout          //unsigned ,RW, default = 0
//Bit 15    inc_mask_timeout_en       //unsigned ,RW, default = 0
//Bit 14    frame_sync_rst_en         //unsigned ,RW, default = 0
//Bit 13    frame_sync_load_en        //unsigned ,RW, default = 0
//Bit 12:2  reserved
//Bit 1 :0  inc_mask_tick_sel         //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL8                      ((0x0048  << 2) + 0xff01d000)
//Bit 31    start_en                  //unsigned ,RW, default = 0
//Bit 30    frame_vs_dst_dly_exc_clr  //unsigned ,RW, default = 0
//Bit 29    soft_load                 //unsigned ,RW, default = 0
//Bit 28:16 reserved
//Bit 15    hsync_irq_num_en          //unsigned ,RW, default = 0
//Bit 14    reserved
//Bit 13    no_frame_sv_sync_en       //unsigned ,RW, default = 0
//Bit 12    exc_mask_dis              //unsigned ,RW, default = 0
//Bit 11    mult_camera_req_sf_en     //unsigned ,RW, default = 0
//Bit 10    mult_camera_req_sf        //unsigned ,RW, default = 0
//Bit 9:7   reserved
//Bit 6     isp_mult_frame_req_en     //unsigned ,RW, default = 0
//Bit 5     frame_continue            //unsigned ,RW, default = 0
//Bit 4:3   reserved
//Bit 2     ls_flag_force_val_pre     //unsigned ,RW, default = 0
//Bit 1:0   ls_flag_sel_pre           //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL9                      ((0x0049  << 2) + 0xff01d000)
//Bit 31:16 reserved
//Bit 15:0  hsync_irq_num_pre         //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL10                     ((0x004a  << 2) + 0xff01d000)
//Bit 31:26 reserved
//Bit 25    isp_hold_src1_en          //unsigned ,RW, default = 0
//Bit 24    isp_hold_src0_en          //unsigned ,RW, default = 0
//Bit 23:0  reserved
#define MIPI_ADAPT_ALIG_CNTL11                     ((0x004b  << 2) + 0xff01d000)
//Bit 31:19 reserved
//Bit 18:16 frame_vs_dst0_sel         //unsigned ,RW, default = 0
//Bit 15:0  frame_vs_dst0_cke_delay   //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL12                     ((0x004c  << 2) + 0xff01d000)
//Bit 31:19 reserved
//Bit 18:16 frame_vs_dst1_sel         //unsigned ,RW, default = 0
//Bit 15:0  frame_vs_dst1_cke_delay   //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL13                     ((0x004d  << 2) + 0xff01d000)
//Bit 31:19 reserved
//Bit 18:16 frame_vs_dst2_sel         //unsigned ,RW, default = 0
//Bit 15:0  frame_vs_dst2_cke_delay   //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_CNTL14                     ((0x004e  << 2) + 0xff01d000)
//Bit 31:19 reserved
//Bit 18:16 frame_vs_dst3_sel         //unsigned ,RW, default = 0
//Bit 15:0  frame_vs_dst3_cke_delay   //unsigned ,RW, default = 0
#define MIPI_ADAPT_ALIG_ST0                        ((0x0050  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_alig_st0       //unsigned ,RO, default = 0
#define MIPI_ADAPT_ALIG_ST1                        ((0x0051  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_alig_st1       //unsigned ,RO, default = 0
#define MIPI_ADAPT_ALIG_ST2                        ((0x0052  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_alig_st2       //unsigned ,RO, default = 0
#define MIPI_ADAPT_TOP_CNTL0                       ((0x0060  << 2) + 0xff01d000)
//Bit 31:30 reserved
//Bit 29    reg_lbuf1_clk_on          //unsigned ,RW, default = 0
//Bit 28    reg_vfifo_rst_sync        //unsigned ,RW, default = 0
//Bit 27:26 reg_rd1_lbuf_ov_mask      //unsigned ,RW, default = 3
//Bit 25    reserved
//Bit 24:20 reg_adapt_debug_sel       //unsigned ,RW, default = 0
//Bit 19:18 reg_rd0_lbuf_ov_mask      //unsigned ,RW, default = 3
//Bit 17    reg_vfifo_clk_on          //unsigned ,RW, default = 0
//Bit 16    reg_lbuf0_clk_on          //unsigned ,RW, default = 0
//Bit 15:0  reg_soft_rst              //unsigned ,RW, default = 0
#define MIPI_ADAPT_TOP_CNTL1                       ((0x0061  << 2) + 0xff01d000)
//Bit 31:13 reserved
//Bit 12    reg_clk_off_pixel1        //unsigned ,RW, default = 0
//Bit 11    reg_clk_off_lbuf1_ugt     //unsigned ,RW, default = 0
//Bit 10    reg_clk_off_lbuf1         //unsigned ,RW, default = 0
//Bit 9     reg_clk_off_ddr_rd1       //unsigned ,RW, default = 0
//Bit 8     reg_clk_off_fe1           //unsigned ,RW, default = 0
//Bit 7     reg_clk_off_vfifo         //unsigned ,RW, default = 0
//Bit 6     reg_clk_off_fe_mux        //unsigned ,RW, default = 0
//Bit 5     reg_clk_off_align         //unsigned ,RW, default = 0
//Bit 4     reg_clk_off_pixel0        //unsigned ,RW, default = 0
//Bit 3     reg_clk_off_lbuf0_ugt     //unsigned ,RW, default = 0
//Bit 2     reg_clk_off_lbuf0         //unsigned ,RW, default = 0
//Bit 1     reg_clk_off_ddr_rd0       //unsigned ,RW, default = 0
//Bit 0     reg_clk_off_fe0           //unsigned ,RW, default = 0
#define MIPI_ADAPT_AXI_CTRL0                       ((0x0062  << 2) + 0xff01d000)
//Bit 31:24 reserved
//Bit 23:22 reg_rd1_axi_extra_addr       //unsigned ,RW, default = 0
//Bit 21:20 reg_rd0_axi_extra_addr       //unsigned ,RW, default = 0
//Bit 19:18 reg_fe1_axi_extra_addr       //unsigned ,RW, default = 0
//Bit 17:16 reg_fe0_axi_extra_addr       //unsigned ,RW, default = 0
//Bit 15:12 reg_ddr_rd1_axi_rd_prot_ctrl //unsigned ,RW, default = 0
//Bit 11:8  reg_ddr_rd0_axi_rd_prot_ctrl //unsigned ,RW, default = 0
//Bit 7:4   reg_fe1_axi_wr_prot_ctrl     //unsigned ,RW, default = 0
//Bit 3:0   reg_fe0_axi_wr_prot_ctrl     //unsigned ,RW, default = 0
#define MIPI_ADAPT_AXI_PROT_STAT0                  ((0x0068  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_axi_prot_stat0  //unsigned ,RO, default = 0
#define MIPI_ADAPT_AXI_PROT_STAT1                  ((0x0069  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_axi_prot_stat1  //unsigned ,RO, default = 0
#define MIPI_ADAPT_AXI_PROT_STAT2                  ((0x006a  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_axi_prot_stat2  //unsigned ,RO, default = 0
#define MIPI_ADAPT_AXI_PROT_STAT3                  ((0x006b  << 2) + 0xff01d000)
//Bit 31:0  mipi_adapt_axi_prot_stat3  //unsigned ,RO, default = 0
#define MIPI_ADAPT_FE_MUX_CTL0                     ((0x0090  << 2) + 0xff01d000)
//Bit 31    reg_rd1_fe_sel                //unsigned, RW, default = 0
//Bit 30:26 reserved
//Bit 25:23 reg_lbuf1_vs_sel              //unsigned, RW, default = 0
//Bit 22:20 reg_pixel1_vs_sel             //unsigned, RW, default = 0
//Bit 19    reserved
//Bit 18    reg_ddr_rd1_line_wr_vs_sel    //unsigned ,RW, default = 0
//Bit 17    reg_ddr_rd1_frame_wr_done_sel //unsigned ,RW, default = 0
//Bit 16    reg_ddr_rd1_line_wr_done_sel  //unsigned ,RW, default = 0
//Bit 15    reg_rd0_fe_sel                //unsigned ,RW, default = 0
//Bit 14:11 reserved
//Bit 10:8  reg_lbuf0_vs_sel              //unsigned ,RW, default = 0
//Bit 7     reserved
//Bit 6:4   reg_pixel0_vs_sel             //unsigned ,RW, default = 0
//Bit 3     reserved
//Bit 2     reg_ddr_rd0_line_wr_vs_sel    //unsigned ,RW, default = 0
//Bit 1     reg_ddr_rd0_frame_wr_done_sel //unsigned ,RW, default = 0
//Bit 0     reg_ddr_rd0_line_wr_done_sel  //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX_CTL1                     ((0x0091  << 2) + 0xff01d000)
//Bit 31:19 reserved
//Bit 18:16 reg_de_rd_vs_sel            //unsigned, RW, default = 0
//Bit 15    reserved
//Bit 14:12 reg_de_wr_vs_sel            //unsigned, RW, default = 0
//Bit 11    reg_hs_vs_sel               //unsigned, RW, default = 0
//Bit 10    reserved
//Bit 9:8   reg_alig_frame_valid_en     //unsigned, RW, default = 0
//Bit 7:4   reg_vfifo_vs_sel            //unsigned, RW, default = 0
//Bit 3     reserved
//Bit 2:0   reg_alig_vs_sel             //unsigned, RW, default = 0
#define MIPI_ADAPT_FE_MUX_CTL2                     ((0x0092  << 2) + 0xff01d000)
//Bit 31:16 reserved
//Bit 15:12 reg_md_vs_sel               //unsigned ,RW, default = 0
//Bit 11:8  reg_eof_vs_sel              //unsigned ,RW, default = 0
//Bit 7:4   reg_sof_vs_sel              //unsigned ,RW, default = 0
//Bit 3:0   reg_isp_vs_sel              //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX0_DLY_CNTL0               ((0x0098  << 2) + 0xff01d000)
//Bit 31    reg_mux0_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux0_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux0_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux0_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux0_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux0_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux0_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX0_DLY_STAT0               ((0x0099  << 2) + 0xff01d000)
//Bit 31    ro_mux0_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux0_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux0_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux0_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX1_DLY_CNTL0               ((0x009a  << 2) + 0xff01d000)
//Bit 31    reg_mux1_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux1_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux1_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux1_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux1_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux1_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux1_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX1_DLY_STAT0               ((0x009b  << 2) + 0xff01d000)
//Bit 31    ro_mux1_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux1_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux1_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux1_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX2_DLY_CNTL0               ((0x009c  << 2) + 0xff01d000)
//Bit 31    reg_mux2_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux2_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux2_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux2_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux2_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux2_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux2_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX2_DLY_STAT0               ((0x009d  << 2) + 0xff01d000)
//Bit 31    ro_mux2_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux2_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux2_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux2_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX3_DLY_CNTL0               ((0x009e  << 2) + 0xff01d000)
//Bit 31    reg_mux3_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux3_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux3_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux3_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux3_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux3_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux3_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX3_DLY_STAT0               ((0x009f  << 2) + 0xff01d000)
//Bit 31    ro_mux3_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux3_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux3_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux3_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX4_DLY_CNTL0               ((0x00a0  << 2) + 0xff01d000)
//Bit 31    reg_mux4_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux4_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux4_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux4_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux4_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux4_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux4_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX4_DLY_STAT0               ((0x00a1  << 2) + 0xff01d000)
//Bit 31    ro_mux4_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux4_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux4_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux4_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX5_DLY_CNTL0               ((0x00a2  << 2) + 0xff01d000)
//Bit 31    reg_mux5_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux5_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux5_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux5_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux5_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux5_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux5_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX5_DLY_STAT0               ((0x00a3  << 2) + 0xff01d000)
//Bit 31    ro_mux5_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux5_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux5_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux5_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX6_DLY_CNTL0               ((0x00a4  << 2) + 0xff01d000)
//Bit 31    reg_mux6_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux6_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux6_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux6_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux6_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux6_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux6_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX6_DLY_STAT0               ((0x00a5  << 2) + 0xff01d000)
//Bit 31    ro_mux6_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux6_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux6_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux6_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX7_DLY_CNTL0               ((0x00a6  << 2) + 0xff01d000)
//Bit 31    reg_mux7_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux7_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux7_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux7_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux7_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux7_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux7_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX7_DLY_STAT0               ((0x00a7  << 2) + 0xff01d000)
//Bit 31    ro_mux7_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux7_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux7_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux7_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX8_DLY_CNTL0               ((0x00a8  << 2) + 0xff01d000)
//Bit 31    reg_mux8_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux8_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux8_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux8_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux8_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux8_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux8_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX8_DLY_STAT0               ((0x00a9  << 2) + 0xff01d000)
//Bit 31    ro_mux8_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux8_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux8_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux8_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_FE_MUX9_DLY_CNTL0               ((0x00aa  << 2) + 0xff01d000)
//Bit 31    reg_mux9_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_mux9_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_mux9_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_mux9_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_mux9_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_mux9_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_mux9_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_FE_MUX9_DLY_STAT0               ((0x00ab  << 2) + 0xff01d000)
//Bit 31    ro_mux9_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_mux9_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_mux9_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_mux9_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_CSI_HSYNC_0_DLY_CNTL            ((0x00b0  << 2) + 0xff01d000)
//Bit 31    reg_hsync0_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_hsync0_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_hsync0_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_hsync0_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_hsync0_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_hsync0_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_hsync0_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_CSI_HSYNC_0_DLY_STAT            ((0x00b1  << 2) + 0xff01d000)
//Bit 31    ro_hsync0_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16 ro_hsync0_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15    ro_hsync0_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0  ro_hsync0_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_CSI_VSYNC_0_DLY_CNTL            ((0x00b2  << 2) + 0xff01d000)
//Bit 31    reg_vsync0_soft_rst          //unsigned ,RW, default = 0
//Bit 30    reserved
//Bit 29    reg_vsync0_mont_clr          //unsigned ,RW, default = 0
//Bit 28    reg_vsync0_mont_en           //unsigned ,RW, default = 0
//Bit 27    reg_vsync0_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20 reserved
//Bit 19    reg_vsync0_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18    reserved
//Bit 17:16 reg_vsync0_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15    reserved
//Bit 14:0  reg_vsync0_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_CSI_VSYNC_0_DLY_STAT            ((0x00b3  << 2) + 0xff01d000)
//Bit 31     ro_vsync0_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16  ro_vsync0_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15     ro_vsync0_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0   ro_vsync0_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_CSI_VSYNC_1_DLY_CNTL            ((0x00b4  << 2) + 0xff01d000)
//Bit 31     reg_vsync1_soft_rst          //unsigned ,RW, default = 0
//Bit 30     reserved
//Bit 29     reg_vsync1_mont_clr          //unsigned ,RW, default = 0
//Bit 28     reg_vsync1_mont_en           //unsigned ,RW, default = 0
//Bit 27     reg_vsync1_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20  reserved
//Bit 19     reg_vsync1_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18     reserved
//Bit 17:16  reg_vsync1_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15     reserved
//Bit 14:0   reg_vsync1_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_CSI_VSYNC_1_DLY_STAT            ((0x00b5  << 2) + 0xff01d000)
//Bit 31     ro_vsync1_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16  ro_vsync1_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15     ro_vsync1_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0   ro_vsync1_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_CSI_VSYNC_2_DLY_CNTL            ((0x00b6  << 2) + 0xff01d000)
//Bit 31     reg_vsync2_soft_rst          //unsigned ,RW, default = 0
//Bit 30     reserved
//Bit 29     reg_vsync2_mont_clr          //unsigned ,RW, default = 0
//Bit 28     reg_vsync2_mont_en           //unsigned ,RW, default = 0
//Bit 27     reg_vsync2_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20  reserved
//Bit 19     reg_vsync2_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18     reserved
//Bit 17:16  reg_vsync2_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15     reserved
//Bit 14:0   reg_vsync2_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_CSI_VSYNC_2_DLY_STAT            ((0x00b7  << 2) + 0xff01d000)
//Bit 31     ro_vsync2_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16  ro_vsync2_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15     ro_vsync2_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0   ro_vsync2_vs_mon_min         //unsigned  ,RO,  default = 0
#define MIPI_ADAPT_CSI_VSYNC_3_DLY_CNTL            ((0x00b8  << 2) + 0xff01d000)
//Bit 31     reg_vsync3_soft_rst          //unsigned ,RW, default = 0
//Bit 30     reserved
//Bit 29     reg_vsync3_mont_clr          //unsigned ,RW, default = 0
//Bit 28     reg_vsync3_mont_en           //unsigned ,RW, default = 0
//Bit 27     reg_vsync3_vs_delay_exc_clr  //unsigned ,RW, default = 0
//Bit 26:20  reserved
//Bit 19     reg_vsync3_vs_delay_en       //unsigned ,RW, default = 0
//Bit 18     reserved
//Bit 17:16  reg_vsync3_vs_delay_tick_sel //unsigned ,RW, default = 0
//Bit 15     reserved
//Bit 14:0   reg_vsync3_vs_delay_num      //unsigned ,RW, default = 0
#define MIPI_ADAPT_CSI_VSYNC_3_DLY_STAT            ((0x00b9  << 2) + 0xff01d000)
//Bit 31     ro_vsync3_vs_delay_exc       //unsigned  ,RO,  default = 0
//Bit 30:16  ro_vsync3_vs_mont_max        //unsigned  ,RO,  default = 0
//Bit 15     ro_vsync3_vs_delay_cnt0      //unsigned  ,RO,  default = 0
//Bit 14:0   ro_vsync3_vs_mon_min         //unsigned  ,RO,  default = 0
//
// Closing file:  ./mipi_adapt.h
//
//========================================================================
// MIPI_ISP  data compress/decompress0_0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff010c00
// -----------------------------------------------
//
// Reading file:  ./mipi_adapt_cmpr_regs.h
//
// synopsys translate_off
// synopsys translate_on
//-------------------------------------------------
#define MIPI_ADAPT_CMPR_SPLIT_CTRL                 ((0x0000  << 2) + 0xff010c00)
//Bit 31:16 reg_split_sync_ctrl       // unsigned , RW, default = 0, register sync (shadow) ctrl
//Bit 15:8  reserved
//Bit 7 :4  reserved
//Bit    3  reg_split_ignore_frag_cmd // unsigned , RW, default = 1, ingore no used axi cmd before cmd with address = "reg_wsub0_iaddr_bgn"
//Bit    2  reserved
//Bit    1  reg_split_big_endian      // unsigned , RW, default = 0,  Big_endian
//Bit    0  reg_split_enable          // unsigned , RW, default = 1,  1 to enable
#define MIPI_ADAPT_CMPR_SPLIT_SIZE                 ((0x0001  << 2) + 0xff010c00)
//Bit 31:16 reg_split_gclk_ctrl       // unsigned , RW, default = 0
//Bit 15:0  reg_split_hsize           // unsigned , RW, default = 4608 hsize
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_CTRL          ((0x0002  << 2) + 0xff010c00)
//Bit 31:21 reserved
//Bit 20    reg_split_abort_after_cmd_1st    // unsigned , RW, default = 1
//Bit 19    reg_split_internal_abort_en      // unsigned , RW, default = 1
//Bit 18    reg_split_abort_hold_input       // unsigned , RW, default = 1
//Bit 17    reg_split_frmrst_hold_input      // unsigned , RW, default = 1, 1 to hold axi input during frmrst generate, only valid for reg_frmrst_mode =0/2
//Bit 16    reg_split_rdma_trigger_mode      // unsigned , RW, default = 0, 0 to use frmrst, 1 to use frame_end
//Bit 15    reg_split_rdma_enable            // unsigned , RW, default = 0, 1 to enable RDMA
//Bit 14    reserved
//Bit 13    reg_split_frmrst_hold4abort_mode // unsigned , RW, default = 0, 1 to start frmrst delay counter caused by abort after enc path idle.
//Bit 12    reg_split_frmrst_hold4gen_mode   // unsigned , RW, default = 0, 1 to start frmrst delay counter after enc path idle.
//Bit 11    reg_split_dis_abort              // unsigned , RW, default = 0, disable abnormal abort processing.
//Bit 10    reg_split_dis_frmrst_by_abort    // unsigned , RW, default = 0, disable frmrst generate caused by abnormal abort
//Bit 9     reg_split_wait_idle_for_abort    // unsigned , RW, default = 1, wait enc path idle before frmrst generate cause by abnormal abort.
//Bit 8     reg_split_wait_idle_for_frmrst   // unsigned , RW, default = 1, wait enc path idle before frmrst generate.
//Bit 7 : 6 reserved
//Bit 5 : 4 reg_split_frmrst_mode   // unsigned , RW, default = 0, frmrst mode, 0:use input frmrst; 1:use reg_soft_frmrst; 2: use axi iaddr_end to generate; 3: use iaddr_bgn to generate
//Bit 3 : 1 reserved
//Bit 0     reg_split_soft_frmrst   // unsigned , RW, default = 0, write 1 to generate a soft frmrst
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_DLY0          ((0x0003  << 2) + 0xff010c00)
//Bit 31:0  reg_split_frmrst_dlys4gen     // unsigned , RW, default = 0, clock delays for frmrst generate except caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_SPLIT_FRMRST_DLY1          ((0x0004  << 2) + 0xff010c00)
//Bit 31:0  reg_split_frmrst_dlys4abort   // unsigned , RW, default = 16, clock delays for frmrst generate caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_SPLIT_FRMHOLD              ((0x0005  << 2) + 0xff010c00)
//Bit 31:0  reg_split_frm_holds           // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define MIPI_ADAPT_CMPR_RO_SPLIT_STATS             ((0x0007  << 2) + 0xff010c00)
//Bit 31:0  ro_split_status               // unsigned , RW, default = 0
#define MIPI_ADAPT_CMPR_WSUB0_CTRL                 ((0x0008  << 2) + 0xff010c00)
//Bit 31:21 reserved
//Bit 20    reg_wsub0_raw67_ext           // unsigned , RW, default = 0,
//Bit 19    reserved
//Bit 18:16 reg_wsub0_raw_mode            // unsigned , RW, default = 1,  //raw6/7/8/10/12/14
//Bit 15:10 reserved
//Bit 9 : 0 reg_wsub0_dfifo_size          // unsigned , RW, default = 32
#define MIPI_ADAPT_CMPR_WSUB0_IADDRS               ((0x0009  << 2) + 0xff010c00)
//Bit 31:0  reg_wsub0_iaddr_bgn           // unsigned , RW, default =0, start address for WSUB0
#define MIPI_ADAPT_CMPR_WSUB0_IADDRE               ((0x000a  << 2) + 0xff010c00)
//Bit 31:0  reg_wsub0_iaddr_end           // unsigned , RW, default =0, end address for WSUB0
//-------------------------------------------------
#define MIPI_ADAPT_CMPR_PACK_CTRL                  ((0x0010  << 2) + 0xff010c00)
//Bit 31:16 reg_pack_sync_ctrl            // unsigned , RW, default = 0, register sync (shadow) ctrl
//Bit 15:7  reserved
//Bit    6  reg_pack_skip_flag_init       // unsigned , RW, default = 0, skip flag for pack, 1 to skip pack axi cmd for current frame
//Bit    5  reg_pack_skip_auto_ctrl       // unsigned , RW, default = 0, auto control for skip flag, if 1, the 1st frame use the reg_pack_skip_init as skip flag, and the next frames use 0 for skip flag
//Bit    4  reserved
//Bit    3  reg_pack_ignore_frag_cmd      // unsigned , RW, default = 1, ingore no used axi cmd before cmd with address = "reg_rsub0_iaddr_bgn"
//Bit    2  reserved
//Bit    1  reg_pack_big_endian           // unsigned , RW, default = 0,  Big_endian
//Bit    0  reg_pack_enable               // unsigned , RW, default = 1,  1 to enable
#define MIPI_ADAPT_CMPR_PACK_SIZE                  ((0x0011  << 2) + 0xff010c00)
//Bit 31:16 reg_pack_gclk_ctrl            // unsigned , RW, default = 0
//Bit 15:0  reg_pack_hsize                // unsigned , RW, default = 4608 hsize
#define MIPI_ADAPT_CMPR_PACK_FRMRST_CTRL           ((0x0012  << 2) + 0xff010c00)
//Bit 31:25 reserved
//Bit 24    reg_pack_busy_care_rdmif        // unsigned , RW, default = 0, 1 to take rdmif busy as pack busy
//Bit 23:21 reserved
//Bit 20    reg_pack_abort_after_cmd_1st    // unsigned , RW, default = 1
//Bit 19    reg_pack_internal_abort_en      // unsigned , RW, default = 1
//Bit 18    reg_pack_abort_hold_input       // unsigned , RW, default = 1
//Bit 17    reg_pack_frmrst_hold_input      // unsigned , RW, default = 1, 1 to hold axi input during frmrst generate, only valid for reg_frmrst_mode =0/2
//Bit 16    reg_pack_rdma_trigger_mode      // unsigned , RW, default = 0, 0 to use frmrst, 1 to use frame_end
//Bit 15    reg_pack_rdma_enable            // unsigned , RW, default = 0, 1 to enable RDMA
//Bit 14    reserved
//Bit 13    reg_pack_frmrst_hold4abort_mode // unsigned , RW, default = 0, 1 to start frmrst delay counter caused by abort after enc path idle.
//Bit 12    reg_pack_frmrst_hold4gen_mode   // unsigned , RW, default = 0, 1 to start frmrst delay counter after enc path idle.
//Bit 11    reg_pack_dis_abort              // unsigned , RW, default = 0, disable abnormal abort processing.
//Bit 10    reg_pack_dis_frmrst_by_abort    // unsigned , RW, default = 0, disable frmrst generate caused by abnormal abort
//Bit 9     reg_pack_wait_idle_for_abort    // unsigned , RW, default = 1, wait enc path idle before frmrst generate cause by abnormal abort.
//Bit 8     reg_pack_wait_idle_for_frmrst  // unsigned , RW, default = 1, wait enc path ready before frmrst generate.
//Bit 7 : 6 reserved
//Bit 5 : 4 reg_pack_frmrst_mode   // unsigned , RW, default = 0, frmrst mode, 0:use input frmrst; 1:use reg_soft_frmrst; 2: use axi iaddr_end to generate; 3: use iaddr_bgn to generate
//Bit 3 : 1 reserved
//Bit 0     reg_pack_soft_frmrst   // unsigned , RW, default = 0, write 1 to generate a soft frmrst
#define MIPI_ADAPT_CMPR_PACK_FRMRST_DLY0           ((0x0013  << 2) + 0xff010c00)
//Bit 31:0  reg_pack_frmrst_dlys4gen      // unsigned , RW, default = 0, clock delays for frmrst generate except caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_PACK_FRMRST_DLY1           ((0x0014  << 2) + 0xff010c00)
//Bit 31:0  reg_pack_frmrst_dlys4abort   // unsigned , RW, default = 16, clock delays for frmrst generate caused by "abnormal abort"
#define MIPI_ADAPT_CMPR_PACK_FRMHOLD               ((0x0015  << 2) + 0xff010c00)
//Bit 31:0  reg_pack_frm_holds            // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define MIPI_ADAPT_CMPR_RO_PACK_STATS              ((0x0017  << 2) + 0xff010c00)
//Bit 31:0  ro_pack_status                 // unsigned , RW, default = 0
#define MIPI_ADAPT_CMPR_RSUB0_CTRL                 ((0x0018  << 2) + 0xff010c00)
//Bit 31:21 reserved
//Bit 20    reg_rsub0_raw67_ext           // unsigned , RW, default = 0,
//Bit 19    reserved
//Bit 18:16 reg_rsub0_raw_mode            // unsigned , RW, default = 1,  //raw6/7/8/10/12/14
//Bit 15:10 reserved
//Bit 9 : 0 reg_rsub0_dfifo_size          // unsigned , RW, default = 32
#define MIPI_ADAPT_CMPR_RSUB0_IADDRS               ((0x0019  << 2) + 0xff010c00)
//Bit 31:0  reg_rsub0_iaddr_bgn           // unsigned , RW, default =0, start address for RSUB0
#define MIPI_ADAPT_CMPR_RSUB0_IADDRE               ((0x001a  << 2) + 0xff010c00)
//Bit 31:0  reg_rsub0_iaddr_end           // unsigned , RW, default =0, end address for RSUB0
//--------------------------------------------------
#define MIPI_ADAPT_CMPR_INT_EN                     ((0x0020  << 2) + 0xff010c00)
//Bit 31:0  reg_adapt_int_en             // unsigned , RW default = 0, interrupt mask
#define MIPI_ADAPT_CMPR_RO_INT_STATUS              ((0x0021  << 2) + 0xff010c00)
//Bit 31:0  ro_adapt_int_status          // unsigned , RO, default 0, interrupt status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_adapt_cmpr_regs.h
//
//========================================================================
// MIPI_ISP  data compress/decompress0_1
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff311400
// -----------------------------------------------
//`include "mipi_adapt_cmpr_loss_sub0.h"
//========================================================================
// MIPI_ISP  data compress enc
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff011000
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_raw_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define MIPI_LOSSE_RAW_CTRL                        ((0x0000  << 2) + 0xff011000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define MIPI_LOSSE_RAW_FRAME_HOLD                  ((0x0001  << 2) + 0xff011000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define MIPI_LOSSE_RAW_GCLK_CTRL                   ((0x0002  << 2) + 0xff011000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define MIPI_LOSSE_RAW_RO_CODEC_STATUS             ((0x0003  << 2) + 0xff011000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define MIPI_LOSSE_RAW_MISC                        ((0x0004  << 2) + 0xff011000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define MIPI_LOSSE_RAW_BASIS                       ((0x0008  << 2) + 0xff011000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define MIPI_LOSSE_RAW_OFST_BIT_DEPTH              ((0x0009  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define MIPI_LOSSE_RAW_PIC_SIZE                    ((0x000a  << 2) + 0xff011000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define MIPI_LOSSE_RAW_SLICE_SIZE                  ((0x000b  << 2) + 0xff011000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_1                ((0x000c  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_2                ((0x000d  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_SLICE_SIZE_3                ((0x000e  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSE_RAW_PRESL_LAST_BITS             ((0x000f  << 2) + 0xff011000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define MIPI_LOSSE_RAW_PRESL_FIFO_LEVEL            ((0x0010  << 2) + 0xff011000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define MIPI_LOSSE_RAW_DEBUG                       ((0x0011  << 2) + 0xff011000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_REF_DATA                    ((0x0012  << 2) + 0xff011000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_REF_DATA_1                  ((0x0013  << 2) + 0xff011000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_REF_DATA_2                  ((0x0014  << 2) + 0xff011000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define MIPI_LOSSE_RAW_PRED_PROCE                  ((0x0015  << 2) + 0xff011000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define MIPI_LOSSE_RAW_GLOBAL_PHASE_LUT            ((0x0016  << 2) + 0xff011000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSE_RAW_GLOBAL_PHASE_LUT_1          ((0x0017  << 2) + 0xff011000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSE_RAW_PHASE_LUT                   ((0x0018  << 2) + 0xff011000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define MIPI_LOSSE_RAW_FLATNESS_0                  ((0x0019  << 2) + 0xff011000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define MIPI_LOSSE_RAW_FLATNESS_QP                 ((0x001a  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define MIPI_LOSSE_RAW_FLATNESS_TH0                ((0x001b  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_FLATNESS_TH1                ((0x001c  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_FLATNESS_TH2                ((0x001d  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSE_RAW_QP_MAP_CHN0                 ((0x001e  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_1               ((0x001f  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_2               ((0x0020  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_3               ((0x0021  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_4               ((0x0022  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_5               ((0x0023  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_6               ((0x0024  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_7               ((0x0025  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_8               ((0x0026  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN0_9               ((0x0027  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1                 ((0x0028  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_1               ((0x0029  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_2               ((0x002a  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_3               ((0x002b  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_4               ((0x002c  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_5               ((0x002d  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_6               ((0x002e  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_7               ((0x002f  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_8               ((0x0030  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN1_9               ((0x0031  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2                 ((0x0032  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_1               ((0x0033  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_2               ((0x0034  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_3               ((0x0035  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_4               ((0x0036  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_5               ((0x0037  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_6               ((0x0038  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_7               ((0x0039  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_8               ((0x003a  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_QP_MAP_CHN2_9               ((0x003b  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSE_RAW_RC_GROUP_2                  ((0x003c  << 2) + 0xff011000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define MIPI_LOSSE_RAW_RC_BUDGET_0                 ((0x003d  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_3 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_2 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_1 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_0 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSE_RAW_RC_BUDGET_1                 ((0x003e  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_7 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_6 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_5 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_4 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSE_RAW_RC_BUDGET_2                 ((0x003f  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_11 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_10 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_9 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_8 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSE_RAW_RC_BUDGET_3                 ((0x0040  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_15 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_14 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_13 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_12 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSE_RAW_RC_BUDGET_4                 ((0x0041  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_16 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define MIPI_LOSSE_RAW_RC_BUDGET_5                 ((0x0042  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define MIPI_LOSSE_RAW_RC_BUDGET_6                 ((0x0043  << 2) + 0xff011000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define MIPI_LOSSE_RAW_RC_QP_MARGIN                ((0x0044  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_1              ((0x0045  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_2              ((0x0046  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_3              ((0x0047  << 2) + 0xff011000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_4              ((0x0048  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSE_RAW_RC_QP_MARGIN_5              ((0x0049  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSE_RAW_FLATNESS_ADJ0               ((0x004a  << 2) + 0xff011000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define MIPI_LOSSE_RAW_FLATNESS_ADJ1               ((0x004b  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define MIPI_LOSSE_RAW_FIFO_THD_0                  ((0x004c  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_THD_1                  ((0x004d  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_THD_2                  ((0x004e  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_FIFO_AVG                    ((0x004f  << 2) + 0xff011000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define MIPI_LOSSE_RAW_FIFO_DLT                    ((0x0050  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSE_RAW_BITSGAP_THD_0               ((0x0051  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define MIPI_LOSSE_RAW_BITSGAP_THD_1               ((0x0052  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define MIPI_LOSSE_RAW_REF_ADJ                     ((0x0053  << 2) + 0xff011000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_0               ((0x0054  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_1               ((0x0055  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_2               ((0x0056  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_3               ((0x0057  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_DLT_4               ((0x0058  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_REF_ADJ_DLT_5           ((0x0059  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN0             ((0x005a  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN0_1           ((0x005b  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN1             ((0x005c  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN1_1           ((0x005d  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN2             ((0x005e  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define MIPI_LOSSE_RAW_REF_ADJ_TH_CHN2_1           ((0x005f  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define MIPI_LOSSE_RAW_ACCUM_OFSET_0               ((0x0060  << 2) + 0xff011000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_1               ((0x0061  << 2) + 0xff011000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_2               ((0x0062  << 2) + 0xff011000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_ACCUM_OFSET_3               ((0x0063  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define MIPI_LOSSE_RAW_WDR_LINE_DELAY              ((0x0064  << 2) + 0xff011000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define MIPI_LOSSE_RAW_CORING_TH_OFST              ((0x0065  << 2) + 0xff011000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define MIPI_LOSSE_RAW_CORING_RST                  ((0x0066  << 2) + 0xff011000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define MIPI_LOSSE_RAW_STATS_RAM_MODE              ((0x0067  << 2) + 0xff011000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define MIPI_LOSSE_RAW_STATS_RAM_ADDR              ((0x0068  << 2) + 0xff011000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define MIPI_LOSSE_RAW_RO_STATS_RAM_DATA           ((0x0069  << 2) + 0xff011000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_raw_enc_regs.h
//
//========================================================================
// MIPI_ISP  data compress mif enc
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff011000
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_mif_enc_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define AWSUB0_ISP_LOSS_MIF_CTRL                   ((0x0070  << 2) + 0xff011000)
//Bit 31:24    reg_sync_sel                  // unsigned , RW, default = 0, sync with frm rst
//Bit 23:16    reg_canvas_id                 // unsigned , RW, default = 0, axi canvas id num
//Bit 15       reserved
//Bit 14:12    reg_cmd_intr_len              // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10    reserved
//Bit  9: 8    reg_cmd_req_size              // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=48 3=64
//Bit  7       reserved
//Bit  6: 4    reg_burst_len                 // unsigned , RW, default = 3, burst type: 0->1; 1->2; 2->4; 3->8; 4->16, others reserved
//Bit  3       reserved
//Bit  2       reg_check_resp_id             // unsigned , RW, default = 0
//Bit  1       reg_dol_mode                  // unsigned , RW, default = 0  1: DOL mode
//Bit  0       reg_mif_enable                // unsigned , RW, default = 1  1 to mif
#define AWSUB0_ISP_LOSS_MIF_QOS                    ((0x0071  << 2) + 0xff011000)
//Bit 31:0     reg_qos_ctrl                  // unsigned , RW, default = 0, Qos control reg
                                             //18    reg_qos_auto_en
                                             //17    reg_qos_sup
                                             //16    reg_qos_ini
                                             //15:8  reg_qos_up_th
                                             // 7:0  reg_qos_dn_th
#define AWSUB0_ISP_LOSS_MIF_URGENT                 ((0x0072  << 2) + 0xff011000)
//Bit 31:0     reg_urgent_ctrl               // unsigned , RW, default = 0, urgent control reg
                                             //18    reg_urgent_auto_en
                                             //17    reg_urgent_sup
                                             //16    reg_urgent_ini
                                             //15:8  reg_urgent_up_th
                                             // 7:0  reg_urgent_dn_th
#define AWSUB0_ISP_LOSS_MIF_MISC                   ((0x0073  << 2) + 0xff011000)
//Bit 31:4  reserved
//Bit 3     reg_mif_busy_noresp_check       // unsigned , RW, default =1, for mif write, dont take "respond busy" as mif unit busy.
//Bit 2     reg_mif_wait_input4busy         // unsigned , RW, default =0, use in encoder, mif is busy till input data comming. only for mif wr
//Bit 1     reg_mif_dbl_baddr_init          // unsigned , RW, default =0, write 1 to use reg_mif_baddr as base-addr for next frame,it would be clear automatically.
//Bit 0     reg_mif_dbl_baddr_en            // unsigned , RW, default =0, 1 to use ping-pong base-addr based on frame.
#define AWSUB0_ISP_LOSS_MIF_BADDR                  ((0x0074  << 2) + 0xff011000)
//Bit 31:0  reg_mif_baddr                    // unsigned , RW, default = 0,  mif base address
#define AWSUB0_ISP_LOSS_MIF_BADDR1                 ((0x0075  << 2) + 0xff011000)
//Bit 31:0  reg_mif_baddr1                  // unsigned , RW, default = 0,  mif base address
#define AWSUB0_ISP_LOSS_MIF_FIFO_CTRL              ((0x0077  << 2) + 0xff011000)
//Bit 31:16 reg_mif_gclk_ctrl                // unsigned , RW, default = 0, gate clock control
//Bit 15:8  reserved                         //
//Bit 7 :0  reg_mif_fifo_size                // unsigned , RW, data FIFO max size, default = 128,
#define AWSUB0_ISP_LOSS_MIF_FRM_HOLD               ((0x0078  << 2) + 0xff011000)
//Bit 31:0  reg_mif_frm_holds                // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define AWSUB0_ISP_LOSS_MIF_RO_STATS               ((0x0079  << 2) + 0xff011000)
//Bit 31: 0  ro_mif_status                  // unsigned ,  RO, default = 0  mif status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_mif_enc_regs.h
//
//========================================================================
// MIPI_ISP  data compress dec
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff011000
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_raw_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define MIPI_LOSSD_RAW_CTRL                        ((0x0080  << 2) + 0xff011000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define MIPI_LOSSD_RAW_FRAME_HOLD                  ((0x0081  << 2) + 0xff011000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define MIPI_LOSSD_RAW_GCLK_CTRL                   ((0x0082  << 2) + 0xff011000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define MIPI_LOSSD_RAW_RO_CODEC_STATUS             ((0x0083  << 2) + 0xff011000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define MIPI_LOSSD_RAW_MISC                        ((0x0084  << 2) + 0xff011000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define MIPI_LOSSD_RAW_BASIS                       ((0x0088  << 2) + 0xff011000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define MIPI_LOSSD_RAW_OFST_BIT_DEPTH              ((0x0089  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define MIPI_LOSSD_RAW_PIC_SIZE                    ((0x008a  << 2) + 0xff011000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define MIPI_LOSSD_RAW_SLICE_SIZE                  ((0x008b  << 2) + 0xff011000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_1                ((0x008c  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_2                ((0x008d  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_SLICE_SIZE_3                ((0x008e  << 2) + 0xff011000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define MIPI_LOSSD_RAW_PRESL_LAST_BITS             ((0x008f  << 2) + 0xff011000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define MIPI_LOSSD_RAW_PRESL_FIFO_LEVEL            ((0x0090  << 2) + 0xff011000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define MIPI_LOSSD_RAW_DEBUG                       ((0x0091  << 2) + 0xff011000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_REF_DATA                    ((0x0092  << 2) + 0xff011000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_REF_DATA_1                  ((0x0093  << 2) + 0xff011000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_REF_DATA_2                  ((0x0094  << 2) + 0xff011000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define MIPI_LOSSD_RAW_PRED_PROCE                  ((0x0095  << 2) + 0xff011000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define MIPI_LOSSD_RAW_GLOBAL_PHASE_LUT            ((0x0096  << 2) + 0xff011000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSD_RAW_GLOBAL_PHASE_LUT_1          ((0x0097  << 2) + 0xff011000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define MIPI_LOSSD_RAW_PHASE_LUT                   ((0x0098  << 2) + 0xff011000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define MIPI_LOSSD_RAW_FLATNESS_0                  ((0x0099  << 2) + 0xff011000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define MIPI_LOSSD_RAW_FLATNESS_QP                 ((0x009a  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define MIPI_LOSSD_RAW_FLATNESS_TH0                ((0x009b  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_FLATNESS_TH1                ((0x009c  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_FLATNESS_TH2                ((0x009d  << 2) + 0xff011000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define MIPI_LOSSD_RAW_QP_MAP_CHN0                 ((0x009e  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_1               ((0x009f  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_2               ((0x00a0  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_3               ((0x00a1  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_4               ((0x00a2  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_5               ((0x00a3  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_6               ((0x00a4  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_7               ((0x00a5  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_8               ((0x00a6  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN0_9               ((0x00a7  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1                 ((0x00a8  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_1               ((0x00a9  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_2               ((0x00aa  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_3               ((0x00ab  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_4               ((0x00ac  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_5               ((0x00ad  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_6               ((0x00ae  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_7               ((0x00af  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_8               ((0x00b0  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN1_9               ((0x00b1  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2                 ((0x00b2  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_1               ((0x00b3  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_2               ((0x00b4  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_3               ((0x00b5  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_4               ((0x00b6  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_5               ((0x00b7  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_6               ((0x00b8  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_7               ((0x00b9  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_8               ((0x00ba  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_QP_MAP_CHN2_9               ((0x00bb  << 2) + 0xff011000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define MIPI_LOSSD_RAW_RC_GROUP_2                  ((0x00bc  << 2) + 0xff011000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define MIPI_LOSSD_RAW_RC_BUDGET_0                 ((0x00bd  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_3 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_2 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_1 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_0 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSD_RAW_RC_BUDGET_1                 ((0x00be  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_7 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_6 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_5 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_4 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSD_RAW_RC_BUDGET_2                 ((0x00bf  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_11 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_10 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_9 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_8 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSD_RAW_RC_BUDGET_3                 ((0x00c0  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_15 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_perln_16pec_xbdgt_14 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 15: 8        reg_rc_perln_16pec_xbdgt_13 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit  7: 0        reg_rc_perln_16pec_xbdgt_12 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
#define MIPI_LOSSD_RAW_RC_BUDGET_4                 ((0x00c1  << 2) + 0xff011000)
//Bit 31:24        reg_rc_perln_16pec_xbdgt_16 // signed ,    RW, default = 0  extra bit budget (in pct= x/128) for the cells within the line, defined by 17 nodes to split the line into 16 piece.
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define MIPI_LOSSD_RAW_RC_BUDGET_5                 ((0x00c2  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define MIPI_LOSSD_RAW_RC_BUDGET_6                 ((0x00c3  << 2) + 0xff011000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define MIPI_LOSSD_RAW_RC_QP_MARGIN                ((0x00c4  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_1              ((0x00c5  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_2              ((0x00c6  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_3              ((0x00c7  << 2) + 0xff011000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_4              ((0x00c8  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define MIPI_LOSSD_RAW_RC_QP_MARGIN_5              ((0x00c9  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define MIPI_LOSSD_RAW_FLATNESS_ADJ0               ((0x00ca  << 2) + 0xff011000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define MIPI_LOSSD_RAW_FLATNESS_ADJ1               ((0x00cb  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define MIPI_LOSSD_RAW_FIFO_THD_0                  ((0x00cc  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_THD_1                  ((0x00cd  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_THD_2                  ((0x00ce  << 2) + 0xff011000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_FIFO_AVG                    ((0x00cf  << 2) + 0xff011000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define MIPI_LOSSD_RAW_FIFO_DLT                    ((0x00d0  << 2) + 0xff011000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define MIPI_LOSSD_RAW_BITSGAP_THD_0               ((0x00d1  << 2) + 0xff011000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define MIPI_LOSSD_RAW_BITSGAP_THD_1               ((0x00d2  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define MIPI_LOSSD_RAW_REF_ADJ                     ((0x00d3  << 2) + 0xff011000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_0               ((0x00d4  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_1               ((0x00d5  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_2               ((0x00d6  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_3               ((0x00d7  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_DLT_4               ((0x00d8  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_REF_ADJ_DLT_5           ((0x00d9  << 2) + 0xff011000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN0             ((0x00da  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN0_1           ((0x00db  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN1             ((0x00dc  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN1_1           ((0x00dd  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN2             ((0x00de  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define MIPI_LOSSD_RAW_REF_ADJ_TH_CHN2_1           ((0x00df  << 2) + 0xff011000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define MIPI_LOSSD_RAW_ACCUM_OFSET_0               ((0x00e0  << 2) + 0xff011000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_1               ((0x00e1  << 2) + 0xff011000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_2               ((0x00e2  << 2) + 0xff011000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_ACCUM_OFSET_3               ((0x00e3  << 2) + 0xff011000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define MIPI_LOSSD_RAW_WDR_LINE_DELAY              ((0x00e4  << 2) + 0xff011000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define MIPI_LOSSD_RAW_CORING_TH_OFST              ((0x00e5  << 2) + 0xff011000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define MIPI_LOSSD_RAW_CORING_RST                  ((0x00e6  << 2) + 0xff011000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define MIPI_LOSSD_RAW_STATS_RAM_MODE              ((0x00e7  << 2) + 0xff011000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define MIPI_LOSSD_RAW_STATS_RAM_ADDR              ((0x00e8  << 2) + 0xff011000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define MIPI_LOSSD_RAW_RO_STATS_RAM_DATA           ((0x00e9  << 2) + 0xff011000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_raw_dec_regs.h
//
//========================================================================
// MIPI_ISP  data compress mif dec
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff011000
// -----------------------------------------------
//
// Reading file:  ./mipi_cmpr_mif_dec_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ARSUB0_ISP_LOSS_MIF_CTRL                   ((0x00f0  << 2) + 0xff011000)
//Bit 31:24    reg_sync_sel                  // unsigned , RW, default = 0, sync with frm rst
//Bit 23:16    reg_canvas_id                 // unsigned , RW, default = 0, axi canvas id num
//Bit 15       reserved
//Bit 14:12    reg_cmd_intr_len              // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10    reserved
//Bit  9: 8    reg_cmd_req_size              // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=48 3=64
//Bit  7       reserved
//Bit  6: 4    reg_burst_len                 // unsigned , RW, default = 3, burst type: 0->1; 1->2; 2->4; 3->8; 4->16, others reserved
//Bit  3       reserved
//Bit  2       reg_check_resp_id             // unsigned , RW, default = 0
//Bit  1       reg_dol_mode                  // unsigned , RW, default = 0  1: DOL mode
//Bit  0       reg_mif_enable                // unsigned , RW, default = 1  1 to mif
#define ARSUB0_ISP_LOSS_MIF_QOS                    ((0x00f1  << 2) + 0xff011000)
//Bit 31:0     reg_qos_ctrl                  // unsigned , RW, default = 0, Qos control reg
                                             //18    reg_qos_auto_en
                                             //17    reg_qos_sup
                                             //16    reg_qos_ini
                                             //15:8  reg_qos_up_th
                                             // 7:0  reg_qos_dn_th
#define ARSUB0_ISP_LOSS_MIF_URGENT                 ((0x00f2  << 2) + 0xff011000)
//Bit 31:0     reg_urgent_ctrl               // unsigned , RW, default = 0, urgent control reg
                                             //18    reg_urgent_auto_en
                                             //17    reg_urgent_sup
                                             //16    reg_urgent_ini
                                             //15:8  reg_urgent_up_th
                                             // 7:0  reg_urgent_dn_th
#define ARSUB0_ISP_LOSS_MIF_MISC                   ((0x00f3  << 2) + 0xff011000)
//Bit 31:4  reserved
//Bit 3     reg_mif_busy_noresp_check       // unsigned , RW, default =1, for mif write, dont take "respond busy" as mif unit busy.
//Bit 2     reg_mif_wait_input4busy         // unsigned , RW, default =0, use in encoder, mif is busy till input data comming. only for mif wr
//Bit 1     reg_mif_dbl_baddr_init          // unsigned , RW, default =0, write 1 to use reg_mif_baddr as base-addr for next frame,it would be clear automatically.
//Bit 0     reg_mif_dbl_baddr_en            // unsigned , RW, default =0, 1 to use ping-pong base-addr based on frame.
#define ARSUB0_ISP_LOSS_MIF_BADDR                  ((0x00f4  << 2) + 0xff011000)
//Bit 31:0  reg_mif_baddr                    // unsigned , RW, default = 0,  mif base address
#define ARSUB0_ISP_LOSS_MIF_BADDR1                 ((0x00f5  << 2) + 0xff011000)
//Bit 31:0  reg_mif_baddr1                  // unsigned , RW, default = 0,  mif base address
#define ARSUB0_ISP_LOSS_MIF_FIFO_CTRL              ((0x00f7  << 2) + 0xff011000)
//Bit 31:16 reg_mif_gclk_ctrl                // unsigned , RW, default = 0, gate clock control
//Bit 15:8  reserved                         //
//Bit 7 :0  reg_mif_fifo_size                // unsigned , RW, data FIFO max size, default = 128,
#define ARSUB0_ISP_LOSS_MIF_FRM_HOLD               ((0x00f8  << 2) + 0xff011000)
//Bit 31:0  reg_mif_frm_holds                // unsigned , RW, clock cycle holder from frm_rst,to wait register ready, default = 16
#define ARSUB0_ISP_LOSS_MIF_RO_STATS               ((0x00f9  << 2) + 0xff011000)
//Bit 31: 0  ro_mif_status                  // unsigned ,  RO, default = 0  mif status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_cmpr_mif_dec_regs.h
//
//========================================================================
// MIPI_ISP  arbit
//========================================================================
//========================================================================
// MIPI_ISP  mot det
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff01e000
// -----------------------------------------------
//
// Reading file:  ./isp_md_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define MD_TOP_GCLK                                ((0x0000  << 2) + 0xff01e000)
//Bit 31: 0        reg_md_gclk               // unsigned ,    RW, default = 0  clock gate control
#define MD_TOP_CTRL                                ((0x0001  << 2) + 0xff01e000)
//Bit 31: 0        reg_md_top_ctrl           // unsigned ,    RW, default = 32'h204  md top ntrol
#define MD_WR_CTRL0                                ((0x0002  << 2) + 0xff01e000)
//Bit 31           reg_wr_axi_wr_en          // unsigned ,    RW, default = 1  axi wr enable
//Bit 30           reg_wr_axi_req_en         // unsigned ,    RW, default = 1  axi request enable
//Bit 29           reg_wr_axi_bypass         // unsigned ,    RW, default = 0  bypass axi wr
//Bit 28           reg_wr_frame_int          // unsigned ,    RW, default = 0  init wr frame
//Bit 27:24        reserved
//Bit 23: 0        reg_wr_total_size         // unsigned ,    RW, default = 57600  pixels hsize * vsize
#define MD_WR_CTRL1                                ((0x0003  << 2) + 0xff01e000)
//Bit 31: 0        reg_wr_based_addr          // unsigned ,    RW, default = 32'h80000000  wr axi based address
#define MD_WR_CTRL2                                ((0x0004  << 2) + 0xff01e000)
//Bit 31:23        reserved
//Bit 22:20        reg_wr_burst_lens         // unsigned ,    RW, default = 2  burst_lens limitation, burst_size: 0: 1x128, 1: 2x128, 2~3: 4x128
//Bit 19:16        reg_wr_req_th             // unsigned ,    RW, default = 4  fifo depth req_th * 8 *128 bits in fifo.
//Bit 15: 0        reg_wr_urgent_ctrl        // unsigned ,    RW, default = 0  urgent control
#define MD_WR_CTRL3                                ((0x0005  << 2) + 0xff01e000)
//Bit 31:24        reg_wr_awid               // unsigned ,    RW, default = 0  wr id
//Bit 23:21        reg_wr_awprot             // unsigned ,    RW, default = 0  awprot for security control
//Bit 20: 0        reserved
#define MD_RO_WR_ST0                               ((0x0006  << 2) + 0xff01e000)
//Bit 31: 0        ro_wr_st0                 // unsigned ,    RW, default = 0
#define MD_RO_WR_ST1                               ((0x0007  << 2) + 0xff01e000)
//Bit 31: 0        ro_wr_st1                 // unsigned ,    RW, default = 0
#define MD_RO_WR_ST2                               ((0x0008  << 2) + 0xff01e000)
//Bit 31: 0        ro_wr_st2                 // unsigned ,    RW, default = 0
#define MD_RD_CTRL0                                ((0x0009  << 2) + 0xff01e000)
//Bit 31           reg_rd_axi_rd_en          // unsigned ,    RW, default = 1  axi rd enable
//Bit 30           reg_rd_axi_req_en         // unsigned ,    RW, default = 1  axi request enable
//Bit 29:24        reserved
//Bit 23: 0        reg_rd_total_size         // unsigned ,    RW, default = 57600  total size hsize*vsize, <= 1024*1024
#define MD_RD_CTRL1                                ((0x000a  << 2) + 0xff01e000)
//Bit 31: 0        reg_rd_based_addr          // unsigned ,    RW, default = 32'h80000000
#define MD_RD_CTRL2                                ((0x000b  << 2) + 0xff01e000)
//Bit 31:23        reserved
//Bit 22:20        reg_rd_burst_lens         // unsigned ,    RW, default = 2  burst_lens limitation, burst_size: 0: 1x128, 1: 2x128, 2~3: 4x128
//Bit 19:16        reg_rd_req_th             // unsigned ,    RW, default = 4  fifo depth req_th * 8 *128 bits in fifo.
//Bit 15: 0        reg_rd_urgent_ctrl        // unsigned ,    RW, default = 0  urgent control
#define MD_RD_CTRL3                                ((0x000c  << 2) + 0xff01e000)
//Bit 31:24        reg_rd_arid               // unsigned ,    RW, default = 0  wr id
//Bit 23:21        reg_rd_arprot             // unsigned ,    RW, default = 0  awprot for security control
//Bit 20: 0        reserved
#define MD_RO_RD_ST0                               ((0x000d  << 2) + 0xff01e000)
//Bit 31: 0        ro_rd_st0                 // unsigned ,    RW, default = 0
#define MD_RO_RD_ST1                               ((0x000e  << 2) + 0xff01e000)
//Bit 31: 0        ro_rd_st1                 // unsigned ,    RW, default = 0
#define MD_INPUT_CTRL0                             ((0x000f  << 2) + 0xff01e000)
//Bit 31           reg_md_enable             // unsigned ,    RW, default = 1  lp motion detection enable, 0: disable;  1: enable
//Bit 30           reg_md_raw_xphase_ofst    // unsigned ,    RW, default = 0  horizontal phase of the raw data, 0: start wz R-col (RGGB or GBRG); 1: start wz B-col (GRBG or BGGR)
//Bit 29           reg_md_raw_yphase_ofst    // unsigned ,    RW, default = 0  vertical phase of the raw data,   0: start wz R-row (RGGB or GRBG); 1: start wz B-row (GRBG or BGGR)
//Bit 28           reg_md_is_on_raw          // unsigned ,    RW, default = 1  the md_sel is on raw data, set together with md_sel.    0: YUV/RGB;  1:RAW
//Bit 27:24        reg_md_input_sel          // unsigned ,    RW, default = 1  data selection for the lp motion detection. 0: raw sensor input; 1: raw WDR stitch; 2:raw fed_out(nr_in); 3:raw mirror_in; 4閿熸枻鎷� RGB after dms; 5: IRout; 6:RGB/YUV after gamma; 7: fe_o yuv bypass , default=1
//Bit 23:20        reg_md_input_ls           // unsigned ,    RW, default = 0  E domain data left shift bit num to align with u20 Odomain data and will clip to u10 by dropping 10lsb, e.g. yuv is u12, then ls = 8;
//Bit 19: 0        reserved
#define MD_INPUT_SIZE                              ((0x0010  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_md_input_xsize        // unsigned ,    RW, default = 1920  xsize of the input in pixels, set to image xsize
//Bit 15:12        reserved
//Bit 11: 0        reg_md_input_ysize        // unsigned ,    RW, default = 1080  ysize of the input in pixels, set to image ysize
#define MD_WINXY_0                                 ((0x0011  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_md_inpc_winxxyy_0     // unsigned ,    RW, default = 0  input combined window for processing.
//Bit 15:12        reserved
//Bit 11: 0        reg_md_inpc_winxxyy_1     // unsigned ,    RW, default = 960  input combined window for processing.
#define MD_WINXY_1                                 ((0x0012  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_md_inpc_winxxyy_2     // unsigned ,    RW, default = 0  input combined window for processing.
//Bit 15:12        reserved
//Bit 11: 0        reg_md_inpc_winxxyy_3     // unsigned ,    RW, default = 540  input combined window for processing.
#define MD_RGGB_OFSET_0                            ((0x0013  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19: 0        reg_md_rggb_ofset_0       // signed ,    RW, default = 0  ofset to the components, same as the ISP mission mode ofset
#define MD_RGGB_OFSET_1                            ((0x0014  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19: 0        reg_md_rggb_ofset_1       // signed ,    RW, default = 0  ofset to the components, same as the ISP mission mode ofset
#define MD_RGGB_OFSET_2                            ((0x0015  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19: 0        reg_md_rggb_ofset_2       // signed ,    RW, default = 0  ofset to the components, same as the ISP mission mode ofset
#define MD_RGGB_OFSET_3                            ((0x0016  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19: 0        reg_md_rggb_ofset_3       // signed ,    RW, default = 0  ofset to the components, same as the ISP mission mode ofset
#define MD_RGGB_GAIN_0                             ((0x0017  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_md_rggb_gain_0        // unsigned ,    RW, default = 1024  gain to different channel, normalize to 1024 as "1.0"
//Bit 15:12        reserved
//Bit 11: 0        reg_md_rggb_gain_1        // unsigned ,    RW, default = 1024  gain to different channel, normalize to 1024 as "1.0"
#define MD_RGGB_GAIN_1                             ((0x0018  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_md_rggb_gain_2        // unsigned ,    RW, default = 1024  gain to different channel, normalize to 1024 as "1.0"
//Bit 15:12        reserved
//Bit 11: 0        reg_md_rggb_gain_3        // unsigned ,    RW, default = 1024  gain to different channel, normalize to 1024 as "1.0"
#define MD_RGGB_COEF                               ((0x0019  << 2) + 0xff01e000)
//Bit 31:24        reg_md_bld_coefs_0        // unsigned ,    RW, default = 32  blender coef of the components to Y, normalize to 128 as "1"
//Bit 23:16        reg_md_bld_coefs_1        // unsigned ,    RW, default = 32  blender coef of the components to Y, normalize to 128 as "1"
//Bit 15: 8        reg_md_bld_coefs_2        // unsigned ,    RW, default = 32  blender coef of the components to Y, normalize to 128 as "1"
//Bit  7: 0        reg_md_bld_coefs_3        // unsigned ,    RW, default = 32  blender coef of the components to Y, normalize to 128 as "1"
#define MD_COMB_EOTF_0                             ((0x001a  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_0        // unsigned ,    RW, default = 0  piec wise lut
//Bit 21:12        reg_md_comb_eotf_1        // unsigned ,    RW, default = 0  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_2        // unsigned ,    RW, default = 1  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_1                             ((0x001b  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_3        // unsigned ,    RW, default = 1  piec wise lut
//Bit 21:12        reg_md_comb_eotf_4        // unsigned ,    RW, default = 1  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_5        // unsigned ,    RW, default = 1  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_2                             ((0x001c  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_6        // unsigned ,    RW, default = 2  piec wise lut
//Bit 21:12        reg_md_comb_eotf_7        // unsigned ,    RW, default = 2  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_8        // unsigned ,    RW, default = 2  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_3                             ((0x001d  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_9        // unsigned ,    RW, default = 3  piec wise lut
//Bit 21:12        reg_md_comb_eotf_10       // unsigned ,    RW, default = 3  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_11       // unsigned ,    RW, default = 4  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_4                             ((0x001e  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_12       // unsigned ,    RW, default = 4  piec wise lut
//Bit 21:12        reg_md_comb_eotf_13       // unsigned ,    RW, default = 5  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_14       // unsigned ,    RW, default = 6  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_5                             ((0x001f  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_15       // unsigned ,    RW, default = 7  piec wise lut
//Bit 21:12        reg_md_comb_eotf_16       // unsigned ,    RW, default = 8  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_17       // unsigned ,    RW, default = 10  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_6                             ((0x0020  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_18       // unsigned ,    RW, default = 12  piec wise lut
//Bit 21:12        reg_md_comb_eotf_19       // unsigned ,    RW, default = 14  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_20       // unsigned ,    RW, default = 16  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_7                             ((0x0021  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_21       // unsigned ,    RW, default = 20  piec wise lut
//Bit 21:12        reg_md_comb_eotf_22       // unsigned ,    RW, default = 24  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_23       // unsigned ,    RW, default = 28  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_8                             ((0x0022  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_24       // unsigned ,    RW, default = 32  piec wise lut
//Bit 21:12        reg_md_comb_eotf_25       // unsigned ,    RW, default = 40  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_26       // unsigned ,    RW, default = 48  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_9                             ((0x0023  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_27       // unsigned ,    RW, default = 56  piec wise lut
//Bit 21:12        reg_md_comb_eotf_28       // unsigned ,    RW, default = 64  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_29       // unsigned ,    RW, default = 80  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_10                            ((0x0024  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_30       // unsigned ,    RW, default = 96  piec wise lut
//Bit 21:12        reg_md_comb_eotf_31       // unsigned ,    RW, default = 112  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_32       // unsigned ,    RW, default = 128  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_11                            ((0x0025  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_33       // unsigned ,    RW, default = 160  piec wise lut
//Bit 21:12        reg_md_comb_eotf_34       // unsigned ,    RW, default = 192  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_35       // unsigned ,    RW, default = 223  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_12                            ((0x0026  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_36       // unsigned ,    RW, default = 256  piec wise lut
//Bit 21:12        reg_md_comb_eotf_37       // unsigned ,    RW, default = 288  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_38       // unsigned ,    RW, default = 320  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_13                            ((0x0027  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_39       // unsigned ,    RW, default = 352  piec wise lut
//Bit 21:12        reg_md_comb_eotf_40       // unsigned ,    RW, default = 384  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_41       // unsigned ,    RW, default = 416  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_14                            ((0x0028  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_42       // unsigned ,    RW, default = 448  piec wise lut
//Bit 21:12        reg_md_comb_eotf_43       // unsigned ,    RW, default = 480  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_44       // unsigned ,    RW, default = 512  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_15                            ((0x0029  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_45       // unsigned ,    RW, default = 544  piec wise lut
//Bit 21:12        reg_md_comb_eotf_46       // unsigned ,    RW, default = 576  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_47       // unsigned ,    RW, default = 608  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_16                            ((0x002a  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_48       // unsigned ,    RW, default = 640  piec wise lut
//Bit 21:12        reg_md_comb_eotf_49       // unsigned ,    RW, default = 672  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_50       // unsigned ,    RW, default = 704  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_17                            ((0x002b  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_51       // unsigned ,    RW, default = 736  piec wise lut
//Bit 21:12        reg_md_comb_eotf_52       // unsigned ,    RW, default = 768  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_53       // unsigned ,    RW, default = 800  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_18                            ((0x002c  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_54       // unsigned ,    RW, default = 832  piec wise lut
//Bit 21:12        reg_md_comb_eotf_55       // unsigned ,    RW, default = 864  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_56       // unsigned ,    RW, default = 896  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_19                            ((0x002d  << 2) + 0xff01e000)
//Bit 31:22        reg_md_comb_eotf_57       // unsigned ,    RW, default = 928  piec wise lut
//Bit 21:12        reg_md_comb_eotf_58       // unsigned ,    RW, default = 960  piec wise lut
//Bit 11: 2        reg_md_comb_eotf_59       // unsigned ,    RW, default = 992  piec wise lut
//Bit  1: 0        reserved
#define MD_COMB_EOTF_20                            ((0x002e  << 2) + 0xff01e000)
//Bit 31:10        reserved
//Bit  9: 0        reg_md_comb_eotf_60       // unsigned ,    RW, default = 1023  piec wise lut
#define MD_EOTF                                    ((0x002f  << 2) + 0xff01e000)
//Bit 31: 2        reserved
//Bit  1           reg_md_bld_use_max        // unsigned ,    RW, default = 0  use max of the components for the blender, 0: no max, 1:max (more sensitive)
//Bit  0           reg_md_eotf_en            // unsigned ,    RW, default = 1  piece wise lut enable
#define MD_DS_STEP                                 ((0x0030  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19:16        reg_ds_hstep              // unsigned ,    RW, default = 3  integer pixel ratio for horizontal scalar, o2i_ratio= 1/step, 1~15
//Bit 15: 4        reserved
//Bit  3: 0        reg_ds_vstep              // unsigned ,    RW, default = 3  integer pixel ratio for vertical scalar,   o2i_ratio= 1/step閿熸枻鎷�1~15
#define MD_DS_OSIZE                                ((0x0031  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:16        reg_ds_ocol               // unsigned ,    RW, default = 320  actual downscaled field buffer col number.
//Bit 15:12        reserved
//Bit 11: 0        reg_ds_orow               // unsigned ,    RW, default = 180  actual downscaled field buffer row number.
#define MD_DS_CTRL                                 ((0x0032  << 2) + 0xff01e000)
//Bit 31:11        reserved
//Bit 10           reg_ds_inp8b              // unsigned ,    RW, default = 0  input to ds accum cell use 8bits instead of 10bits,only set to 1 when (v_step*h_step>64) 0: input 10bits, 1: input 8bits
//Bit  9: 0        reg_ds_norm               // unsigned ,    RW, default = 256  normalization gain to the accum to get the 8bits data for ddr, norm = (inp8b? 4096:1024)/pixelnum(v_step*h_step)
#define MD_CORE_CTRL0                              ((0x0033  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27:25        reg_md_sad_mode           // unsigned ,    RW, default = 2  window size for sad, 0: no sad, 1: 1x7,  2:3x3; 3:3x5, else 3x7
//Bit 24           reg_md_edge_mode          // unsigned ,    RW, default = 0  mode for the pre and cur edge calculation, 0: min(edge_pre, edge_cur);  1: avg(edge_pre, edge_cur)
//Bit 23:16        reg_md_coring             // unsigned ,    RW, default = 6  coring for sad for noise robustness. sad_core = max(sad-coring,0);
//Bit 15:14        reserved
//Bit 13: 8        reg_md_edge_ratio         // unsigned ,    RW, default = 4  ratio to edge as dynamic coring part, final_coring or 1b_thrd = (edge*ratio + coring); norm to 16 as '1'
//Bit  7: 0        reserved
#define MD_WIN_XXYY0                               ((0x0034  << 2) + 0xff01e000)
//Bit 31:26        reserved
//Bit 25:16        reg_md_win_xxyy_0         // unsigned ,    RW, default = 0  for motion sum statistics on down-scaled image. [x_st x_ed; y_st y_ed]*4
//Bit 15:10        reserved
//Bit  9: 0        reg_md_win_xxyy_1         // unsigned ,    RW, default = 1023  for motion sum statistics on down-scaled image. [x_st x_ed; y_st y_ed]*4
#define MD_WIN_XXYY1                               ((0x0035  << 2) + 0xff01e000)
//Bit 31:26        reserved
//Bit 25:16        reg_md_win_xxyy_2         // unsigned ,    RW, default = 0  for motion sum statistics on down-scaled image. [x_st x_ed; y_st y_ed]*4
//Bit 15:10        reserved
//Bit  9: 0        reg_md_win_xxyy_3         // unsigned ,    RW, default = 1023  for motion sum statistics on down-scaled image. [x_st x_ed; y_st y_ed]*4
#define RO_MD_SAD_SUM                              ((0x0036  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27: 0        ro_md_sad_sum             // unsigned ,    RW, default = 0  sum of the motion sad for all the pixels within the window;
#define RO_MD_1BM_SUM                              ((0x0037  << 2) + 0xff01e000)
//Bit 31:20        reserved
//Bit 19: 0        ro_md_1bm_sum             // unsigned ,    RW, default = 0  sum of the 1bit motion for all the pixels within the window;
#define RO_MD_EDG_SUM                              ((0x0038  << 2) + 0xff01e000)
//Bit 31:28        reserved
//Bit 27: 0        ro_md_edg_sum             // unsigned ,    RW, default = 0  sum of the edge info for all the pixels within the window;
#define MD_ISMOT_SAD_THRD                          ((0x0039  << 2) + 0xff01e000)
//Bit 31:24        reserved
//Bit 23: 0        reg_ismot_sad_thrd        // unsigned ,    RW, default = 65536  threshold to sum_sad for current frame is motion
#define MD_ISMOT_1BM_THRD                          ((0x003a  << 2) + 0xff01e000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ismot_1bm_thrd        // unsigned ,    RW, default = 4096  threshold to sum_1bm for current frame consider as motion
#define MD_WR_P_BADDR                              ((0x003b  << 2) + 0xff01e000)
//Bit 31: 0        reg_rd_based_addr_p          // unsigned ,    RW, default = 32'h80000000
#define MD_RD_P_BADDR                              ((0x003c  << 2) + 0xff01e000)
//Bit 31: 0        reg_wr_based_addr_p          // unsigned ,    RW, default = 32'h80000000  wr axi based address
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_md_reg.h
//
//========================================================================
// MIPI_ISP  axi arbit0
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xff010800
// -----------------------------------------------
//
// Reading file:  ./mipi_isp_arb_axi_regs.h
//
//========================================================================
// MIPI_ISP  axi arbit0
//========================================================================
#define MIPI_ISP_RDARB_MODE                        ((0x0000  << 2) + 0xff010800)
#define MIPI_ISP_RDARB_REQEN_SLV                   ((0x0001  << 2) + 0xff010800)
#define MIPI_ISP_RDARB_WEIGH0_SLV                  ((0x0002  << 2) + 0xff010800)
#define MIPI_ISP_RDARB_WEIGH1_SLV                  ((0x0003  << 2) + 0xff010800)
#define MIPI_ISP_RDARB_UGT                         ((0x0004  << 2) + 0xff010800)
#define MIPI_ISP_RDARB_LIMT0                       ((0x0005  << 2) + 0xff010800)
#define MIPI_ISP_WRARB_MODE                        ((0x0006  << 2) + 0xff010800)
#define MIPI_ISP_WRARB_REQEN_SLV                   ((0x0007  << 2) + 0xff010800)
#define MIPI_ISP_WRARB_WEIGH0_SLV                  ((0x0008  << 2) + 0xff010800)
#define MIPI_ISP_WRARB_WEIGH1_SLV                  ((0x0009  << 2) + 0xff010800)
#define MIPI_ISP_WRARB_UGT                         ((0x000a  << 2) + 0xff010800)
#define MIPI_ISP_RDWR_ARB_STATUS                   ((0x000b  << 2) + 0xff010800)
#define MIPI_ISP_ARB_DBG_CTRL                      ((0x000c  << 2) + 0xff010800)
#define MIPI_ISP_ARB_DBG_STAT                      ((0x000d  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_CNTL0               ((0x0080  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_CNTL0               ((0x0088  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT0               ((0x0090  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT1               ((0x0091  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT2               ((0x0092  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT3               ((0x0093  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT4               ((0x0094  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT5               ((0x0095  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT6               ((0x0096  << 2) + 0xff010800)
#define MIPI_ISP_ARB_WBUS_PROT_STAT7               ((0x0097  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT0               ((0x0098  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT1               ((0x0099  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT2               ((0x009a  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT3               ((0x009b  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT4               ((0x009c  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT5               ((0x009d  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT6               ((0x009e  << 2) + 0xff010800)
#define MIPI_ISP_ARB_RBUS_PROT_STAT7               ((0x009f  << 2) + 0xff010800)
#define MIPI_ISP_ARB_AXI_BUS_CNTL0                 ((0x00b0  << 2) + 0xff010800)
#define MIPI_ISP_ARB_AXI_BUS_CNTL1                 ((0x00b1  << 2) + 0xff010800)
#define MIPI_ISP_ARB_AXI_BUS_STAT0                 ((0x00b2  << 2) + 0xff010800)
//
// Closing file:  ./mipi_isp_arb_axi_regs.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./mipi_isp.h
//
//========================================================================
// DEWRAP/AML_GDC
//========================================================================
//
// Reading file:  ./isp_dwap_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04e000
// -----------------------------------------------
#define ISP_DWAP_TOP_SRC_FSIZE                     ((0x0000  << 2) + 0xfe04e000)
//Bit 31: 16        reg_src_frm_hsize               // unsigned , RW, default = 1280
//Bit 15: 0         reg_src_frm_vsize               // unsigned , RW, default = 720
//
#define ISP_DWAP_TOP_HDNUM                         ((0x0001  << 2) + 0xfe04e000)
//Bit 31: 26        reserved
//Bit 25: 13        reg_hold_hnum               // unsigned , RW, default = 2
//Bit 12: 0         reg_hold_vnum               // unsigned , RW, default = 2
#define ISP_DWAP_TOP_CTRL0                         ((0x0002  << 2) + 0xfe04e000)
//Bit 31            pls_frm_rst              //unsigned, RW, default=0
//Bit 30            pls_sw_rst              //unsigned, RW, default=0
//Bit 29            reserved
//Bit 28:16         reg_stdly_num           //unsigned, RW, default=2
//Bit 15:11         reserved
//Bit 10:7          reg_err_intr_sel        //unsigned, RW, default=15
//Bit 6             reg_err_intr_en         //unsigned, RW, default=1
//Bit 5             reg_sec_ctrl            //unsigned, RW, default=0
//Bit 4             reg_hs_sel              //unsigned, RW, default=0
//Bit 3:2           reg_din_sel             //unsigned, RW, default=1, dos vidin select
//Bit 1             reserved
//Bit 0             reg_frm_sel             //unsigned, RW, default=0, must be set before pls_frm_rst
#define ISP_DWAP_TOP_COEF_CTRL0                    ((0x0003  << 2) + 0xfe04e000)
//Bit 31:0          reg_coef_baddr          //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_COEF_CTRL1                    ((0x0004  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_coef_size           //unsigned, RW, default=0
#define ISP_DWAP_TOP_CMD_CTRL0                     ((0x0005  << 2) + 0xfe04e000)
//Bit 31:0          reg_cmd_baddr          //unsigned, RW, default=0
#define ISP_DWAP_TOP_CMD_CTRL1                     ((0x0006  << 2) + 0xfe04e000)
//Bit 31:30         reg_src_bwidth          //unsigned, RW, default=0
//Bit 29            reg_data_test           //unsigned, RW, default=0
//Bit 28:22         reserved
//Bit 21:16         reg_rdmif_id            //unsigned, RW, default=6'h39;
//Bit 15:0          reg_cmd_size            //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_Y_CTRL0                   ((0x0007  << 2) + 0xfe04e000)
//Bit 31:0          reg_src_y_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_Y_CTRL1                   ((0x0008  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_y_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_U_CTRL0                   ((0x0009  << 2) + 0xfe04e000)
//Bit 31:0          reg_src_u_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_U_CTRL1                   ((0x000a  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_u_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_SRC_V_CTRL0                   ((0x000b  << 2) + 0xfe04e000)
//Bit 31:0          reg_src_v_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_SRC_V_CTRL1                   ((0x000c  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_src_v_stride          //unsigned, RW, default=0
#define ISP_DWAP_TOP_MESH_CTRL0                    ((0x000d  << 2) + 0xfe04e000)
//Bit 31:0          reg_mesh_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_MESH_CTRL1                    ((0x000e  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_mesh_stride          //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_GCLK                          ((0x000f  << 2) + 0xfe04e000)
//Bit 31:0           reg_gclk_ctrl           //unsigned, RW, default=0
#define ISP_DWAP_TOP_DST_FSIZE                     ((0x0010  << 2) + 0xfe04e000)
//Bit 31: 16        reg_dst_frm_hsize               // unsigned , RW, default = 1280
//Bit 15: 0         reg_dst_frm_vsize               // unsigned , RW, default = 720
#define ISP_DWAP_TOP_BLK_NUM                       ((0x0011  << 2) + 0xfe04e000)
//Bit 31: 16        reg_edge_num           // unsigned, RW, default = 0
//Bit 15: 0         reg_blk_num            // unsigned , RW, default = 256
#define ISP_DWAP_TOP_MESH_SIZE                     ((0x0012  << 2) + 0xfe04e000)
//Bit 31: 16        reg_mesh_hsize            // unsigned, RW, default = 32
//Bit 15: 0         reg_mesh_vsize            // unsigned, RW, default = 32
#define ISP_DWAP_TOP_DST_Y_CTRL0                   ((0x0013  << 2) + 0xfe04e000)
//Bit 31:0          reg_dst_y_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_Y_CTRL1                   ((0x0014  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_y_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_DST_U_CTRL0                   ((0x0015  << 2) + 0xfe04e000)
//Bit 31:0          reg_dst_u_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_U_CTRL1                   ((0x0016  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_u_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_DST_V_CTRL0                   ((0x0017  << 2) + 0xfe04e000)
//Bit 31:0          reg_dst_v_baddr           //unsigned, RW, default=0
//
#define ISP_DWAP_TOP_DST_V_CTRL1                   ((0x0018  << 2) + 0xfe04e000)
//Bit 31:16         reserved
//Bit 15:0          reg_dst_v_stride          //unsigned, RW, default=1024
#define ISP_DWAP_TOP_ERR_CTRL                      ((0x0019  << 2) + 0xfe04e000)
//Bit 31:1          reserved
//Bit 0             pls_err_clr              // unsigned, RW, default=0
//
#define ISP_DWAP_TOP_CMD_ERR                       ((0x001a  << 2) + 0xfe04e000)
//Bit 31:0          ro_cmd_err             // unsigned, RO, default=0
#define ISP_DWAP_TOP_MESH_ERR                      ((0x001b  << 2) + 0xfe04e000)
//Bit 31:0          ro_mesh_num_err        // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR0                    ((0x001c  << 2) + 0xfe04e000)
//Bit 31:0          ro_oflow_err0          // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR1                    ((0x001d  << 2) + 0xfe04e000)
//Bit 31:0          ro_oflow_err1           // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR2                    ((0x001e  << 2) + 0xfe04e000)
//Bit 31:0          ro_oflow_err2           // unsigned, RO, default=0
#define ISP_DWAP_TOP_OFLOW_ERR3                    ((0x001f  << 2) + 0xfe04e000)
//Bit 31:0          ro_oflow_err3           // unsigned, RO, default=0
#define ISP_DWAP_TOP_VSPLT_8LN                     ((0x0020  << 2) + 0xfe04e000)
//Bit 31:0          ro_vsplt_8ln            // unsigned, RO, default=0
#define ISP_DWAP_TOP_VSPLT_4LN                     ((0x0021  << 2) + 0xfe04e000)
//Bit 31:0          ro_vsplt_4ln            // unsigned, RO, default=0
#define ISP_DWAP_WATCH_DOG                         ((0x0022  << 2) + 0xfe04e000)
//Bit 31:0      reg_watch_dog           // unsigned, RW, default=32'hffffffff
#define ISP_DWAP_TOP_PERF                          ((0x0023  << 2) + 0xfe04e000)
//Bit 31:0      ro_proc_time            // unsigned, RO, default=0
#define ISP_DWAP_DDR_VCNT                          ((0x0024  << 2) + 0xfe04e000)
//Bit 31:17     reserved
//Bit 16        reg_ddr_vcnt_mode       // unsigned, RW, default=0
//Bit 15:0      reg_ddr_vcnt            // unsigned, RW, default=16'hffff
#define ISP_DWAP_COEF_LD_TIME                      ((0x0025  << 2) + 0xfe04e000)
//Bit 31:0      ro_coef_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_MESH_LD_TIME                      ((0x0026  << 2) + 0xfe04e000)
//Bit 31:0      ro_mesh_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_DATA_LD_TIME                      ((0x0027  << 2) + 0xfe04e000)
//Bit 31:0      ro_data_ld_time         // unsigned, RO, default=0
#define ISP_DWAP_TILE_PROC_TIME                    ((0x0028  << 2) + 0xfe04e000)
//Bit 31:0      ro_tile_proc_time       // unsigned, RO, default=0
#define ISP_DWAP_EDGE_PROC_TIME                    ((0x0029  << 2) + 0xfe04e000)
//Bit 31:0      ro_edge_proc_time       // unsigned, RO, default=0
#define ISP_DWAP_WAIT_RST_TIME                     ((0x002a  << 2) + 0xfe04e000)
//Bit 31:0      ro_wait_rst_time        // unsigned, RO, default=0
#define ISP_DWAP_CMD_SWAP                          ((0x002b  << 2) + 0xfe04e000)
//Bit 31:14     reserved
//Bit 13        reg_coef_little_endian  // unsigned, RW, default=1
//Bit 12        reg_mesh_little_endian  // unsigned, RW, default=1
//Bit 11        reg_data_swap64         // unsigned, RW, default=0
//Bit 10        reg_coef_swap64         // unsigned, RW, default=0
//Bit 9         reg_mesh_swap64         // unsigned, RW, default=0
//Bit 8         reg_wrmif_swap8         // unsigned, RW, default=0
//Bit 7         reg_wrmif_uvswap        // unsigned, RW, default=0
//Bit 6         reg_data_little_endian  // unsigned, RW, default=1
//Bit 5         reg_data_uvswap         // unsigned, RW, default=0
//Bit 4         reg_coef_swap32         // unsigned, RW, default=0
//Bit 3         reg_coef_swap16         // unsigned, RW, default=0
//Bit 2         reg_mesh_swap32         // unsigned, RW, default=0
//Bit 1         reg_cmd_swap64          // unsigned, RW, default=0
//Bit 0         reg_cmd_swap32          // unsigned, RW, default=0
#define ISP_DWAP_DBG_CTRL0                         ((0x002c  << 2) + 0xfe04e000)
//Bit 31:16     reg_blk_cnt_sel         // unsigned, RW, default=0
//Bit 15:13     reg_cmd_idx             // unsigned, RW, default=0
//Bit 12:11     reg_cmd_sel             // unsigned, RW, default=3
//Bit 10:1      reserved
//Bit 0         reg_ram_dbg_mode        // unsigned, RW, default=0
#define ISP_DWAP_DBG_CTRL1                         ((0x002d  << 2) + 0xfe04e000)
//Bit 31:16     reg_dbg_hidx            // unsigned, RW, default=0
//Bit 15:0      reg_dbg_vidx            // unsigned, RW, default=0
//
#define ISP_DWAP_DBG_CTRL2                         ((0x002e  << 2) + 0xfe04e000)
//Bit 31:30     reg_dbg_en              // unsigned, RW, default=0
//Bit 29:23     reg_dbg_hscale          // unsigned, RW, default=0
//Bit 22:16     reg_dbg_vscale          // unsigned, RW, default=0
//Bit 15:8      reg_dbg_val0            // unsigned, RW, default=0
//Bit 7:0       reg_dbg_val1            // unsigned, RW, default=0
#define ISP_DWAP_CMD_DATA0                         ((0x002f  << 2) + 0xfe04e000)
//Bit 31:0      ro_cmd_data0            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA1                         ((0x0030  << 2) + 0xfe04e000)
//Bit 31:0      ro_cmd_data1            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA2                         ((0x0031  << 2) + 0xfe04e000)
//Bit 31:0      ro_cmd_data2            // unsigned, RO, default=0
#define ISP_DWAP_CMD_DATA3                         ((0x0032  << 2) + 0xfe04e000)
//Bit 31:0      ro_cmd_data3            // unsigned, RO, default=0
#define ISP_DWAP_BLK_INFO                          ((0x0033  << 2) + 0xfe04e000)
//Bit 31:16     ro_blk_cnt              // unsigned, RO, default=0
//Bit 15        ro_dwap_idle            // unsigned, RO, default=0
//Bit 14:12     ro_cmd_dec_st           // unsigned, RO, default=0
//Bit 11        ro_cfg_hold_f           // unsigned, RO, default=0
//Bit 10:2      reserved
//Bit 1         ro_ram_acc_err          // unsigned, RO, default=0
//Bit 0         ro_bresp_err            // unsigned, RO, default=0
#define ISP_DWAP_GAMMA_CTRL                        ((0x0060  << 2) + 0xfe04e000)
//Bit 31:16     reg_dwgm_gain           //unsigned, RW, default=256
//Bit 15:5      reserved
//Bit 4:2       reg_output_bw_sel       //unsigned, RW, default=0
//Bit 1         reg_dwgm_lut_mode       //unsigned, RW, default=1
//Bit 0         reg_dwgm_en             //unsigned, RW, default=0
#define ISP_DWAP_GAMMA_OFST                        ((0x0061  << 2) + 0xfe04e000)
//Bit 31:28     reserved
//Bit 27:16     reg_dwgm_pre_ofst       //unsigned, RW, default=0
//Bit 15:0      reg_dwgm_pst_ofst       //unsigned, RW, default=0
//
#define ISP_DWAP_GAMMA_NUM                         ((0x0062  << 2) + 0xfe04e000)
//Bit 31:24     reserved
//Bit 23:0      reg_dwgm_lut_num        //unsigned, RW, default=24'hb1b645 //24'b1011_0001_1011_0110_1110_0101 //{5, 4, 3, 3, 3, 3, 4, 5}
#define ISP_DWAP_GAMMA_STP                         ((0x0063  << 2) + 0xfe04e000)
//Bit 31:0      reg_dwgm_lut_stp        //unsigned, RW, default = 32'heeedcb98
#define ISP_DWAP_GAMMA_LUT_ADDR                    ((0x0064  << 2) + 0xfe04e000)
//Bit 31:0      reg_dwgm_lut_addr       //unsigned, RW, default = 0
#define ISP_DWAP_GAMMA_LUT_DATA                    ((0x0065  << 2) + 0xfe04e000)
//Bit 31:0      reg_dwgm_lut_data       //unsigned, RW, default = 0
//
// Reading file:  ./isp_dwap_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe04e000
// -----------------------------------------------
#define ISP_DWAP_WMIF_CTRL1                        ((0x0040  << 2) + 0xfe04e000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 1, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_DWAP_WMIF_CTRL2                        ((0x0041  << 2) + 0xfe04e000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:22 reserved
//Bit 21:20 reg_int_clr       // unsigned , default = 0
//Bit 19:18 reg_gclk_ctrl     // unsigned , default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=wrmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_DWAP_WMIF_CTRL3                        ((0x0042  << 2) + 0xfe04e000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , default = 0
//Bit 29:24 reg_pass_num      // unsigned , default = 1
//Bit 23:18 reg_hold_num      // unsigned , default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define ISP_DWAP_WMIF_CTRL4                        ((0x0043  << 2) + 0xfe04e000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define ISP_DWAP_WMIF_SCOPE_X                      ((0x0044  << 2) + 0xfe04e000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define ISP_DWAP_WMIF_SCOPE_Y                      ((0x0045  << 2) + 0xfe04e000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define ISP_DWAP_WMIF_RO_STAT                      ((0x0046  << 2) + 0xfe04e000)
//Bit 31:16 reserved
//Bit 15:0  reg_status        // unsigned , default = 0
#define ISP_DWAP_RMIF_CTRL1                        ((0x0050  << 2) + 0xfe04e000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , default = 1, interrupt send cmd when how many series axi cmd,
                              // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , default = 2, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_swap_64bit    // unsigned , default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , default = 0, big endian enable
//Bit 5     reg_y_rev         // unsigned , default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_DWAP_RMIF_CTRL2                        ((0x0051  << 2) + 0xfe04e000)
//Bit 31:30 reg_sw_rst        // unsigned , default = 0,
//Bit 29:26 reserved
//Bit 25:22 reg_vstep         // unsigned , default = 1
//Bit 21:20 reg_int_clr       // unsigned , default = 0
//Bit 19:18 reg_gclk_ctrl     // unsigned , default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , default = 0, urgent control reg :
                              //  16  reg_ugt_init  :  urgent initial value
                              //  15  reg_ugt_en    :  urgent enable
                              //  14  reg_ugt_type  :  1= wrmif 0=rdmif
                              // 7:4  reg_ugt_top_th:  urgent top threshold
                              // 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_DWAP_RMIF_CTRL3                        ((0x0052  << 2) + 0xfe04e000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , default = 0
//Bit 29:24 reg_pass_num      // unsigned , default = 1
//Bit 23:18 reg_hold_num      // unsigned , default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , default = 1,
//Bit 15:14 reg_block_mode    // unsigned , default = 0
//Bit 13    reg_32b_align     // unsigned , default = 0
//Bit 12:0  reg_stride        // unsigned , default = 4096,
#define ISP_DWAP_RMIF_CTRL4                        ((0x0053  << 2) + 0xfe04e000)
//Bit 31:0  reg_baddr        // unsigned , default = 0,
#define ISP_DWAP_RMIF_SCOPE_X                      ((0x0054  << 2) + 0xfe04e000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , default = 0, the canvas hor start pixel position
#define ISP_DWAP_RMIF_SCOPE_Y                      ((0x0055  << 2) + 0xfe04e000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , default = 0, the canvas ver start pixel position
#define ISP_DWAP_RMIF_RO_STAT                      ((0x0056  << 2) + 0xfe04e000)
//Bit 31:16 reserved
//Bit 15:0  reg_status        // unsigned , default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_dwap_mif_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_dwap_top_reg.h
//
//========================================================================
// VC9000E_TOP
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe096000
// -----------------------------------------------
#define VC9000E_TOP_SW_RESET                       ((0x0000  << 2) + 0xfe096000)
#define VC9000E_TOP_CNTL_STAT                      ((0x0001  << 2) + 0xfe096000)
#define VC9000E_TOP_NSEC_SCRATCH                   ((0x0002  << 2) + 0xfe096000)
#define VC9000E_TOP_SEC_SCRATCH                    ((0x0010  << 2) + 0xfe096000)
#define VC9000E_TOP_SECURE_CTL_INDEX               ((0x0011  << 2) + 0xfe096000)
#define VC9000E_TOP_SECURE_CTL_DATA                ((0x0012  << 2) + 0xfe096000)
#define VC9000E_TOP_AXI_ID_MAP_RD0                 ((0x0014  << 2) + 0xfe096000)
#define VC9000E_TOP_AXI_ID_MAP_RD1                 ((0x0015  << 2) + 0xfe096000)
#define VC9000E_TOP_AXI_ID_MAP_WR0                 ((0x0016  << 2) + 0xfe096000)
#define VC9000E_TOP_AXI_ID_MAP_WR1                 ((0x0017  << 2) + 0xfe096000)
//========================================================================
// VC9000E_CORE
//========================================================================
// -----------------------------------------------
// REG_BASE:  REGISTER_BASE_ADDR = 0xfe310000
// -----------------------------------------------
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./REG_LIST_RTL.h
//
//
// Reading file:  ./vpu_inc/vout_regs_base.h
//
// -----------------------------------------------
// REG_BASE:  VOUT_TOP_VCBUS_BASE = 0x00
// -----------------------------------------------
//
// Reading file:  ./vpu_inc/vpu_vout_top_reg.h
//
#define VPU_VOUT_TOP_CTRL                          ((0x0000  << 2) + 0xfe350000)
//Bit 31:16  reg_gclk_ctrl              //unsigned,   RW,   default = 16'h0; todo  16bit or 10bit
//Bit 15: 0  reg_sw_resets              //unsigned,   RW,   default = 16'h0;
#define VPU_VOUT_SECURE_BIT_NOR                    ((0x0001  << 2) + 0xfe350000)
//Bit 31: 0  reg_secure_bits_nor        //unsigned,   RW,   default = 32'h0;
#define VPU_VOUT_SECURE_DATA                       ((0x0002  << 2) + 0xfe350000)
//Bit 31:30  reserved
//Bit 29: 0  reg_secure_data             //unsigned,   RW,   default = 30'h0;
#define VPU_VOUT_FRM_CTRL                          ((0x0003  << 2) + 0xfe350000)
//Bit 31:17  reserved
//Bit    16  reg_dsi_suspend_en          //unsigned,   RW,   default = 0;
//Bit    15  reg_scan_en                 //unsigned,   RW,   default = 0;
//Bit 14: 2  reg_hold_line_num           //unsigned,   RW,   default = 4;
//Bit     1  pls_frm_start
//Bit     0  reg_frm_start_sel           //unsigned,   RW,   default = 0;
#define VPU_VOUT_AXI_ARBIT                         ((0x0004  << 2) + 0xfe350000)
//Bit 31:15  reserved
//Bit 14:13  reg_arb_urg_sel             //unsigned,   RW,   default = 2;
//Bit    12  reg_am_prot                 //unsigned,   RW,   default = 1;
//Bit 11: 4  reg_arb_arqos               //unsigned,   RW,   default = 0;
//Bit  3: 0  reg_arb_arcache             //unsigned,   RW,   default = 0;
#define VPU_VOUT_RDARB_IDMAP0                      ((0x0005  << 2) + 0xfe350000)
//Bit  31:0  reg_rdarb_id_map0           //unsigned,   RW,   default = 32'h10101010 ;
#define VPU_VOUT_RDARB_IDMAP1                      ((0x0006  << 2) + 0xfe350000)
//Bit  31:0  reg_rdarb_id_map1           //unsigned,   RW,   default = 32'h10101010 ;
#define VPU_VOUT_IRQ_CTRL                          ((0x0007  << 2) + 0xfe350000)
//Bit     31  reserved
//Bit  30:16  reg_irq_line_num           //unsigned,   RW,   default = 200;
//Bit  15: 8  reg_irq_en                 //unsigned,   RW,   default = 1;
//Bit   7: 0  pls_irq_clr                //unsigned,   RW,   default = 0;
#define VPU_VOUT_VLK_CTRL                          ((0x0009  << 2) + 0xfe350000)
//Bit 31: 12 reserved
//Bit 11: 8  reg_vlock_vsrc_sel          //unsigned,   RW,   default = 0;
//Bit  7: 4  reg_vlock_lath_sel          //unsigned,   RW,   default = 1;
//Bit  3: 1  reserved
//Bit     0  reg_vlock_en                //unsigned,   RW,   default = 0;
//blend module
#define VPU_VOUT_BLEND_CTRL                        ((0x0010  << 2) + 0xfe350000)
//Bit 31:28  reserved
//Bit 27:26  reg_blend_use_latch        //unsigned,   RW,   default = 2'h0;
//Bit    25  reg_blend_bg_en            //unsigned,   RW,   default = 1'h0;//0:vd1 is  background   1:osd is background
//Bit 24:16  reg_blend0_dummy_alpha     //unsigned,   RW,   default = 9'h0;
//Bit 15:13  reserved
//Bit 12: 4  reg_vd1_alpha              //unsigned,   RW,   default = 9'h0;
//Bit  3: 2  reg_blend0_premult_en      //unsigned,   RW,   default = 2'h1;
//Bit  1: 0  reg_blend_din_en           //unsigned,   RW,   default = 2'h3;
#define VPU_VOUT_BLEND_DUMDATA                     ((0x0011  << 2) + 0xfe350000)
//Bit 31:30  reserved
//Bit 29: 0  reg_blend0_dummy_data      //unsigned,   RW,   default = 30'h0;
#define VPU_VOUT_BLEND_SIZE                        ((0x0012  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_blend_hsize            //unsigned,   RW,   default = 720;
//Bit 15:13  reserved
//Bit 12:0   reg_blend_vsize            //unsigned,   RW,   default = 480;
//vd1 module
#define VPU_VOUT_BLD_SRC0_HPOS                     ((0x0020  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_bld_src0_h_end          //unsigned,   RW,   default = 719;
//Bit 15:13  reserved
//Bit 12: 0  reg_bld_src0_h_start        //unsigned,   RW,   default = b0;
#define VPU_VOUT_BLD_SRC0_VPOS                     ((0x0021  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_bld_src0_v_end          //unsigned,   RW,   default = 479;
//Bit 15:13  reserved
//Bit 12: 0  reg_bld_src0_v_start        //unsigned,   RW,   default = 0;
//osd1 module
#define VPU_VOUT_BLD_SRC1_HPOS                     ((0x0030  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_bld_src1_h_end          //unsigned,   RW,   default = 719;
//Bit 15:13  reserved
//Bit 12: 0  reg_bld_src1_h_start        //unsigned,   RW,   default = 0;
#define VPU_VOUT_BLD_SRC1_VPOS                     ((0x0031  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_bld_src1_v_end          //unsigned,   RW,   default = 479;
//Bit 15:13  reserved
//Bit 12: 0  reg_bld_src1_v_start        //unsigned,   RW,   default = 0;
//ofifo
#define VPU_VOUT_OFIFO_SIZE                        ((0x0040  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_ofifo_line_lenm1        //unsigned,   RW,   default = 480;
//Bit 15:14  reserved
//Bit 13: 0  reg_ofifo_size              //unsigned,   RW,   default = 2048;
#define VPU_VOUT_OFIFO_URG_CTRL                    ((0x0041  << 2) + 0xfe350000)
//Bit  31:30  reserved
//Bit     29  reg_ofifo_urg_hold_en      //unsigned,   RW,   default = 1'h0;
//Bit  28:16  reg_ofifo_urg_hold_line_th //unsigned,   RW,   default = 13'h0;
//Bit  15: 0  reg_ofifo_urg_ctrl         //unsigned,   RW,   default = 16'h0;
//for ro
#define VPU_VOUT_RO_STATUS                         ((0x0050  << 2) + 0xfe350000)
//Bit 31:23  reserved
//Bit 22:15  ro_irq_status
//Bit 14: 2  ro_ofifo_buf_count
//Bit     1  ro_osd_sc_blki_done
//Bit     0  ro_osd1_nearfull            //unsigned  ro
#define VPU_VOUT_RO_BLD_CURXY                      ((0x0051  << 2) + 0xfe350000)
//Bit 31:0  ro_blend0_current_xy         //unsigned  ro
#define VPU_VOUT_RO_VLK_ISP_TCNT                   ((0x0052  << 2) + 0xfe350000)
//Bit 31:0  ro_vlock_isp_tim_cnt         //unsigned  ro
#define VPU_VOUT_RO_VLK_VOUT_TCNT                  ((0x0053  << 2) + 0xfe350000)
//Bit 31:0  ro_vlock_vout_tim_cnt        //unsigned  ro
#define VPU_VOUT_RO_VLK_HIG_TCNT                   ((0x0054  << 2) + 0xfe350000)
//Bit 31:0  ro_vlock_tim_cnt_h           //unsigned  ro
#define VPU_VOUT_RO_VLK_FRM_CNT                    ((0x0055  << 2) + 0xfe350000)
//Bit 31:16  ro_vlock_isp_frm_cnt       //unsigned  ro
//Bit 15 :0  ro_vlock_vout_frm_cnt      //unsigned  ro
#define VPU_VOUT_RO_VLK_LATCH_TCNT                 ((0x0056  << 2) + 0xfe350000)
//Bit 31:0  ro_vlock_lth_tim_cnt_l      //unsigned  ro
#define VPU_VOUT_RO_VLK_LATCH_FCNT                 ((0x0057  << 2) + 0xfe350000)
//Bit 31:16  ro_vlock_lth_tim_cnt_h     //unsigned  ro
//Bit 15 :0  ro_vlock_lth_frm_cnt       //unsigned  ro
//for hw secure only
#define VPU_VOUT_TOP_SEC_KP                        ((0x0070  << 2) + 0xfe350000)
#define VPU_VOUT_TOP_SEC_BIT                       ((0x0071  << 2) + 0xfe350000)
#define VPU_VOUT_TOP_SEC_RO                        ((0x0072  << 2) + 0xfe350000)
//
// Closing file:  ./vpu_inc/vpu_vout_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  VOUT_TIMGEN_VCBUS_BASE = 0x01
// -----------------------------------------------
//
// Reading file:  ./vpu_inc/vpu_vout_timgen_reg.h
//
#define VPU_VOUT_CORE_CTRL                         ((0x0100  << 2) + 0xfe350000)
//Bit    31 reg_lath_size               // unsigned,  RW,  default = 0,
//Bit 30:29 reg_dth_glk_ctrl            // unsigned,  RW,  default = 0,
//Bit    28 reg_out_ctrl                // unsigned,  RW,  default = 0,
//Bit    27 reg_pos_switch              // unsigned,  RW,  default = 0,    //0:lcd_vout[23:0]=lcd_out[23:0]   1:lcd_out[15:8] exchange with lcd_out[7:0]
//Bit    26 reg_bt1120_simp_tim         // unsigned,  RW,  default = 0,    // 0:BT1120 with crc/ln0/ln1   1:BT1120 without crc/ln0/ln1
//Bit 25:16 reg_out_mode                // unsigned,  RW,  default = 0,
//Bit 15:12 reg_gclk_mode_ctrl          // unsigned,  RW,  default = 0,    //[3:2] clk_1120_ctrl [1:0]clk_656_ctrl,
//Bit 11:10 reg_gclk_regs_ctrl          // unsigned,  RW,  default = 0,    //[1:0] clk_reg
//Bit  9: 4 reg_dat_reo_sel             // unsigned,  RW,  default = 6'h24 //output data reorder
//Bit  3: 2 reg_serial_rate             // unsigned,  RW,  default = 0,    //0:pix/1cylce    1:pix/2cycle  2:pix/3cycle
//Bit 1     reg_field_mode              // unsigned,  RW,  default = 0;    //0:progressive   1:interlaced
//Bit 0     reg_venc_en                 // unsigned,  RW,  default = 0;    //0:venc disable  1:venc enable
#define VPU_VOUT_INT_CTRL                          ((0x0101  << 2) + 0xfe350000)
//Bit 31:15 reserved
//Bit    14 reg_dth_en                  // unsigned,  RW,  default = 0
//Bit 13:12 reg_sw_rst_sel              // unsigned,  RW,  default = 0
//Bit 11:8  reg_tim_rev                 // unsigned,  RW,  default = 0
//Bit 7     reg_int_error_ctrl          // unsigned,  RW,  default = 0
//Bit 6     reg_int_disable_rst_afifo   // unsigned,  RW,  default = 0
//Bit 5     pls_int_force_go_field      // unsigned,  RW,  default = 0
//Bit 4     pls_int_force_go_line       // unsigned,  RW,  default = 0
//Bit 3:2   reg_int_force_field_ctrl    // unsigned,  RW,  default = 0
//Bit 1:0   reg_int_vs_hs_ctrl          // unsigned,  RW,  default = 0
//
//
#define VPU_VOUT_DETH_CTRL                         ((0x0102  << 2) + 0xfe350000)
//Bit 31:19  reg_dth_vsize               // unsigned,  RW,  default = 0
//Bit 18:6   reg_dth_hsize               // unsigned,  RW,  default = 0
//Bit    5   reg_dth_bw                  // unsigned,  RW,  default = 0
//Bit  4:2   reg_dth_force_cnt_val       // unsigned,  RW,  default = 0
//Bit    1   reg_dth_force_cnt_en        // unsigned,  RW,  default = 0
//Bit    0   reg_sw_rst                  // unsigned,  RW,  default = 0
#define VPU_VOUT_DTH_DATA                          ((0x0103  << 2) + 0xfe350000)
//Bit 31:0   reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define VPU_VOUT_DTH_ADDR                          ((0x0104  << 2) + 0xfe350000)
//Bit 31:5   reserved
//Bit 4 :0   reg_dth_addr                      // unsigned ,    RW, default = 5'h0/
#define VPU_VOUT_HS_POS                            ((0x0112  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_hs_px_bgn    // unsigned,  RW,  default = 0;  pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_hs_px_end    // unsigned,  RW,  default = 1;  pixel end
#define VPU_VOUT_VSLN_E_POS                        ((0x0113  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_vs_ln_bgn_e  // unsigned,  RW,  default = 0;  (even field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_vs_ln_end_e  // unsigned,  RW,  default = 0;  (even field) line end
#define VPU_VOUT_VSPX_E_POS                        ((0x0114  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_vs_px_bgn_e  // unsigned,  RW,  default = 0;  (even field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_vs_px_end_e  // unsigned,  RW,  default = 0;  (even field) pixel end
#define VPU_VOUT_VSLN_O_POS                        ((0x0115  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_vs_ln_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_vs_ln_end_o  // unsigned,  RW,  default = 0;  (odd  field) line end
#define VPU_VOUT_VSPX_O_POS                        ((0x0116  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_vs_px_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_vs_px_end_o  // unsigned,  RW,  default = 0;  (odd  field) pixel end
#define VPU_VOUT_DE_PX_EN                          ((0x0117  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_de_px_bgn    // unsigned,  RW,  default = 100;  (even field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_de_px_end    // unsigned,  RW,  default = 2019;  (even field) pixel end
#define VPU_VOUT_DELN_E_POS                        ((0x0118  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_de_ln_bgn_e  // unsigned,  RW,  default = 41;  (even field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_de_ln_end_e  // unsigned,  RW,  default = 1120;  (even field) line end
#define VPU_VOUT_DELN_O_POS                        ((0x0119  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_de_ln_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_de_ln_end_o  // unsigned,  RW,  default = 0;  (odd  field) line end
#define VPU_VOUT_MAX_SIZE                          ((0x011a  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_total_hsize     // unsigned,  RW,  default = 2200;  maximum pixel count
//Bit 15:13 reserved
//Bit 12: 0 reg_total_vsize     // unsigned,  RW,  default = 1125;  maximum line  count
#define VPU_VOUT_FLD_BGN_LINE                      ((0x011b  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_field_ln_bgn_o     // unsigned,  RW,  default = 564;  BT1120 60I:1;   BT656_525:4    ;  odd field begin line
//Bit 15:13 reserved
//Bit 12: 0 reg_field_ln_bgn_e     // unsigned,  RW,  default = 1;    BT1120 60I:564; BT656_525:268  ;  even field begin line
//////////////////////////////////////////
//for independent timgen crtl_signal out
#define VPU_VOUTO_HS_POS                           ((0x0120  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_hs_px_bgn    // unsigned,  RW,  default = 0;  pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_hs_px_end    // unsigned,  RW,  default = 1;  pixel end
#define VPU_VOUTO_VSLN_E_POS                       ((0x0121  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_vs_ln_bgn_e  // unsigned,  RW,  default = 0;  (even field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_vs_ln_end_e  // unsigned,  RW,  default = 0;  (even field) line end
#define VPU_VOUTO_VSPX_E_POS                       ((0x0122  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_vs_px_bgn_e  // unsigned,  RW,  default = 0;  (even field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_vs_px_end_e  // unsigned,  RW,  default = 0;  (even field) pixel end
#define VPU_VOUTO_VSLN_O_POS                       ((0x0123  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_vs_ln_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_vs_ln_end_o  // unsigned,  RW,  default = 0;  (odd  field) line end
#define VPU_VOUTO_VSPX_O_POS                       ((0x0124  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_vs_px_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_vs_px_end_o  // unsigned,  RW,  default = 0;  (odd  field) pixel end
#define VPU_VOUTO_DE_PX_EN                         ((0x0125  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_de_px_bgn    // unsigned,  RW,  default = 100;  (even field) pixel begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_de_px_end    // unsigned,  RW,  default = 2019;  (even field) pixel end
#define VPU_VOUTO_DELN_E_POS                       ((0x0126  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_de_ln_bgn_e  // unsigned,  RW,  default = 41;  (even field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_de_ln_end_e  // unsigned,  RW,  default = 1120;  (even field) line end
#define VPU_VOUTO_DELN_O_POS                       ((0x0127  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_de_ln_bgn_o  // unsigned,  RW,  default = 0;  (odd  field) line begin
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_de_ln_end_o  // unsigned,  RW,  default = 0;  (odd  field) line end
#define VPU_VOUTO_MAX_SIZE                         ((0x0128  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_total_hsize     // unsigned,  RW,  default = 2200;  maximum pixel count
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_total_vsize     // unsigned,  RW,  default = 1125;  maximum line  count
#define VPU_VOUTO_FLD_BGN_LINE                     ((0x0129  << 2) + 0xfe350000)
//Bit 31:29 reserved
//Bit 28:16 reg_venco_field_ln_bgn_o     // unsigned,  RW,  default = 564;  BT1120 60I:1;   BT656_525:4    ;  odd field begin line
//Bit 15:13 reserved
//Bit 12: 0 reg_venco_field_ln_bgn_e     // unsigned,  RW,  default = 1;    BT1120 60I:564; BT656_525:268  ;  even field begin line
// bt1120
#define VPU_VOUT_BT_CTRL                           ((0x0130  << 2) + 0xfe350000)
//Bit 31:13  reserved
//Bit 12     reg_field_en       // unsigned,  RW,  default = 0;   //for interlace output
//Bit 11:4   reserved
//Bit 3: 2   reg_422_mode       // unsigned,  RW,  default = 0;   //0:left, 1:right, 2:average
//Bit 1      reg_cr_fst         // unsigned,  RW,  default = 0;   //0:cb first   1:cr first
//Bit 0: 0   reg_yc_switch      // unsigned,  RW,  default = 0;
#define VPU_VOUT_BT_PLD_LINE                       ((0x0131  << 2) + 0xfe350000)
//Bit 31:29  reserved
//Bit 28:16  reg_payload_line_e // unsigned,  RW,  default = 10;
//Bit 15:13  reserved
//Bit 12: 0  reg_payload_line_o // unsigned,  RW,  default = 572;
#define VPU_VOUT_BT_PLDIDT0                        ((0x0132  << 2) + 0xfe350000)
//Bit 31:26  reserved
//Bit 25:16  reg_payload_idt1   // unsigned,  RW,  default = 10'h32c;  // payload identifier byte1
//Bit 15:10  reserved
//Bit 9:0    reg_payload_idt0   // unsigned,  RW,  default = 10'h224; // payload identifier byte0
#define VPU_VOUT_BT_PLDIDT1                        ((0x0133  << 2) + 0xfe350000)
//Bit 31:26  reserved
//Bit 25:16  reg_payload_idt3   // unsigned,  RW,  default = 10'h4;  // payload identifier byte3
//Bit 15:10  reserved
//Bit 9:0    reg_payload_idt2   // unsigned,  RW,  default = 10'h80; // payload identifier byte2
#define VPU_VOUT_BT_BLK_DATA                       ((0x0134  << 2) + 0xfe350000)
//Bit 31:26  reserved
//Bit 25:16  reg_blank_data0    // unsigned,  RW,  default = 64;   //for Y,R,G,B
//Bit 15:10  reserved
//Bit  9: 0  reg_blank_data1    // unsigned,  RW,  default = 512;  //for Cb,Cr
#define VPU_VOUT_BT_DAT_CLPY                       ((0x0135  << 2) + 0xfe350000)
//Bit 31:26  reserved
//Bit 25:16  reg_dat_clp_max_y    // unsigned,  RW,  default = 940;   //for y max clip
//Bit 15:10  reserved
//Bit  9: 0  reg_dat_clp_min_y    // unsigned,  RW,  default = 0;      //for y min clip
#define VPU_VOUT_BT_DAT_CLPC                       ((0x0136  << 2) + 0xfe350000)
//Bit 31:26  reserved
//Bit 25:16  reg_dat_clp_max_c    // unsigned,  RW,  default = 960;   //for C max clip
//Bit 15:10  reserved
//Bit  9: 0  reg_dat_clp_min_c    // unsigned,  RW,  default = 64;      //for C min clip
#define VPU_VOUT_RO_INT                            ((0x0140  << 2) + 0xfe350000)
//Bit  31:0  ro_vout_timgen_status  //unsigned, RO  {afifo_count[4:0],ro_int_error_cnt[7:0]}
//
// Closing file:  ./vpu_inc/vpu_vout_timgen_reg.h
//
// -----------------------------------------------
// REG_BASE:  VOUT_MISC_VCBUS_BASE = 0x02
// -----------------------------------------------
//
// Reading file:  ./vpu_inc/vpu_vout_misc_reg.h
//
//VD1_RDMIF
#define VOUT_VD1_GEN_REG                           ((0x0200  << 2) + 0xfe350000)
#define VOUT_VD1_GEN_REG2                          ((0x0201  << 2) + 0xfe350000)
#define VOUT_VD1_CANVAS0                           ((0x0202  << 2) + 0xfe350000)
#define VOUT_VD1_LUMA_X0                           ((0x0203  << 2) + 0xfe350000)
#define VOUT_VD1_LUMA_Y0                           ((0x0204  << 2) + 0xfe350000)
#define VOUT_VD1_CHROMA_X0                         ((0x0205  << 2) + 0xfe350000)
#define VOUT_VD1_CHROMA_Y0                         ((0x0206  << 2) + 0xfe350000)
#define VOUT_VD1_RPT_LOOP                          ((0x0207  << 2) + 0xfe350000)
#define VOUT_VD1_LUMA0_RPT_PAT                     ((0x0208  << 2) + 0xfe350000)
#define VOUT_VD1_CHROMA0_RPT_PAT                   ((0x0209  << 2) + 0xfe350000)
#define VOUT_VD1_DUMMY_PIXEL                       ((0x020a  << 2) + 0xfe350000)
#define VOUT_VD1_LUMA_FIFO_SIZE                    ((0x020b  << 2) + 0xfe350000)
#define VOUT_VD1_RANGE_MAP_Y                       ((0x020c  << 2) + 0xfe350000)
#define VOUT_VD1_RANGE_MAP_CB                      ((0x020d  << 2) + 0xfe350000)
#define VOUT_VD1_RANGE_MAP_CR                      ((0x020e  << 2) + 0xfe350000)
#define VOUT_VD1_URGENT_CTRL                       ((0x020f  << 2) + 0xfe350000)
#define VOUT_VD1_GEN_REG3                          ((0x0210  << 2) + 0xfe350000)
#define VOUT_VD1_AXI_CMD_CNT                       ((0x0211  << 2) + 0xfe350000)
#define VOUT_VD1_AXI_RDAT_CNT                      ((0x0212  << 2) + 0xfe350000)
#define VOUT_VD1_CFMT_CTRL                         ((0x0213  << 2) + 0xfe350000)
#define VOUT_VD1_CFMT_W                            ((0x0214  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_Y                           ((0x0215  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_CB                          ((0x0216  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_CR                          ((0x0217  << 2) + 0xfe350000)
#define VOUT_VD1_STRIDE_0                          ((0x0218  << 2) + 0xfe350000)
#define VOUT_VD1_STRIDE_1                          ((0x0219  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_Y_F1                        ((0x021a  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_CB_F1                       ((0x021b  << 2) + 0xfe350000)
#define VOUT_VD1_BADDR_CR_F1                       ((0x021c  << 2) + 0xfe350000)
#define VOUT_VD1_STRIDE_0_F1                       ((0x021d  << 2) + 0xfe350000)
#define VOUT_VD1_STRIDE_1_F1                       ((0x021e  << 2) + 0xfe350000)
#define VOUT_OSD1_CTRL_STAT                        ((0x0240  << 2) + 0xfe350000)
#define VOUT_OSD1_CTRL_STAT2                       ((0x0241  << 2) + 0xfe350000)
#define VOUT_OSD1_COLOR_ADDR                       ((0x0242  << 2) + 0xfe350000)
#define VOUT_OSD1_COLOR                            ((0x0243  << 2) + 0xfe350000)
#define VOUT_OSD1_TCOLOR_AG0                       ((0x0244  << 2) + 0xfe350000)
#define VOUT_OSD1_TCOLOR_AG1                       ((0x0245  << 2) + 0xfe350000)
#define VOUT_OSD1_TCOLOR_AG2                       ((0x0246  << 2) + 0xfe350000)
#define VOUT_OSD1_TCOLOR_AG3                       ((0x0247  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK0_CFG_W0                      ((0x0248  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK1_CFG_W0                      ((0x0249  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK2_CFG_W0                      ((0x024a  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK3_CFG_W0                      ((0x024b  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK0_CFG_W1                      ((0x024c  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK1_CFG_W1                      ((0x024d  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK2_CFG_W1                      ((0x024e  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK3_CFG_W1                      ((0x024f  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK0_CFG_W2                      ((0x0250  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK1_CFG_W2                      ((0x0251  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK2_CFG_W2                      ((0x0252  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK3_CFG_W2                      ((0x0253  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK0_CFG_W3                      ((0x0254  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK1_CFG_W3                      ((0x0255  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK2_CFG_W3                      ((0x0256  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK3_CFG_W3                      ((0x0257  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK0_CFG_W4                      ((0x0258  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK1_CFG_W4                      ((0x0259  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK2_CFG_W4                      ((0x025a  << 2) + 0xfe350000)
#define VOUT_OSD1_BLK3_CFG_W4                      ((0x025b  << 2) + 0xfe350000)
#define VOUT_OSD1_FIFO_CTRL_STAT                   ((0x0260  << 2) + 0xfe350000)
#define VOUT_OSD1_TEST_RDDATA                      ((0x0261  << 2) + 0xfe350000)
#define VOUT_OSD1_PROT_CTRL                        ((0x0262  << 2) + 0xfe350000)
#define VOUT_OSD1_MALI_UNPACK_CTRL                 ((0x0263  << 2) + 0xfe350000)
#define VOUT_OSD1_DIMM_CTRL                        ((0x0264  << 2) + 0xfe350000)
//VD1_RDMIF_CSC
#define VOUT_VD1_CSC_COEF00_01                     ((0x0270  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF02_10                     ((0x0271  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF11_12                     ((0x0272  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF20_21                     ((0x0273  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF22                        ((0x0274  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF13_14                     ((0x0275  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF23_24                     ((0x0276  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_COEF15_25                     ((0x0277  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_CLIP                          ((0x0278  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_OFFSET0_1                     ((0x0279  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_OFFSET2                       ((0x027a  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_PRE_OFFSET0_1                 ((0x027b  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_PRE_OFFSET2                   ((0x027c  << 2) + 0xfe350000)
#define VOUT_VD1_CSC_EN_CTRL                       ((0x027d  << 2) + 0xfe350000)
//OSD_CSC
#define VOUT_OSD1_CSC_COEF00_01                    ((0x0280  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF02_10                    ((0x0281  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF11_12                    ((0x0282  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF20_21                    ((0x0283  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF22                       ((0x0284  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF30_31                    ((0x0285  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF32_40                    ((0x0286  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_COEF41_42                    ((0x0287  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_CLIP                         ((0x0288  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_OFFSET0_1                    ((0x0289  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_OFFSET2                      ((0x028a  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_PRE_OFFSET0_1                ((0x028b  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_PRE_OFFSET2                  ((0x028c  << 2) + 0xfe350000)
#define VOUT_OSD1_CSC_EN_CTRL                      ((0x028d  << 2) + 0xfe350000)
//OSD_SCALER
#define VOUT_OSD1_VSC_PHASE_STEP                   ((0x02a0  << 2) + 0xfe350000)
#define VOUT_OSD1_VSC_INI_PHASE                    ((0x02a1  << 2) + 0xfe350000)
#define VOUT_OSD1_VSC_CTRL0                        ((0x02a2  << 2) + 0xfe350000)
#define VOUT_OSD1_HSC_PHASE_STEP                   ((0x02a3  << 2) + 0xfe350000)
#define VOUT_OSD1_HSC_INI_PHASE                    ((0x02a4  << 2) + 0xfe350000)
#define VOUT_OSD1_HSC_CTRL0                        ((0x02a5  << 2) + 0xfe350000)
#define VOUT_OSD1_HSC_INI_PAT_CTRL                 ((0x02a6  << 2) + 0xfe350000)
#define VOUT_OSD1_SC_DUMMY_DATA                    ((0x02a7  << 2) + 0xfe350000)
#define VOUT_OSD1_SC_CTRL0                         ((0x02a8  << 2) + 0xfe350000)
#define VOUT_OSD1_SCI_WH_M1                        ((0x02a9  << 2) + 0xfe350000)
#define VOUT_OSD1_SCO_H_START_END                  ((0x02aa  << 2) + 0xfe350000)
#define VOUT_OSD1_SCO_V_START_END                  ((0x02ab  << 2) + 0xfe350000)
#define VOUT_OSD1_SCALE_COEF_IDX                   ((0x02ac  << 2) + 0xfe350000)
#define VOUT_OSD1_SCALE_COEF                       ((0x02ad  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_CTRL                      ((0x02ae  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_CTRL1                     ((0x02af  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_LUMA_THRD                 ((0x02b0  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_CHRM_THRD                 ((0x02b1  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_RANDLUT                   ((0x02b2  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_PXI_THRD                  ((0x02b3  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED_Y                    ((0x02b4  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED_U                    ((0x02b5  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED_V                    ((0x02b6  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED3                     ((0x02b7  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED4                     ((0x02b8  << 2) + 0xfe350000)
#define VOUT_OSD1_DB_FLT_SEED5                     ((0x02b9  << 2) + 0xfe350000)
//
// Closing file:  ./vpu_inc/vpu_vout_misc_reg.h
//
// -----------------------------------------------
// REG_BASE:  VOUT_RDARB_VCBUS_BASE = 0x04
// -----------------------------------------------
//`include "viu_rdarb_regs.h"
//
// Closing file:  ./vpu_inc/vout_regs_base.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_regs_base.h
//
// -----------------------------------------------
// REG_BASE:  ISP_TOP_APB0_APB_BASE = 0x00
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_top_hw_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_TOP_INPUT_SIZE                         ((0x0000  << 2) + 0xff000000)
//Bit 31:16         reg_input_hsize                // unsigned ,    RW, default = 720
//Bit 15: 0         reg_input_vsize                // unsigned ,    RW, default = 480
#define ISP_TOP_FRM_SIZE                           ((0x0001  << 2) + 0xff000000)
//Bit 31:16         reg_core_ihsize                // unsigned ,    RW, default = 720
//Bit 15: 0         reg_core_ivsize                // unsigned ,    RW, default = 480
#define ISP_TOP_HOLD_SIZE                          ((0x0002  << 2) + 0xff000000)
//Bit 31:16         reg_hold_hsize                 // unsigned ,    RW, default = 720
//Bit 15: 0         reg_hold_vsize                 // unsigned ,    RW, default = 20
#define ISP_TOP_CTRL0                              ((0x0003  << 2) + 0xff000000)
//Bit 31:19         reserved
//Bit 18            pls_din_vsync                 // unsigned ,    RW, default = 0,  //
//Bit 17:16         reg_din_vsync_sel             // unsigned ,    RW, default = 0,  //0: mipi/tmg vsync,  1:pls 2:1'b1  3:1'b0
//Bit 15:13         reserved
//Bit 12:11         reg_frm_latch_sel             // unsigned ,    RW, default = 0,  //latch use 0:frm_start 1:frm_end 2:1'b1 3:1'b0
//Bit 10            pls_frm_st_clr                // unsigned ,    W1T, default = 0, //pluse to clr frm_start_flg
//Bit 9:8           reg_frm_start_sel             // unsigned ,    RW, default = 0, //0:din_vsync 1:pls 2:fst_din
//Bit 7:6           reg_frm_rst_sel               // unsigned ,    RW, default = 2, //0:auto 1:pls 2:start_din
//Bit 5:2           reg_sw_rst_ctrl               // unsigned ,    RW, default = 0,
//Bit 1             pls_frm_start                 // unsigned ,    W1T, default = 0,
//Bit 0             pls_frm_rst                   // unsigned ,    W1T, default = 0,
#define ISP_TOP_PATH_EN                            ((0x0004  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28         reg_pnrmif_en                 // unsigned ,    RW, default = 0, {pnr_wrmif_y,pnr_rdmif_meta,pnr_rdmif_y}
//Bit 27:20         reg_nrmif_en                  // unsigned ,    RW, default = 0, {nr_rdmif_x4,nr_wrmif_x4},{meta,mv,mix,raw}
//Bit 19:18         reserved
//Bit 17:16         reg_rdmif_en                  // unsigned ,    RW, default = 0,
//Bit 15:13         reserved
//Bit 12:8          reg_wrmif_en                  // unsigned ,    RW, default = 0,
//Bit 7:4           reg_disp_2out_en              // unsigned ,    RW, default = 4'h3, //disp2out_enable
//Bit 3:0           reg_disp_en                   // unsigned ,    RW, default = 4'h1, //disp_en
#define ISP_TOP_PATH_SEL                           ((0x0005  << 2) + 0xff000000)
//Bit 31:20         reserved
//Bit 19            reg_dpth_hs_en_post           // unsigned ,    RW, default = 0, 0: raw_in->ofe->dms->post, 1:yuv_in->post
//Bit 18:16         reg_dpth_hs_en_core           // unsigned ,    RW, default = 1, 'b000:core disable, 'b001:mipi->core 'b010:rd0->core 'b100:rd1->core
//Bit 15:6          reserved
//Bit 5:4           reg_dpth_hs_en_rd1            // unsigned ,    RW, default = 2, [0]:rd1 to post hs en   [1]:rd1 to disp hs en
//Bit 3:2           reg_dpth_hs_en_rd0            // unsigned ,    RW, default = 3, [0]:rd0  to core hs en  [1]:rd0  to disp hs en
//Bit 1:0           reg_dpth_hs_en_mipi           // unsigned ,    RW, default = 3, [0]:mipi to core hs en  [1]:mipi to disp hs en
#define ISP_TOP_DISPIN_SEL                         ((0x0006  << 2) + 0xff000000)
//Bit 31:30         reserved
//Bit 29:20         reg_dispin_dat_sel            // unsigned ,    RW, default = 10'h6,disp0[1:0] ,01:cmpn1 02:cmpn2 else:cmpn0
//Bit 19:0          reg_dispin_path_sel           // unsigned ,    RW, default = 20'h0,6:close 5:rdmif1 4:dbgpath 3:rd02disp, 2:mipi2disp, 1:core_ir_dout, 0:core_dout
#define ISP_TOP_LS_INV                             ((0x0009  << 2) + 0xff000000)
//Bit 31:24         reg_rd1_reo_sel               // unsigned ,    RW, default = 8'h24
//Bit 23:16         reg_din_reo_sel               // unsigned ,    RW, default = 8'h24
//Bit 15:0          reg_ls_flag_inv               // unsigned ,    RW, default = 0  0:reg0 1:reg1 2:i_ls_flg 3:i_ls_flg_inv for long/short expos
#define ISP_TOP_MEAS                               ((0x000a  << 2) + 0xff000000)
//Bit 31:19         reserved
//Bit 18            pls_tmg_rst                    // unsigned ,   W1T, default = 0, //pluse to clr tmg_cnt
//Bit 17            reg_tmg_phase                  // unsigned ,    RW, default = 1, timing_gen enable
//Bit 16            reg_tmg_vsyn_sel               // unsigned ,    RW, default = 0, 0:din_vsyn_dly 1:tim_vsyn
//Bit 15            reg_tmg_hsyn_sel               // unsigned ,    RW, default = 1, 0:din_hsyn     1:ref_hend
//Bit 14            reserved
//Bit 13:12         reg_meas_ref_sel               // unsigned ,    RW, default = 0, for measure line dly
//Bit 11:8          reg_meas_din_sel               // unsigned ,    RW, default = 1
//Bit 7:4           reg_meas_dout_sel              // unsigned ,    RW, default = 7
//Bit 3:0           reserved
#define ISP_TOP_SYN_CTRL                           ((0x000b  << 2) + 0xff000000)
//Bit 31:23         reserved
//Bit 22            reg_din_secure                 // unsigned ,    RW, default = 0
//Bit 21            reg_rdmif1_secure              // unsigned ,    RW, default = 0
//Bit 20            reg_rdmif0_secure              // unsigned ,    RW, default = 0
//Bit 19:18         reserved
//Bit 17:16         reg_din_syn_mode               // unsigned ,    RW, default = 0  sel between din_h/vsyn from mipi & dly bit0 for vsyn bit1 for hsyn
//Bit 15:0          reserved
#define ISP_TOP_TIMGEN                             ((0x000c  << 2) + 0xff000000)
//Bit 31:16         reg_tmg_vtotal                 // unsigned ,    RW, default = 16'hffff
//Bit 15:0          reg_tmg_htotal                 // unsigned ,    RW, default = 1920
#define ISP_TOP_TIMGEN_REF                         ((0x000d  << 2) + 0xff000000)
//Bit 31:16         reg_tmg_ref_vcnt               // unsigned ,    RW, default = 0
//Bit 15:0          reg_tmg_ref_hcnt               // unsigned ,    RW, default = 2
#define ISP_TOP_TIMEGEN_RO_DBG                     ((0x000e  << 2) + 0xff000000)
//Bit 31:16         reserved
//Bit 15:0          ro_ref_vcnt                    // unsigned ,    RO, default = 0
#define ISP_TOP_DBGPATH                            ((0x000f  << 2) + 0xff000000)
//Bit 31:5          reserved
//Bit 4             reg_dbgpath_enable             // unsigned ,    RW, default = 0
//Bit 3:0           reg_dbgpath_src_sel            // unsigned ,    RW, default = 0  source sel for dbgpath 0: dfe 1:obe
#define ISP_TOP_SYN_VS                             ((0x0010  << 2) + 0xff000000)
//Bit 31:0          reg_vs_dly_num                 // unsigned ,    RW, default = 32
#define ISP_PROB_CTRL                              ((0x0011  << 2) + 0xff000000)
//Bit 31:19         reserved
//Bit 18:17         reg_hilight_mode               // unsigned ,    RW, default = 0
//Bit 16            reg_hilight_en                 // unsigned ,    RW, default = 0
//Bit 15:10          reserved
//Bit 9:4           reg_prob_sel                   // unsigned ,    RW, default = 1 0:ofe_din 1:ofe_dout 2:dfe_dout 3: obe_dout 4: dms_dout 5: post_dout
//Bit 3             reserved
//Bit 2             reg_checksum_en                // unsigned ,    RW, default = 0
//Bit 1             reg_prob_clr                   // unsigned ,    RW, default = 0
//Bit 0             reg_prob_en                    // unsigned ,    RW, default = 0
#define ISP_HILT_COLOR                             ((0x0012  << 2) + 0xff000000)
//Bit 31:24         reserved
//Bit 23:0          reg_hilight_color              // unsigned ,    RW, default = 0
#define ISP_PROB_POS                               ((0x0013  << 2) + 0xff000000)
//Bit 31:16         reg_prob_ypos                  // unsigned ,    RW, default = 50
//Bit 15:0          reg_prob_xpos                  // unsigned ,    RW, default = 50
#define ISP_PROB_RO_DAT_0                          ((0x0014  << 2) + 0xff000000)
//Bit 31:0          ro_prob_dat_0                  // unsigned ,    RO, default = 0
#define ISP_PROB_RO_DAT_1                          ((0x0015  << 2) + 0xff000000)
//Bit 31:0          ro_prob_dat_1                  // unsigned ,    RO, default = 0
#define ISP_TOP_IRQ_ABN_EN                         ((0x001f  << 2) + 0xff000000)
//Bit 31:16         reserved
//Bit 15:0          reg_irq_abn_en                 // unsigned ,    RW, default = 1
#define ISP_TOP_IRQ_EN                             ((0x0020  << 2) + 0xff000000)
//Bit 31:0          reg_irq_en                    // unsigned ,    RW, default = 1  //{6'h0, irq_intf,6'h0,din_vsyn_dly,din_vsyn,2'h0,irq_3a_dma_err,irq_abnorm_end,irq_line,frm_en,frm_rst,frm_end}
#define ISP_TOP_IRQ_CLR                            ((0x0021  << 2) + 0xff000000)
//Bit 31:0          pls_irq_clr                   // unsigned ,    W1T, default = 0
#define ISP_TOP_IRQ_LINE_THRD                      ((0x0022  << 2) + 0xff000000)
//Bit 31:20         reserved
//Bit 19:18         reg_irq_pos_flg_rev           // unsigned ,    RW, default = 0, [0]o_irq_flg 0:use flg 1:use pos  [1]:o_irq_pos 0:use pos 1:use flg
//Bit 17:16         reg_irq_line_sel              // unsigned ,    RW, default = 0, irq_line_sel from din_hsyn or core_dout_vcnt
//Bit 15:0          reg_irq_line_thrd             // unsigned ,    RW, default = 16'h100
#define ISP_TOP_RAW_MODE_SEL                       ((0x0023  << 2) + 0xff000000)
//Bit 31:4          reserved
//Bit 3:2           reg_bdryext_mode_ofe          // unsigned ,    RW, default = 0 ,hw_bdryext 0:1x1 repeat else 2x2 repeat
//Bit 1:0           reg_bdryext_mode_dms          // unsigned ,    RW, default = 0 ,hw_bdryext 0:1x1 repeat else 2x2 repeat
#define ISP_TOP_ABN_RDMA                           ((0x0024  << 2) + 0xff000000)
//Bit 31:16         pls_undone_clr                // unsigned ,    W1T, default = 0, frm_undone_clr
//Bit 15:0          reg_undone_en                 // unsigned ,    RW, default = 0, rdma_abnorm_frm_end_en
#define ISP_TOP_RDMA_CTRL                          ((0x0025  << 2) + 0xff000000)
//Bit 31:24         reserved
//Bit 23:16         pls_rdma_start                // unsigned ,    W1T, default= 0,
//Bit 15:8          reg_rdma_abn_en               // unsigned ,    RW, default = 0,
//Bit 7:0           reg_rdma_start_sel            // unsigned ,    RW, default = 0,
#define ISP_TOP_GCLK_CTRL                          ((0x0026  << 2) + 0xff000000)
//Bit 31:24         reserved
//Bit 23:8          reg_core_gclk_ctrl            // unsigned ,    RW, default = 0,
//Bit 7:6           reg_intf_gclk_wr              // unsigned ,    RW, default = 0,
//Bit 5:4           reg_intf_gclk_rd              // unsigned ,    RW, default = 0,
//Bit 3:2           reg_top_gclk_ctrl             // unsigned ,    RW, default = 0,
//Bit 1:0           reg_rgb2y_gclk_ctrl           // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_CTRL                        ((0x0027  << 2) + 0xff000000)
//Bit 31:19         reserved
//Bit 18:3          reg_srcdif_dbg_thrd           // unsigned ,    RW, default = 800, thrd for diff between same pixel from rdmif frame & mipi_din frame
//Bit 2             pls_srcdif_dbg_clr            // unsigned ,    W1T,default = 0, clr pls for ro_dbg_cnt
//Bit 1             reg_srcdif_dbg_mode           // unsigned ,    RW, default = 0, 0: output dbg_cnt 1: output dbg_cnt_max for several frames
//Bit 0             reg_srcdif_dbg_en             // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_START                       ((0x0028  << 2) + 0xff000000)
//Bit 31:16         reg_srcdif_dbg_hstart         // unsigned ,    RW, default = 0,
//Bit 15:0          reg_srcdif_dbg_vstart         // unsigned ,    RW, default = 0,
#define ISP_TOP_SRCDIF_SIZE                        ((0x0029  << 2) + 0xff000000)
//Bit 31:16         reg_srcdif_dbg_hsize          // unsigned ,    RW, default = 200,
//Bit 15:0          reg_srcdif_dbg_vsize          // unsigned ,    RW, default = 200,
#define ISP_TOP_SRCDIF_RO_CNT                      ((0x002a  << 2) + 0xff000000)
//Bit 31:0          ro_srcdif_dbg_cnt             // unsigned ,    RO, default = 0,
#define ISP_TOP_IRQ_LINE_THRD1                     ((0x002b  << 2) + 0xff000000)
//Bit 31:16         reserved
//Bit 15:0          reg_irq_line_thrd1             // unsigned ,    RW, default = 16'h200
#define ISP_DMA_CHN_EN                             ((0x002c  << 2) + 0xff000000)
//Bit 31:5          reserved
//Bit 4:0           reg_dma_chn_en                 // unsigned ,    RW, default = 5'h1f
#define ISP_FRM_CNT_CTRL                           ((0x002d  << 2) + 0xff000000)
//Bit 31:28         reg_frm_cnt_sel                      //unsigned,  RW, default = 0, ro_frm_cnt vld src sel
//Bit 27            reserved
//Bit 26            reg_frm_cnt_en                       //unsigned,  RW, default = 0, ro_frm_cnt_enable
//Bit 25            reg_frm_end_cnt_en                   //unsigned,  RW, default = 0, frm_end dly cnt enable
//Bit 24            reg_frm_end_cnt_sel                  //unsigned,  RW, default = 0, rdma_frm_end sel 0:frm_end, 1:frm_end_dly
//Bit 23:0          reg_frm_end_cnt_thrd                 //unsigned,  RW, default = 0, frm_end dly cnt thrd
#define ISP_TOP_CORE_CTRL0                         ((0x0030  << 2) + 0xff000000)
//Bit 31:0          reg_isp_core_ctrl0                   // unsigned ,    RW, default = 0
#define ISP_TOP_CORE_CTRL1                         ((0x0031  << 2) + 0xff000000)
//Bit 31:0          reg_isp_core_ctrl1                   // unsigned ,    RW, default = 0
#define ISP_TOP_FRM_END_MASK                       ((0x0035  << 2) + 0xff000000)
//Bit 31:0          reg_frm_end_mask          // unsigned ,    RW, default = 0  disable frm_end_chn
#define ISP_TOP_AXI_CNT_ID                         ((0x0036  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_axi_cnt_all                  // unsigned ,    RW, default = 0 axi_ro_cnt en
//Bit 19:16        reg_axi_cnt_en                   // unsigned ,    RW, default = 0 axi_ro_cnt en
//Bit 15:12        reg_axi_cnt_id_wr1               // unsigned ,    RW, default = 0 axi_ro_cnt id
//Bit 11:8         reg_axi_cnt_id_wr0               // unsigned ,    RW, default = 0 axi_ro_cnt id
//Bit 7:0          reg_axi_cnt_id_rd0               // unsigned ,    RW, default = 0 axi_ro_cnt id
#define ISP_TOP_OFFLINE_CTRL                       ((0x0038  << 2) + 0xff000000)
//Bit 31:17       reserved
//Bit 16          reg_slice_splt_en             // unsigned ,    RW, default = 0, two slice mode en
//Bit 15:3        reserved
//Bit 2           reg_offline_ena               // unsigned ,    RW, default = 0, offline mode enable
//Bit 1           pls_offline_frm_start         // unsigned ,    W1T, default = 0, offline sw frm_start
//Bit 0           pls_offline_frm_rst           // unsigned ,    W1T, default = 0, offline sw frm_rst
#define ISP_TOP_SLICE_TOTAL_SIZE                   ((0x0039  << 2) + 0xff000000)
//Bit 31:16       reg_slice_tvsize            // unsigned ,    RW, default = 1080  2slice mode,total size
//Bit 15:0        reg_slice_thsize            // unsigned ,    RW, default = 1920  2slice mode,total size
#define ISP_TOP_SLICE_HSCOPE0                      ((0x003a  << 2) + 0xff000000)
//Bit 31:16       reg_slice_hend0            // unsigned ,    RW, default = 1920  2slice mode,slice0 hend
//Bit 15:0        reg_slice_hbgn0            // unsigned ,    RW, default = 0     2slice mode,slice0 hbgn
#define ISP_TOP_SLICE_VSCOPE0                      ((0x003b  << 2) + 0xff000000)
//Bit 31:16       reg_slice_vend0            // unsigned ,    RW, default = 1080  2slice mode,slice0 vend
//Bit 15:0        reg_slice_vbgn0            // unsigned ,    RW, default = 0     2slice mode,slice0 vbgn
#define ISP_TOP_SLICE_HSCOPE1                      ((0x003c  << 2) + 0xff000000)
//Bit 31:16       reg_slice_hend1            // unsigned ,    RW, default = 1920  2slice mode,slice1 hend
//Bit 15:0        reg_slice_hbgn1            // unsigned ,    RW, default = 0     2slice mode,slice1 hbgn
#define ISP_TOP_SLICE_VSCOPE1                      ((0x003d  << 2) + 0xff000000)
//Bit 31:16       reg_slice_vend1            // unsigned ,    RW, default = 1080  2slice mode,slice1 vend
//Bit 15:0        reg_slice_vbgn1            // unsigned ,    RW, default = 0     2slice mode,slice1 vbgn
#define ISP_CHECKSUM_RO_DAT_0                      ((0x0040  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_0                // unsigned ,   RO, default = 0 checksum for ofe_din
#define ISP_CHECKSUM_RO_DAT_1                      ((0x0041  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_1                // unsigned ,   RO, default = 0 checksum for ofe_dout
#define ISP_CHECKSUM_RO_DAT_2                      ((0x0042  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_2                // unsigned ,   RO, default = 0 checksum for dfe_dout
#define ISP_CHECKSUM_RO_DAT_3                      ((0x0043  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_3                // unsigned ,   RO, default = 0 checksum for obe_dout
#define ISP_CHECKSUM_RO_DAT_4                      ((0x0044  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_4                // unsigned ,   RO, default = 0 checksum for dms_dout
#define ISP_CHECKSUM_RO_DAT_5                      ((0x0045  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_5                // unsigned ,   RO, default = 0 checksum for post_dout
#define ISP_CHECKSUM_RO_DAT_6                      ((0x0046  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_6                // unsigned ,   RO, default = 0 checksum for post_ir
#define ISP_CHECKSUM_RO_DAT_7                      ((0x0047  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_7                // unsigned ,   RO, default = 0 checksum for disp_0
#define ISP_CHECKSUM_RO_DAT_8                      ((0x0048  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_8                // unsigned ,   RO, default = 0 checksum for disp_1
#define ISP_CHECKSUM_RO_DAT_9                      ((0x0049  << 2) + 0xff000000)
//Bit 31:0         ro_checksum_dat_9                // unsigned ,   RO, default = 0 checksum for disp_2
#define ISP_TOP_RO_DBG_STAT0                       ((0x0070  << 2) + 0xff000000)
//Bit 31:0          ro_debug_stat0                  // unsigned ,    RO, default = 0 ,[15:0]:isp_undone_vcnt,[31:16]:{corein,ofe,dfe,obe,  dms,post,3a,core,  disp,line,intf,all_end},
#define ISP_TOP_RO_IRQ_STAT                        ((0x0071  << 2) + 0xff000000)
//Bit 31:0          ro_irq_status                   // unsigned ,    RO, default = 0 , {frm_end_dly,irq_line_out1,din_vsyn_dly,din_vsyn_mipi,offline_frm_end,post_int,intf_err_int,irq_3a_dma_err ,irq_abnorm_end,irq_line,frm_en,frm_rst,frm_end}
#define ISP_TOP_RO_MEAS                            ((0x0072  << 2) + 0xff000000)
//Bit 31:16         ro_isp_frm_cnt                  // unsigned ,    RO, default = 0 ,
//Bit 15:0          ro_meas_dly_num                 // unsigned ,    RO, default = 0 ,
#define ISP_TOP_AXI_RO_RD0_STAT                    ((0x0073  << 2) + 0xff000000)
//Bit 31:0          ro_axi_rd0_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR0_STAT                    ((0x0074  << 2) + 0xff000000)
//Bit 31:0          ro_axi_wr0_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR1_STAT                    ((0x0075  << 2) + 0xff000000)
//Bit 31:0          ro_axi_wr1_cnt                  //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR0_RSP                     ((0x0076  << 2) + 0xff000000)
//Bit 31:0          ro_axi_wr0_rsp_cnt              //unsigned, RO, default=0
#define ISP_TOP_AXI_RO_WR1_RSP                     ((0x0077  << 2) + 0xff000000)
//Bit 31:0          ro_axi_wr1_rsp_cnt              //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_top_hw_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_TOP_APB1_APB_BASE = 0x01
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_TOP_MODE_CTRL                          ((0x0100  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16:12        reg_src_bit_depth         // unsigned ,    RW, default = 14  source data bit depth from input port, support 8bit~14bit
//Bit 11:10        reserved
//Bit  9: 8        reg_src_inp_chn           // unsigned ,    RW, default = 0  the source data channels, support (1+inp_chn) as 1/2/3/4 from input port
//Bit  7: 6        reserved
//Bit  5: 4        reg_wdr_inp_chn           // unsigned ,    RW, default = 0  the input channels for wdr stitch, support (1+inp_chn) as 1/2/3/4 images as wdr stitch's input;
//Bit  3            reserved
//Bit  2: 0        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
#define ISP_TOP_RAW_PHS_0                          ((0x0101  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  phase lut for raw data
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  phase lut for raw data
#define ISP_TOP_RAW_PHS_1                          ((0x0102  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  phase lut for raw data
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  phase lut for raw data
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  phase lut for raw data
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  phase lut for raw data
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  phase lut for raw data
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  phase lut for raw data
#define ISP_TOP_FEO_CTRL0                          ((0x0103  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12           reg_crop_en               // unsigned ,    RW, default = 0  enable crop mode
//Bit 11           reg_bin_en                // unsigned ,    RW, default = 0  enable binning function
//Bit 10           reg_fpnr_en               // unsigned ,    RW, default = 0  1:fpnr enable
//Bit  9           reg_bac_en                // unsigned ,    RW, default = 0  enable binning artifacts correction
//Bit  8           reg_inp_fmt_en            // unsigned ,    RW, default = 1  enable input formatter
//Bit  7           reg_decmp_en              // unsigned ,    RW, default = 0  0: disable decompander for linear src, 1: enable decompander for compander src
//Bit  6           reg_wdr_stat_en           // unsigned ,    RW, default = 0  enable wdr statistic
//Bit  5: 4        reg_expstitch_mode        // unsigned ,    RW, default = 0  0: linear mode (bypass wdr), 1: wdr mode, 2or3: combination mode
//Bit  3: 1        reg_pre_mux_mode          // unsigned ,    RW, default = 0  pre mux mode for front-end output, 4 or else: ch0 before formatter,
//Bit  0           reg_pst_mux_mode          // unsigned ,    RW, default = 0  post mux mode for front-end output, 1: wdr output, 0: no-wdr output
#define ISP_TOP_FEO_CTRL1_0                        ((0x0104  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5           reg_og_en_0               // unsigned ,    RW, default = 1  enable for wdr gain offst adjustment each channels
//Bit  4           reg_pat_en_0              // unsigned ,    RW, default = 0  enable pattern generation
//Bit  3           reg_dpc_en_0              // unsigned ,    RW, default = 1  enable defect pixel correction
//Bit  2           reg_ge_en_0               // unsigned ,    RW, default = 0  enable green equalization
//Bit  1: 0        reg_crossbar_mux_0        // unsigned ,    RW, default = 0  selection for crossbar mux
#define ISP_TOP_FEO_CTRL1_1                        ((0x0105  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5           reg_og_en_1               // unsigned ,    RW, default = 1  enable for wdr gain offst adjustment each channels
//Bit  4           reg_pat_en_1              // unsigned ,    RW, default = 0  enable pattern generation
//Bit  3           reg_dpc_en_1              // unsigned ,    RW, default = 1  enable defect pixel correction
//Bit  2           reg_ge_en_1               // unsigned ,    RW, default = 0  enable green equalization
//Bit  1: 0        reg_crossbar_mux_1        // unsigned ,    RW, default = 1  selection for crossbar mux
#define ISP_TOP_FED_CTRL                           ((0x0106  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:17        reg_flkr_sta_pos          // unsigned ,    RW, default = 1  select flicker statistic position in ISP 0:feo 1:nr 2:post
//Bit 16           reg_dgain_en              // unsigned ,    RW, default = 1  enable digital gain
//Bit 15           reg_fe_bl_en              // unsigned ,    RW, default = 0  enable front end black level
//Bit 14           reg_sqrt_en               // unsigned ,    RW, default = 1  enable for the sqrt function, 0, simple rounding from BIT_DEPTH02 to BIT_DEPTH1; 1: using sqrt lut
//Bit 13           reg_cubic_en              // unsigned ,    RW, default = 0  enable cubic
//Bit 12           reg_cubic_cs_en           // unsigned ,    RW, default = 1  default: 0(0: bayer, 1: yvuy), description: color space mode for snr1 input
//Bit 11           reg_tnr0_en               // unsigned ,    RW, default = 1  enable tnr0, default: 1, range: 0~1
//Bit 10           reg_mc_tnr_en             // unsigned ,    RW, default = 0  enable mc tnr, default: 0, range: 0~1
//Bit  9           reg_snr1_en               // unsigned ,    RW, default = 1  enable snr, default: 1, range: 0~1
//Bit  8: 7        reg_stage2_input_mode     // unsigned ,    RW, default = 2  nr model C/E, default: 2
//Bit  6: 5        reg_rawcnr_enable         // unsigned ,    RW, default = 1  enable of the rawcnr_function, 0: disable; 1: enable,5x5 window, default=1
//Bit  4           reg_flkr_det_en           // unsigned ,    RW, default = 0  enable flicker detection (HW)
//Bit  3           reg_flkr_stat_en          // unsigned ,    RW, default = 0  enable row statistic for flicker detection
//Bit  2           reg_cac_en                // unsigned ,    RW, default = 0  enable of CAC function, o: bypass CAC (power gated); 1: enable CAC
//Bit  1           reg_pdpc_enable           // unsigned ,    RW, default = 1  enable for the post dpc function
//Bit  0           reg_lcge_enable           // unsigned ,    RW, default = 0  enable of the lcge function
#define ISP_TOP_BEO_CTRL                           ((0x0107  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9           reg_eotf_en               // unsigned ,    RW, default = 1  enable for the eotf function, 0, simple rounding from BIT_DEPTH2 to BIT_DEPTH3; 1: using eotf lut
//Bit  8           reg_idgain_en             // unsigned ,    RW, default = 1  enable inv digital gain
//Bit  7           reg_blc_en                // unsigned ,    RW, default = 1  enable black level correction
//Bit  6           reg_wb_en                 // unsigned ,    RW, default = 1  enable white balance gain
//Bit  5           reg_wb_switch             // unsigned ,    RW, default = 0  0: wb before radial and mesh shading, 1: wb after radial and mesh shading
//Bit  4           reg_lns_rad_en            // unsigned ,    RW, default = 0  shading enable
//Bit  3           reg_lns_mesh_en           // unsigned ,    RW, default = 0  mesh shading enable
//Bit  2           reg_gtm_en                // unsigned ,    RW, default = 0  enable tone mapping
//Bit  1           reg_ltm_en                // unsigned ,    RW, default = 0  enable local tone mapping
//Bit  0            reserved
#define ISP_TOP_BED_CTRL                           ((0x0108  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25           reg_amcm_en               // unsigned ,    RW, default = 1  amcm enable
//Bit 24:22        reserved
//Bit 21           reg_pst_tnr_lite_en       // unsigned ,    RW, default = 1
//Bit 20           reg_mirror_en             // unsigned ,    RW, default = 0  enable horizontal flipping
//Bit 19           reg_dmsc_en               // unsigned ,    RW, default = 1  enable demosaic
//Bit 18           reg_ccm_en                // unsigned ,    RW, default = 1  enable color correction matrix, 0=off 1=on
//Bit 17           reg_lut3d_en              // unsigned ,    RW, default = 1  signal for lut3d ip
//Bit 16           reg_pst_gamma_en          // unsigned ,    RW, default = 1  enable rgb gamma lut, tuning curve gamma, default as off
//Bit 15           reg_dgamma_en             // unsigned ,    RW, default = 0  display gamma, should be enable
//Bit 14           reg_cm0_en                // unsigned ,    RW, default = 1  enable color matrix 0
//Bit 13           reg_cm1_en                // unsigned ,    RW, default = 1  enable color matrix 1
//Bit 12            reserved
//Bit 11           reg_cnr2_en               // unsigned ,    RW, default = 1  cnr2 enable
//Bit 10           reg_bsc_en                // unsigned ,    RW, default = 1  enable bsc adjust
//Bit  9           reg_ir_plus_en            // unsigned ,    RW, default = 0  enable Ir plus function
//Bit  8           reg_lc_en                 // unsigned ,    RW, default = 0  enable local contrast
//Bit  7           reg_dhz_en                // unsigned ,    RW, default = 0  enable dehaze
//Bit  6           reg_dnlp_en               // unsigned ,    RW, default = 0  enable dnlp contrast
//Bit  5           reg_pk_en                 // unsigned ,    RW, default = 0  enable peaking for sharpness
//Bit  4           reg_nr_en                 // unsigned ,    RW, default = 0  enable noise reduction for sharpness
//Bit  3           reg_fmeter_en             // unsigned ,    RW, default = 1  enable fmeter fucntion
//Bit  2           reg_grph_en               // unsigned ,    RW, default = 1  enable graphic statistic
//Bit  1: 0        reg_yhs_sta_en            // unsigned ,    RW, default = 1
#define ISP_TOP_3A_STAT_CRTL                       ((0x0109  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_awb_stat_mux          // unsigned ,    RW, default = 0  mux input data in feo for awb statistic
//Bit 19:17        reserved
//Bit 16           reg_ae_stat_mux           // unsigned ,    RW, default = 0  mux input data in feo for awb statistic
//Bit 15:14        reserved
//Bit 13:12        reg_af_stat_switch        // unsigned ,    RW, default = 1  0: from snr, 1: from dms pp, 2or3: from sharpness, switch of auto focus statistics
//Bit 11:10        reserved
//Bit  9: 8        reg_ae_stat_switch        // unsigned ,    RW, default = 2  0: from GE, 1: from MLS, 2: Before DRC, 3: After DRC, switch of ae statistic
//Bit  7            reserved
//Bit  6: 4        reg_awb_stat_switch       // unsigned ,    RW, default = 2  0: from FE, 1: from GE, 2: before WB, 3: after WB, 4: from DRC, 5 or else: from PEK, switch of awb statistic
//Bit  3            reserved
//Bit  2           reg_af_stat_en            // unsigned ,    RW, default = 1  enable af statistic
//Bit  1           reg_awb_stat_en           // unsigned ,    RW, default = 1  enable awb statistic
//Bit  0           reg_ae_stat_en            // unsigned ,    RW, default = 1  enable ae statistic
#define ISP_TOP_BYPASS                             ((0x010a  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_bypass_feo            // unsigned ,    RW, default = 0  bypass ch0~2 after TPG and the wdr stich output for md
#define ISP_TOP_STITCH_CTRL                        ((0x010b  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16: 1        reg_stch_ovlp_num         // unsigned ,    RW, default = 160  number of overlap pixels in left/right slice mode
//Bit  0           reg_two_slic_mode         // unsigned ,    RW, default = 0  stitch enable
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB0_APB_BASE = 0x02
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GE0_CTRL                               ((0x0200  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_ge_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for ge
//Bit 15:14        reserved
//Bit 13:12        reg_ge_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for ge
//Bit 11: 9        reserved
//Bit  8           reg_ge_rpt_mode           // unsigned ,    RW, default = 1  0: repeat, 1: mirror, repeat mode for green equalization
//Bit  7: 0        reg_ge_edge_rs            // unsigned ,    RW, default = 128  for edge shift
#define ISP_GE0_STAT                               ((0x0201  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ge_stat_edge_thd      // unsigned ,    RW, default = 16  edge threshold for ge statistic
#define ISP_GE0_COMM                               ((0x0202  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17: 8        reg_ge_hv_thrd            // unsigned ,    RW, default = 34  ge, if absdiff > reg_ge_hv_thrd, weight, 0, if absidff < reg_ge_hv_thrd, do filter
//Bit  7: 0        reg_ge_final_bld          // unsigned ,    RW, default = 0  heavy ge and ge blend ratio, 0 use ge_lpf, 255 use ge_dlt
#define ISP_GE0_HV_RATIO                           ((0x0203  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ge_hv_ratio_0         // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_hv_ratio_1         // unsigned ,    RW, default = 12
//Bit  7: 0        reg_ge_hv_ratio_2         // unsigned ,    RW, default = 28
#define ISP_GE0_HV_WT2                             ((0x0204  << 2) + 0xff000000)
//Bit 31:24        reg_ge_hv_wtlut_0         // unsigned ,    RW, default = 64  when making the weighted average, the weights need to be looked up according to the diff
//Bit 23:16        reg_ge_hv_wtlut_1         // unsigned ,    RW, default = 84  when making the weighted average, the weights need to be looked up according to the diff
//Bit 15: 8        reg_ge_hv_wtlut_2         // unsigned ,    RW, default = 96  when making the weighted average, the weights need to be looked up according to the diff
//Bit  7: 0        reg_ge_hv_wtlut_3         // unsigned ,    RW, default = 128  when making the weighted average, the weights need to be looked up according to the diff
#define ISP_GE0_GI_LUT0                            ((0x0205  << 2) + 0xff000000)
//Bit 31:24        reg_ge_gi_lut_0           // unsigned ,    RW, default = 24  GI_LUT
//Bit 23:16        reg_ge_gi_lut_1           // unsigned ,    RW, default = 24  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_2           // unsigned ,    RW, default = 12  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_3           // unsigned ,    RW, default = 12  GI_LUT
#define ISP_GE0_GI_LUT1                            ((0x0206  << 2) + 0xff000000)
//Bit 31:24        reg_ge_gi_lut_4           // unsigned ,    RW, default = 10  GI_LUT
//Bit 23:16        reg_ge_gi_lut_5           // unsigned ,    RW, default = 10  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_6           // unsigned ,    RW, default = 5  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_7           // unsigned ,    RW, default = 5  GI_LUT
#define ISP_GE0_DLT_CTRL1                          ((0x0207  << 2) + 0xff000000)
//Bit 31:30        reg_ge_gi_lut_sft         // signed ,    RW, default = 0  ge_gi_lut_shift
//Bit 29:25        reg_max_ge_dlt_ratio      // unsigned ,    RW, default = 31  ge_max_delta_ratio
//Bit 24           reg_ge_dlt_real_max_en    // unsigned ,    RW, default = 1  ge_delta_real_max enable
//Bit 23:16        reg_ge_dlt_bld_th0        // unsigned ,    RW, default = 10  ge_delta_blend_th0
//Bit 15:12        reg_ge_dlt_bld_thn        // unsigned ,    RW, default = 5  ge_delta_blend_thn
//Bit 11: 6        reg_ge_dlt_bld_alph0      // unsigned ,    RW, default = 48  ge_delta_blend_alpha0
//Bit  5: 0        reg_ge_dlt_bld_alph1      // unsigned ,    RW, default = 48  ge_delta_blend_alpha1
#define ISP_GE0_DLT_CTRL2                          ((0x0208  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:17        reg_ge_lpf_blend_alp      // unsigned ,    RW, default = 0  ge_out_dlt use lpf data centered gr/gb and neighbor gbs/grs
//Bit 16           reg_ge_dlt_edge_en        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_dlt_edge_ratio_0   // unsigned ,    RW, default = 8
//Bit  7: 0        reg_ge_dlt_edge_ratio_1   // unsigned ,    RW, default = 8
#define ISP_GE0_CORE                               ((0x0209  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ge_coring             // unsigned ,    RW, default = 0  coring for ge difference and edge calc
#define ISP_OG0_OFST0                              ((0x020a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_0         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gr for wdr previous offset each color each channels
//Bit 15: 6        reserved
//Bit  5: 4        reg_og_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for offset/gain
//Bit  3: 2        reserved
//Bit  1: 0        reg_og_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for offset/gain
#define ISP_OG0_OFST12                             ((0x020b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_2         // unsigned ,    RW, default = 0  (BIT_DEPTH01), B  for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_1         // unsigned ,    RW, default = 0  (BIT_DEPTH01), R  for wdr previous offset each color each channels
#define ISP_OG0_OFST34                             ((0x020c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_4         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_3         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gb for wdr previous offset each color each channels
#define ISP_OG0_GAIN_PST                           ((0x020d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_0             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pst_ofst           // unsigned ,    RW, default = 0  (BIT_DEPTH01), for wdr post offset each channels
#define ISP_OG0_GAIN1                              ((0x020e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_1             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_2             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_OG0_GAIN2                              ((0x020f  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_3             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_4             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_FPNR0_CTRL_CORR                        ((0x0210  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_fpnr_corr_en          // unsigned ,    RW, default = 1  fpnr correction enable for each channel
#define ISP_FPNR0_CORR_GAIN_0                      ((0x0211  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_0     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_0     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_1                      ((0x0212  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_1     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_1     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_2                      ((0x0213  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_2     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_2     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_3                      ((0x0214  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_3     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_3     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_GAIN_4                      ((0x0215  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_4     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_4     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR0_CORR_OFST_0                      ((0x0216  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_0      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_1                      ((0x0217  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_1      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_2                      ((0x0218  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_2      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_3                      ((0x0219  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_3      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_CORR_OFST_4                      ((0x021a  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_4      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR0_LUT_ADDR                         ((0x021e  << 2) + 0xff000000)
//Bit 31:0        reg_fpnr_lut_addr         // unsigned, RW, default=0, fpnr lut addr
#define ISP_FPNR0_LUT_DATA                         ((0x021f  << 2) + 0xff000000)
//Bit 31:0        reg_fpnr_lut_data         // unsigned, RW, default=0, fpnr lut data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_PAT0_CTRL                              ((0x0220  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_pat_xphs_ofst         // unsigned ,    RW, default = 1  x phase offset for pattern generation
//Bit 11:10        reg_pat_yphs_ofst         // unsigned ,    RW, default = 0  y phase offset for pattern generation
//Bit  9: 8        reg_pat_dft_mode          // unsigned ,    RW, default = 0  0 no dft; 1 dead pixel 2: hot pixel; 3: not dft
//Bit  7: 5        reg_pat_xmode             // unsigned ,    RW, default = 0  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along x-direction
//Bit  4: 2        reg_pat_ymode             // unsigned ,    RW, default = 3  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along y-direction
//Bit  1           reg_pat_xinvt             // unsigned ,    RW, default = 0  invert along x-direction
//Bit  0           reg_pat_yinvt             // unsigned ,    RW, default = 0  invert along y-direction
#define ISP_PAT0_IDX_SCL                           ((0x0221  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_scale        // unsigned ,    RW, default = 32  index scale, 1<<(15-reg_pat_xidx_rshft) / HSIZE
//Bit 15: 4        reg_pat_yidx_scale        // unsigned ,    RW, default = 46  index scale, 1<<(15-reg_pat_yidx_rshft) / VSIZE
//Bit  3: 2        reg_pat_xidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for x index
//Bit  1: 0        reg_pat_yidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for y index
#define ISP_PAT0_IDX_OFST                          ((0x0222  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_ofset        // unsigned ,    RW, default = 0  x index offset for pattern generation
//Bit 15:12        reserved
//Bit 11: 0        reg_pat_yidx_ofset        // unsigned ,    RW, default = 0  y index offset for pattern generation
#define ISP_PAT0_FWIN_R                            ((0x0223  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_0        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15: 2        reserved
//Bit  1           reg_pat_fwin_clr_chk      // unsigned ,    RW, default = 1  color checker for foreground window
//Bit  0           reg_pat_fwin_en           // unsigned ,    RW, default = 1  enable foreground window
#define ISP_PAT0_FWIN_GB                           ((0x0224  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_2        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_fwin_rgb_1        // unsigned ,    RW, default = 1023  rgb of foreground window
#define ISP_PAT0_FWIN_START                        ((0x0225  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hstart       // unsigned ,    RW, default = 480  horizontal start of foreground window
//Bit 15: 0        reg_pat_fwin_vstart       // unsigned ,    RW, default = 270  vertical start of foreground window
#define ISP_PAT0_FWIN_SIZE                         ((0x0226  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hsize        // unsigned ,    RW, default = 960  horizontal size of foreground window
//Bit 15: 0        reg_pat_fwin_vsize        // unsigned ,    RW, default = 540  vertical size of foreground window
#define ISP_PAT0_FWIN_BLK_SIZE                     ((0x0227  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hblk_size    // unsigned ,    RW, default = 160  horizontal block size of foreground window
//Bit 15: 0        reg_pat_fwin_vblk_size    // unsigned ,    RW, default = 135  vertical block size of foreground window
#define ISP_PAT0_IR_MODE                           ((0x0228  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 27:26        reserved
//Bit 15:10        reserved
#define ISP_PAT0_XRMP_SRGB                         ((0x0229  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_xrmp_scalergb_2   // unsigned ,    RW, default = 255  B x ramp scale for pattern generation
//Bit 15: 8        reg_pat_xrmp_scalergb_1   // unsigned ,    RW, default = 255  G x ramp scale for pattern generation
//Bit  7: 0        reg_pat_xrmp_scalergb_0   // unsigned ,    RW, default = 255  R x ramp scale for pattern generation
#define ISP_PAT0_YRMP_SRGB                         ((0x022a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_yrmp_scalergb_2   // unsigned ,    RW, default = 0  B y ramp scale for pattern generation
//Bit 15: 8        reg_pat_yrmp_scalergb_1   // unsigned ,    RW, default = 0  G y ramp scale for pattern generation
//Bit  7: 0        reg_pat_yrmp_scalergb_0   // unsigned ,    RW, default = 0  R y ramp scale for pattern generation
#define ISP_PAT0_BAR24_R01                         ((0x022b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R23                         ((0x022c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_2      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R45                         ((0x022d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_5      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_4      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R67                         ((0x022e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_6      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R89                         ((0x022f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_R1011                       ((0x0230  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_R1213                       ((0x0231  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_R1415                       ((0x0232  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_R1617                       ((0x0233  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R1819                       ((0x0234  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_R2021                       ((0x0235  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_R2223                       ((0x0236  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G01                         ((0x0237  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G23                         ((0x0238  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_3      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_2      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G45                         ((0x0239  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_4      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G67                         ((0x023a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_6      // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G89                         ((0x023b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_G1011                       ((0x023c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_G1213                       ((0x023d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_G1415                       ((0x023e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_G1617                       ((0x023f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G1819                       ((0x0240  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_G2021                       ((0x0241  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_G2223                       ((0x0242  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_B01                         ((0x0243  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_1      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_0      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B23                         ((0x0244  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_2      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B45                         ((0x0245  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_4      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B67                         ((0x0246  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_6      // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B89                         ((0x0247  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_8      // unsigned ,    RW, default = 128
#define ISP_PAT0_BAR24_B1011                       ((0x0248  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_10     // unsigned ,    RW, default = 384
#define ISP_PAT0_BAR24_B1213                       ((0x0249  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_12     // unsigned ,    RW, default = 640
#define ISP_PAT0_BAR24_B1415                       ((0x024a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_14     // unsigned ,    RW, default = 896
#define ISP_PAT0_BAR24_B1617                       ((0x024b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_16     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B1819                       ((0x024c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_18     // unsigned ,    RW, default = 0
#define ISP_PAT0_BAR24_B2021                       ((0x024d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_20     // unsigned ,    RW, default = 1023
#define ISP_PAT0_BAR24_B2223                       ((0x024e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_22     // unsigned ,    RW, default = 0
#define ISP_PAT0_DFT_XIDX                          ((0x024f  << 2) + 0xff000000)
//Bit 31:16        reg_pat_dft_xidx          // unsigned ,    RW, default = 100  x index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_xwid          // unsigned ,    RW, default = 100  x window for defeat pixel on pattern
#define ISP_PAT0_DFT_YIDX                          ((0x0250  << 2) + 0xff000000)
//Bit 31:16        reg_pat_dft_yidx          // unsigned ,    RW, default = 200  y index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_ywid          // unsigned ,    RW, default = 1  y window for defeat pixel on pattern
#define ISP_PAT0_DFT_GAIN                          ((0x0251  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pat_dft_gaingrbg_3    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 23:22        reserved
//Bit 21:16        reg_pat_dft_gaingrbg_2    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 15:14        reserved
//Bit 13: 8        reg_pat_dft_gaingrbg_1    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit  7: 6        reserved
//Bit  5: 0        reg_pat_dft_gaingrbg_0    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC0_CNTL                              ((0x0260  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_dpc_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 11:10        reserved
//Bit  9: 8        reg_dpc_xphs_ofst         // unsigned ,    RW, default = 1
//Bit  7: 5        reserved
//Bit  4           reg_dpc_det_en            // unsigned ,    RW, default = 1  1 = enable defect pixel detection, 0 = diable
//Bit  3: 1        reserved
//Bit  0           reg_dpc_cor_en            // unsigned ,    RW, default = 1  1 = enable defect pixel correction, 0 = disable
#define ISP_DPC0_AVG_GAIN0                         ((0x0261  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h0       // unsigned ,    RW, default = 512  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l0       // unsigned ,    RW, default = 128  is used to set the gain of average
#define ISP_DPC0_AVG_GAIN1                         ((0x0262  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h1       // unsigned ,    RW, default = 435  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l1       // unsigned ,    RW, default = 150  is used to set the gain of average
#define ISP_DPC0_AVG_GAIN2                         ((0x0263  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h2       // unsigned ,    RW, default = 332  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l2       // unsigned ,    RW, default = 196  is used to set the gain of average
#define ISP_DPC0_VAR_THD                           ((0x0264  << 2) + 0xff000000)
//Bit 31:24        reg_dpc_cond_en           // unsigned ,    RW, default = 0  is used to enable some condition constraint.
//Bit 23:19        reserved
//Bit 18:16        reg_dpc_cnt_thd           // unsigned ,    RW, default = 3  it is used to set the judge threshold for variance of 8 pixels at same channel
//Bit 15:11        reserved
//Bit 10: 8        reg_dpc_var2_sft0         // unsigned ,    RW, default = 4  it is used to set the judge threshold for variance of 4 pixels at same channel
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_var2_sft1         // unsigned ,    RW, default = 6  it is used to set the judge threshold for variance of 4 pixels at same channel
#define ISP_DPC0_AVG_SFT_CTRL                      ((0x0265  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:16        reg_dpc_avg_diff_sft2     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit 15            reserved
//Bit 14:12        reg_dpc_avg_thd_sft1      // unsigned ,    RW, default = 3  it is used to select the shift1 in avg thd
//Bit 11            reserved
//Bit 10: 8        reg_dpc_avg_thd_sft0      // unsigned ,    RW, default = 3  it is used to select the shift0 in avg thd
//Bit  7            reserved
//Bit  6: 4        reg_dpc_avg_diff_sft1     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit  3            reserved
//Bit  2: 0        reg_dpc_avg_diff_sft0     // unsigned ,    RW, default = 3  it is used to select the shift0 in avg diff
#define ISP_DPC0_VAR_GAIN                          ((0x0266  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_bld_auto_dis      // unsigned ,    RW, default = 0  it is used to disable the auto blending alpha
//Bit 23:21        reserved
//Bit 20           reg_dpc_avg_thd2_en       // unsigned ,    RW, default = 1  it is used to enable the avg_thd2
//Bit 19            reserved
//Bit 18:16        reg_dpc_avg_sft           // unsigned ,    RW, default = 3  it is used to set the shift of avg in avg_thd2 calculation
//Bit 15            reserved
//Bit 14:12        reg_dpc_var_gain_00       // unsigned ,    RW, default = 2  it is used to set the gain for variance
//Bit 11            reserved
//Bit 10: 8        reg_dpc_var_gain_01       // unsigned ,    RW, default = 1  it is used to set the gain for variance
//Bit  7            reserved
//Bit  6: 4        reg_dpc_var_gain_10       // unsigned ,    RW, default = 4  it is used to set the gain for variance
//Bit  3            reserved
//Bit  2: 0        reg_dpc_var_gain_11       // unsigned ,    RW, default = 2  it is used to set the gain for variance
#define ISP_DPC0_STD_GAIN                          ((0x0267  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24:20        reg_dpc_std_gain          // unsigned ,    RW, default = 12  is used to set the gain of standard bias
//Bit 19:13        reserved
//Bit 12: 8        reg_dpc_std_diff_gain     // unsigned ,    RW, default = 16  is used to set the difference gain of standard bias
//Bit  7: 0        reg_dpc_max_min_bias_thd  // unsigned ,    RW, default = 20  is used to set the threshold between maximum standard bias and minimum one
#define ISP_DPC0_AVG_MOD                           ((0x0268  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:10        reg_dpc_low_thd           // unsigned ,    RW, default = 50  is used to set the low theshold for dp_x6
//Bit  9: 8        reg_dpc_avg_mode          // unsigned ,    RW, default = 3  0 = auto selection average value between avg6 and avg4,1 = avg6, 2 = avg4, 3 = avg8
//Bit  7: 0        reg_dpc_avg_bias_thd      // unsigned ,    RW, default = 40  it is used to set theshold for selecting the average value
#define ISP_DPC0_AVG_DEV                           ((0x0269  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_dpc_avg_dev_sft       // unsigned ,    RW, default = 3  it is used to set the avg_dev shift
//Bit 27:25        reserved
//Bit 24           reg_dpc_avg_dev_mode      // unsigned ,    RW, default = 0  it is used to set the mode for calculation of average bias. 0 = variance+offset, 1 = offset
//Bit 23:16        reg_dpc_avg_dev_offset    // unsigned ,    RW, default = 20  it is used to set the offset for average bias
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_blend_alpha   // unsigned ,    RW, default = 12'h800  it used to set the blending alpha for average deviation and standard deviation
#define ISP_DPC0_DEV_DP                            ((0x026a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_dpc_dev_dp_offset     // unsigned ,    RW, default = 30  it is used to set the threshold for deviation mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_dp_slope      // unsigned ,    RW, default = 82  it is used to set the slope for deviation mapping
#define ISP_DPC0_X1_2_CTRL                         ((0x026b  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21: 8        reg_dpc_low_thd_top       // unsigned ,    RW, default = 50  is used to set the low theshold for top
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_x2_rank_lim       // unsigned ,    RW, default = 2  it is used to set the rank limit.
#define ISP_DPC0_X6_CTRL                           ((0x026c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_high_gain         // unsigned ,    RW, default = 256  it is used to set the gain
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_diff_ratio        // unsigned ,    RW, default = 213  it is used to set the diff gain
#define ISP_DPC0_COR_CTRL                          ((0x026d  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_vote_en           // unsigned ,    RW, default = 0  it is used to enable the detection vote. 1= enable, 0=disable
//Bit 23            reserved
//Bit 22:16        reg_dpc_flag_en           // unsigned ,    RW, default = 1  it is used to enbale the detection flag.
//Bit 15            reserved
//Bit 14:12        reg_dpc_vote_thd          // unsigned ,    RW, default = 3  it is used to set the vote threshold.
//Bit 11            reserved
//Bit 10: 8        reg_dpc_ud_mode           // unsigned ,    RW, default = 4  it is used to set the mode for un-diretioanal estimation.0= auto,1=median,2= avg6, 3=avg4,4=avg8,
//Bit  7: 5        reserved
//Bit  4           reg_dpc_highlight_en      // unsigned ,    RW, default = 0  it is used to enable highlighting the defect pixels. 1= enbale, 0=disable
//Bit  3: 2        reserved
//Bit  1: 0        reg_dpc_correct_mode      // unsigned ,    RW, default = 2  it is used to set the correction mode.0= disable, 1= static, 2= dynamic, 3=static or dynamic
#define ISP_DPC0_BLEND                             ((0x026e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_dpc_cor_blend_alpha   // unsigned ,    RW, default = 12'h800  it is used to set the blending alpha for directional estimation and un-directional estimation
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_org_blend_alpha   // unsigned ,    RW, default = 12'hfff  it is used to set the blending alpha for estimation and original value.
#define ISP_DPC0_LUT_CTRL                          ((0x026f  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:20        reg_dpc_lut_start         // unsigned ,    RW, default = 0  it is used to set the start position of table
//Bit 19:17        reserved
//Bit 16           reg_dpc_write_to_lut      // unsigned ,    RW, default = 0  it is used to write the defect pixel position into memory
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_writeto_lut_stline // unsigned ,    RW, default = 0  it is used to set the start line to write to memory
#define ISP_DPC0_SDP_NUM                           ((0x0270  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 0        ro_dpc_sdp_num            // unsigned ,    RO, default = 0  it is used to report the number of the static defect pixel
#define ISP_DPC0_DDP_NUM                           ((0x0271  << 2) + 0xff000000)
//Bit 31:16        ro_dpc_ddp_num            // unsigned ,    RO, default = 0  it is used to report the number of the dynamic defect pixel
//Bit 15: 0        ro_dpc_defect_num         // unsigned ,    RO, default = 0  it is used to report the number of the defect pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC0_LUT1024_ADDR                      ((0x0280  << 2) + 0xff000000)
//Bit 31:0      isp_dpc_lut1024_addr              // unsigned , RW, default=0
#define ISP_DPC0_LUT1024_DATA                      ((0x0281  << 2) + 0xff000000)
//Bit 31:0      isp_dpc_lut1024_data              // unsigned , RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB1_APB_BASE = 0x03
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GE1_CTRL                               ((0x0300  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_ge_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for ge
//Bit 15:14        reserved
//Bit 13:12        reg_ge_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for ge
//Bit 11: 9        reserved
//Bit  8           reg_ge_rpt_mode           // unsigned ,    RW, default = 1  0: repeat, 1: mirror, repeat mode for green equalization
//Bit  7: 0        reg_ge_edge_rs            // unsigned ,    RW, default = 128  for edge shift
#define ISP_GE1_STAT                               ((0x0301  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ge_stat_edge_thd      // unsigned ,    RW, default = 16  edge threshold for ge statistic
#define ISP_GE1_COMM                               ((0x0302  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17: 8        reg_ge_hv_thrd            // unsigned ,    RW, default = 34  ge, if absdiff > reg_ge_hv_thrd, weight, 0, if absidff < reg_ge_hv_thrd, do filter
//Bit  7: 0        reg_ge_final_bld          // unsigned ,    RW, default = 0  heavy ge and ge blend ratio, 0 use ge_lpf, 255 use ge_dlt
#define ISP_GE1_HV_RATIO                           ((0x0303  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ge_hv_ratio_0         // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_hv_ratio_1         // unsigned ,    RW, default = 12
//Bit  7: 0        reg_ge_hv_ratio_2         // unsigned ,    RW, default = 28
#define ISP_GE1_HV_WT2                             ((0x0304  << 2) + 0xff000000)
//Bit 31:24        reg_ge_hv_wtlut_0         // unsigned ,    RW, default = 64  when making the weighted average, the weights need to be looked up according to the diff
//Bit 23:16        reg_ge_hv_wtlut_1         // unsigned ,    RW, default = 84  when making the weighted average, the weights need to be looked up according to the diff
//Bit 15: 8        reg_ge_hv_wtlut_2         // unsigned ,    RW, default = 96  when making the weighted average, the weights need to be looked up according to the diff
//Bit  7: 0        reg_ge_hv_wtlut_3         // unsigned ,    RW, default = 128  when making the weighted average, the weights need to be looked up according to the diff
#define ISP_GE1_GI_LUT0                            ((0x0305  << 2) + 0xff000000)
//Bit 31:24        reg_ge_gi_lut_0           // unsigned ,    RW, default = 24  GI_LUT
//Bit 23:16        reg_ge_gi_lut_1           // unsigned ,    RW, default = 24  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_2           // unsigned ,    RW, default = 12  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_3           // unsigned ,    RW, default = 12  GI_LUT
#define ISP_GE1_GI_LUT1                            ((0x0306  << 2) + 0xff000000)
//Bit 31:24        reg_ge_gi_lut_4           // unsigned ,    RW, default = 10  GI_LUT
//Bit 23:16        reg_ge_gi_lut_5           // unsigned ,    RW, default = 10  GI_LUT
//Bit 15: 8        reg_ge_gi_lut_6           // unsigned ,    RW, default = 5  GI_LUT
//Bit  7: 0        reg_ge_gi_lut_7           // unsigned ,    RW, default = 5  GI_LUT
#define ISP_GE1_DLT_CTRL1                          ((0x0307  << 2) + 0xff000000)
//Bit 31:30        reg_ge_gi_lut_sft         // signed ,    RW, default = 0  ge_gi_lut_shift
//Bit 29:25        reg_max_ge_dlt_ratio      // unsigned ,    RW, default = 31  ge_max_delta_ratio
//Bit 24           reg_ge_dlt_real_max_en    // unsigned ,    RW, default = 1  ge_delta_real_max enable
//Bit 23:16        reg_ge_dlt_bld_th0        // unsigned ,    RW, default = 10  ge_delta_blend_th0
//Bit 15:12        reg_ge_dlt_bld_thn        // unsigned ,    RW, default = 5  ge_delta_blend_thn
//Bit 11: 6        reg_ge_dlt_bld_alph0      // unsigned ,    RW, default = 48  ge_delta_blend_alpha0
//Bit  5: 0        reg_ge_dlt_bld_alph1      // unsigned ,    RW, default = 48  ge_delta_blend_alpha1
#define ISP_GE1_DLT_CTRL2                          ((0x0308  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:17        reg_ge_lpf_blend_alp      // unsigned ,    RW, default = 0  ge_out_dlt use lpf data centered gr/gb and neighbor gbs/grs
//Bit 16           reg_ge_dlt_edge_en        // unsigned ,    RW, default = 0
//Bit 15: 8        reg_ge_dlt_edge_ratio_0   // unsigned ,    RW, default = 8
//Bit  7: 0        reg_ge_dlt_edge_ratio_1   // unsigned ,    RW, default = 8
#define ISP_GE1_CORE                               ((0x0309  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ge_coring             // unsigned ,    RW, default = 0  coring for ge difference and edge calc
#define ISP_OG1_OFST0                              ((0x030a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_0         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gr for wdr previous offset each color each channels
//Bit 15: 6        reserved
//Bit  5: 4        reg_og_xphs_ofst          // unsigned ,    RW, default = 1  x phase ofst for offset/gain
//Bit  3: 2        reserved
//Bit  1: 0        reg_og_yphs_ofst          // unsigned ,    RW, default = 0  y phase ofst for offset/gain
#define ISP_OG1_OFST12                             ((0x030b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_2         // unsigned ,    RW, default = 0  (BIT_DEPTH01), B  for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_1         // unsigned ,    RW, default = 0  (BIT_DEPTH01), R  for wdr previous offset each color each channels
#define ISP_OG1_OFST34                             ((0x030c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_og_pre_ofst_4         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pre_ofst_3         // unsigned ,    RW, default = 0  (BIT_DEPTH01), Gb for wdr previous offset each color each channels
#define ISP_OG1_GAIN_PST                           ((0x030d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_0             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15:14        reserved
//Bit 13: 0        reg_og_pst_ofst           // unsigned ,    RW, default = 0  (BIT_DEPTH01), for wdr post offset each channels
#define ISP_OG1_GAIN1                              ((0x030e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_1             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_2             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_OG1_GAIN2                              ((0x030f  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_og_gain_3             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit 15: 3        reg_og_gain_4             // unsigned ,    RW, default = 256  u5.8 format for wdr gain adjustment each channels
//Bit  2: 0        reserved
#define ISP_FPNR1_CTRL_CORR                        ((0x0310  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_fpnr_corr_en          // unsigned ,    RW, default = 1  fpnr correction enable for each channel
#define ISP_FPNR1_CORR_GAIN_0                      ((0x0311  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_0     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_0     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_1                      ((0x0312  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_1     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_1     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_2                      ((0x0313  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_2     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_2     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_3                      ((0x0314  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_3     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_3     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_GAIN_4                      ((0x0315  << 2) + 0xff000000)
//Bit 31:16        reg_fpnr_corr_gain0_4     // unsigned ,    RW, default = 256  fpnr correction gain0 (u8.8) updated by firmware related to ISO
//Bit 15: 0        reg_fpnr_corr_gain1_4     // unsigned ,    RW, default = 256  fpnr correction gain1 (u8.8) updated by firmware related to ISO
#define ISP_FPNR1_CORR_OFST_0                      ((0x0316  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_0      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_1                      ((0x0317  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_1      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_2                      ((0x0318  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_2      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_3                      ((0x0319  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_3      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_CORR_OFST_4                      ((0x031a  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_fpnr_corr_ofst_4      // unsigned ,    RW, default = 0  fpnr correction offset by average value of all pixels of all frames
#define ISP_FPNR1_LUT_ADDR                         ((0x031e  << 2) + 0xff000000)
//Bit 31:0        reg_fpnr_lut_addr         // unsigned, RW, default=0, fpnr lut addr
#define ISP_FPNR1_LUT_DATA                         ((0x031f  << 2) + 0xff000000)
//Bit 31:0        reg_fpnr_lut_data         // unsigned, RW, default=0, fpnr lut data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_chn_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_PAT1_CTRL                              ((0x0320  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_pat_xphs_ofst         // unsigned ,    RW, default = 1  x phase offset for pattern generation
//Bit 11:10        reg_pat_yphs_ofst         // unsigned ,    RW, default = 0  y phase offset for pattern generation
//Bit  9: 8        reg_pat_dft_mode          // unsigned ,    RW, default = 0  0 no dft; 1 dead pixel 2: hot pixel; 3: not dft
//Bit  7: 5        reg_pat_xmode             // unsigned ,    RW, default = 0  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along x-direction
//Bit  4: 2        reg_pat_ymode             // unsigned ,    RW, default = 3  0: raster/bar16/burst; 1; ramp-up; 2/3: 256 gain for this direction, pattern mode along y-direction
//Bit  1           reg_pat_xinvt             // unsigned ,    RW, default = 0  invert along x-direction
//Bit  0           reg_pat_yinvt             // unsigned ,    RW, default = 0  invert along y-direction
#define ISP_PAT1_IDX_SCL                           ((0x0321  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_scale        // unsigned ,    RW, default = 32  index scale, 1<<(15-reg_pat_xidx_rshft) / HSIZE
//Bit 15: 4        reg_pat_yidx_scale        // unsigned ,    RW, default = 46  index scale, 1<<(15-reg_pat_yidx_rshft) / VSIZE
//Bit  3: 2        reg_pat_xidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for x index
//Bit  1: 0        reg_pat_yidx_rshft        // unsigned ,    RW, default = 0  0~3, right shift for y index
#define ISP_PAT1_IDX_OFST                          ((0x0322  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_pat_xidx_ofset        // unsigned ,    RW, default = 0  x index offset for pattern generation
//Bit 15:12        reserved
//Bit 11: 0        reg_pat_yidx_ofset        // unsigned ,    RW, default = 0  y index offset for pattern generation
#define ISP_PAT1_FWIN_R                            ((0x0323  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_0        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15: 2        reserved
//Bit  1           reg_pat_fwin_clr_chk      // unsigned ,    RW, default = 1  color checker for foreground window
//Bit  0           reg_pat_fwin_en           // unsigned ,    RW, default = 1  enable foreground window
#define ISP_PAT1_FWIN_GB                           ((0x0324  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_fwin_rgb_2        // unsigned ,    RW, default = 1023  rgb of foreground window
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_fwin_rgb_1        // unsigned ,    RW, default = 1023  rgb of foreground window
#define ISP_PAT1_FWIN_START                        ((0x0325  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hstart       // unsigned ,    RW, default = 480  horizontal start of foreground window
//Bit 15: 0        reg_pat_fwin_vstart       // unsigned ,    RW, default = 270  vertical start of foreground window
#define ISP_PAT1_FWIN_SIZE                         ((0x0326  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hsize        // unsigned ,    RW, default = 960  horizontal size of foreground window
//Bit 15: 0        reg_pat_fwin_vsize        // unsigned ,    RW, default = 540  vertical size of foreground window
#define ISP_PAT1_FWIN_BLK_SIZE                     ((0x0327  << 2) + 0xff000000)
//Bit 31:16        reg_pat_fwin_hblk_size    // unsigned ,    RW, default = 160  horizontal block size of foreground window
//Bit 15: 0        reg_pat_fwin_vblk_size    // unsigned ,    RW, default = 135  vertical block size of foreground window
#define ISP_PAT1_IR_MODE                           ((0x0328  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 27:26        reserved
//Bit 15:10        reserved
#define ISP_PAT1_XRMP_SRGB                         ((0x0329  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_xrmp_scalergb_2   // unsigned ,    RW, default = 255  B x ramp scale for pattern generation
//Bit 15: 8        reg_pat_xrmp_scalergb_1   // unsigned ,    RW, default = 255  G x ramp scale for pattern generation
//Bit  7: 0        reg_pat_xrmp_scalergb_0   // unsigned ,    RW, default = 255  R x ramp scale for pattern generation
#define ISP_PAT1_YRMP_SRGB                         ((0x032a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pat_yrmp_scalergb_2   // unsigned ,    RW, default = 0  B y ramp scale for pattern generation
//Bit 15: 8        reg_pat_yrmp_scalergb_1   // unsigned ,    RW, default = 0  G y ramp scale for pattern generation
//Bit  7: 0        reg_pat_yrmp_scalergb_0   // unsigned ,    RW, default = 0  R y ramp scale for pattern generation
#define ISP_PAT1_BAR24_R01                         ((0x032b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R23                         ((0x032c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_2      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R45                         ((0x032d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_5      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_4      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R67                         ((0x032e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_6      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R89                         ((0x032f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_R1011                       ((0x0330  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_R1213                       ((0x0331  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_R1415                       ((0x0332  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_R1617                       ((0x0333  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R1819                       ((0x0334  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_R2021                       ((0x0335  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_R2223                       ((0x0336  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_0_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_0_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G01                         ((0x0337  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_1      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G23                         ((0x0338  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_3      // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_2      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G45                         ((0x0339  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_4      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G67                         ((0x033a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_6      // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G89                         ((0x033b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_G1011                       ((0x033c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_G1213                       ((0x033d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_G1415                       ((0x033e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_G1617                       ((0x033f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G1819                       ((0x0340  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_G2021                       ((0x0341  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_G2223                       ((0x0342  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_1_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_1_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_B01                         ((0x0343  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_1      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_0      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B23                         ((0x0344  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_3      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_2      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B45                         ((0x0345  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_5      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_4      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B67                         ((0x0346  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_7      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_6      // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B89                         ((0x0347  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_9      // unsigned ,    RW, default = 256
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_8      // unsigned ,    RW, default = 128
#define ISP_PAT1_BAR24_B1011                       ((0x0348  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_11     // unsigned ,    RW, default = 512
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_10     // unsigned ,    RW, default = 384
#define ISP_PAT1_BAR24_B1213                       ((0x0349  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_13     // unsigned ,    RW, default = 768
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_12     // unsigned ,    RW, default = 640
#define ISP_PAT1_BAR24_B1415                       ((0x034a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_15     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_14     // unsigned ,    RW, default = 896
#define ISP_PAT1_BAR24_B1617                       ((0x034b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_17     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_16     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B1819                       ((0x034c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_19     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_18     // unsigned ,    RW, default = 0
#define ISP_PAT1_BAR24_B2021                       ((0x034d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_21     // unsigned ,    RW, default = 1023
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_20     // unsigned ,    RW, default = 1023
#define ISP_PAT1_BAR24_B2223                       ((0x034e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pat_bar24rgb_2_23     // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9: 0        reg_pat_bar24rgb_2_22     // unsigned ,    RW, default = 0
#define ISP_PAT1_DFT_XIDX                          ((0x034f  << 2) + 0xff000000)
//Bit 31:16        reg_pat_dft_xidx          // unsigned ,    RW, default = 100  x index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_xwid          // unsigned ,    RW, default = 100  x window for defeat pixel on pattern
#define ISP_PAT1_DFT_YIDX                          ((0x0350  << 2) + 0xff000000)
//Bit 31:16        reg_pat_dft_yidx          // unsigned ,    RW, default = 200  y index for defeat pixel on pattern
//Bit 15            reserved
//Bit 14: 0        reg_pat_dft_ywid          // unsigned ,    RW, default = 1  y window for defeat pixel on pattern
#define ISP_PAT1_DFT_GAIN                          ((0x0351  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pat_dft_gaingrbg_3    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 23:22        reserved
//Bit 21:16        reg_pat_dft_gaingrbg_2    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit 15:14        reserved
//Bit 13: 8        reg_pat_dft_gaingrbg_1    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
//Bit  7: 6        reserved
//Bit  5: 0        reg_pat_dft_gaingrbg_0    // unsigned ,    RW, default = 0  dft gain for each channel, <32 means lazy pixel; >32 means active pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_patgen_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC1_CNTL                              ((0x0360  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:12        reg_dpc_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 11:10        reserved
//Bit  9: 8        reg_dpc_xphs_ofst         // unsigned ,    RW, default = 1
//Bit  7: 5        reserved
//Bit  4           reg_dpc_det_en            // unsigned ,    RW, default = 1  1 = enable defect pixeldetection, 0 = diable
//Bit  3: 1        reserved
//Bit  0           reg_dpc_cor_en            // unsigned ,    RW, default = 1  1 = enable defect pixel correction, 0 = disable
#define ISP_DPC1_AVG_GAIN0                         ((0x0361  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h0       // unsigned ,    RW, default = 512  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l0       // unsigned ,    RW, default = 128  is used to set the gain of average
#define ISP_DPC1_AVG_GAIN1                         ((0x0362  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h1       // unsigned ,    RW, default = 435  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l1       // unsigned ,    RW, default = 150  is used to set the gain of average
#define ISP_DPC1_AVG_GAIN2                         ((0x0363  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_avg_gain_h2       // unsigned ,    RW, default = 332  is used to set the gain of average
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_avg_gain_l2       // unsigned ,    RW, default = 196  is used to set the gain of average
#define ISP_DPC1_VAR_THD                           ((0x0364  << 2) + 0xff000000)
//Bit 31:24        reg_dpc_cond_en           // unsigned ,    RW, default = 0  is used to enable some condition constraint.
//Bit 23:19        reserved
//Bit 18:16        reg_dpc_cnt_thd           // unsigned ,    RW, default = 3  it is used to set the judge threshold for variance of 8 pixels at same channel
//Bit 15:11        reserved
//Bit 10: 8        reg_dpc_var2_sft0         // unsigned ,    RW, default = 4  it is used to set the judge threshold for variance of 4 pixels at same channel
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_var2_sft1         // unsigned ,    RW, default = 6  it is used to set the judge threshold for variance of 4 pixels at same channel
#define ISP_DPC1_AVG_SFT_CTRL                      ((0x0365  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:16        reg_dpc_avg_diff_sft2     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit 15            reserved
//Bit 14:12        reg_dpc_avg_thd_sft1      // unsigned ,    RW, default = 3  it is used to select the shift1 in avg thd
//Bit 11            reserved
//Bit 10: 8        reg_dpc_avg_thd_sft0      // unsigned ,    RW, default = 3  it is used to select the shift0 in avg thd
//Bit  7            reserved
//Bit  6: 4        reg_dpc_avg_diff_sft1     // unsigned ,    RW, default = 3  it is used to select the shift1 in avg diff
//Bit  3            reserved
//Bit  2: 0        reg_dpc_avg_diff_sft0     // unsigned ,    RW, default = 3  it is used to select the shift0 in avg diff
#define ISP_DPC1_VAR_GAIN                          ((0x0366  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_bld_auto_dis      // unsigned ,    RW, default = 0  it is used to disable the auto blending alpha
//Bit 23:21        reserved
//Bit 20           reg_dpc_avg_thd2_en       // unsigned ,    RW, default = 1  it is used to enable the avg_thd2
//Bit 19            reserved
//Bit 18:16        reg_dpc_avg_sft           // unsigned ,    RW, default = 3  it is used to set the shift of avg in avg_thd2 calculation
//Bit 15            reserved
//Bit 14:12        reg_dpc_var_gain_00       // unsigned ,    RW, default = 2  it is used to set the gain for variance
//Bit 11            reserved
//Bit 10: 8        reg_dpc_var_gain_01       // unsigned ,    RW, default = 1  it is used to set the gain for variance
//Bit  7            reserved
//Bit  6: 4        reg_dpc_var_gain_10       // unsigned ,    RW, default = 4  it is used to set the gain for variance
//Bit  3            reserved
//Bit  2: 0        reg_dpc_var_gain_11       // unsigned ,    RW, default = 2  it is used to set the gain for variance
#define ISP_DPC1_STD_GAIN                          ((0x0367  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24:20        reg_dpc_std_gain          // unsigned ,    RW, default = 12  is used to set the gain of standard bias
//Bit 19:13        reserved
//Bit 12: 8        reg_dpc_std_diff_gain     // unsigned ,    RW, default = 16  is used to set the difference gain of standard bias
//Bit  7: 0        reg_dpc_max_min_bias_thd  // unsigned ,    RW, default = 20  is used to set the threshold between maximum standard bias and minimum one
#define ISP_DPC1_AVG_MOD                           ((0x0368  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:10        reg_dpc_low_thd           // unsigned ,    RW, default = 50  is used to set the low theshold for dp_x6
//Bit  9: 8        reg_dpc_avg_mode          // unsigned ,    RW, default = 3  0 = auto selection average value between avg6 and avg4,1 = avg6, 2 = avg4, 3 = avg8
//Bit  7: 0        reg_dpc_avg_bias_thd      // unsigned ,    RW, default = 40  it is used to set theshold for selecting the average value
#define ISP_DPC1_AVG_DEV                           ((0x0369  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_dpc_avg_dev_sft       // unsigned ,    RW, default = 3  it is used to set the avg_dev shift
//Bit 27:25        reserved
//Bit 24           reg_dpc_avg_dev_mode      // unsigned ,    RW, default = 0  it is used to set the mode for calculation of average bias. 0 = variance+offset, 1 = offset
//Bit 23:16        reg_dpc_avg_dev_offset    // unsigned ,    RW, default = 20  it is used to set the offset for average bias
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_blend_alpha   // unsigned ,    RW, default = 12'h800  it used to set the blending alpha for average deviation and standard deviation
#define ISP_DPC1_DEV_DP                            ((0x036a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_dpc_dev_dp_offset     // unsigned ,    RW, default = 30  it is used to set the threshold for deviation mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_dev_dp_slope      // unsigned ,    RW, default = 82  it is used to set the slope for deviation mapping
#define ISP_DPC1_X1_2_CTRL                         ((0x036b  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21: 8        reg_dpc_low_thd_top       // unsigned ,    RW, default = 50  is used to set the low theshold for top
//Bit  7: 3        reserved
//Bit  2: 0        reg_dpc_x2_rank_lim       // unsigned ,    RW, default = 2  it is used to set the rank limit.
#define ISP_DPC1_X6_CTRL                           ((0x036c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dpc_high_gain         // unsigned ,    RW, default = 256  it is used to set the gain
//Bit 15:10        reserved
//Bit  9: 0        reg_dpc_diff_ratio        // unsigned ,    RW, default = 213  it is used to set the diff gain
#define ISP_DPC1_COR_CTRL                          ((0x036d  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_dpc_vote_en           // unsigned ,    RW, default = 0  it is used to enable the detection vote. 1= enable, 0=disable
//Bit 23            reserved
//Bit 22:16        reg_dpc_flag_en           // unsigned ,    RW, default = 1  it is used to enbale the detection flag.
//Bit 15            reserved
//Bit 14:12        reg_dpc_vote_thd          // unsigned ,    RW, default = 3  it is used to set the vote threshold.
//Bit 11            reserved
//Bit 10: 8        reg_dpc_ud_mode           // unsigned ,    RW, default = 4  it is used to set the mode for un-diretioanal estimation.0= auto,1=median,2= avg6, 3=avg4,4=avg8,
//Bit  7: 5        reserved
//Bit  4           reg_dpc_highlight_en      // unsigned ,    RW, default = 0  it is used to enable highlighting the defect pixels. 1= enbale, 0=disable
//Bit  3: 2        reserved
//Bit  1: 0        reg_dpc_correct_mode      // unsigned ,    RW, default = 2  it is used to set the correction mode.0= disable, 1= static, 2= dynamic, 3=static or dynamic
#define ISP_DPC1_BLEND                             ((0x036e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_dpc_cor_blend_alpha   // unsigned ,    RW, default = 12'h800  it is used to set the blending alpha for directional estimation and un-directional estimation
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_org_blend_alpha   // unsigned ,    RW, default = 12'hfff  it is used to set the blending alpha for estimation and original value.
#define ISP_DPC1_LUT_CTRL                          ((0x036f  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:20        reg_dpc_lut_start         // unsigned ,    RW, default = 0  it is used to set the start position of table
//Bit 19:17        reserved
//Bit 16           reg_dpc_write_to_lut      // unsigned ,    RW, default = 0  it is used to write the defect pixel position into memory
//Bit 15:12        reserved
//Bit 11: 0        reg_dpc_writeto_lut_stline // unsigned ,    RW, default = 0  it is used to set the start line to write to memory
#define ISP_DPC1_SDP_NUM                           ((0x0370  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 0        ro_dpc_sdp_num            // unsigned ,    RO, default = 0  it is used to report the number of the static defect pixel
#define ISP_DPC1_DDP_NUM                           ((0x0371  << 2) + 0xff000000)
//Bit 31:16        ro_dpc_ddp_num            // unsigned ,    RO, default = 0  it is used to report the number of the dynamic defect pixel
//Bit 15: 0        ro_dpc_defect_num         // unsigned ,    RO, default = 0  it is used to report the number of the defect pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DPC1_LUT1024_ADDR                      ((0x0380  << 2) + 0xff000000)
//Bit 31:0      isp_dpc_lut1024_addr              // unsigned , RW, default=0
#define ISP_DPC1_LUT1024_DATA                      ((0x0381  << 2) + 0xff000000)
//Bit 31:0      isp_dpc_lut1024_data              // unsigned , RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dpc_reg_hw_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB2_APB_BASE = 0x04
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CROP_START                             ((0x0400  << 2) + 0xff000000)
//Bit 31:16        reg_crop_hstart           // unsigned ,    RW, default = 0  horizontal start for crop
//Bit 15: 0        reg_crop_vstart           // unsigned ,    RW, default = 0  vertical start for crop
#define ISP_CROP_SIZE                              ((0x0401  << 2) + 0xff000000)
//Bit 31:16        reg_crop_hsize            // unsigned ,    RW, default = 1920  horizontal size for crop
//Bit 15: 0        reg_crop_vsize            // unsigned ,    RW, default = 1080  vertical size for crop
#define ISP_DECOMP_CTRL                            ((0x0402  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2           reg_decmp0_en             // unsigned ,    RW, default = 0  enable decompander0
//Bit  1           reg_decmp1_en             // unsigned ,    RW, default = 0  enable decompander1
//Bit  0           reg_decmp1_mode           // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for decompander1 lut
#define ISP_DECOMP1_STP                            ((0x0403  << 2) + 0xff000000)
//Bit 31:28        reg_decmp1_stp_7          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 27:24        reg_decmp1_stp_6          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 23:20        reg_decmp1_stp_5          // unsigned ,    RW, default = 14  step for each segment of decompander1 lut
//Bit 19:16        reg_decmp1_stp_4          // unsigned ,    RW, default = 13  step for each segment of decompander1 lut
//Bit 15:12        reg_decmp1_stp_3          // unsigned ,    RW, default = 12  step for each segment of decompander1 lut
//Bit 11: 8        reg_decmp1_stp_2          // unsigned ,    RW, default = 11  step for each segment of decompander1 lut
//Bit  7: 4        reg_decmp1_stp_1          // unsigned ,    RW, default = 9  step for each segment of decompander1 lut
//Bit  3: 0        reg_decmp1_stp_0          // unsigned ,    RW, default = 8  step for each segment of decompander1 lut
#define ISP_DECOMP1_NUM                            ((0x0404  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_decmp1_num_7          // unsigned ,    RW, default = 5  numbers for each segment of decompander1 lut
//Bit 27            reserved
//Bit 26:24        reg_decmp1_num_6          // unsigned ,    RW, default = 4  numbers for each segment of decompander1 lut
//Bit 23            reserved
//Bit 22:20        reg_decmp1_num_5          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 19            reserved
//Bit 18:16        reg_decmp1_num_4          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 15            reserved
//Bit 14:12        reg_decmp1_num_3          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit 11            reserved
//Bit 10: 8        reg_decmp1_num_2          // unsigned ,    RW, default = 3  numbers for each segment of decompander1 lut
//Bit  7            reserved
//Bit  6: 4        reg_decmp1_num_1          // unsigned ,    RW, default = 4  numbers for each segment of decompander1 lut
//Bit  3            reserved
//Bit  2: 0        reg_decmp1_num_0          // unsigned ,    RW, default = 5  numbers for each segment of decompander1 lut
#define ISP_INPFMT_KPTS_01                         ((0x0405  << 2) + 0xff000000)
//Bit 31:16        reg_inp_fmt_kneepts_1     // unsigned ,    RW, default = 1408  (BIT_DEPTH00), default for u12 to u20, knee point1 for decompanding
//Bit 15: 0        reg_inp_fmt_kneepts_0     // unsigned ,    RW, default = 512  (BIT_DEPTH00), default for u12 to u20, knee point0 for decompanding
#define ISP_INPFMT_KPTS2_SLP                       ((0x0406  << 2) + 0xff000000)
//Bit 31:16        reg_inp_fmt_kneepts_2     // unsigned ,    RW, default = 2176  (BIT_DEPTH00), default for u12 to u20, knee point2 for decompanding
//Bit 15:12        reg_inp_fmt_slope_3       // unsigned ,    RW, default = 9  slope of knee points for decompanding, equal to 2^n
//Bit 11: 8        reg_inp_fmt_slope_2       // unsigned ,    RW, default = 6  slope of knee points for decompanding, equal to 2^n
//Bit  7: 4        reg_inp_fmt_slope_1       // unsigned ,    RW, default = 4  slope of knee points for decompanding, equal to 2^n
//Bit  3: 0        reg_inp_fmt_slope_0       // unsigned ,    RW, default = 2  slope of knee points for decompanding, equal to 2^n
#define ISP_INPFMT_SPLT                            ((0x0407  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_inp_fmt_chn           // unsigned ,    RW, default = 1  the data channels after input formatter, support (1+inp_fmt_chn) as 1/2/3/4
//Bit 15:13        reserved
//Bit 12           reg_inp_fmt_diag_mux      // unsigned ,    RW, default = 0  0: select 0 or (0,1), 1: select 1 or (1,0), ouput mux for diagonal split
//Bit 11: 8        reg_inp_fmt_split_sbit    // unsigned ,    RW, default = 4  short exp bits split for combined split
//Bit  7: 6        reserved
//Bit  5: 4        reg_inp_fmt_split_mode    // unsigned ,    RW, default = 0  0: bypass, 1: long/short split, 2or3: diag sum split for quadra, channel0 split mode for input formatter
//Bit  3: 2        reserved
//Bit  1: 0        reg_inp_fmt_32mux         // unsigned ,    RW, default = 0  0: select 0,1, 1: select 0,2, 2or3: select 1,2
#define ISP_INPFMT_MOD_BD_0                        ((0x0408  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 8        reg_inp_fmt_mod_0         // unsigned ,    RW, default = 0  input formatter mode, 0: linear data, 1: companding data with knee points, 2or3: log data
//Bit  7            reserved
//Bit  6: 4        reg_inp_fmt_ibit_depth_0  // unsigned ,    RW, default = 2  sensor data inp (compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
//Bit  3            reserved
//Bit  2: 0        reg_inp_fmt_obit_depth_0  // unsigned ,    RW, default = 2  sensor data out (de-compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
#define ISP_INPFMT_MOD_BD_1                        ((0x0409  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 8        reg_inp_fmt_mod_1         // unsigned ,    RW, default = 0  input formatter mode, 0: linear data, 1: companding data with knee points, 2or3: log data
//Bit  7            reserved
//Bit  6: 4        reg_inp_fmt_ibit_depth_1  // unsigned ,    RW, default = 2  sensor data inp (compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
//Bit  3            reserved
//Bit  2: 0        reg_inp_fmt_obit_depth_1  // unsigned ,    RW, default = 2  sensor data out (de-compression or linear) bit depth, 0: 8bit, 1: 10bit, 2: 12bit, 3: 14bit, 4: 16bit, 5 or else: 20bit
#define ISP_BIN_BAC_CTRL                           ((0x040a  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_bin_mode              // unsigned ,    RW, default = 0  0: 2x2 binning, 1: 4x4 binning, 2: 2x2 skip, 3: 4x4 skip, binning mode
//Bit 15:14        reserved
//Bit 13:12        reg_bac_xphs_ofst         // unsigned ,    RW, default = 0  x phase ofst for bac
//Bit 11:10        reserved
//Bit  9: 8        reg_bac_yphs_ofst         // unsigned ,    RW, default = 0  y phase ofst for bac
//Bit  7: 5        reserved
//Bit  4           reg_bac_mode              // unsigned ,    RW, default = 0  0: 2x2 bac, 1: 4x4 bac, bac mode
//Bit  3: 1        reserved
//Bit  0           reg_bac_norm              // unsigned ,    RW, default = 0  0: 64, 1: 128, normalization for bac filter
#define ISP_BAC_HCOEF                              ((0x040b  << 2) + 0xff000000)
//Bit 31:24        reg_bac_hcoef_3           // signed ,    RW, default = 16  phase 1 horizontal coef1. for bac filter
//Bit 23:16        reg_bac_hcoef_2           // signed ,    RW, default = 48  phase 1 horizontal coef0. for bac filter
//Bit 15: 8        reg_bac_hcoef_1           // signed ,    RW, default = 0  phase 0 horizontal coef1. for bac filter
//Bit  7: 0        reg_bac_hcoef_0           // signed ,    RW, default = 64  phase 0 horizontal coef0. for bac filter
#define ISP_BAC_VCOEF                              ((0x040c  << 2) + 0xff000000)
//Bit 31:24        reg_bac_vcoef_3           // signed ,    RW, default = 16  phase 1 vertical coef1. for bac filter
//Bit 23:16        reg_bac_vcoef_2           // signed ,    RW, default = 48  phase 1 vertical coef0. for bac filter
//Bit 15: 8        reg_bac_vcoef_1           // signed ,    RW, default = 0  phase 0 vertical coef1. for bac filter
//Bit  7: 0        reg_bac_vcoef_0           // signed ,    RW, default = 64  phase 0 vertical coef0. for bac filter
#define ISP_FPNR_CTRL                              ((0x040d  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30           reg_fpnr_cali_flag        // unsigned ,    RW, default = 1  0: no fpnr cali operation; 1: more than 0 time fpnr cali operation
//Bit 29            reserved
//Bit 28           reg_fpnr_cali_corr_sel    // unsigned ,    RW, default = 1  0: calibration mode 1:correction mode, fpnr mode selection
//Bit 27:26        reserved
//Bit 25:24        reg_fpnr_xphs_ofst        // unsigned ,    RW, default = 1  xphase ofset
//Bit 23:22        reserved
//Bit 21:20        reg_fpnr_yphs_ofst        // unsigned ,    RW, default = 0  yphase ofset
//Bit 19            reserved
//Bit 18           reg_fpnr_cali_trigger     // unsigned ,    RW, default = 0  1: calibration trigger signal for fpnr, auto. reset to zero
//Bit 17:16        reserved
//Bit 15:14        reg_fpnr_corr_mode        // unsigned ,    RW, default = 0  0: correction mode 1; 1: correction mode 1; else: correction mode 2
//Bit 13: 0        reg_fpnr_ofst             // unsigned ,    RW, default = 0  fpnr ofst
#define ISP_BAC_PRCT                               ((0x040e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_bac_prct_vrat         // unsigned ,    RW, default = 16  vdifs v.s. hdifs ratio (4.2) for bac protection
//Bit 23:22        reserved
//Bit 21:16        reg_bac_prct_hrat         // unsigned ,    RW, default = 16  hdifs v.s. vdifs ratio (4.2) for bac protection
//Bit 15:14        reserved
//Bit 13: 8        reg_bac_prct_coring       // unsigned ,    RW, default = 0  coring for difs in bac protection
//Bit  7: 1        reserved
//Bit  0           reg_bac_prct_en           // unsigned ,    RW, default = 1  enable bac protection
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_top_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_OFE_DECMP0_LUT_ADDR                    ((0x04f0  << 2) + 0xff000000)
//Bit 31:0  reg_decmp0_lut_addr    // unsigned, RW, default=0
//
#define ISP_OFE_DECMP0_LUT_DATA                    ((0x04f1  << 2) + 0xff000000)
//Bit 31:20 reserved
//Bit 19:0  reg_decmp0_lut_data    //unsigned, RW, default=0
//
#define ISP_OFE_DECMP1_LUT_ADDR                    ((0x04f2  << 2) + 0xff000000)
//Bit 31:0  reg_decmp1_lut_addr    // unsigned, RW, default=0
//
#define ISP_OFE_DECMP1_LUT_DATA                    ((0x04f3  << 2) + 0xff000000)
//Bit 31:20 reserved
//Bit 19:0  reg_decmp1_lut_data    //unsigned, RW, default=0
//
#define ISP_OFE_GCLK_CTRL0                         ((0x04f4  << 2) + 0xff000000)
//Bit 31:0  reg_gclk_ctrl_0           //unsigned, RW, default=0
//
#define ISP_OFE_GCLK_CTRL1                         ((0x04f5  << 2) + 0xff000000)
//Bit 31:0  reg_gclk_ctrl_1           //unsigned, RW, default=0
//
#define ISP_OFE_HW_CTRL0                           ((0x04f6  << 2) + 0xff000000)
//Bit 31:1  reserved
//Bit 0     reg_ofe_bypass          //unsigned, RW, default=0;
#define ISP_DPC_GCLK_CTRL                          ((0x04f7  << 2) + 0xff000000)
//Bit 31:0  reg_dpc_gclk_ctrl           //unsigned, RW, default=0
//
#define ISP_OFE_SW_RST                             ((0x04f8  << 2) + 0xff000000)
//Bit 31:30 reserved
//Bit 0     reg_sw_rst          //unsigned, RW, default=0, pulse, sw rst for ofe logic, especially fpnr
#define ISP_OFE_FPNR_CALI_STAT                     ((0x04f9  << 2) + 0xff000000)
//Bit 31:0  ro_cali_stat        //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB3_APB_BASE = 0x05
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ofe_wdr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_WDR_COM_BLC0                           ((0x0500  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_gr     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_gb     // unsigned ,    RW, default = 240  black level for WDR
#define ISP_WDR_COM_BLC1                           ((0x0501  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_rg     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_bg     // unsigned ,    RW, default = 240  black level for WDR
#define ISP_WDR_COM_BLC2                           ((0x0502  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_blacklevel_ir     // unsigned ,    RW, default = 240  black level for WDR
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_blacklevel_wdr    // unsigned ,    RW, default = 240  compensation black level for WDR
#define ISP_WDR_COM_PARAM0                         ((0x0503  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:26        reg_wdr_force_exp_mode    // unsigned ,    RW, default = 0  0:long exposure output, 1:short1 exposure output, 2: short2 exposure output, 3: short3 exposure output; 4:
//Bit 25            reserved
//Bit 24           reg_wdr_force_exp_en      // unsigned ,    RW, default = 0  0: disable, 1: enable force single expsure output
//Bit 23:21        reserved
//Bit 20:16        reg_sensor_bitdepth       // unsigned ,    RW, default = 10  the bitdepth of sensor output, max support 20bit
//Bit 15: 9        reserved
//Bit  8           reg_wdr_motiondect_en     // unsigned ,    RW, default = 1  0: wdr motion detection disable,  1: enable
//Bit  7: 4        reserved
//Bit  3: 2        reg_expst_xphase_ofst     // unsigned ,    RW, default = 0  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_expst_yphase_ofst     // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_WDR_COM_AWBGAIN2                       ((0x0504  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_awb_gain_256_4        // unsigned ,    RW, default = 256  4.8, AWB gain for Ir channel
#define ISP_WDR_COM_AWBGAIN1                       ((0x0505  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_gain_256_3        // unsigned ,    RW, default = 256  4.8, AWB gain for Gb channel
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_gain_256_2        // unsigned ,    RW, default = 256  4.8, AWB gain for B channel
#define ISP_WDR_COM_AWBGAIN0                       ((0x0506  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_gain_256_1        // unsigned ,    RW, default = 256  4.8, AWB gain for R channel
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_gain_256_0        // unsigned ,    RW, default = 256  4.8, AWB gain for Gr channel
#define ISP_WDR_GEN_EXPRATIO1                      ((0x0507  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lexpratio_int64_3 // unsigned ,    RW, default = 64  exposure ratio between long and short3
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lexpratio_int64_2 // unsigned ,    RW, default = 64  exposure ratio between long and short2
#define ISP_WDR_GEN_EXPRARIO0                      ((0x0508  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lexpratio_int64_1 // unsigned ,    RW, default = 64  exposure ratio between long and short1
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lexpratio_int64_0 // unsigned ,    RW, default = 64  exposure ratio of long
#define ISP_WDR_GEN_MAPRATIO2                      ((0x0509  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_2_1 // unsigned ,    RW, default = 64  of short2 to short3, short3 x Ratio(L/S3)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_2_0 // unsigned ,    RW, default = 64  of short2 to short3, short2 x Ratio(L/S2)
#define ISP_WDR_GEN_MAPRATIO1                      ((0x050a  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_1_1 // unsigned ,    RW, default = 64  of short1 to short2, short2 x Ratio(L/S2)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_1_0 // unsigned ,    RW, default = 64  of short1 to short2, short1 x Ratio(L/S1)
#define ISP_WDR_GEN_MAPRATIO0                      ((0x050b  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_wdr_lmapratio_int64_0_1 // unsigned ,    RW, default = 64  of long   to short1, short1 x Ratio(L/S1)
//Bit 15            reserved
//Bit 14: 0        reg_wdr_lmapratio_int64_0_0 // unsigned ,    RW, default = 64  of long   to short1, long x 64
#define ISP_WDR_GEN_LEXPCOMP0                      ((0x050c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_LEXPCOMP1                      ((0x050d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_LEXPCOMP2                      ((0x050e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_LEXPCOMP3                      ((0x050f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_LEXPCOMP4                      ((0x0510  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_0 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_MEXPCOMP0                      ((0x0511  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_MEXPCOMP1                      ((0x0512  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_MEXPCOMP2                      ((0x0513  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_MEXPCOMP3                      ((0x0514  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_MEXPCOMP4                      ((0x0515  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_1 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_SEXPCOMP0                      ((0x0516  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gr_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gr channel
#define ISP_WDR_GEN_SEXPCOMP1                      ((0x0517  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_gb_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Gb channel
#define ISP_WDR_GEN_SEXPCOMP2                      ((0x0518  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_rg_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Rg channel
#define ISP_WDR_GEN_SEXPCOMP3                      ((0x0519  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_bg_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_GEN_SEXPCOMP4                      ((0x051a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_wdr_lexpcomp_ir_int64_2 // unsigned ,    RW, default = 64  norm 64 as 1, compensation exposure data for Bg channel
#define ISP_WDR_MDETC_MODE                         ((0x051b  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3           reg_wdr_mdetc_withblc_mode // unsigned ,    RW, default = 0  pix value w/o blc for MDthd calculation, 1: w/ blc for MDthd calculation
//Bit  2: 1        reg_wdr_mdetc_chksat_mode // unsigned ,    RW, default = 0  check G & C w/ BLC, 1: check G & C w/o BLC
//Bit  0           reg_wdr_mdetc_motionmap_mode // unsigned ,    RW, default = 0  final map determined by Gdiff, 1: determined by MAX3(Gmap, Rmap, Bmap)
#define ISP_WDR_MDETC_WEIGHT1                      ((0x051c  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_wdr_mdetc_lo_weight_2 // unsigned ,    RW, default = 64  weight for motion detection
//Bit  7: 0        reg_wdr_mdetc_hi_weight_2 // unsigned ,    RW, default = 128  weight for motion detection
#define ISP_WDR_MDETC_WEIGHT0                      ((0x051d  << 2) + 0xff000000)
//Bit 31:24        reg_wdr_mdetc_lo_weight_1 // unsigned ,    RW, default = 64  weight for motion detection
//Bit 23:16        reg_wdr_mdetc_hi_weight_1 // unsigned ,    RW, default = 128  weight for motion detection
//Bit 15: 8        reg_wdr_mdetc_lo_weight_0 // unsigned ,    RW, default = 64  weight for motion detection
//Bit  7: 0        reg_wdr_mdetc_hi_weight_0 // unsigned ,    RW, default = 128  weight for motion detection
#define ISP_WDR_MDETC_SATTHD0                      ((0x051e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdetc_sat_gr_thd  // unsigned ,    RW, default = 3853  saturation threshold for Gr channel
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_gb_thd  // unsigned ,    RW, default = 3853  saturation threshold for Gb channel
#define ISP_WDR_MDETC_SATTHD1                      ((0x051f  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdetc_sat_rg_thd  // unsigned ,    RW, default = 3853  saturation threshold for Rg channel
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_bg_thd  // unsigned ,    RW, default = 3853  saturation threshold for Bg channel
#define ISP_WDR_MDETC_SATTHD2                      ((0x0520  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_wdr_mdetc_sat_ir_thd  // unsigned ,    RW, default = 3853  saturation threshold for Ir channel
#define ISP_WDR_MDETC_SQRT_AGAIN                   ((0x0521  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_wdr_mdetc_sqrt_again_ir // unsigned ,    RW, default = 1  result of sqrt by Ir channel Again
//Bit 23:21        reserved
//Bit 20:16        reg_wdr_mdetc_sqrt_again_bg // unsigned ,    RW, default = 1  result of sqrt by B channel Again
//Bit 15:13        reserved
//Bit 12: 8        reg_wdr_mdetc_sqrt_again_rg // unsigned ,    RW, default = 1  result of sqrt by R channel Again
//Bit  7: 5        reserved
//Bit  4: 0        reg_wdr_mdetc_sqrt_again_g // unsigned ,    RW, default = 1  result of sqrt by G channel Again
#define ISP_WDR_MDETC_SQRT_DGAIN                   ((0x0522  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_wdr_mdetc_sqrt_dgain_ir // unsigned ,    RW, default = 1  result of sqrt by Ir channel Dgain
//Bit 23:21        reserved
//Bit 20:16        reg_wdr_mdetc_sqrt_dgain_bg // unsigned ,    RW, default = 1  result of sqrt by B channel Dgain
//Bit 15:13        reserved
//Bit 12: 8        reg_wdr_mdetc_sqrt_dgain_rg // unsigned ,    RW, default = 1  result of sqrt by R channel Dgain
//Bit  7: 5        reserved
//Bit  4: 0        reg_wdr_mdetc_sqrt_dgain_g // unsigned ,    RW, default = 1  result of sqrt by G channel Dgain
#define ISP_WDR_MDETC_GNOISEFLOOR                  ((0x0523  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_g_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_g_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_g_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_RNOISEFLOOR                  ((0x0524  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_rg_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_rg_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_rg_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_BNOISEFLOOR                  ((0x0525  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_bg_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_bg_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_bg_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDETC_IRNOISEFLOOR                 ((0x0526  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_wdr_mdetc_noisefloor_ir_2 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit 15            reserved
//Bit 14: 8        reg_wdr_mdetc_noisefloor_ir_1 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
//Bit  7            reserved
//Bit  6: 0        reg_wdr_mdetc_noisefloor_ir_0 // unsigned ,    RW, default = 0  channel noisefloor for motion detection
#define ISP_WDR_MDECI_PARAM                        ((0x0527  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28           reg_wdr_mdeci_msk_sat_prct_en // unsigned ,    RW, default = 0  mask saturation protection disable, 1: mask saturation protection enable
//Bit 27:26        reserved
//Bit 25           reg_wdr_mdeci_chkstill_mode // unsigned ,    RW, default = 0  check G w/o BLC, 1: check G & C w/o BLC
//Bit 24           reg_wdr_mdeci_satmoving_gain_en // unsigned ,    RW, default = 0  the mask of a saturated moving pixel is set as 254; 1: the mask of a saturated moving pixel is affected by the reg_wdr_mdetc_lo/hi_weight
//Bit 23:16        reg_wdr_mdeci_addlong     // unsigned ,    RW, default = 0  reduce motion map value in order to include more long-exp data
//Bit 15: 8        reg_wdr_mdeci_still_thd   // unsigned ,    RW, default = 20  motion map value is less than this threshold, this motion map is set as 0
//Bit  7: 0        reg_wdr_mdeci_fullmot_thd // unsigned ,    RW, default = 250  motion map value is more than this threshold, this motion map will look for the next exposure's map
#define ISP_WDR_MDECI_LSTHD0                       ((0x0528  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gr_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gr_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD1                       ((0x0529  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gr_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gb_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD2                       ((0x052a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_gb_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_gb_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD3                       ((0x052b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_rg_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_rg_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD4                       ((0x052c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_rg_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_bg_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD5                       ((0x052d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_bg_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_bg_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD6                       ((0x052e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_mdeci_sexpstill_ir_lsthd_1 // unsigned ,    RW, default = 0  for pixel still or motion
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_ir_lsthd_0 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_MDECI_LSTHD7                       ((0x052f  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13: 0        reg_wdr_mdeci_sexpstill_ir_lsthd_2 // unsigned ,    RW, default = 0  for pixel still or motion
#define ISP_WDR_FLONG_PARAM                        ((0x0530  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 8        reg_wdr_forcelong_en      // unsigned ,    RW, default = 1  1:based on 32x32 long-exp data in previous frame, 2: based on mode1, increase short-exp data under specific condition to avoid discontinuity
//Bit  7: 5        reserved
//Bit  4           reg_wdr_flong2_colorcorrect_en // unsigned ,    RW, default = 1  1: enable
//Bit  3: 1        reserved
//Bit  0           reg_wdr_forcelong_thdmode // unsigned ,    RW, default = 0  thd is set by register, 1: thd is set by the background info calculation
#define ISP_WDR_FLONG_MASKTHD                      ((0x0531  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_flong2_mask_orgthd // unsigned ,    RW, default = 250  mask threshold in flong2 mode
//Bit 15: 8        reserved
//Bit  7: 0        reg_wdr_flong2_mask_afterthd // unsigned ,    RW, default = 251  mask threshold in flong2 mode
#define ISP_WDR_FLONG_THD0                         ((0x0532  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_0     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_0     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG_THD1                         ((0x0533  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_1     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_1     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG_THD2                         ((0x0534  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong2_thd0_2     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong2_thd1_2     // unsigned ,    RW, default = 0  threshold for Mask interpolation in flong2 mode
#define ISP_WDR_FLONG1_THD                         ((0x0535  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_flong1_thd0       // unsigned ,    RW, default = 1000  threshold for Mask interpolation in flong1 mode
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_flong1_thd1       // unsigned ,    RW, default = 1600  threshold for Mask interpolation in flong1 mode
#define ISP_WDR_EXPCOMB_PARAM                      ((0x0536  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21           reg_wdr_expcomb_maxavg_winsize // unsigned ,    RW, default = 1  5x5, 1: 5x9
//Bit 20:18        reg_wdr_expcomb_maxavg_mode // unsigned ,    RW, default = 3  original long and short data, 1: check G w/ BLC, 2: check G w/o BLC, 3: check G & C w/ BLC, 4: check G & C w/o BLC
//Bit 17:14        reg_wdr_expcomb_maxavg_ratio // unsigned ,    RW, default = 4  indx calculated by ratio of max and avg, #/16, 0->using max, 16->using avg
//Bit 13:10        reg_wdr_expcomb_slope_weight // unsigned ,    RW, default = 6  weight for exp combine
//Bit  9: 0        reg_wdr_expcomb_blend_slope // unsigned ,    RW, default = 0  slope for exp combine
#define ISP_WDR_EXPCOMB_SATTHD0                    ((0x0537  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 15:14        reserved
#define ISP_WDR_EXPCOMB_SATTHD1                    ((0x0538  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 15:14        reserved
#define ISP_WDR_EXPCOMB_SATTHD2                    ((0x0539  << 2) + 0xff000000)
//Bit 31:14        reserved
#define ISP_WDR_EXPCOMB_BLDTHD                     ((0x053a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_expcomb_blend_thd0 // unsigned ,    RW, default = 3008  precision depending on sensor bit depth, exposure combination lo_thd, when long value is less than this thd, output long data, higher than this thd, blend long and short
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_expcomb_blend_thd1 // unsigned ,    RW, default = 3900  precision depending on sensor bit depth, exposure combination hi_thd, when long vlaue is higher than this thd, output short data
#define ISP_WDR_EXPCOMB_IRBLDTHD                   ((0x053b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_wdr_expcomb_ir_blend_thd0 // unsigned ,    RW, default = 3008  precision depending on sensor bit depth, exposure combination lo_thd, when long value is less than this thd, output long data, higher than this thd, blend long and short
//Bit 15:14        reserved
//Bit 13: 0        reg_wdr_expcomb_ir_blend_thd1 // unsigned ,    RW, default = 3900  precision depending on sensor bit depth, exposure combination hi_thd, when long vlaue is higher than this thd, output short data
#define ISP_WDR_EXPCOMB_IRPARAM                    ((0x053c  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13:10        reg_wdr_expcomb_ir_slope_weight // unsigned ,    RW, default = 6
//Bit  9: 0        reg_wdr_expcomb_ir_blend_slope // unsigned ,    RW, default = 0
#define ISP_WDR_EXPCOMB_MAXRATIO                   ((0x053d  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22: 1        reg_wdr_expcomb_maxratio  // unsigned ,    RW, default = 0  ratio for exp combine
//Bit  0           reg_wdr_expcomb_irmode    // unsigned ,    RW, default = 1  0:ir channel and other channels share the blend coefficient,
#define ISP_WDR_SEXPNR_PARAM0                      ((0x053e  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6           reg_wdr_sexpnr_en         // unsigned ,    RW, default = 1  disable short-exp nr, 1: enable short-exp nr for moving areas
//Bit  5: 3        reg_wdr_sexpnr_gweight_mode // unsigned ,    RW, default = 3  control G channel filtering strength, larger number, stronger filtering effect
//Bit  2: 0        reg_wdr_sexpnr_cweight_mode // unsigned ,    RW, default = 3  control R/B channel filtering strength, larger number, stronger filtering effect
#define ISP_WDR_SEXPNR_LPWEIGHT_0                  ((0x053f  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_0_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_0_1 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_0_0 // unsigned ,    RW, default = 1  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_1                  ((0x0540  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_1_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_1_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_1_0 // unsigned ,    RW, default = 4  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_2                  ((0x0541  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_2_2 // unsigned ,    RW, default = 0  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_2_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_2_0 // unsigned ,    RW, default = 2  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_3                  ((0x0542  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_3_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_3_1 // unsigned ,    RW, default = 2  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_3_0 // unsigned ,    RW, default = 3  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_4                  ((0x0543  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_4_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_4_1 // unsigned ,    RW, default = 3  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_4_0 // unsigned ,    RW, default = 4  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_5                  ((0x0544  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_5_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_5_1 // unsigned ,    RW, default = 2  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_5_0 // unsigned ,    RW, default = 2  mode for sigma filter
#define ISP_WDR_SEXPNR_LPWEIGHT_6                  ((0x0545  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_wdr_sexpnr_lpweight_6_2 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  7: 4        reg_wdr_sexpnr_lpweight_6_1 // unsigned ,    RW, default = 1  mode for sigma filter
//Bit  3: 0        reg_wdr_sexpnr_lpweight_6_0 // unsigned ,    RW, default = 1  mode for sigma filter
#define ISP_WDR_SEXPNR_GWEIGHT                     ((0x0546  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_gsigma_weight // unsigned ,    RW, default = 16  value bigger than 16, stronger filtering effect (default: 16)
//Bit 15: 8        reg_wdr_sexpnr_gsigma_l2weight // unsigned ,    RW, default = 32  (default: 32)
//Bit  7: 0        reg_wdr_sexpnr_gsigma_l3weight // unsigned ,    RW, default = 48  (default: 48)
#define ISP_WDR_SEXPNR_CWEIGHT                     ((0x0547  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_csigma_weight // unsigned ,    RW, default = 16  value bigger than 16, stronger filtering effect (default: 16)
//Bit 15: 8        reg_wdr_sexpnr_csigma_l2weight // unsigned ,    RW, default = 32
//Bit  7: 0        reg_wdr_sexpnr_csigma_l3weight // unsigned ,    RW, default = 48
#define ISP_WDR_SEXPNR_PARAM1                      ((0x0548  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_wdr_sexpnr_motion_lothd // unsigned ,    RW, default = 180  the motion mask is bigger than this threshold, this pixel is marked as motion pixel for short-exp NR process
//Bit 15: 8        reg_wdr_sexpnr_blend_hithd // unsigned ,    RW, default = 50  the blend ratio is smaller than this threshold, this pixel is marked as motion pixel for short-exp NR process
//Bit  7: 6        reserved
//Bit  5: 0        reg_wdr_sexpnr_blend_bayerlocnt // unsigned ,    RW, default = 1  a bayer pixel, the number of pixel's blend ratio being smaller than blend_hithd is more than this threshold, this bayer pixel will be marked as motion bayer pixel
#define ISP_WDR_SEXPNR_PARAM2                      ((0x0549  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:14        reg_wdr_sexpnr_motion_locnt1 // unsigned ,    RW, default = 1
//Bit 13: 8        reg_wdr_sexpnr_motion_locnt2 // unsigned ,    RW, default = 0
//Bit  7: 2        reg_wdr_sexpnr_blend_locnt2 // unsigned ,    RW, default = 1
//Bit  1           reg_wdr_sexpnr_gsigma_mode // unsigned ,    RW, default = 0  0:physical theory 1:based on noise profile
//Bit  0           reg_wdr_sexpnr_csigma_mode // unsigned ,    RW, default = 0  0:physical theory 1:based on noise profile
#define ISP_WDR_STAT_SUM_0                         ((0x054a  << 2) + 0xff000000)
//Bit 31: 0        ro_wdr_stat_sum_0         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_CNT_0                         ((0x054b  << 2) + 0xff000000)
//Bit 31: 0        ro_wdr_stat_cnt_0         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_SUM_1                         ((0x054c  << 2) + 0xff000000)
//Bit 31: 0        ro_wdr_stat_sum_1         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_CNT_1                         ((0x054d  << 2) + 0xff000000)
//Bit 31: 0        ro_wdr_stat_cnt_1         // unsigned ,    RO, default = 0
#define ISP_WDR_STAT_PARAM                         ((0x054e  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_wdr_stat_bk_binsize   // unsigned ,    RW, default = 1023  1023
//Bit 15: 8        reg_wdr_stat_bk_binwidth  // unsigned ,    RW, default = 250  width of stat
//Bit  7: 1        reserved
//Bit  0           reg_wdr_stat_flt_en       // unsigned ,    RW, default = 1  wdr statistic flt en
#define ISP_COMB_PARAM                             ((0x054f  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_comb_shortexp_mode    // unsigned ,    RW, default = 3  use original short-exp data, when exposure ratio is larger than 6x
//Bit 15: 0        reg_comb_maxratio         // unsigned ,    RW, default = 0  ratio for combination mode
#define ISP_COMB_LSBARRIER0_0                      ((0x0550  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_0    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_0                      ((0x0551  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_0   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_1                      ((0x0552  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_1    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_1                      ((0x0553  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_1   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_2                      ((0x0554  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_2    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_2                      ((0x0555  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_2   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER0_3                      ((0x0556  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_g_lsbarrier_3    // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_rg_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_LSBARRIER1_3                      ((0x0557  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_comb_bg_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
//Bit 15:14        reserved
//Bit 13: 0        reg_comb_ir_lsbarrier_3   // unsigned ,    RW, default = 0  saturation clipping threshold (with left-shift) of Combination mode
#define ISP_COMB_EXPRAT_01                         ((0x0558  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:16        reg_comb_expratio_int64_1 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
//Bit 15            reserved
//Bit 14: 0        reg_comb_expratio_int64_0 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
#define ISP_COMB_EXPRAT_2                          ((0x0559  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14: 0        reg_comb_expratio_int64_2 // unsigned ,    RW, default = 64  exposure ratio of Combination mode
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_0          ((0x055a  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_0 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_1          ((0x055b  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_1 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_COMB_RECIPROCAL_EXPRAT_RLTV_2          ((0x055c  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 0        reg_comb_exprratio_int1024_2 // unsigned ,    RW, default = 1024  reciprocal of expr_relative, ((1<<10)/expr_relative[i]); 0-1024
#define ISP_WDR_HW_CTRL                            ((0x0590  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 0            reg_wdr_mskmap_en          // unsigned ,    RW, default = 1 1:mask out enable 0:mask out disable
#define ISP_WDR_HW_STATUS                          ((0x0598  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit 9            ro_wdr_din_done           // unsigned ,    RO, default = 0
//Bit 8            ro_wdr_dout_done          // unsigned ,    RO, default = 0
//Bit 7:6          reserved
//Bit 5            ro_wdr_din_srdy           // unsigned ,    RO, default = 0
//Bit 4            ro_wdr_din_rrdy           // unsigned ,    RO, default = 0
//Bit 3            ro_wdr_dout_srdy          // unsigned ,    RO, default = 0
//Bit 2            ro_wdr_dout_rrdy          // unsigned ,    RO, default = 0
//Bit 1            ro_wdr_mmsk_srdy          // unsigned ,    RO, default = 0
//Bit 0            ro_wdr_mmsk_rrdy          // unsigned ,    RO, default = 0
#define ISP_WDR_GSIGMA_LUT_ADDR                    ((0x05a0  << 2) + 0xff000000)
#define ISP_WDR_GSIGMA_LUT_DATA                    ((0x05a1  << 2) + 0xff000000)
#define ISP_WDR_RSIGMA_LUT_ADDR                    ((0x05a2  << 2) + 0xff000000)
#define ISP_WDR_RSIGMA_LUT_DATA                    ((0x05a3  << 2) + 0xff000000)
#define ISP_WDR_BSIGMA_LUT_ADDR                    ((0x05a4  << 2) + 0xff000000)
#define ISP_WDR_BSIGMA_LUT_DATA                    ((0x05a5  << 2) + 0xff000000)
#define ISP_CH0_RO_WDR_STAT_FLT_ADDR               ((0x05b0  << 2) + 0xff000000)
//Bit 31:0      ro_wdr_stat_flt_addr // unsigned ,    RW, default = 0
#define ISP_CH0_RO_WDR_STAT_FLT_DATA               ((0x05b1  << 2) + 0xff000000)
//Bit 31:0      ro_wdr_stat_flt_data // unsigned ,    RW, default = 0
#define ISP_CH1_RO_WDR_STAT_FLT_ADDR               ((0x05b2  << 2) + 0xff000000)
#define ISP_CH1_RO_WDR_STAT_FLT_DATA               ((0x05b3  << 2) + 0xff000000)
#define ISP_CH2_RO_WDR_STAT_FLT_ADDR               ((0x05b4  << 2) + 0xff000000)
#define ISP_CH2_RO_WDR_STAT_FLT_DATA               ((0x05b5  << 2) + 0xff000000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ofe_wdr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OFE_APB4_APB_BASE = 0x06
// -----------------------------------------------
//reserved
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TOP_APB_BASE = 0x08
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_fed_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_FED_DG_PHS_OFST                        ((0x0800  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_dg_xphs_ofst          // unsigned ,    RW, default = 1
//Bit  3: 2        reserved
//Bit  1: 0        reg_dg_yphs_ofst          // unsigned ,    RW, default = 0
#define ISP_FED_DG_GAIN01                          ((0x0801  << 2) + 0xff000000)
//Bit 31:16        reg_dg_gain_1             // unsigned ,    RW, default = 4096  in format 4.12, digital gain1 for linear bayer data
//Bit 15: 0        reg_dg_gain_0             // unsigned ,    RW, default = 4096  in format 4.12, digital gain0for linear bayer data
#define ISP_FED_DG_GAIN23                          ((0x0802  << 2) + 0xff000000)
//Bit 31:16        reg_dg_gain_3             // unsigned ,    RW, default = 4096  in format 4.12, digital gain3 for linear bayer data
//Bit 15: 0        reg_dg_gain_2             // unsigned ,    RW, default = 4096  in format 4.12, digital gain2 for linear bayer data
#define ISP_FED_DG_GAIN4                           ((0x0803  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_dg_gain_4             // unsigned ,    RW, default = 4096  in format 4.12, digital gain4 for linear bayer data
#define ISP_FED_DG_OFST                            ((0x0804  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_dg_ofst               // unsigned ,    RW, default = 0  offset before and after digital gain for linear bayer data
#define ISP_FED_BL_PHS                             ((0x0805  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_fe_bl_xphs_ofst       // unsigned ,    RW, default = 1
//Bit  3: 2        reserved
//Bit  1: 0        reg_fe_bl_yphs_ofst       // unsigned ,    RW, default = 0
#define ISP_FED_BL_OFST_GR                         ((0x0806  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_0          // signed ,    RW, default = 0  Gr for fe_bl offset each color each channels
#define ISP_FED_BL_OFST_R                          ((0x0807  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_1          // signed ,    RW, default = 0  R for blc offset each color each channels
#define ISP_FED_BL_OFST_B                          ((0x0808  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_2          // signed ,    RW, default = 0  B  for blc offset each color each channels
#define ISP_FED_BL_OFST_GB                         ((0x0809  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_3          // signed ,    RW, default = 0  Gb for blc offset each color each channels
#define ISP_FED_BL_OFST_IR                         ((0x080a  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_fe_bl_ofst_4          // signed ,    RW, default = 0  Ir of 4x4 rgbir pattern for wdr previous offset each color each channels
#define ISP_FED_SQRT_PRE_OFST                      ((0x080b  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_sqrt_pre_ofst         // signed ,    RW, default = 0  previous offset before square root
#define ISP_FED_SQRT_PST_OFST                      ((0x080c  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16: 0        reg_sqrt_pst_ofst         // signed ,    RW, default = 0  post offset after square root
#define ISP_FED_SQRT_EN_MODE                       ((0x080d  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8           reg_sqrt1_mode            // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for square root 1 lut
//Bit  7: 5        reserved
//Bit  4           reg_sqrt0_en              // unsigned ,    RW, default = 1  enable sqrt0
//Bit  3: 1        reserved
//Bit  0           reg_sqrt1_en              // unsigned ,    RW, default = 1  enable sqrt1
#define ISP_FED_SQRT_STP                           ((0x080e  << 2) + 0xff000000)
//Bit 31:28        reg_sqrt1_stp_7           // unsigned ,    RW, default = 15  step for each segment of  square root 1 lut
//Bit 27:24        reg_sqrt1_stp_6           // unsigned ,    RW, default = 14  step for each segment of  square root 1 lut
//Bit 23:20        reg_sqrt1_stp_5           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 19:16        reg_sqrt1_stp_4           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 15:12        reg_sqrt1_stp_3           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit 11: 8        reg_sqrt1_stp_2           // unsigned ,    RW, default = 13  step for each segment of  square root 1 lut
//Bit  7: 4        reg_sqrt1_stp_1           // unsigned ,    RW, default = 12  step for each segment of  square root 1 lut
//Bit  3: 0        reg_sqrt1_stp_0           // unsigned ,    RW, default = 11  step for each segment of  square root 1 lut
#define ISP_FED_SQRT_NUM                           ((0x080f  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_sqrt1_num_7           // unsigned ,    RW, default = 3  numbers for each segment of  square root 1 lut
//Bit 27            reserved
//Bit 26:24        reg_sqrt1_num_6           // unsigned ,    RW, default = 3  numbers for each segment of  square root 1 lut
//Bit 23            reserved
//Bit 22:20        reg_sqrt1_num_5           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 19            reserved
//Bit 18:16        reg_sqrt1_num_4           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 15            reserved
//Bit 14:12        reg_sqrt1_num_3           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit 11            reserved
//Bit 10: 8        reg_sqrt1_num_2           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit  7            reserved
//Bit  6: 4        reg_sqrt1_num_1           // unsigned ,    RW, default = 4  numbers for each segment of  square root 1 lut
//Bit  3            reserved
//Bit  2: 0        reg_sqrt1_num_0           // unsigned ,    RW, default = 5  numbers for each segment of  square root 1 lut
#define ISP_FED_SQRT0_ADDR                         ((0x081a  << 2) + 0xff000000)
//Bit  31:6        reserved
//Bit  5: 0        reg_prefe_lut0_addr        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT0_DATA                         ((0x081b  << 2) + 0xff000000)
//Bit  31:20       reserved
//Bit  19: 0       reg_prefe_lut0_data        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT1_ADDR                         ((0x081c  << 2) + 0xff000000)
//Bit  31:8        reserved
//Bit  7: 0        reg_prefe_lut1_addr        // unsigned ,    RW, default = 0
#define ISP_FED_SQRT1_DATA                         ((0x081d  << 2) + 0xff000000)
//Bit  31:20       reserved
//Bit  19: 0       reg_prefe_lut1_data        // unsigned ,    RW, default = 0
#define ISP_FED_GCLK                               ((0x081e  << 2) + 0xff000000)
//Bit 31:6      reserved
//Bit 5:0       reg_pre_gclk_ctrl             // unsigned  ,   RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_fed_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_nr_top_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBIC_CS_COMMON                        ((0x0880  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reserved
//Bit  9: 8        reg_xphs_ofst             // unsigned ,    RW, default = 0
//Bit  7: 6        reserved
//Bit  5: 4        reg_yphs_ofst             // unsigned ,    RW, default = 0
//Bit  3: 2        reserved
//Bit  1: 0        reg_cubic_cs_derr_mode    // unsigned ,    RW, default = 2  diagonal G5 interpolation error mode: 0: |g1/g0-g2|, 1: 2*|g1/g0-g2|, 2: |g1/g0-g2| + (|g0-g3|or|g1-g4|)/2; 3: |g1/g0-g2| + (|g0-g3|or|g1-g4|)
#define ISP_CUBIC_CS_CRTL                          ((0x0881  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_cubic_cs_dint_alph    // unsigned ,    RW, default = 4  diagonal interpolation mode, 0: just use (G1+G2)/2 or (G0+G2)/2, 7: ((G1+G2)or(G0+G2))/4 + G0/2; default= 4
//Bit 27:24        reg_cubic_cs_G3bld_alp    // unsigned ,    RW, default = 0  blend alpha of G3(XC criteria) with G5, for iG, only for rb2uv; norm to 16 as 1; default= 0
//Bit 23:20        reg_cubic_detect_thrd_rt  // unsigned ,    RW, default = 8  detect bad point thrd ratio
//Bit 19:16        reg_cubic_dpc_avg_rt      // unsigned ,    RW, default = 14  min_err and min2_err is almost same,but dat is quite different,use min_err >= min2_err * rt ? use avg : use dat[min_err];
//Bit 15: 8        reg_cubic_cs_vint_thrd    // unsigned ,    RW, default = 25  bayer2yuv,vertical interpolation mode=err[2]>=thrd*4: just use G2, else: (G0+G1)/4 + G2/2; default= 25
//Bit  7: 4        reg_cubic_cs_diff_gain    // unsigned ,    RW, default = 1  bayer2yuv, gain to diff for error modifications, the larger of this value, the less cross color will be; default = 1;
//Bit  3: 0        reg_cubic_cs_grad_gain    // unsigned ,    RW, default = 8  bayer2yuv, gain to gradient for error modifications, the smaller of this value, the more reliable on xc-diff; norm to 8 as 1.0 default = 8;
#define ISP_CUBIC_CS_DRT                           ((0x0882  << 2) + 0xff000000)
//Bit 31:24        reg_cubic_cs_useavg_th    // unsigned ,    RW, default = 10  bayer2yuv,max_err<(th*4), use average g0~g2 as og for DbDr calculation (flat region), default =10;
//Bit 23:20        reg_cubic_cs_useavg_rt    // unsigned ,    RW, default = 12  bayer2yuv, min_err>(max_err*rate/16), use average g0~g2 as og for DbDr calculation (non good edge), default =12;
//Bit 19:16        reg_cubic_cs_usedrt_rt    // unsigned ,    RW, default = 13  bayer2yuv, min_err<(max_err*rate/16), use 100% drt g0~g2 as og for DbDr calculation (very good edge), otherwise (avg+3*drt)/4, default = 8;
//Bit 15:12        reg_cubic_cs_direct_en    // unsigned ,    RW, default = 15  enable of the four directions for the G5 calc, b[0]: horizontal, b[1]: D0(TL-BR), b[2]: Vertical; b[3]: D1(TR-BL), default=b'1111
//Bit 11: 8        reg_cubic_csi_diff_gain   // unsigned ,    RW, default = 1  yuv2bayer, gain to diff for error modifications, the larger of this value, the less cross color will be; default = 1;
//Bit  7: 0        reg_cubic_csi_vint_thrd   // unsigned ,    RW, default = 25  yuv2bayer,vertical interpolation mode=err[2]>=thrd*4: just use G2, else: (G0+G1)/4 + G2/2; default = 25
#define ISP_CUBIC_CSI_DRT                          ((0x0883  << 2) + 0xff000000)
//Bit 31:28        reg_cubic_csi_grad_gain   // unsigned ,    RW, default = 8  bayer2yuv, gain to gradient for error modifications, the smaller of this value, the more reliable on xc-diff; norm to 8 as 1.0 default = 8;
//Bit 27:24        reg_cubic_csi_useavg_rt   // unsigned ,    RW, default = 12  yuv2bayer, min_err>(max_err*rate/16), use average g0~g2 as og for DbDr calculation (non good edge), default = 12;
//Bit 23:20        reg_cubic_csi_usedrt_rt   // unsigned ,    RW, default = 13  bayer2yuv, min_err<(max_err*rate/16), use 100% drt g0~g2 as og for DbDr calculation (very good edge), otherwise (avg+3*drt)/4, default = 8;
//Bit 19:16        reg_cubic_csi_direct_en   // unsigned ,    RW, default = 15  enable of the four directions for the G5 calc, b[0]: horizontal, b[1]: D0(TL-BR), b[2]: Vertical; b[3]: D1(TR-BL), default =b'1111
//Bit 15: 8        reg_cubic_csi_color_cor   // unsigned ,    RW, default = 0  yuv2bayer, color coring threshold (hard threshold), default =10;
//Bit  7: 0        reg_cubic_csi_useavg_th   // unsigned ,    RW, default = 10  yuv2bayer, max_err<(th*4), use average g0~g2 as og for DbDr calculation (flat region), default =10;
#define ISP_CUBIC_CS_POWER                         ((0x0884  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_cubic_cs_powersaving  // unsigned ,    RW, default = 2  power saving mode bayer2yuv and yuv2bayer use average; 0,adaptive, 1:use avg; 2/3: use g_avg_within_2x2, default=0
//Bit 23:18        reserved
//Bit 17:16        reg_cubic_csi_powersaving // unsigned ,    RW, default = 2  power saving mode bayer2yuv and yuv2bayer use average; 0,adaptive, 1:use avg; 2/3: use g_avg_within_2x2, default=0
//Bit 15: 0        reserved
#define ISP_CUBIC_RAD_CRTL                         ((0x0885  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26           reg_rad_tnr0_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  TNR0;
//Bit 25           reg_rad_snr1_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  SNR1;
//Bit 24           reg_rad_tnr2_en           // unsigned ,    RW, default = 1  enable of using radius shading map to adjust the signma for  TNR2;
//Bit 23:16        reg_rad_tnr0_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to tnr0_rad_gain, norm to 64 as 1.0, the larger, the more TNR0 on the border
//Bit 15: 8        reg_rad_snr1_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to snr1_rad_gain, norm to 64 as 1.0, the larger, the more SNR1 on the border
//Bit  7: 0        reg_rad_tnr2_gain         // unsigned ,    RW, default = 64  gain to map rad_gain to tnr2_rad_gain, norm to 64 as 1.0, the larger, the more TNR2 on the border
#define ISP_CUBIC_RAD_SCL0                         ((0x0886  << 2) + 0xff000000)
//Bit 31:16        reg_rad_xscale            // unsigned ,    RW, default = 64  norm 512 as "1"; x scale <=65536/(ColMax)*32
//Bit 15: 0        reg_rad_yscale            // unsigned ,    RW, default = 64  norm 512 as "1"; y scale <=65536/(RowMax)*32
#define ISP_CUBIC_RAD_CENTER                       ((0x0887  << 2) + 0xff000000)
//Bit 31:16        reg_rad_centerx           // unsigned ,    RW, default = 540  the coordinates of the center of the image on the X axis
//Bit 15: 0        reg_rad_centery           // unsigned ,    RW, default = 960  the coordinates of the center of the image on the Y axis
#define ISP_CUBIC_RAD_SCL1                         ((0x0888  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_rad_scale             // unsigned ,    RW, default = 181  rad scale up to fill 65bin lut, set to 128*2/sqrt(a^2 +b^2), norm to 128 as "1", 256/1.414
#define ISP_CUBIC_LUT65_ADDR                       ((0x0890  << 2) + 0xff000000)
//Bit  31:5        reserved
//Bit  4: 0        reg_rad_lut65_addr        // unsigned ,    RW, default = 0
#define ISP_CUBIC_LUT65_DATA                       ((0x0891  << 2) + 0xff000000)
//Bit  31: 0       reg_rad_lut65_data        // unsigned ,    RW, default = 0
#define ISP_CUBIC_GCLK                             ((0x0892  << 2) + 0xff000000)
//Bit 31:8      reserved
//Bit 7:6       reserved
//Bit 5:0       reg_gclk_ctrl_top             // unsigned  ,   RW, default = 0
#define ISP_TNR_GCLK_CTRL                          ((0x0893  << 2) + 0xff000000)
//Bit  31: 0        reg_tnr_gclk_ctrl             // unsigned ,    RW, default = 0
#define ISP_MCNR_GCLK_CTRL                         ((0x0894  << 2) + 0xff000000)
//Bit  31: 0        reg_mcnr_gclk_ctrl            // unsigned ,    RW, default = 0
#define ISP_SNR_GCLK_CTRL                          ((0x0895  << 2) + 0xff000000)
//Bit  31: 0        reg_snr_gclk_ctrl             // unsigned ,    RW, default = 0
#define ISP_RCNR_GCLK_CTRL                         ((0x0896  << 2) + 0xff000000)
//Bit  31: 0        reg_rcnr_gclk_ctrl            // unsigned ,    RW, default = 0
#define ISP_NR_TOP_GCLK_CTRL                       ((0x0897  << 2) + 0xff000000)
//Bit  31: 0        reg_nr_top_gclk_ctrl          // unsigned ,    RW, default = 0
#define ISP_NR_DBG_PATH_CTRL                       ((0x0898  << 2) + 0xff000000)
//Bit  31: 16       reg_nr_dbg_path_gain          // unsigned ,    RW, default = 0
//Bit  15: 1        reg_nr_dbg_path_sel           // unsigned ,    RW, default = 0
//Bit  0            reg_nr_dbg_path_en            // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_nr_top_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_CAC_APB_BASE = 0x09
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_cac_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CAC_CNTL                               ((0x0900  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_cac_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset
//Bit 27:26        reserved
//Bit 25:24        reg_cac_xphs_ofst         // unsigned ,    RW, default = 1  horizontal phase offset
//Bit 23:12        reg_cac_col_step          // unsigned ,    RW, default = 12'h3e
//Bit 11: 0        reg_cac_row_step          // unsigned ,    RW, default = 12'h24
#define ISP_CAC_CNTL0                              ((0x0901  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22: 0        reg_cac_col_step_inv      // unsigned ,    RW, default = 23'h42108  the inversion of column step
#define ISP_CAC_CNTL1                              ((0x0902  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22: 0        reg_cac_row_step_inv      // unsigned ,    RW, default = 23'h71c72  inversion of row step
#define ISP_CAC_COL_OFFSET                         ((0x0903  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 8        reg_cac_col_idx_offset1   // unsigned ,    RW, default = 0  the offset of colum alpha index
//Bit  7: 5        reserved
//Bit  4: 0        reg_cac_col_idx_offset0   // unsigned ,    RW, default = 0  the offset of column index
#define ISP_CAC_FILTER_COEF0                       ((0x0904  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_0      // unsigned ,    RW, default = 32'h8000  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF1                       ((0x0905  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_1      // unsigned ,    RW, default = 32'h280fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF2                       ((0x0906  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_2      // unsigned ,    RW, default = 32'h57ffc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF3                       ((0x0907  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_3      // unsigned ,    RW, default = 32'hff087dfb  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF4                       ((0x0908  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_4      // unsigned ,    RW, default = 32'hff0c7bfa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF5                       ((0x0909  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_5      // unsigned ,    RW, default = 32'hff1079f9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF6                       ((0x090a  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_6      // unsigned ,    RW, default = 32'hfe1476f8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF7                       ((0x090b  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_7      // unsigned ,    RW, default = 32'hfe1873f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF8                       ((0x090c  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_8      // unsigned ,    RW, default = 32'hfd1d6ff7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF9                       ((0x090d  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_9      // unsigned ,    RW, default = 32'hfc226bf7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF10                      ((0x090e  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_10     // unsigned ,    RW, default = 32'hfc2767f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF11                      ((0x090f  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_11     // unsigned ,    RW, default = 32'hfb2c62f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF12                      ((0x0910  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_12     // unsigned ,    RW, default = 32'hfa325df7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF13                      ((0x0911  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_13     // unsigned ,    RW, default = 32'hfa3758f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF14                      ((0x0912  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_14     // unsigned ,    RW, default = 32'hf93d53f7  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF15                      ((0x0913  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_15     // unsigned ,    RW, default = 32'hf9424df8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF16                      ((0x0914  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_16     // unsigned ,    RW, default = 32'hf84848f8  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF17                      ((0x0915  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_17     // unsigned ,    RW, default = 32'hf84d42f9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF18                      ((0x0916  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_18     // unsigned ,    RW, default = 32'hf7533df9  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF19                      ((0x0917  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_19     // unsigned ,    RW, default = 32'hf75837fa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF20                      ((0x0918  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_20     // unsigned ,    RW, default = 32'hf75d32fa  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF21                      ((0x0919  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_21     // unsigned ,    RW, default = 32'hf7622cfb  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF22                      ((0x091a  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_22     // unsigned ,    RW, default = 32'hf76727fc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF23                      ((0x091b  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_23     // unsigned ,    RW, default = 32'hf76b22fc  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF24                      ((0x091c  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_24     // unsigned ,    RW, default = 32'hf76f1dfd  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF25                      ((0x091d  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_25     // unsigned ,    RW, default = 32'hf77318fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF26                      ((0x091e  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_26     // unsigned ,    RW, default = 32'hf87614fe  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF27                      ((0x091f  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_27     // unsigned ,    RW, default = 32'hf97910ff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF28                      ((0x0920  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_28     // unsigned ,    RW, default = 32'hfa7b0cff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF29                      ((0x0921  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_29     // unsigned ,    RW, default = 32'hfb7d08ff  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF30                      ((0x0922  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_30     // unsigned ,    RW, default = 32'hfc7f0500  cac interpolation coefficients
#define ISP_CAC_FILTER_COEF31                      ((0x0923  << 2) + 0xff000000)
//Bit 31: 0        reg_cac_cubic_coef_31     // unsigned ,    RW, default = 32'hfe800200  cac interpolation coefficients
#define ISP_PDPC_CNTL                              ((0x0924  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16           reg_pdpc_ic_mimx3x3       // unsigned ,    RW, default = 1  use minmax3 as local range decision, 0: use 5x5; 1:3x3
//Bit 15:13        reserved
//Bit 12           reg_pdpc_oc_minmax        // unsigned ,    RW, default = 1  use out of channel minmax3 same components as local range decision, 0: no use ; 1: use min max of same color (raw_mode=0/1/4, chn=0/3)
//Bit 11: 9        reserved
//Bit  8           reg_pdpc_th_mode          // unsigned ,    RW, default = 1  mode of reg_pulnr_thrd[i].  0:i is for channel number; 1: i is the pixel level 4 piece, can set thrd based on the level. default=1
//Bit  7: 6        reserved
//Bit  5: 4        reg_pdpc_lpf_alp          // unsigned ,    RW, default = 2  alpha for lpf, the larger of alpha, the more heavier of the lpf. default = 2
//Bit  3: 1        reserved
//Bit  0           reg_pdpc_lpf_sel          // unsigned ,    RW, default = 0  select the lpf output when hot/dead pixel
#define ISP_PDPC_THRD0                             ((0x0925  << 2) + 0xff000000)
//Bit 31:24        reg_pdpc_thrd_0           // unsigned ,    RW, default = 1  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 23:16        reg_pdpc_thrd_1           // unsigned ,    RW, default = 2  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 15: 8        reg_pdpc_thrd_2           // unsigned ,    RW, default = 2  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit  7: 0        reg_pdpc_thrd_3           // unsigned ,    RW, default = 3  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
#define ISP_PDPC_RATIO_CTRL                        ((0x0926  << 2) + 0xff000000)
//Bit 31:24        reg_pdpc_thrd_4           // unsigned ,    RW, default = 4  different channel pulse noise decision static threshold: impulse_flag = dist>max(var*ratio/32, thrd*4)
//Bit 23:22        reserved
//Bit 21:16        reg_pdpc_ic_ratio         // unsigned ,    RW, default = 16  same channel (in Channel) margin ratio from each direction [-2,-1] [+1, 2] prediction, norm to 16 as 1.0, default= 16;
//Bit 15:14        reserved
//Bit 13: 8        reg_pdpc_oc_ratio         // unsigned ,    RW, default = 16  nearby neighbor channel (out Channel)var ratio, the larger of this ratio, the less possibility dp detected, norm to 32 as 1.0, default, 16;
//Bit  7: 0        reg_pdpc_oc_coring        // unsigned ,    RW, default = 4  nearby neighbor channel (out Channel)var coring, the larger of this coring, the less possibility dp detected, 4x in uBL scale;
#define ISP_PDPC_THR_CTRL                          ((0x0927  << 2) + 0xff000000)
//Bit 31:16        reg_pdpc_dead_thr         // unsigned ,    RW, default = 512  dead pixel threshold, default , BLC in sqrt domain, sqrt((BLC+0x40)/4096)*4096
//Bit 15: 0        reg_pdpc_hoti_thr         // unsigned ,    RW, default = 65535  hot  pixel threshold, maximum valid pixel range
#define ISP_LCGE_EN                                ((0x0928  << 2) + 0xff000000)
//Bit 31:14        reserved
//Bit 13           reg_lcge_mono_mode_en     // unsigned ,    RW, default = 0  enale of lcge  in mono mode
//Bit 12: 8        reg_lcge_flat_rate        // unsigned ,    RW, default = 3  flat ratio of lpf g, 32 as 1
//Bit  7: 0        reg_lcge_gdiff_rate       // unsigned ,    RW, default = 32  detail ratio of avg g, 256 as 1
#define ISP_LCGE_FLAT_TH_MIN_MAX                   ((0x0929  << 2) + 0xff000000)
//Bit 31:16        reg_lcge_flat_var_th_min  // unsigned ,    RW, default = 30  variance min threshold
//Bit 15: 0        reg_lcge_flat_var_th_max  // unsigned ,    RW, default = 2000  variance max threshold
#define ISP_LCGE_FLAT_RATIO_0                      ((0x092a  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_0          // unsigned ,    RW, default = 0  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_0          // unsigned ,    RW, default = 0  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_1                      ((0x092b  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_1          // unsigned ,    RW, default = 4  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_1          // unsigned ,    RW, default = 1  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_2                      ((0x092c  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_2          // unsigned ,    RW, default = 8  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_2          // unsigned ,    RW, default = 2  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_3                      ((0x092d  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_3          // unsigned ,    RW, default = 12  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_3          // unsigned ,    RW, default = 3  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_4                      ((0x092e  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_4          // unsigned ,    RW, default = 16  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_4          // unsigned ,    RW, default = 4  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_5                      ((0x092f  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_5          // unsigned ,    RW, default = 20  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_5          // unsigned ,    RW, default = 5  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_6                      ((0x0930  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_6          // unsigned ,    RW, default = 24  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_6          // unsigned ,    RW, default = 6  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_FLAT_RATIO_7                      ((0x0931  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 4        reg_lcge_ratio_7          // unsigned ,    RW, default = 28  flat ratio of avg g, smaller than reg_lcge_gdiff_rate, 256 as 1
//Bit  3: 0        reg_lcge_alpha_7          // unsigned ,    RW, default = 7  flat alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_ALPHA                             ((0x0932  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 9        reg_lcge_alpha_8          // unsigned ,    RW, default = 8  flat alpha to blend current and avg_g, 16 as 1
//Bit  8           reg_lcge_hv_line_en       // unsigned ,    RW, default = 0  short horizontal or vertical lines
//Bit  7           reg_lcge_hv_line_tnr_meta_en // unsigned ,    RW, default = 1  lcge in motion area, 0: whole frame do lcge, 1: motion area do lcge
//Bit  6: 4        reg_lcge_hv_line_tnr_meta_th // unsigned ,    RW, default = 0  lcge in motion area, tnr_meta <= th
//Bit  3: 0        reg_lcge_hv_line_alpha    // unsigned ,    RW, default = 8  alpha to blend current and avg_g, 16 as 1
#define ISP_LCGE_HV_LINE_DIFF_TH                   ((0x0933  << 2) + 0xff000000)
//Bit 31:16        reg_lcge_hv_line_diff_th  // signed ,    RW, default = 0  condition1,threshold of diff
//Bit 15: 0        reg_lcge_hv_line_cor2_diff_th // signed ,    RW, default = 0  condition2, threshold of diff corner pixel
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_cac_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_cac_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CAC_GCLK_CTRL                          ((0x0970  << 2) + 0xff000000)
//Bit 31:22       reserved
//Bit 21: 0       reg_cac_wrap_gc                 // unsigned ,    RW, default = 22'h0  reg_cac_wrap_gc
#define ISP_CAC_COL_ALPHA                          ((0x0971  << 2) + 0xff000000)
//Bit 31:24       reserved
//Bit 23: 0       reg_cac_col_alpha_ofst          // unsigned ,    RW, default = 24'h0  reg_cac_col_alpha_ofst=reg_cac_col_idx_offset1*reg_cac_col_step_inv
#define ISP_CAC_TAB_DATA                           ((0x0980  << 2) + 0xff000000)
//Bit 31: 0       reg_cac_ram_data                // unsigned ,    RW, default = 31'h0  reg_cac_ram_data
#define ISP_CAC_TAB_ADDR                           ((0x0981  << 2) + 0xff000000)
//Bit 31:18       reserved
//Bit 17:16       reg_cac_ram_chnx                // unsigned ,    RW, default = 2'h0   reg_cac_ram_chnx
//Bit 15:13       reserved
//Bit 12: 8       reg_cac_ram_vidx                // unsigned ,    RW, default = 5'h0   reg_cac_ram_vidx
//Bit  7: 5       reserved
//Bit  4: 0       reg_cac_ram_hidx                // unsigned ,    RW, default = 5'h0   reg_cac_ram_hidx
#define ISP_CAC_TAB_CTRL                           ((0x0982  << 2) + 0xff000000)
//Bit 31: 1       reserved
//Bit     0       reg_cac_apb2ram_en              // unsigned ,    RW, default = 1'h0   reg_cac_apb2ram_en
#define ISP_CAC_TAB_INT                            ((0x0983  << 2) + 0xff000000)
//Bit 31: 1       reserved
//Bit     0       reg_ram_cfg_done_status         // unsigned ,    RW, default = 1'h0   reg_ram_cfg_done_status
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_cac_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_NLM_APB_BASE = 0x0a
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_snr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_SNR_CTRL                               ((0x0a00  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reg_snr_xphs_ofst         // unsigned ,    RW, default = 1
//Bit 25:24        reg_snr_yphs_ofst         // unsigned ,    RW, default = 0
//Bit 23:21        reserved
//Bit 20           reg_snr_cur_wind_lpf_en   // unsigned ,    RW, default = 1
//Bit 19:17        reserved
//Bit 16           reg_snr_meta_en           // unsigned ,    RW, default = 1  snr meta adaptive enable, 0:disable,1:enable,default:1
//Bit 15:12        reserved
//Bit 11           reg_snr_sad_chk_mb_en     // unsigned ,    RW, default = 0  snr motion boundary add coring enable, 0:disable,1:enable,default:1                                                  //u
//Bit 10           reg_snr_smooth_mask       // unsigned ,    RW, default = 1  smooth maskmap
//Bit  9           reg_snr_rad_en            // unsigned ,    RW, default = 1  snr radius gain enable,0:disable,1:enable .cubic_t.reg_rad_snr1_en = 1 will calculate snr1_rad_gain
//Bit  8           reg_snr_sub_bl_en         // unsigned ,    RW, default = 0  : when calculating average intensity, could choose to subtract the black level,  default:0, do not subtract black level
//Bit  7: 5        reserved
//Bit  4           reg_snr_wt_sad_th_en      // unsigned ,    RW, default = 1  wdr adj
//Bit  3           reg_snr_coring_var_en     // unsigned ,    RW, default = 1  wdr adj
//Bit  2           reg_snr_coring_grad_en    // unsigned ,    RW, default = 1  wdr adj
//Bit  1           reg_snr_wt_ratio_en       // unsigned ,    RW, default = 1  wdr adj
//Bit  0           reg_snr_mask_en           // unsigned ,    RW, default = 1  wdr adj
#define ISP_SNR_RATIO0                             ((0x0a01  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_ratio_gr          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit 15: 8        reg_snr_ratio_r           // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit  7: 0        reg_snr_ratio_b           // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
#define ISP_SNR_RATIO1                             ((0x0a02  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_ratio_gb          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_ratio_ir          // unsigned ,    RW, default = 32  snr modulation of different channels, 32 norm to 1.0,[0,255], default:32
#define ISP_SNR_WT_LUT_0                           ((0x0a03  << 2) + 0xff000000)
//Bit 31:24        reg_snr_wt_lut_3          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_2          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_1          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_0          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_1                           ((0x0a04  << 2) + 0xff000000)
//Bit 31:24        reg_snr_wt_lut_7          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_6          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_5          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_4          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_2                           ((0x0a05  << 2) + 0xff000000)
//Bit 31:24        reg_snr_wt_lut_11         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_10         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_9          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_8          // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_SNR_WT_LUT_3                           ((0x0a06  << 2) + 0xff000000)
//Bit 31:24        reg_snr_wt_lut_15         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 23:16        reg_snr_wt_lut_14         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit 15: 8        reg_snr_wt_lut_13         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
//Bit  7: 0        reg_snr_wt_lut_12         // unsigned ,    RW, default = 100  weight lut for snr weighted sum
#define ISP_APL_BLACK_LEVEL                        ((0x0a07  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 8        reg_snr_bl                // unsigned ,    RW, default = 1470  when calculating average intensity, could choose to subtract the black level,  default:sqrt(black_level/2^20)*2^12, fw set
//Bit  7: 0        reg_snr_bl_ratio          // unsigned ,    RW, default = 192  adjest apl ,16 is "1"
#define ISP_SNR_SAD_CURV                           ((0x0a08  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_snr_sad_th_mode       // unsigned ,    RW, default = 0  of sad th calcuate, 0: avg and avg_l bland , 1: avg and avg_h bland
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_avg_alpha     // unsigned ,    RW, default = 8  of avg when bland with avg_l or avg_h  16 is "1"  (0-16)
//Bit 15: 8        reg_snr_sad_min_th        // unsigned ,    RW, default = 255  threshold of sad min th
//Bit  7: 0        reg_snr_sad_max_th        // unsigned ,    RW, default = 255  threshold of sad max th
#define ISP_SNR_META_LUT0                          ((0x0a09  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_0        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reg_snr_meta_adj_1        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit  7: 0        reg_snr_meta_adj_2        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_META_LUT1                          ((0x0a0a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_3        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reg_snr_meta_adj_4        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit  7: 0        reg_snr_meta_adj_5        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_META_LUT2                          ((0x0a0b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_meta_adj_6        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_meta_adj_7        // unsigned ,    RW, default = 64  using reg_snr_meta_adj, adjust wt according meta, norm 64 as 1.0
#define ISP_SNR_MASK_LUT0                          ((0x0a0c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_0        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reg_snr_mask_adj_1        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit  7: 0        reg_snr_mask_adj_2        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_MASK_LUT1                          ((0x0a0d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_3        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reg_snr_mask_adj_4        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit  7: 0        reg_snr_mask_adj_5        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_MASK_LUT2                          ((0x0a0e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_mask_adj_6        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
//Bit 15: 8        reserved
//Bit  7: 0        reg_snr_mask_adj_7        // unsigned ,    RW, default = 64  adjust wt according mask, for wdr and combination model, norm 64 as .10
#define ISP_SNR_PROFILE_ADJ                        ((0x0a0f  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30           reg_snr_sad_cor_manual_mode // unsigned ,    RW, default = 0  0:noise profile lut, 1: apl curve
//Bit 29:16        reserved
//Bit 15: 8        reg_snr_sad_cor_profile_adj // unsigned ,    RW, default = 64  increase flexibility of LUT noise profile tuning
//Bit  7: 0        reg_snr_sad_cor_profile_ofst // signed ,    RW, default = 0  increase flexibility of lut noise profile tuning
#define ISP_SNR_SAD_META_RATIO                     ((0x0a10  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_sad_meta_ratio_3  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_meta_ratio_2  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit 15:13        reserved
//Bit 12: 8        reg_snr_sad_meta_ratio_1  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
//Bit  7: 5        reserved
//Bit  4: 0        reg_snr_sad_meta_ratio_0  // unsigned ,    RW, default = 16  ratio for sad calculate,sad = (sad * ratio )/16,[0,16]
#define ISP_SNR_SAD_META_BND                       ((0x0a11  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_snr_sad_meta_bnd_2    // unsigned ,    RW, default = 5  meta boundary2 for sad calculation
//Bit  7: 4        reg_snr_sad_meta_bnd_1    // unsigned ,    RW, default = 3  meta boundary1 for sad calculation
//Bit  3: 0        reg_snr_sad_meta_bnd_0    // unsigned ,    RW, default = 1  meta boundary0 for sad calculation
#define ISP_SNR_CORING                             ((0x0a12  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_sad_th_y0         // unsigned ,    RW, default = 4  curve value of coring
//Bit 11: 0        reg_snr_sad_th_y1         // unsigned ,    RW, default = 8
#define ISP_SNR_CORING_1                           ((0x0a13  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_sad_th_y2         // unsigned ,    RW, default = 12
//Bit 11: 0        reg_snr_sad_max_coring    // unsigned ,    RW, default = 1024  the max coring for calculate sad
#define ISP_SNR_CORING_2                           ((0x0a14  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:24        reg_snr_sad_cor_alp_rs    // unsigned ,    RW, default = 4  shift bits apl for calculate coring
//Bit 23:16        reg_snr_sad_th_x0         // unsigned ,    RW, default = 70  threshold x0 of thr coring curve
//Bit 15:12        reg_snr_sad_th_x1         // unsigned ,    RW, default = 2  threshold = x0 + (1<<x1)
//Bit 11: 8        reg_snr_sad_th_x2         // unsigned ,    RW, default = 2  threshold = x0 + (1<<x1) + (1<<x2)
//Bit  7: 0        reg_snr_mix_th_iso_gain   // unsigned ,    RW, default = 32  iso gain for coring
#define ISP_SNR_CORING_META2ALP_0                  ((0x0a15  << 2) + 0xff000000)
//Bit 31:24        reg_snr_sad_meta2alp_3    // unsigned ,    RW, default = 48  adjust coring according meta
//Bit 23:16        reg_snr_sad_meta2alp_2    // unsigned ,    RW, default = 64  adjust coring according meta
//Bit 15: 8        reg_snr_sad_meta2alp_1    // unsigned ,    RW, default = 120  adjust coring according meta
//Bit  7: 0        reg_snr_sad_meta2alp_0    // unsigned ,    RW, default = 240  adjust coring according meta
#define ISP_SNR_CORING_META2ALP_1                  ((0x0a16  << 2) + 0xff000000)
//Bit 31:24        reg_snr_sad_meta2alp_7    // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 23:16        reg_snr_sad_meta2alp_6    // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 15: 8        reg_snr_sad_meta2alp_5    // unsigned ,    RW, default = 24  adjust coring according meta
//Bit  7: 0        reg_snr_sad_meta2alp_4    // unsigned ,    RW, default = 32  adjust coring according meta
#define ISP_SNR_MB_APL                             ((0x0a17  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 8        reg_snr_sad_mb_apl_th     // unsigned ,    RW, default = 48  boundary apl threshold
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_sad_mb_gain       // unsigned ,    RW, default = 0  gain of diff_apl add to coring in light shadow
#define ISP_SNR_MB_META                            ((0x0a18  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_sad_mb_meta_sth   // unsigned ,    RW, default = 3  boundary static meta threshold  (0-16)
//Bit 23:21        reserved
//Bit 20:16        reg_snr_sad_mb_meta_mth   // unsigned ,    RW, default = 1  boundary motion meta threshold   (0-16)
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_sad_mb_meta_cnt_sth // unsigned ,    RW, default = 6  boundary static count threshold  (0-35)
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_sad_mb_meta_cnt_mth // unsigned ,    RW, default = 6  boundary motion count threshold  (0-35)
#define ISP_SNR_CORING_GRAD                        ((0x0a19  << 2) + 0xff000000)
//Bit 31:24        reg_snr_lpf_phs_grad_ratio // unsigned ,    RW, default = 16  max_grad and min_grad ratio decision edge  256 is "1"
//Bit 23:16        reg_snr_grad_max_th       // unsigned ,    RW, default = 8  the threshold of flatness
//Bit 15:13        reserved
//Bit 12: 8        reg_snr_grad_flat_gain    // unsigned ,    RW, default = 16  flatness coring gain
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_gain_4       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
#define ISP_SNR_CORING_GRAD_RATIO                  ((0x0a1a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_grad_ratio_3      // unsigned ,    RW, default = 6  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit 23:22        reserved
//Bit 21:16        reg_snr_grad_ratio_2      // unsigned ,    RW, default = 12  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_grad_ratio_1      // unsigned ,    RW, default = 20  and min_grad ratio decision the strength of boundary, 64 as 1.0
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_ratio_0      // unsigned ,    RW, default = 32  and min_grad ratio decision the strength of boundary, 64 as 1.0
#define ISP_SNR_CORING_GRAD_GAIN                   ((0x0a1b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_grad_gain_3       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit 23:22        reserved
//Bit 21:16        reg_snr_grad_gain_2       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_grad_gain_1       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_grad_gain_0       // unsigned ,    RW, default = 16  adjust coring according grad value, normal 16 as 1
#define ISP_SNR_CORING_MASK                        ((0x0a1c  << 2) + 0xff000000)
//Bit 31:24        reg_snr_sad_th_mask_gain_0 // unsigned ,    RW, default = 8  adjust coring according mask, for wdr case,norm 16 as .1
//Bit 23:16        reg_snr_sad_th_mask_gain_1 // unsigned ,    RW, default = 10  adjust coring according mask, for wdr case,norm 16 as .1
//Bit 15: 8        reg_snr_sad_th_mask_gain_2 // unsigned ,    RW, default = 14  adjust coring according mask, for wdr case,norm 16 as .1
//Bit  7: 0        reg_snr_sad_th_mask_gain_3 // unsigned ,    RW, default = 16  adjust coring according mask, for wdr case,norm 16 as .1
#define ISP_SNR_WT_LUMA_ADJ                        ((0x0a1d  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 9        reserved
//Bit  8           reg_snr_luma_adj_en       // unsigned ,    RW, default = 0  adjust wt according luma
//Bit  7: 4        reg_snr_wt_luma_meta_th   // unsigned ,    RW, default = 4  threshold of meta
//Bit  3: 0        reg_snr_wt_luma_idx_rs    // unsigned ,    RW, default = 9
#define ISP_SNR_WT_LUMA_SCAL_0                     ((0x0a1e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_wt_luma_gain_3    // unsigned ,    RW, default = 32
//Bit 23:22        reserved
//Bit 21:16        reg_snr_wt_luma_gain_2    // unsigned ,    RW, default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_luma_gain_1    // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_luma_gain_0    // unsigned ,    RW, default = 32
#define ISP_SNR_WT_LUMA_SCAL_1                     ((0x0a1f  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_snr_wt_luma_gain_7    // unsigned ,    RW, default = 32
//Bit 23:22        reserved
//Bit 21:16        reg_snr_wt_luma_gain_6    // unsigned ,    RW, default = 32
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_luma_gain_5    // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_luma_gain_4    // unsigned ,    RW, default = 32
#define ISP_SNR_WT_IDX_RATIO                       ((0x0a20  << 2) + 0xff000000)
//Bit 31:24        reg_snr_idx_wt_ratio_3    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit 23:16        reg_snr_idx_wt_ratio_2    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit 15: 8        reg_snr_idx_wt_ratio_1    // unsigned ,    RW, default = 128  wt accoring current wt position
//Bit  7: 0        reg_snr_idx_wt_ratio_0    // unsigned ,    RW, default = 128  wt accoring current wt position
#define ISP_SNR_SAD_IDX_RATIO                      ((0x0a21  << 2) + 0xff000000)
//Bit 31:24        reg_snr_sad_idx_ratio_3   // unsigned ,    RW, default = 64  sad according candidate position
//Bit 23:16        reg_snr_sad_idx_ratio_2   // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_sad_idx_ratio_1   // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_sad_idx_ratio_0   // unsigned ,    RW, default = 64
#define ISP_SNR_SAD_IDX_OFFSET                     ((0x0a22  << 2) + 0xff000000)
//Bit 31:24        reg_snr_sad_idx_offset_3  // signed ,    RW, default = 0  sad according candidate position
//Bit 23:16        reg_snr_sad_idx_offset_2  // signed ,    RW, default = 0
//Bit 15: 8        reg_snr_sad_idx_offset_1  // signed ,    RW, default = 0
//Bit  7: 0        reg_snr_sad_idx_offset_0  // signed ,    RW, default = 0
#define ISP_SNR_VARIANCE_FLAT                      ((0x0a23  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:29        reg_snr_var_flat_mode     // unsigned ,    RW, default = 1  mode in calculate coring , 0 : sum,  1: max2 ,2: blend
//Bit 28           reg_snr_var_meta_en       // unsigned ,    RW, default = 0  check according meta enble
//Bit 27:25        reserved
//Bit 24:20        reg_snr_var_meta_th       // unsigned ,    RW, default = 4  of meta in variance  (0-16)
//Bit 19: 8        reg_snr_var_flat_th_x0    // unsigned ,    RW, default = 64  x0 of the variance
//Bit  7: 4        reg_snr_var_flat_th_x1    // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_var_flat_th_x2    // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_VARIANCE_FLAT_GAIN                 ((0x0a24  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_snr_var_flat_th_y_2   // unsigned ,    RW, default = 32  value of variance gain
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_var_flat_th_y_1   // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_var_flat_th_y_0   // unsigned ,    RW, default = 32
#define ISP_SNR_VARIANCE_EDGE                      ((0x0a25  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_snr_var_edge_mode     // unsigned ,    RW, default = 1  mode in calculate coring , 0 : sum,  1: max2 ,2: blend
//Bit 23:20        reg_snr_var_edge_weight   // unsigned ,    RW, default = 8  weight in variance blend ,normal 16 as 1
//Bit 19: 8        reg_snr_var_edge_th_x0    // unsigned ,    RW, default = 64  x0 of the variance
//Bit  7: 4        reg_snr_var_edge_th_x1    // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_var_edge_th_x2    // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_VARIANCE_EDGE_GAIN                 ((0x0a26  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_snr_var_edge_th_y_2   // unsigned ,    RW, default = 32  value of variance gain
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_var_edge_th_y_1   // unsigned ,    RW, default = 32
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_var_edge_th_y_0   // unsigned ,    RW, default = 32
#define ISP_SNR_VARIANCE_BL                        ((0x0a27  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16:12        reg_snr_var_coring_ratio  // unsigned ,    RW, default = 16  coring ratio
//Bit 11: 0        reg_snr_var_bl            // unsigned ,    RW, default = 240  black level
#define ISP_SNR_CUR_WT_0                           ((0x0a28  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_1          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_0          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_1                           ((0x0a29  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_3          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_2          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_2                           ((0x0a2a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_5          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_4          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_WT_3                           ((0x0a2b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_cur_wt_7          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
//Bit 11: 0        reg_snr_cur_wt_6          // unsigned ,    RW, default = 255  cur point wt adjust according to meta
#define ISP_SNR_CUR_BLEND_RATIO                    ((0x0a2c  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_snr_blend_cur_ratio_3 // unsigned ,    RW, default = 0  cur blend ratio
//Bit 11: 8        reg_snr_blend_cur_ratio_2 // unsigned ,    RW, default = 0  cur blend ratio
//Bit  7: 4        reg_snr_blend_cur_ratio_1 // unsigned ,    RW, default = 0  cur blend ratio
//Bit  3: 0        reg_snr_blend_cur_ratio_0 // unsigned ,    RW, default = 0  cur blend ratio
#define ISP_SNR_LPF0                               ((0x0a2d  << 2) + 0xff000000)
//Bit 31:24        reg_snr_lpf_avg_comp_ratio // unsigned ,    RW, default = 16  ratio
//Bit 23:12        reg_snr_lpf_avg_th        // unsigned ,    RW, default = 1024  of avg in calculate lpf
//Bit 11: 0        reg_snr_lpf_min_th        // unsigned ,    RW, default = 100  of min in calculate lpf
#define ISP_SNR_LPF1                               ((0x0a2e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_snr_lpf_mm_diff_ratio // unsigned ,    RW, default = 16  of min/max
//Bit 23:12        reg_snr_lpf_mm_diff_th    // unsigned ,    RW, default = 1024  of min/max diff
//Bit 11: 0        reg_snr_lpf_max_th        // unsigned ,    RW, default = 100  of max in calculate lpf
#define ISP_SNR_STRENGHT                           ((0x0a2f  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_snr_dbg_wt_sft        // unsigned ,    RW, default = 2  weigh sum shift num
//Bit 27:20        reg_snr_wt_th             // unsigned ,    RW, default = 64  of wt used to calculate count sum
//Bit 19:17        reserved
//Bit 16:12        reg_snr_strenght_count_th // unsigned ,    RW, default = 16  of count sum reflect snr strenght
//Bit 11: 0        reg_snr_strenght_wt_th    // unsigned ,    RW, default = 1024  of wt sum reflect snr strenght
#define ISP_SNR_VAR_FLAT_LUMA_SCAL_0               ((0x0a30  << 2) + 0xff000000)
//Bit 31:24        reg_snr_var_flat_luma_gain_3 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_flat_luma_gain_2 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_flat_luma_gain_1 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_flat_luma_gain_0 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_FLAT_LUMA_SCAL_1               ((0x0a31  << 2) + 0xff000000)
//Bit 31:24        reg_snr_var_flat_luma_gain_7 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_flat_luma_gain_6 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_flat_luma_gain_5 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_flat_luma_gain_4 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_EDGE_LUMA_SCAL_0               ((0x0a32  << 2) + 0xff000000)
//Bit 31:24        reg_snr_var_edge_luma_gain_3 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_edge_luma_gain_2 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_edge_luma_gain_1 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_edge_luma_gain_0 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_EDGE_LUMA_SCAL_1               ((0x0a33  << 2) + 0xff000000)
//Bit 31:24        reg_snr_var_edge_luma_gain_7 // unsigned ,    RW, default = 64
//Bit 23:16        reg_snr_var_edge_luma_gain_6 // unsigned ,    RW, default = 64
//Bit 15: 8        reg_snr_var_edge_luma_gain_5 // unsigned ,    RW, default = 64
//Bit  7: 0        reg_snr_var_edge_luma_gain_4 // unsigned ,    RW, default = 64
#define ISP_SNR_VAR_LUMA_RS                        ((0x0a34  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_snr_var_edge_luma_idx_rs // unsigned ,    RW, default = 9
//Bit  3: 0        reg_snr_var_flat_luma_idx_rs // unsigned ,    RW, default = 9
#define ISP_SNR_WT_VAR_ADJ_X                       ((0x0a35  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27           reg_snr_wt_var_adj_en     // unsigned ,    RW, default = 0  adjust variance enable
//Bit 26:24        reserved
//Bit 23:20        reg_snr_wt_var_meta_th    // unsigned ,    RW, default = 0
//Bit 19: 8        reg_snr_wt_var_th_x0      // unsigned ,    RW, default = 1024  x0 of the variance
//Bit  7: 4        reg_snr_wt_var_th_x1      // unsigned ,    RW, default = 4  = x0 + (1<<x1)
//Bit  3: 0        reg_snr_wt_var_th_x2      // unsigned ,    RW, default = 5  = x0 + (1<<x1) + (1<<x2)
#define ISP_SNR_WT_VAR_ADJ_Y                       ((0x0a36  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_snr_wt_var_th_y_2     // unsigned ,    RW, default = 32  value of variance gain
//Bit 15: 8        reg_snr_wt_var_th_y_1     // unsigned ,    RW, default = 32
//Bit  7: 0        reg_snr_wt_var_th_y_0     // unsigned ,    RW, default = 32
#define ISP_SNR_NP_LUT0_0                          ((0x0a37  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_1        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_0        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_1                          ((0x0a38  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_3        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_2        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_2                          ((0x0a39  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_5        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_4        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_3                          ((0x0a3a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_7        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_6        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_4                          ((0x0a3b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_9        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_8        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_5                          ((0x0a3c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_11       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_10       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_6                          ((0x0a3d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_13       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_12       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_NP_LUT0_7                          ((0x0a3e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_snr_np_lut16_15       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_snr_np_lut16_14       // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_SNR_LPF_PHS_DIFF                       ((0x0a3f  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_snr_lpf_use_diff_phs_en // unsigned ,    RW, default = 0  enable of use different phs in snr
//Bit 18           reg_snr_lpf_chk_edge_flag_en // unsigned ,    RW, default = 0  enable of edge check
//Bit 17           reg_snr_lpf_chk_xrate_en  // unsigned ,    RW, default = 0  of check the same phs diff and random phs diff
//Bit 16           reg_snr_lpf_xrate_chk_edge_en // unsigned ,    RW, default = 0  of edge check in check xrate
//Bit 15:12        reserved
//Bit 11: 0        reg_snr_lpf_phs_diff_max  // unsigned ,    RW, default = 400  threshold of phs_th
#define ISP_SNR_WT_ADJ                             ((0x0a42  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_snr_sad_wt_add_th_ratio // unsigned ,    RW, default = 8  of wt add
//Bit 11: 4        reg_snr_sad_wt_count_th   // unsigned ,    RW, default = 4  of sad sum count
//Bit  3: 2        reserved
//Bit  1           reg_snr_sad_wt_add_en     // unsigned ,    RW, default = 0  enable of add wt adjust according to target snr intensity
//Bit  0           reg_snr_sad_wt_adjust_en  // unsigned ,    RW, default = 0  enable of wt adjust according to target snr intensity
#define ISP_SNR_SAD_MAP_FLAT_TH                    ((0x0a43  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:20        reg_snr_sad_flat_th_1     // unsigned ,    RW, default = 32
//Bit 19:18        reserved
//Bit 17: 8        reg_snr_sad_flat_th_0     // unsigned ,    RW, default = 800  of  sad for check flat
//Bit  7: 0        reg_snr_sad_wt_add_wt_th  // unsigned ,    RW, default = 32  of  wt for add wt
#define ISP_SNR_SAD_MAP_EDGE_TH                    ((0x0a44  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:12        reg_snr_sad_edge_th_1     // unsigned ,    RW, default = 32
//Bit 11:10        reserved
//Bit  9: 0        reg_snr_sad_edge_th_0     // unsigned ,    RW, default = 800  of  sad for check edge
#define ISP_SNR_SAD_MAP_EDGE_TH1                   ((0x0a45  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_snr_sad_edge_th_2     // unsigned ,    RW, default = 32
#define ISP_SNR_SAD_MAP_TXT_TH                     ((0x0a46  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:12        reg_snr_sad_txt_th_1      // unsigned ,    RW, default = 32
//Bit 11:10        reserved
//Bit  9: 0        reg_snr_sad_txt_th_0      // unsigned ,    RW, default = 800  of  sad for txt edge
#define ISP_SNR_WT_ADJ_SUM_TH                      ((0x0a47  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_snr_sad_wt_sum_th_1   // unsigned ,    RW, default = 512  threshold of target snr intensity
//Bit 15:13        reserved
//Bit 12: 0        reg_snr_sad_wt_sum_th_0   // unsigned ,    RW, default = 1024  threshold of target snr intensity
#define ISP_SNR_MV_CORING_GAIN                     ((0x0a48  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:20        reg_snr_coring_mv_gain_x  // unsigned ,    RW, default = 5  x0 of the mv for coring adjust
//Bit 19            reserved
//Bit 18:16        reg_snr_coring_mv_gain_xn // unsigned ,    RW, default = 5  = x0 + 1<<xn
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_coring_mv_gain_y_1 // unsigned ,    RW, default = 16  value of mv gain for coring adjust
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_coring_mv_gain_y_0 // unsigned ,    RW, default = 16
#define ISP_SNR_MV_WT_GAIN                         ((0x0a49  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:20        reg_snr_wt_mv_gain_x      // unsigned ,    RW, default = 5  x0 of the mv for wt adjust
//Bit 19            reserved
//Bit 18:16        reg_snr_wt_mv_gain_xn     // unsigned ,    RW, default = 5  = x0 + 1<<xn
//Bit 15:14        reserved
//Bit 13: 8        reg_snr_wt_mv_gain_y_1    // unsigned ,    RW, default = 16  value of mv gain for wt adjust
//Bit  7: 6        reserved
//Bit  5: 0        reg_snr_wt_mv_gain_y_0    // unsigned ,    RW, default = 16
#define ISP_SNR_PHS_SEL_ADDR                       ((0x0a50  << 2) + 0xff000000)
//Bit 31:3        reserved
//Bit 2:0         reg_snr_phs_sel_addr       // unsigned ,    RW, default = 0
#define ISP_SNR_PHS_SEL_DATA                       ((0x0a51  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:0         reg_snr_phs_sel_data     // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_snr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TNR0_APB_BASE = 0x0b
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_mcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_CTRL                            ((0x0b00  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:18        reserved
//Bit 17:16        reg_xphs_ofst             // unsigned ,    RW, default = 1  default:1, range:0~3
//Bit 15:10        reserved
//Bit  9: 8        reg_yphs_ofst             // unsigned ,    RW, default = 0  default:0, range:0~3
//Bit  7: 0        reserved
#define ISP_CUBICT_MIX_CTRL                        ((0x0b01  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21           reg_mix_lpf_en            // unsigned ,    RW, default = 0  lpf enable
//Bit 20:18        reserved
//Bit 17: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_0                ((0x0b02  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_0         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_1                ((0x0b03  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_1         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_2                ((0x0b04  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_2         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_3                ((0x0b05  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_3         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
#define ISP_CUBICT_CHNMIXGAIN_LUT_4                ((0x0b06  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_chnmix_gain_4         // unsigned ,    RW, default = 1  gain to each channel data for mixxing
//Bit 23: 0        reserved
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_mcnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_BW_MODE                         ((0x0b07  << 2) + 0xff000000)
//Bit 31:24        reg_mix_sad_bw_mode       // unsigned ,    RW, default = 0
//Bit 23: 0        reserved
#define ISP_CUBICT_TNR_WINS_CRTL                   ((0x0b08  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reserved
//Bit 27:20        reserved
//Bit 19:12        reg_ma_mix_th_iso_gain    // unsigned ,    RW, default = 32  iso_gain
//Bit 11: 8        reg_ma_tnr_winw           // unsigned ,    RW, default = 3  tnr window width
//Bit  7: 0        reserved
#define ISP_CUBICT_HIGH_MIX_THRD_Y                 ((0x0b09  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_h_th_y0        // unsigned ,    RW, default = 30  curve value of mix_h_thrd
//Bit 15: 8        reg_ma_mix_h_th_y1        // unsigned ,    RW, default = 40  curve value of mix_h_thrd
//Bit  7: 0        reg_ma_mix_h_th_y2        // unsigned ,    RW, default = 50  curve value of mix_h_thrd
#define ISP_CUBICT_MIX_THRD_X                      ((0x0b0a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_th_x0          // unsigned ,    RW, default = 30  threshold x0 of the curve
//Bit 15:12        reserved
//Bit 11: 8        reg_ma_mix_th_x1          // unsigned ,    RW, default = 4  threshold x0 + (1<<x1)
//Bit  7: 4        reserved
//Bit  3: 0        reg_ma_mix_th_x2          // unsigned ,    RW, default = 4  threshold x0 + (1<<x1) + (1<<x2)
#define ISP_CUBICT_LOW_MIX_THRD_Y                  ((0x0b0b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ma_mix_l_th_y0        // unsigned ,    RW, default = 15  curve value of mix_l_thrd
//Bit 15: 8        reg_ma_mix_l_th_y1        // unsigned ,    RW, default = 25  curve value of mix_l_thrd
//Bit  7: 0        reg_ma_mix_l_th_y2        // unsigned ,    RW, default = 35  curve value of mix_l_thrd
#define ISP_CUBICT_ERR_MIX_RATIO                   ((0x0b0c  << 2) + 0xff000000)
//Bit 31:20        reg_ma_sad_luma_adj_x2    // unsigned ,    RW, default = 42  threshold x2 of luma scale
//Bit 19: 8        reg_ma_sad_luma_adj_x3    // unsigned ,    RW, default = 58  threshold x3 of luma scale
//Bit  7: 0        reg_ma_mix_ratio          // unsigned ,    RW, default = 64
#define ISP_CUBICT_SAD_LUMA_GAIN_X                 ((0x0b0d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ma_sad_luma_adj_x0    // unsigned ,    RW, default = 30  threshold x0 of luma scale
//Bit 15: 4        reg_ma_sad_luma_adj_x1    // unsigned ,    RW, default = 36  threshold x1 of luma scale
//Bit  3: 0        reserved
#define ISP_CUBICT_SAD_LUMA_GAIN_Y                 ((0x0b0e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_ma_sad_luma_adj_y_0   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 23:18        reg_ma_sad_luma_adj_y_1   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 17:12        reg_ma_sad_luma_adj_y_2   // unsigned ,    RW, default = 16  luma gain for sad
//Bit 11: 6        reg_ma_sad_luma_adj_y_3   // unsigned ,    RW, default = 16  luma gain for sad
//Bit  5: 0        reg_ma_sad_luma_adj_y_4   // unsigned ,    RW, default = 16  luma gain for sad
#define ISP_CUBICT_SAD_CORING_NP_CRTL              ((0x0b0f  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_ma_sad_cor_manual_mode // unsigned ,    RW, default = 0  0: get sad_coring according to noise profile; 1 : get sad_coring according to default curve
//Bit 15: 8        reg_ma_tnr_sad_cor_np_gain // unsigned ,    RW, default = 64  increase flexibility of LUT noise profile tuning
//Bit  7: 0        reg_ma_tnr_sad_cor_np_ofst // signed ,    RW, default = 0  increase flexibility of lut noise profile tuning
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y0       ((0x0b10  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y0          // unsigned ,    RW, default = 8  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y1       ((0x0b11  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y1          // unsigned ,    RW, default = 32  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_Y2       ((0x0b12  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_ma_sad_th_y2          // unsigned ,    RW, default = 56  value of sad_thd
#define ISP_CUBICT_SAD_CORING_MANUAL_CURV_X        ((0x0b13  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ma_sad_th_x0          // unsigned ,    RW, default = 64  x0 of thr curve
//Bit  7: 4        reg_ma_sad_th_x1          // unsigned ,    RW, default = 5  threshold x0 + (1<<x1)
//Bit  3: 0        reg_ma_sad_th_x2          // unsigned ,    RW, default = 5  threshold x0 + (1<<x1) + (1<<x2)
#define ISP_CUBICT_MASK_GAIN_0                     ((0x0b14  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_0 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_1                     ((0x0b15  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_1 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_2                     ((0x0b16  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_2 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MASK_GAIN_3                     ((0x0b17  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_th_mask_gain_3 // unsigned ,    RW, default = 16  4, mask gain for sad_coring
#define ISP_CUBICT_MIX_THD_MASK_GAIN_0             ((0x0b18  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_0 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_1             ((0x0b19  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_1 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_2             ((0x0b1a  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_2 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_MIX_THD_MASK_GAIN_3             ((0x0b1b  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_mix_th_mask_gain_3 // unsigned ,    RW, default = 16  4, mask gain for mix thd
#define ISP_CUBICT_SAD_VAR_GAIN_X                  ((0x0b1c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ma_sad_var_th_x0      // unsigned ,    RW, default = 50  variance for cur block
//Bit 15:12        reg_ma_sad_var_th_x1      // unsigned ,    RW, default = 4
//Bit 11: 8        reg_ma_sad_var_th_x2      // unsigned ,    RW, default = 5
//Bit  7: 0        reserved
#define ISP_CUBICT_SAD_VAR_GAIN_Y                  ((0x0b1d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:20        reg_ma_sad_var_th_y_0     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit 19:14        reg_ma_sad_var_th_y_1     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit 13: 8        reg_ma_sad_var_th_y_2     // unsigned ,    RW, default = 32  variance gain for cur block
//Bit  7: 0        reserved
#define ISP_CUBICT_DETAIL_CORING                   ((0x0b1e  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_sad_pdtl_cor_ratio // unsigned ,    RW, default = 64  soft coring to |Y-APL|
#define ISP_CUBICT_DETAIL_CURV_X                   ((0x0b1f  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ma_sad_pdtl4_x0       // unsigned ,    RW, default = 2  pdtl_10bits threshold0 of the curv
//Bit  7: 4        reg_ma_sad_pdtl4_x1       // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit  3: 0        reg_ma_sad_pdtl4_x2       // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 + 2^th2 to get the th1 of the curv
#define ISP_CUBICT_DETAIL_CURV_Y                   ((0x0b20  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_ma_sad_pdtl4_y0       // unsigned ,    RW, default = 12  curve value0 of pdtl_10bits <= th0
//Bit 23:20        reserved
//Bit 19:16        reg_ma_sad_pdtl4_y1       // unsigned ,    RW, default = 8  curve value1 of pdtl_10bits == th1
//Bit 15:12        reserved
//Bit 11: 8        reg_ma_sad_pdtl4_y2       // unsigned ,    RW, default = 2  curve value2 of pdtl_10bits >= th2
//Bit  7: 0        reserved
#define ISP_CUBICT_ZMV_CURV_X                      ((0x0b21  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 4        reg_ma_sad_zmv_x0         // unsigned ,    RW, default = 2112  threshold 0 of the curv
//Bit  3: 0        reg_ma_sad_zmv_x1         // unsigned ,    RW, default = 6  sad_z threshold1 = th0 + 2^thn to get the th1 of the curv
#define ISP_CUBICT_ZMV_CURV_Y                      ((0x0b22  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_ma_sad_zmv_y0         // unsigned ,    RW, default = 4  gain of sad_z <= th0
//Bit 23:20        reg_ma_sad_zmv_y1         // unsigned ,    RW, default = 9  gain of sad_z >= th1
//Bit 19: 0        reserved
#define ISP_CUBICT_WTSAD_CRTL                      ((0x0b23  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4: 1        reg_ma_wtsad_div          // unsigned ,    RW, default = 2  right shift of sad*(dtl_4b+sad_gain_4b)>> div
//Bit  0           reg_ma_wtsad_sel          // unsigned ,    RW, default = 0  0:output pure_sad; 1: output wt_sad
#define ISP_CUBICT_ALPHA_LUMA_GAIN_BLC             ((0x0b24  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_ma_meta_luma_gain     // unsigned ,    RW, default = 10  luma_gain for meta
//Bit 11: 0        reg_ma_meta_luma_blc      // unsigned ,    RW, default = 0  luma black level for -blc
#define ISP_CUBICT_META_PP0                        ((0x0b25  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:26        reserved
//Bit 25:22        reg_ma_dil_winw           // unsigned ,    RW, default = 2  half width for dilate operation
//Bit 21:18        reg_ma_dil_winh           // unsigned ,    RW, default = 2  half height for dilate operation
//Bit 17:14        reg_ma_ero_winw           // unsigned ,    RW, default = 1  half width for erase operation
//Bit 13:10        reg_ma_ero_winh           // unsigned ,    RW, default = 1  half height for erase operation
//Bit  9: 0        reserved
#define ISP_CUBICT_META_PP1                        ((0x0b26  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_ma_lpf_winw           // unsigned ,    RW, default = 1  half width for lpf
//Bit 19:16        reg_ma_lpf_winh           // unsigned ,    RW, default = 1  half height for lpf
//Bit 15:12        reg_ma_sta_winw           // unsigned ,    RW, default = 2  half width for statistic
//Bit 11: 8        reg_ma_sta_winh           // unsigned ,    RW, default = 2  half height for statistic
//Bit  7: 0        reserved
#define ISP_CUBICT_META_PP2                        ((0x0b27  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_ma_meta_pp_sta_stl_ratio // unsigned ,    RW, default = 12  statistic still ratio
//Bit 19:16        reg_ma_meta_pp_sta_mv_ratio // unsigned ,    RW, default = 12  statistic moving ratio
//Bit 15:12        reg_ma_meta_pp_sta_mv2stl_bnd // unsigned ,    RW, default = 0  moving to still boundary <
//Bit 11: 8        reg_ma_meta_pp_sta_stl2mv_bnd // unsigned ,    RW, default = 0  still to moving boundary >
//Bit  7: 6        reg_ma_meta_pp_mode       // unsigned ,    RW, default = 0  0: no pp for meta; 1: lpf; 2: local statistic
//Bit  5: 0        reserved
#define ISP_CUBICT_GLOBAL_INFO                     ((0x0b28  << 2) + 0xff000000)
//Bit 31: 0        ro_global_info            // unsigned ,    RO, default = 0  statistic of global SAD
#define ISP_CUBICT_GLOBAL_STL_SAD_INFO             ((0x0b29  << 2) + 0xff000000)
//Bit 31: 0        ro_global_stl_sad_diff    // unsigned ,    RO, default = 0  statistic of SAD of still region
#define ISP_CUBICT_GLOBAL_MV_SAD_INFO              ((0x0b2a  << 2) + 0xff000000)
//Bit 31: 0        ro_global_mv_sad_diff     // unsigned ,    RO, default = 0  statistic of SAD of mv region
#define ISP_CUBICT_GLOBAL_MV_CNT                   ((0x0b2b  << 2) + 0xff000000)
//Bit 31: 0        ro_global_mv_cnt          // unsigned ,    RO, default = 0  mv pixel number
#define ISP_CUBICT_GLOBAL_STL_CNT                  ((0x0b2c  << 2) + 0xff000000)
//Bit 31: 0        ro_global_stl_cnt         // unsigned ,    RO, default = 0  statistic still pixel number
#define ISP_CUBICT_GLOBAL_STAT_WINDOW              ((0x0b2d  << 2) + 0xff000000)
//Bit 31:16        reg_ro_winv_st            // unsigned ,    RW, default = 0  window_start
//Bit 15: 0        reg_ro_winv_ed            // unsigned ,    RW, default = 960  window_end
#define ISP_CUBICT_SAD_SUM_IN_SECTION_0            ((0x0b2e  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_0  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_1            ((0x0b2f  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_1  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_2            ((0x0b30  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_2  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_3            ((0x0b31  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_3  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_4            ((0x0b32  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_4  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_5            ((0x0b33  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_5  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_6            ((0x0b34  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_6  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_7            ((0x0b35  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_7  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_8            ((0x0b36  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_8  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_9            ((0x0b37  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_9  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_10           ((0x0b38  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_10 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_11           ((0x0b39  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_11 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_12           ((0x0b3a  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_12 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_13           ((0x0b3b  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_13 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_14           ((0x0b3c  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_14 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_SUM_IN_SECTION_15           ((0x0b3d  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_sum_sect_15 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store sum of sad in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_0            ((0x0b3e  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_0  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_1            ((0x0b3f  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_1  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_2            ((0x0b40  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_2  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_3            ((0x0b41  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_3  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_4            ((0x0b42  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_4  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_5            ((0x0b43  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_5  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_6            ((0x0b44  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_6  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_7            ((0x0b45  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_7  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_8            ((0x0b46  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_8  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_9            ((0x0b47  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_9  // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_10           ((0x0b48  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_10 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_11           ((0x0b49  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_11 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_12           ((0x0b4a  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_12 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_13           ((0x0b4b  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_13 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_14           ((0x0b4c  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_14 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_SAD_CNT_IN_SECTION_15           ((0x0b4d  << 2) + 0xff000000)
//Bit 31: 0        ro_global_sad_cnt_sect_15 // unsigned ,    RO, default = 0  statistic of SAD of all pixel, store num in sections according to apl
#define ISP_CUBICT_GLOBAL_RATIO                    ((0x0b4e  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_global_sad_thd_ratio // unsigned ,    RW, default = 16  ratio for sad_thd for abs(mix0[i],mix[1]), norm to 16
#define ISP_CUBICT_ADP_GLOBAL_MIX_THD              ((0x0b4f  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_adp_global_mix_th_ratio // unsigned ,    RW, default = 64  ratio for adaptive mix thd if global motion, norm to 64
#define ISP_CUBICT_ADP_DTL_NFL                     ((0x0b50  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_ma_adp_dtl_mix_th_nfl // unsigned ,    RW, default = 0  detail floor for adaptive mix , norm to 64
#define ISP_CUBICT_MIX_H_GAIN                      ((0x0b51  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:18        reg_ma_mix_h_th_gain_0    // unsigned ,    RW, default = 16  low
//Bit 17:12        reg_ma_mix_h_th_gain_1    // unsigned ,    RW, default = 16
//Bit 11: 6        reg_ma_mix_h_th_gain_2    // unsigned ,    RW, default = 16
//Bit  5: 0        reg_ma_mix_h_th_gain_3    // unsigned ,    RW, default = 16  high
#define ISP_CUBICT_MIX_L_GAIN                      ((0x0b52  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:12        reg_ma_mix_l_th_gain      // unsigned ,    RW, default = 16  low mix gain for delta step decision, still, max
//Bit 11: 0        reserved
#define ISP_CUBICT_DELTA_STEP                      ((0x0b53  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_ma_meta_delt_0        // signed ,    RW, default = 1  still
//Bit 15:12        reg_ma_meta_delt_1        // signed ,    RW, default = 0  keep
//Bit 11: 8        reg_ma_meta_delt_2        // signed ,    RW, default = -7  move
//Bit  7: 0        reserved
#define ISP_CUBICT_MIX_P1_SEL                      ((0x0b54  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11            reserved
//Bit 10           reg_mix_p1_is_iir         // unsigned ,    RW, default = 1  0:mix_p1 is original p1; 1:mix_p1 is iir[0] data
//Bit  9: 0        reserved
#define ISP_TNR_NP_LUT_0                           ((0x0b55  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_1         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_0         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_1                           ((0x0b56  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_3         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_2         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_2                           ((0x0b57  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_5         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_4         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_3                           ((0x0b58  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_7         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_6         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_4                           ((0x0b59  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_9         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_8         // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_5                           ((0x0b5a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_11        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_10        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_6                           ((0x0b5b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_13        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_12        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_TNR_NP_LUT_7                           ((0x0b5c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_ma_np_lut16_15        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
//Bit 11: 0        reg_ma_np_lut16_14        // unsigned ,    RW, default = 10  weight lut for snr weighted sum
#define ISP_LOSS_CORING_META2ALP_0                 ((0x0b5d  << 2) + 0xff000000)
//Bit 31:24        reg_loss_lut_meta2alp_3   // unsigned ,    RW, default = 48  adjust coring according meta
//Bit 23:16        reg_loss_lut_meta2alp_2   // unsigned ,    RW, default = 64  adjust coring according meta
//Bit 15: 8        reg_loss_lut_meta2alp_1   // unsigned ,    RW, default = 120  adjust coring according meta
//Bit  7: 0        reg_loss_lut_meta2alp_0   // unsigned ,    RW, default = 240  adjust coring according meta
#define ISP_LOSS_CORING_META2ALP_1                 ((0x0b5e  << 2) + 0xff000000)
//Bit 31:24        reg_loss_lut_meta2alp_7   // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 23:16        reg_loss_lut_meta2alp_6   // unsigned ,    RW, default = 16  adjust coring according meta
//Bit 15: 8        reg_loss_lut_meta2alp_5   // unsigned ,    RW, default = 24  adjust coring according meta
//Bit  7: 0        reg_loss_lut_meta2alp_4   // unsigned ,    RW, default = 32  adjust coring according meta
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_tnr_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CUBICT_ALPHA0_LUT_ADDR                 ((0x0b6d  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4:0         reg_lut_meta_sad_2alpha_addr       // unsigned ,    RW, default = 0
#define ISP_CUBICT_ALPHA0_LUT_DATA                 ((0x0b6e  << 2) + 0xff000000)
//Bit 31:0         reg_lut_meta_sad_2alpha_data     // unsigned ,    RW, default = 0
#define ISP_CUBICT_TOP_HW_CTRL                     ((0x0b7f  << 2) + 0xff000000)
//Bit 31:0         reg_tnr_mcnr_ctrl         // unsigned , RW ,default = 0 first frame flag ctrl reg
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_tnr_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_TNR1_APB_BASE = 0x0c
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_mcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_MCNR_DS                                ((0x0c00  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:14        reg_me_dsx_scale          // unsigned ,    RW, default = 1  downscale mode of x direction for me input data; 0: no downscale; 1:1/2 downscale; 2:1/4 downscale
//Bit 13:12        reg_me_dsy_scale          // unsigned ,    RW, default = 1  downscale mode of y direction for me input data; 0: no downscale; 1:1/2 downscale; 2:1/4 downscale
//Bit 11:10        reg_me_mvx_div_mode       // unsigned ,    RW, default = 0  0: MVx has 2bits decimal; 1: 3bits decimal; 2: 4bits decimal @ME resolution.
//Bit  9: 8        reg_me_mvy_div_mode       // unsigned ,    RW, default = 0  0: MVy has 2bits decimal; 1: 3bits decimal; 2: 4bits decimal @ME resolution.
//Bit  7: 0        reg_me_mv_var_th          // unsigned ,    RW, default = 5  the threshold of diff mvx/mvy as one group
#define ISP_MCNR_ST_CMV_0                          ((0x0c01  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_0    // signed ,    RW, default = 0  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_0    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_0       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_0      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_1                          ((0x0c02  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_1    // signed ,    RW, default = 0  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_1    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_1       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_1      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_2                          ((0x0c03  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_2    // signed ,    RW, default = -1  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_2    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_2       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_2      // unsigned ,    RW, default = 42  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_3                          ((0x0c04  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_3    // signed ,    RW, default = 1  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_3    // signed ,    RW, default = -1  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_3       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_3      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_4                          ((0x0c05  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_4    // signed ,    RW, default = -2  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_4    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_4       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_4      // unsigned ,    RW, default = 44  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_5                          ((0x0c06  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_5    // signed ,    RW, default = 2  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_5    // signed ,    RW, default = 2  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_5       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_5      // unsigned ,    RW, default = 56  static penalty for S and T candidate
#define ISP_MCNR_ST_CMV_6                          ((0x0c07  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_me_cmv_s_t_pos_x_6    // signed ,    RW, default = -3  / temporal candidate x offset
//Bit 11: 9        reg_me_cmv_s_t_pos_y_6    // signed ,    RW, default = 0  / temporal candidate y offset
//Bit  8           reg_me_add_s_t_en_6       // unsigned ,    RW, default = 1  of st cmv
//Bit  7: 0        reg_me_penalty_s_t_6      // unsigned ,    RW, default = 56  static penalty for S and T candidate
#define ISP_MCNR_RAND_CMV_0                        ((0x0c08  << 2) + 0xff000000)
//Bit 31:28        reg_me_rad_x1_max_0       // unsigned ,    RW, default = 1  max random offset for the cmv (0~+15) random candidate
//Bit 27:24        reg_me_rad_x2_max_0       // unsigned ,    RW, default = 3  max random offset for the cmv (0~+15) random candidate
//Bit 23:20        reg_me_rad_y1_max_0       // unsigned ,    RW, default = 1  max random offset for the cmv (0~+15) random candidate
//Bit 19:16        reg_me_rad_y2_max_0       // unsigned ,    RW, default = 2  max random offset for the cmv (0~+15) random candidate
//Bit 15:14        reserved
//Bit 13:11        reg_me_cmv_rad_pos_x_0    // signed ,    RW, default = -1  random candidate x offset
//Bit 10: 9        reg_me_cmv_rad_pos_y_0    // signed ,    RW, default = -1  random candidate x offset
//Bit  8           reg_me_add_rad_en_0       // unsigned ,    RW, default = 1  enable of random candidate
//Bit  7: 0        reg_me_penalty_rad_0      // unsigned ,    RW, default = 60  static penalty for random candidate
#define ISP_MCNR_RAND_CMV_1                        ((0x0c09  << 2) + 0xff000000)
//Bit 31:28        reg_me_rad_x1_max_1       // unsigned ,    RW, default = 5  max random offset for the cmv (0~+15) random candidate
//Bit 27:24        reg_me_rad_x2_max_1       // unsigned ,    RW, default = 11  max random offset for the cmv (0~+15) random candidate
//Bit 23:20        reg_me_rad_y1_max_1       // unsigned ,    RW, default = 4  max random offset for the cmv (0~+15) random candidate
//Bit 19:16        reg_me_rad_y2_max_1       // unsigned ,    RW, default = 8  max random offset for the cmv (0~+15) random candidate
//Bit 15:14        reserved
//Bit 13:11        reg_me_cmv_rad_pos_x_1    // signed ,    RW, default = 1  random candidate x offset
//Bit 10: 9        reg_me_cmv_rad_pos_y_1    // signed ,    RW, default = -1  random candidate x offset
//Bit  8           reg_me_add_rad_en_1       // unsigned ,    RW, default = 1  enable of random candidate
//Bit  7: 0        reg_me_penalty_rad_1      // unsigned ,    RW, default = 100  static penalty for random candidate
#define ISP_MCNR_RAND_SEED_INT                     ((0x0c0a  << 2) + 0xff000000)
//Bit 31:16        reg_me_rand_seed_mvx      // unsigned ,    RW, default = 43981  random seed for the LFSR for mvx integer part
//Bit 15: 0        reg_me_rand_seed_mvy      // unsigned ,    RW, default = 39304  random seed for the LFSR for mvy integer part
#define ISP_MCNR_RAND_SEED_FRAC                    ((0x0c0b  << 2) + 0xff000000)
//Bit 31:16        reg_me_rand_seed_mvq      // unsigned ,    RW, default = 14392  random seed for the LFSR for mvx/mvy fractional part
//Bit 15: 0        reserved
#define ISP_MCNR_ZMV                               ((0x0c0c  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_me_penalty_zmv        // unsigned ,    RW, default = 18  static zmv penalty
//Bit  7: 3        reserved
//Bit  2           reg_dym_zmv_penalty_en    // unsigned ,    RW, default = 1  enable of dynamic zmv penalty, 0 use reg_me_penalty_zmv; 1: use the dym one
//Bit  1: 0        reg_dym_zmv_penalty_div   // unsigned ,    RW, default = 0  normalized to (gain_dlt_z + gain_sad_z),
#define ISP_MCNR_ZMV_DETAIL                        ((0x0c0d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_detail_zmv_th0        // unsigned ,    RW, default = 64  threshold 0 of the curv
//Bit 15:12        reserved
//Bit 11: 8        reg_detail_zmv_thn        // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  7: 4        reg_detail_zmv_gain0      // unsigned ,    RW, default = 15  gain of pdtl_10bits <= th0  (TBC, changed from ppt)
//Bit  3: 0        reg_detail_zmv_gain1      // unsigned ,    RW, default = 4  gain of pdtl_10bits >= th1
#define ISP_MCNR_ZMV_SAD                           ((0x0c0e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_sad_zmv_th0           // unsigned ,    RW, default = 4224  threshold 0 of the curv
//Bit 15:12        reserved
//Bit 11: 8        reg_sad_zmv_thn           // unsigned ,    RW, default = 6  sad_z threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  7: 4        reg_sad_zmv_gain0         // unsigned ,    RW, default = 4  gain of sad_z <= th0  (TBC, changed from ppt)
//Bit  3: 0        reg_sad_zmv_gain1         // unsigned ,    RW, default = 9  gain of sad_z >= th1
#define ISP_MCNR_PURE_DETAIL                       ((0x0c0f  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reg_sad_pdtl_mode_sel     // unsigned ,    RW, default = 1  sad pure detail 10bit sel mode, default = 1, 0: MIN ; 1: MAX; 2/3: AVG
//Bit  9: 2        reg_sad_pdtl_core         // unsigned ,    RW, default = 1<<4  soft coring to |Y-APL|
//Bit  1: 0        reg_sad_pdtl4_mode_sel    // unsigned ,    RW, default = 1  sad pure detail 4bit sel mode, default = 1, 0: MIN ; 1: MAX; 2/3: AVG
#define ISP_MCNR_PURE_DETAIL_GAIN                  ((0x0c10  << 2) + 0xff000000)
//Bit 31:24        reg_sad_pdtl4_gain_th0    // unsigned ,    RW, default = 2  pdtl_10bits threshold 0 of the curv
//Bit 23:20        reg_sad_pdtl4_gain_th1    // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit 19:16        reg_sad_pdtl4_gain_th2    // unsigned ,    RW, default = 6  pdtl_10bits threshold1 = th0 + 2^th1 + 2^th2 to get the th1 of the curv
//Bit 15:12        reg_sad_pdtl4_gain0       // unsigned ,    RW, default = 12  gain value0 of pdtl_10bits <= th0  (TBC, changed from ppt)
//Bit 11: 8        reg_sad_pdtl4_gain1       // unsigned ,    RW, default = 8  gain value1 of pdtl_10bits == th1
//Bit  7: 4        reg_sad_pdtl4_gain2       // unsigned ,    RW, default = 2  gain value2 of pdtl_10bits >= th2
//Bit  3: 0        reserved
#define ISP_MCNR_PURE_SAD                          ((0x0c11  << 2) + 0xff000000)
//Bit 31:20        reg_me_sad_dc_curv_th0    // unsigned ,    RW, default = 16<<4  threshold 0 of the curv
//Bit 19:16        reg_me_sad_dc_curv_thn    // unsigned ,    RW, default = 7  threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit 15: 0        reserved
#define ISP_MCNR_MAXTRAN_CURVE                     ((0x0c12  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_me_sad_dc_curv0       // unsigned ,    RW, default = 4<<4  curve value0 of maxtran <= th0  (TBC, changed from ppt)
//Bit 11: 0        reg_me_sad_dc_curv1       // unsigned ,    RW, default = 8<<4  curve value1 of maxtran >= th1
#define ISP_MCNR_PURE_SAD_TH0                      ((0x0c13  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_me_sad_dc_mode_sel    // unsigned ,    RW, default = 1  maxtran sel mode, default = TBC, 0: MIN; 1: MAX; 2/3: AVG
//Bit 27:26        reg_me_sad_th_mode_sel    // unsigned ,    RW, default = 2  sad th mode_sel , 0: maxtran, 1:apl, other: noise profile
//Bit 25:18        reg_me_sad_th_curv_th0    // unsigned ,    RW, default = 64  threshold th0 of the curv
//Bit 17:15        reg_me_sad_th_curv_th1    // unsigned ,    RW, default = 5  threshold1 = th0 + 2^th1 to get the th1 of the curv
//Bit 14:12        reg_me_sad_th_curv_th2    // unsigned ,    RW, default = 5  threshold2 = th0 + 2^th2 to get the th1 of the curv
//Bit 11: 0        reg_me_sad_th_curv0       // unsigned ,    RW, default = 32  curve value0 of apl <= th0
#define ISP_MCNR_PURE_SAD_TH1                      ((0x0c14  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_me_sad_th_curv1       // unsigned ,    RW, default = 64  curve value0 of apl <= th1
//Bit 11: 0        reg_me_sad_th_curv2       // unsigned ,    RW, default = 96  curve value0 of apl <= th2
#define ISP_MCNR_PURE_SAD_NP_GAIN                  ((0x0c15  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_me_sad_cor_np_gain    // unsigned ,    RW, default = 64  noise profile gain, increase flexibility of LUT noise profile tuning
//Bit 15: 8        reg_me_sad_cor_np_ofst    // signed ,    RW, default = 0  noise profile ofst, increase flexibility of LUT noise profile tuning
//Bit  7: 0        reserved
#define ISP_MCNR_PURE_SAD_NP_LUT_0                 ((0x0c16  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_0         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_1                 ((0x0c17  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_1         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_2                 ((0x0c18  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_2         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_3                 ((0x0c19  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_3         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_4                 ((0x0c1a  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_4         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_5                 ((0x0c1b  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_5         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_6                 ((0x0c1c  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_6         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_7                 ((0x0c1d  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_7         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_8                 ((0x0c1e  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_8         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_9                 ((0x0c1f  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_9         // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_10                ((0x0c20  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_10        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_11                ((0x0c21  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_11        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_12                ((0x0c22  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_12        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_13                ((0x0c23  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_13        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_14                ((0x0c24  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_14        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_NP_LUT_15                ((0x0c25  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_me_np_lut16_15        // unsigned ,    RW, default = 0  noise profile lut, take apl
#define ISP_MCNR_PURE_SAD_TH_MASK_0                ((0x0c26  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_0 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_1                ((0x0c27  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_1 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_2                ((0x0c28  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_2 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_PURE_SAD_TH_MASK_3                ((0x0c29  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_sad_th_iso_mask_gain_3 // unsigned ,    RW, default = 512  iso gain normalize 32 as "1", mask gain normalize 16 as "1"
#define ISP_MCNR_MVDIFF                            ((0x0c2a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:26        reg_mvdiff_core           // unsigned ,    RW, default = 3  hard coring to mvdiff_count, <core, mvdiff set to 0;
//Bit 25:16        reg_mvdiff_smooth_th0     // unsigned ,    RW, default = 128  threshold 0 of the curv   (change name)
//Bit 15:12        reg_mvdiff_smooth_thn     // unsigned ,    RW, default = 6  mvdiff threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit 11: 8        reg_mvdiff_smooth_gain0   // unsigned ,    RW, default = 4  gain of mvdiff <= th0  (TBC, changed from ppt)
//Bit  7: 4        reg_mvdiff_smooth_gain1   // unsigned ,    RW, default = 12  gain of mvdiff >= th1
//Bit  3           reg_mvdiff_zmv_disable    // unsigned ,    RW, default = 1  calc mvdiff not contail zmv
//Bit  2: 0        reserved
#define ISP_MCNR_WEIGTH_SAD                        ((0x0c2b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:26        reg_wtdc_wsad_div         // unsigned ,    RW, default = 2  right shift of sad_dc*(dtl_4b+mvdiff_gain_4b)>> div
//Bit 25:16        reg_wtdc_pure_detail_max  // unsigned ,    RW, default = 512  max of pur detail (10bits) for pure_detail_tmp calculation
//Bit 15: 8        reg_wtdc_pure_detail_wt   // unsigned ,    RW, default = 0  gain (weight) to the pure_detail_tmp to get the DC_SAD_result, norm to 16 as "1"
//Bit  7: 4        reg_wtdc_mvdf_smooth_wt   // unsigned ,    RW, default = 0  gain (weight) to the mvdiff_10b to get the DC_SAD_result, norm to 4 as "1"
//Bit  3: 0        reserved
#define ISP_MCNR_SMOOTH_PROC_0                     ((0x0c2c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_me_periodic_apl_sel   // unsigned ,    RW, default = 0  apl selection for smooth proc.
//Bit 23:20        reg_me_periodic_apl_gain0 // unsigned ,    RW, default = 3  apl gain0 for smooth proc.
//Bit 19:16        reg_me_periodic_apl_gain1 // unsigned ,    RW, default = 4  apl gain1 for smooth proc.
//Bit 15:12        reg_me_periodic_apl_gain2 // unsigned ,    RW, default = 6  apl gain2 for smooth proc.
//Bit 11: 8        reg_me_periodic_apl_gain_th0 // unsigned ,    RW, default = 15  apl threshold0 for apl gain for smooth proc.
//Bit  7: 4        reg_me_periodic_apl_gain_th1 // unsigned ,    RW, default = 6  apl threshold1 for apl gain for smooth proc., th0 + 2^th1
//Bit  3: 0        reg_me_periodic_apl_gain_th2 // unsigned ,    RW, default = 6  apl threshold2 for apl gain for smooth proc., th0 + 2^th1 + 2^th2
#define ISP_MCNR_SMOOTH_PROC_1                     ((0x0c2d  << 2) + 0xff000000)
//Bit 31:24        reg_me_periodic_sad_similar_th1 // unsigned ,    RW, default = 0  threshold1 for similar sad decision
//Bit 23:16        reg_me_periodic_sad_similar_th2 // unsigned ,    RW, default = 0  threshold2 for similar sad decision
//Bit 15: 8        reg_me_periodic_sad_similar_th3 // unsigned ,    RW, default = 4  threshold3 for similar sad decision
//Bit  7: 0        reserved
#define ISP_MCNR_SMOOTH_PROC_2                     ((0x0c2e  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_me_periodic_sad_similar_th // unsigned ,    RW, default = 2  threshold for similar sad decision
//Bit 15: 8        reg_me_periodic_mv_diff_th // unsigned ,    RW, default = 40  diff for similar mvdiff decision
//Bit  7           reg_me_periodic_mv_diff_rule_en // unsigned ,    RW, default = 1  enable mv diff rule for periodic case
//Bit  6           reg_me_periodic_z_rule_en // unsigned ,    RW, default = 1  zero mv enable for periodic case
//Bit  5           reg_me_periodic_en        // unsigned ,    RW, default = 1  mv smooth enable
//Bit  4           reg_me_periodic_aplsad_rule_en // unsigned ,    RW, default = 1  mv smooth enable
//Bit  3: 0        reserved
#define ISP_MCNR_ZMV_PATCH_EN                      ((0x0c2f  << 2) + 0xff000000)
//Bit 31           reg_me_zmv_patch_en       // unsigned ,    RW, default = 0  enable zmv patch
//Bit 30:23        reg_me_zmv_patch_mv_length_th // unsigned ,    RW, default = 10  zmv patch mv length threshold
//Bit 22:13        reg_me_zmv_patch_sad_th   // unsigned ,    RW, default = 10  sad threshold
//Bit 12: 3        reg_me_zmv_patch_dtl_th   // unsigned ,    RW, default = 120  detail threshold
//Bit  2: 0        reserved
#define ISP_MCNR_ZMV_PATCH_PENALTY                 ((0x0c30  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_me_zmv_patch_penalty  // unsigned ,    RW, default = 10  zmv patch penalty
#define ISP_MCNR_SSAD_DETAIL                       ((0x0c31  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:21        reg_me_meta_mv_length_th  // unsigned ,    RW, default = 10  calc meta delta patch mv length threshold
//Bit 20           reg_me_meta_data_sad_sel  // unsigned ,    RW, default = 0  sad to generate meta delta, 0:pure_sad, 1:sad
//Bit 19:16        reg_me_ssad_detail_th0    // unsigned ,    RW, default = 4  static area sad detail threshold th0
//Bit 15:12        reg_me_ssad_detail_thn    // unsigned ,    RW, default = 2  static area sad detail threshold1 = th0+(1<<thn)
//Bit 11: 6        reg_me_ssad_detail_gain0  // unsigned ,    RW, default = 16  static area sad detail gain0, normalize 16 as"1"
//Bit  5: 0        reg_me_ssad_detail_gain1  // unsigned ,    RW, default = 8  static area sad detail gain1, normalize 16 as"1"
#define ISP_MCNR_MSAD_DETAIL                       ((0x0c32  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_me_msad_detail_th0    // unsigned ,    RW, default = 4  motion area sad detail threshold th0
//Bit 15:12        reg_me_msad_detail_thn    // unsigned ,    RW, default = 2  motion area sad detail threshold1 = th0+(1<<thn)
//Bit 11: 6        reg_me_msad_detail_gain0  // unsigned ,    RW, default = 16  static area sad detail gain0, normalize 16 as"1"
//Bit  5: 0        reg_me_msad_detail_gain1  // unsigned ,    RW, default = 16  static area sad detail gain1, normalize 16 as"1"
#define ISP_MCNR_MVDIFF_GAIN                       ((0x0c33  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:11        reg_me_sad_mvdiff_th0     // unsigned ,    RW, default = 128  sad mvdiff threshold th0
//Bit 10: 8        reg_me_sad_mvdiff_thn     // unsigned ,    RW, default = 6  sad mvdiff threshold1 = th0+(1<<thn)
//Bit  7: 4        reg_me_sad_mvdiff_gain0   // unsigned ,    RW, default = 4  mvdiff gain, 4 as 1
//Bit  3: 0        reg_me_sad_mvdiff_gain1   // unsigned ,    RW, default = 12  mvdiff gain, 4 as 1
#define ISP_MCNR_META_SAD_TH0                      ((0x0c34  << 2) + 0xff000000)
//Bit 31:24        reg_me_meta_sad_th0_0     // unsigned ,    RW, default = 60  static area sad th
//Bit 23:16        reg_me_meta_sad_th0_1     // unsigned ,    RW, default = 90  static area sad th
//Bit 15: 8        reg_me_meta_sad_th0_2     // unsigned ,    RW, default = 110  static area sad th
//Bit  7: 0        reg_me_meta_sad_th0_3     // unsigned ,    RW, default = 110  static area sad th
#define ISP_MCNR_META_DELTA_STEP0                  ((0x0c35  << 2) + 0xff000000)
//Bit 31:24        reg_me_meta_sad_th0_4     // unsigned ,    RW, default = 110  static area sad th
//Bit 23:20        reg_me_meta_delta_step0_0 // signed ,    RW, default = 1  meta delta step
//Bit 19:16        reg_me_meta_delta_step0_1 // signed ,    RW, default = 0  meta delta step
//Bit 15:12        reg_me_meta_delta_step0_2 // signed ,    RW, default = -1  meta delta step
//Bit 11: 8        reg_me_meta_delta_step0_3 // signed ,    RW, default = -2  meta delta step
//Bit  7: 4        reg_me_meta_delta_step0_4 // signed ,    RW, default = -3  meta delta step
//Bit  3: 0        reserved
#define ISP_MCNR_META_SAD_TH1                      ((0x0c36  << 2) + 0xff000000)
//Bit 31:24        reg_me_meta_sad_th1_0     // unsigned ,    RW, default = 50  area sad th
//Bit 23:16        reg_me_meta_sad_th1_1     // unsigned ,    RW, default = 80  area sad th
//Bit 15: 8        reg_me_meta_sad_th1_2     // unsigned ,    RW, default = 120  area sad th
//Bit  7: 0        reg_me_meta_sad_th1_3     // unsigned ,    RW, default = 120  area sad th
#define ISP_MCNR_META_DELTA_STEP1                  ((0x0c37  << 2) + 0xff000000)
//Bit 31:24        reg_me_meta_sad_th1_4     // unsigned ,    RW, default = 120  area sad th
//Bit 23:20        reg_me_meta_delta_step1_0 // signed ,    RW, default = 1  meta delta step
//Bit 19:16        reg_me_meta_delta_step1_1 // signed ,    RW, default = 0  meta delta step
//Bit 15:12        reg_me_meta_delta_step1_2 // signed ,    RW, default = -1  meta delta step
//Bit 11: 8        reg_me_meta_delta_step1_3 // signed ,    RW, default = -2  meta delta step
//Bit  7: 4        reg_me_meta_delta_step1_4 // signed ,    RW, default = -4  meta delta step
//Bit  3: 0        reserved
#define ISP_MCNR_META_POST_PROC                    ((0x0c38  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8           reg_me_meta_data_post_process_en // unsigned ,    RW, default = 0  enable do morphology,erosion and dilation
//Bit  7: 6        reg_me_meta_data_dil_wind_x // unsigned ,    RW, default = 2  dilation window xsize=2*wind_x+1
//Bit  5: 4        reg_me_meta_data_dil_wind_y // unsigned ,    RW, default = 2  dilation window ysize=2*wind_y+1
//Bit  3: 2        reg_me_meta_data_ero_wind_x // unsigned ,    RW, default = 2  erosion window xsize=2*wind_x+1
//Bit  1: 0        reg_me_meta_data_ero_wind_y // unsigned ,    RW, default = 2  erosion window ysize=2*wind_y+1
#define ISP_MCNR_OBMC_0                            ((0x0c39  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_0     // unsigned ,    RW, default = 40  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_0     // unsigned ,    RW, default = 40  v table
#define ISP_MCNR_OBMC_1                            ((0x0c3a  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_1     // unsigned ,    RW, default = 32  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_1     // unsigned ,    RW, default = 32  v table
#define ISP_MCNR_OBMC_2                            ((0x0c3b  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_2     // unsigned ,    RW, default = 24  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_2     // unsigned ,    RW, default = 24  v table
#define ISP_MCNR_OBMC_3                            ((0x0c3c  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 6        reg_mc_obmc_alpha_h_3     // unsigned ,    RW, default = 16  h table
//Bit  5: 0        reg_mc_obmc_alpha_v_3     // unsigned ,    RW, default = 16  v table
#define ISP_MCNR_ALPHA_0_0                         ((0x0c3d  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_0     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_1                         ((0x0c3e  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_1     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_2                         ((0x0c3f  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_2     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_3                         ((0x0c40  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_3     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_4                         ((0x0c41  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_4     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_5                         ((0x0c42  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_5     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_6                         ((0x0c43  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_6     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_0_7                         ((0x0c44  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_0_7     // unsigned ,    RW, default = 0  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_0                         ((0x0c45  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_0     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_1                         ((0x0c46  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_2                         ((0x0c47  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_2     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_3                         ((0x0c48  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_3     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_4                         ((0x0c49  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_4     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_5                         ((0x0c4a  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_5     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_6                         ((0x0c4b  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_6     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_1_7                         ((0x0c4c  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_1_7     // unsigned ,    RW, default = 22  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_0                         ((0x0c4d  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_0     // unsigned ,    RW, default = 									32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_1                         ((0x0c4e  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_2                         ((0x0c4f  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_2     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_3                         ((0x0c50  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_3     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_4                         ((0x0c51  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_4     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_5                         ((0x0c52  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_5     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_6                         ((0x0c53  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_6     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_2_7                         ((0x0c54  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_2_7     // unsigned ,    RW, default = 24  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_0                         ((0x0c55  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_0     // unsigned ,    RW, default = 									32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_1                         ((0x0c56  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_1     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_2                         ((0x0c57  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_2     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_3                         ((0x0c58  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_3     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_4                         ((0x0c59  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_4     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_5                         ((0x0c5a  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_6                         ((0x0c5b  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_3_7                         ((0x0c5c  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_3_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_0                         ((0x0c5d  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_0     // unsigned ,    RW, default = 									36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_1                         ((0x0c5e  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_1     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_2                         ((0x0c5f  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_2     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_3                         ((0x0c60  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_3     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_4                         ((0x0c61  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_4     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_5                         ((0x0c62  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_6                         ((0x0c63  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_4_7                         ((0x0c64  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_4_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_0                         ((0x0c65  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_1                         ((0x0c66  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_1     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_2                         ((0x0c67  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_2     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_3                         ((0x0c68  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_3     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_4                         ((0x0c69  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_4     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_5                         ((0x0c6a  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_5     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_6                         ((0x0c6b  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_6     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_5_7                         ((0x0c6c  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_5_7     // unsigned ,    RW, default = 26  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_0                         ((0x0c6d  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_1                         ((0x0c6e  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_1     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_2                         ((0x0c6f  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_2     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_3                         ((0x0c70  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_3     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_4                         ((0x0c71  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_4     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_5                         ((0x0c72  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_5     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_6                         ((0x0c73  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_6     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_6_7                         ((0x0c74  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_6_7     // unsigned ,    RW, default = 28  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_0                         ((0x0c75  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_0     // unsigned ,    RW, default = 									40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_1                         ((0x0c76  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_1     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_2                         ((0x0c77  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_2     // unsigned ,    RW, default = 40  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_3                         ((0x0c78  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_3     // unsigned ,    RW, default = 38  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_4                         ((0x0c79  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_4     // unsigned ,    RW, default = 36  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_5                         ((0x0c7a  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_5     // unsigned ,    RW, default = 34  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_6                         ((0x0c7b  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_6     // unsigned ,    RW, default = 32  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ALPHA_7_7                         ((0x0c7c  << 2) + 0xff000000)
//Bit 31:26        reg_mc_meta2alpha_7_7     // unsigned ,    RW, default = 30  mc alpha
//Bit 25: 0        reserved
#define ISP_MCNR_ZMV_ALPHA                         ((0x0c7d  << 2) + 0xff000000)
//Bit 31:22        reg_mc_zmv_length_th      // unsigned ,    RW, default = 10  mv length
//Bit 21:16        reg_mc_zmv_alpha_gain     // unsigned ,    RW, default = 20  normalize 16 as "1"
//Bit 15: 8        reg_mc_zmv_alpha_max      // unsigned ,    RW, default = 240  zmv alpha max
//Bit  7           reg_mc_force_zdata_en     // unsigned ,    RW, default = 1  enable force zmv data
//Bit  6: 3        reg_mc_pre_alpha_curv_thn // unsigned ,    RW, default = 4  threshold1 = th0 + 2^thn to get the th1 of the curv
//Bit  2: 0        reserved
#define ISP_MCNR_PRE_ALPHA                         ((0x0c7e  << 2) + 0xff000000)
//Bit 31:24        reg_mc_pre_alpha_curv_th0 // unsigned ,    RW, default = 8  threshold 0 of the curv
//Bit 23:16        reg_mc_pre_alpha_curv0    // unsigned ,    RW, default = 128  curve value0 of sad_diff <= th0  (TBC, changed from ppt)
//Bit 15: 8        reg_mc_pre_alpha_curv1    // unsigned ,    RW, default = 0  curve value1 of sad_diff >= th1
//Bit  7: 0        reg_mc_mv_length_th       // unsigned ,    RW, default = 0  threshold of mv length to do mctnr, if mv_length>th, do mctnr
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_mcnr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dfe_mcnr_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_MCNR_TOP_GCLK_CTRL                     ((0x0cf0  << 2) + 0xff000000)
//Bit 31:0      reg_gclk_ctrl         //unsigned, RW, default=0
//
#define ISP_MCNR_HW_CTRL0                          ((0x0cf1  << 2) + 0xff000000)
//Bit 31        reg_sw_rst            //unsigned, W1T, default=0
//Bit 30        reg_mcnr_use_tnr      //unsigned, RW, default=1
//Bit 29        reg_force_sblk_pre    //unsigned, RW, default=0
//Bit 28:4      reserved
//Bit 3         reg_rand_mv_seed_rst  //unsigned, W1T, default=0
//Bit 2:0       reg_mcnr_dbg_path_sel //unsigned, RW, default=0
#define ISP_MCNR_DBG0                              ((0x0cf2  << 2) + 0xff000000)
//Bit 31:0      ro_mcnr_dbg0        //unsigned, RO, default=0
#define ISP_MCNR_DBG1                              ((0x0cf3  << 2) + 0xff000000)
//Bit 31:0      ro_mcnr_dbg1        //unsigned, RO, default=0
#define ISP_MCNR_MV_DBG0                           ((0x0cf4  << 2) + 0xff000000)
//Bit 31        reg_mcnr_force_vmv_en   // unsigned, RW, default=0
//Bit 30        reg_mcnr_force_vec_en   // unsigned, RW, default=0
//Bit 29        reg_mcnr_force_meta_en  // unsigned, RW, default=0
//Bit 28:19     reserved
//Bit 18:16     reg_mcnr_force_meta  // unsigned, RW, default=0
//Bit 15:10     reg_mcnr_force_mvy   // unsigned, RW, default=0
//Bit 9:0       reg_mcnr_force_mvx   // unsigned, RW, default=0
#define ISP_MCNR_MV_DBG1                           ((0x0cf5  << 2) + 0xff000000)
//Bit 31        reg_mcnr_force_sad_en // unsigned, RW, default=0
//Bit 30:26     reserved
//Bit 25:13     reg_mcnr_force_zsad  // unsigned, RW, default=0
//Bit 12:0      reg_mcnr_force_psad  // unsigned, RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dfe_mcnr_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DFE_RCNR_APB_BASE = 0x0d
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rcnr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_RAWCNR_CTRL                            ((0x0d00  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_rawcnr_force_lpf_en   // unsigned ,    RW, default = 0  enable force raw cnr lpf in large area
//Bit 19:18        reg_rawcnr_xphs_ofst      // unsigned ,    RW, default = 0
//Bit 17:16        reg_rawcnr_yphs_ofst      // unsigned ,    RW, default = 0
//Bit 15:10        reserved
//Bit  9           reg_rawcnr_meta_adaptive_en // unsigned ,    RW, default = 0  raw-cnr strength adaptive to motion meta enable, 0: no adaptive, 1: adaptive, set 0 for static images, 1 for video sequence
//Bit  8           reg_rawcnr_luma_adaptive_en // unsigned ,    RW, default = 0  ns rate scale base on luma function enable
//Bit  7: 6        reg_rawcnr_ishigfreq_mode // unsigned ,    RW, default = 0  is_higfreq mode for curblock for final blend, 0: ishigfrq either yhigfreq==1 or chigfreq; 1: ishigfrq both yhigfreq an chigfreq==1; 2:ishigfreq when only chigfreq==1
//Bit  5: 4        reg_rawcnr_totblk_ishigfreq_mode // unsigned ,    RW, default = 2  is_higfreq mode for curblock for final blend, 0: ishigfrq either yhigfreq==1 or chigfreq; 1: ishigfrq both yhigfreq an chigfreq==1; 2:ishigfreq when only chigfreq==1
//Bit  3            reserved
//Bit  2           reg_rawcnr_curblk_higfrq_en // unsigned ,    RW, default = 1  curblk higfreq based blk enable, 1 : use sub-block higfreq info
//Bit  1           reg_rawcnr_totblk_higfrq_en // unsigned ,    RW, default = 1  totblk higfreq  enable, 1 : use total higfreq info based on avg_blknxn
//Bit  0           reg_rawcnr_svalid_mode    // unsigned ,    RW, default = 0  is svalid mode for curblock for sigma filter, 0: isvalid either yhigfreq_sublknxn==1 or chigfreq_sublknxn; 1:isvalid when only chigfreq_sublknxn==0
#define ISP_RAWCNR_META_ADP_LUT_0                  ((0x0d01  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_meta_gain_lut_3 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_meta_gain_lut_2 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_meta_gain_lut_1 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_meta_gain_lut_0 // unsigned ,    RW, default = 16  gain ,16 is 1
#define ISP_RAWCNR_META_ADP_LUT_1                  ((0x0d02  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_meta_gain_lut_7 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_meta_gain_lut_6 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_meta_gain_lut_5 // unsigned ,    RW, default = 16  gain ,16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_meta_gain_lut_4 // unsigned ,    RW, default = 16  gain ,16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_0          ((0x0d03  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_1 // unsigned ,    RW, default = 16  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_1 // unsigned ,    RW, default = 16  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_0 // unsigned ,    RW, default = 16  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_0 // unsigned ,    RW, default = 16  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_1          ((0x0d04  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_3 // unsigned ,    RW, default = 18  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_3 // unsigned ,    RW, default = 18  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_2 // unsigned ,    RW, default = 18  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_2 // unsigned ,    RW, default = 18  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_2          ((0x0d05  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_5 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_5 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_4 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_4 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_3          ((0x0d06  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_7 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_7 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_6 // unsigned ,    RW, default = 20  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_6 // unsigned ,    RW, default = 20  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_4          ((0x0d07  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_9 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_9 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_8 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_8 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_5          ((0x0d08  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_11 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_11 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_10 // unsigned ,    RW, default = 22  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_10 // unsigned ,    RW, default = 22  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_6          ((0x0d09  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_13 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_13 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_12 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_12 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_LUMA_CHROMA_GAIN_LUT_7          ((0x0d0a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_luma_gain_lut_15 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_chroma_gain_lut_15 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_luma_gain_lut_14 // unsigned ,    RW, default = 24  luma gain to check yhigfrq, 16 is 1
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_chroma_gain_lut_14 // unsigned ,    RW, default = 24  chroma gain to check chigfrq, 16 is 1
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_0            ((0x0d0b  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rawcnr_sps_csig_weight5x5_9 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 27:25        reg_rawcnr_sps_csig_weight5x5_8 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 24:22        reg_rawcnr_sps_csig_weight5x5_7 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 21:19        reg_rawcnr_sps_csig_weight5x5_6 // unsigned ,    RW, default = 2  weight of the the filter
//Bit 18:16        reg_rawcnr_sps_csig_weight5x5_5 // unsigned ,    RW, default = 										1  weight of the the filter
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_4 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_3 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_2 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_1 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_0 // unsigned ,    RW, default = 1  weight of the the filter
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_1            ((0x0d0c  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_rawcnr_sps_csig_weight5x5_19 // unsigned ,    RW, default = 0  weight of the the filter
//Bit 27:25        reg_rawcnr_sps_csig_weight5x5_18 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 24:22        reg_rawcnr_sps_csig_weight5x5_17 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 21:19        reg_rawcnr_sps_csig_weight5x5_16 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 18:16        reg_rawcnr_sps_csig_weight5x5_15 // unsigned ,    RW, default = 									0  weight of the the filter
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_14 // unsigned ,    RW, default = 1  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_13 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_12 // unsigned ,    RW, default = 2  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_11 // unsigned ,    RW, default = 1  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_10 // unsigned ,    RW, default = 									1  weight of the the filter
#define ISP_RAWCNR_CSIG_WEIGHT5X5_LUT_2            ((0x0d0d  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_rawcnr_sps_csig_weight5x5_24 // unsigned ,    RW, default = 0  weight of the the filter
//Bit 11: 9        reg_rawcnr_sps_csig_weight5x5_23 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  8: 6        reg_rawcnr_sps_csig_weight5x5_22 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  5: 3        reg_rawcnr_sps_csig_weight5x5_21 // unsigned ,    RW, default = 0  weight of the the filter
//Bit  2: 0        reg_rawcnr_sps_csig_weight5x5_20 // unsigned ,    RW, default = 									0  weight of the the filter
#define ISP_RAWCNR_NP_0                            ((0x0d0e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_1     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_0     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_1                            ((0x0d0f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_3     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_2     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_2                            ((0x0d10  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_5     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_4     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_3                            ((0x0d11  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_7     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_6     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_4                            ((0x0d12  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_9     // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_8     // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_5                            ((0x0d13  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_11    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_10    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_6                            ((0x0d14  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_13    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_12    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_7                            ((0x0d15  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_np_lut16_15    // unsigned ,    RW, default = 0  noise profile for rawcnr
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_np_lut16_14    // unsigned ,    RW, default = 0  noise profile for rawcnr
#define ISP_RAWCNR_NP_CTRL                         ((0x0d16  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_rawcnr_sad_cor_np_gain // unsigned ,    RW, default = 63  np gain
//Bit 15: 9        reserved
//Bit  8: 0        reg_rawcnr_sad_cor_np_ofst // signed ,    RW, default = 0  np offset
#define ISP_RAWCNR_SNRFLAG_GAIN                    ((0x0d17  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_rawcnr_cor_csnrflg_gain_0 // unsigned ,    RW, default = 16  snrflag gain for c chn coring
//Bit 23:21        reserved
//Bit 20:16        reg_rawcnr_cor_csnrflg_gain_1 // unsigned ,    RW, default = 31  snrflag gain for c chn coring
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_cor_ysnrflg_gain_0 // unsigned ,    RW, default = 16  snrflag gain for y chn yoring
//Bit  7: 5        reserved
//Bit  4: 0        reg_rawcnr_cor_ysnrflg_gain_1 // unsigned ,    RW, default = 31  snrflag gain for y chn yoring
#define ISP_RAWCNR_UCOR_SUM_DIF_THD                ((0x0d18  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_higfrq_sublk_sum_dif_thd_0 // unsigned ,    RW, default = 200  high freq sum thrd for sub block, 0:for y, 1:for color channel
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_higfrq_sublk_sum_dif_thd_1 // unsigned ,    RW, default = 100  high freq sum thrd for sub block, 0:for y, 1:for color channel
#define ISP_RAWCNR_MISC_CTRL0                      ((0x0d19  << 2) + 0xff000000)
//Bit 31:28        reg_rawcnr_ucor_ygain     // unsigned ,    RW, default = 8  coring gain for upper parts subblocks
//Bit 27:24        reg_rawcnr_ucor_cgain     // unsigned ,    RW, default = 12  coring gain for upper parts subblocks
//Bit 23:22        reserved
//Bit 21:16        reg_rawcnr_sps_csigfn_alph // unsigned ,    RW, default = 62  rawCNR final alpha blend to snr output;   0: snr; 63:100% CNR sigma filter output
//Bit 15:13        reserved
//Bit 12: 8        reg_rawcnr_sub_snrflg_sum_thd // unsigned ,    RW, default = 16  snrflag_sum thd for each 5x5 block
//Bit  7: 4        reg_rawcnr_luma_gain_shift_bits // unsigned ,    RW, default = 8  luma to check luma gain lut[16], luma 12 bits
//Bit  3: 0        reg_rawcnr_chroma_gain_shift_bits // unsigned ,    RW, default = 8  chroma to check chroma gain lut[16], chroma 12 bits
#define ISP_RAWCNR_CURBLK_SUM_THD                  ((0x0d1a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_higfrq_curblk_sum_difnxn_thd_0 // unsigned ,    RW, default = 1400  high freq sum thrd for blknxn, 0:for y, 1:for color channel
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_higfrq_curblk_sum_difnxn_thd_1 // unsigned ,    RW, default = 1200  high freq sum thrd for blknxn, 0:for y, 1:for color channel
#define ISP_RAWCNR_CHROMA_MAX_MIN_THD              ((0x0d1b  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_thrd_ca_max    // unsigned ,    RW, default = 512  max chroma threshold in check diff between current subblock and others
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_thrd_ca_min    // unsigned ,    RW, default = 5  min chroma threshold in check diff between current subblock and others
#define ISP_RAWCNR_LUMA_MAX_MIN_THD                ((0x0d1c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rawcnr_thrd_ya_max    // unsigned ,    RW, default = 1024  max luma threshold in check diff between current subblock and others
//Bit 15:12        reserved
//Bit 11: 0        reg_rawcnr_thrd_ya_min    // unsigned ,    RW, default = 5  min luma threshold in check diff between current subblock and others
#define ISP_RAWCNR_SUBLK_SNR_FLAG_GAIN_LUT         ((0x0d1d  << 2) + 0xff000000)
//Bit 31:24        reg_rawcnr_hbsize         // unsigned ,    RW, default = 32  h blank size
//Bit 23:16        reg_rawcnr_vbsize         // unsigned ,    RW, default = 88  v blank size
//Bit 15            reserved
//Bit 14:12        reg_rawcnr_subblk_snr_flag_gain_lut_0 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit 11            reserved
//Bit 10: 8        reg_rawcnr_subblk_snr_flag_gain_lut_1 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit  7            reserved
//Bit  6: 4        reg_rawcnr_subblk_snr_flag_gain_lut_2 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
//Bit  3            reserved
//Bit  2: 0        reg_rawcnr_subblk_snr_flag_gain_lut_3 // unsigned ,    RW, default = 7  subblk_snrflag gain for var_c
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rcnr_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB0_APB_BASE = 0x10
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_lens_shading_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LSWB_EOTF_OFST0                        ((0x1000  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16: 0        reg_eotf_pre_ofst         // signed ,    RW, default = 0  pre offset (-) before eotf
#define ISP_LSWB_EOTF_OFST1                        ((0x1001  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20: 0        reg_eotf_pst_ofst         // signed ,    RW, default = 0  post offset (+) after eotf
#define ISP_LSWB_EOTF_PARAM                        ((0x1002  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2           reg_eotf0_en              // unsigned ,    RW, default = 1  enable eotf0
//Bit  1           reg_eotf1_en              // unsigned ,    RW, default = 1  enable eotf1
//Bit  0           reg_eotf1_mode            // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for eotf 1 lut
#define ISP_LSWB_EOTF_NUM                          ((0x1003  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:27        reg_eotf1_num_0           // unsigned ,    RW, default = 5  numbers for each segment of eotf 1 lut
//Bit 26:24        reg_eotf1_num_1           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 23:22        reserved
//Bit 21:19        reg_eotf1_num_2           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 18:16        reg_eotf1_num_3           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 15:14        reserved
//Bit 13:11        reg_eotf1_num_4           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit 10: 8        reg_eotf1_num_5           // unsigned ,    RW, default = 4  numbers for each segment of eotf 1 lut
//Bit  7: 6        reserved
//Bit  5: 3        reg_eotf1_num_6           // unsigned ,    RW, default = 3  numbers for each segment of eotf 1 lut
//Bit  2: 0        reg_eotf1_num_7           // unsigned ,    RW, default = 3  numbers for each segment of eotf 1 lut
#define ISP_LSWB_EOTF_STP                          ((0x1004  << 2) + 0xff000000)
//Bit 31:28        reg_eotf1_stp_0           // unsigned ,    RW, default = 11  step for each segment of eotf 1 lut
//Bit 27:24        reg_eotf1_stp_1           // unsigned ,    RW, default = 12  step for each segment of eotf 1 lut
//Bit 23:20        reg_eotf1_stp_2           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 19:16        reg_eotf1_stp_3           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 15:12        reg_eotf1_stp_4           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit 11: 8        reg_eotf1_stp_5           // unsigned ,    RW, default = 13  step for each segment of eotf 1 lut
//Bit  7: 4        reg_eotf1_stp_6           // unsigned ,    RW, default = 14  step for each segment of eotf 1 lut
//Bit  3: 0        reg_eotf1_stp_7           // unsigned ,    RW, default = 15  step for each segment of eotf 1 lut
#define ISP_LSWB_IDG_GAIN0                         ((0x1005  << 2) + 0xff000000)
//Bit 31:16        reg_idg_gain_0            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
//Bit 15: 0        reg_idg_gain_1            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_GAIN1                         ((0x1006  << 2) + 0xff000000)
//Bit 31:16        reg_idg_gain_2            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
//Bit 15: 0        reg_idg_gain_3            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_GAIN2                         ((0x1007  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_idg_gain_4            // unsigned ,    RW, default = 4096  in format 4.12, inv digital gain
#define ISP_LSWB_IDG_OFST                          ((0x1008  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 4        reg_idg_ofst              // unsigned ,    RW, default = 0  float16 offset before and after inv digital gain
//Bit  3: 2        reg_idg_xphs_ofst         // unsigned ,    RW, default = 0
//Bit  1: 0        reg_idg_yphs_ofst         // unsigned ,    RW, default = 0
#define ISP_LSWB_BLC_MODE                          ((0x1009  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4           reg_blc_mode_0            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  3           reg_blc_mode_1            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  2           reg_blc_mode_2            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  1           reg_blc_mode_3            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
//Bit  0           reg_blc_mode_4            // unsigned ,    RW, default = 0  0: sub, 1: add, mode for blc offset each color each channels
#define ISP_LSWB_BLC_OFST0                         ((0x100a  << 2) + 0xff000000)
//Bit 31:16        reg_blc_ofst_0            // unsigned ,    RW, default = 0  float16 Gr for blc offset each color each channels
//Bit 15: 0        reg_blc_ofst_1            // unsigned ,    RW, default = 0  float16 R  for blc offset each color each channels
#define ISP_LSWB_BLC_OFST1                         ((0x100b  << 2) + 0xff000000)
//Bit 31:16        reg_blc_ofst_2            // unsigned ,    RW, default = 0  float16 B  for blc offset each color each channels
//Bit 15: 0        reg_blc_ofst_3            // unsigned ,    RW, default = 0  float16 Gb for blc offset each color each channels
#define ISP_LSWB_BLC_OFST2                         ((0x100c  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_blc_ofst_4            // unsigned ,    RW, default = 0  float16 Ir of 4x4 rgbir pattern for blc offset each color each channels
#define ISP_LSWB_BLC_PHSOFST                       ((0x100d  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_blc_xphs_ofst         // unsigned ,    RW, default = 0  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_blc_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_LSWB_WB_GAIN0                          ((0x100e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_wb_gain_0             // unsigned ,    RW, default = 256  u4.8 Gr gain for wb each color each channels
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_1             // unsigned ,    RW, default = 256  u4.8 R gain for wb each color each channels
#define ISP_LSWB_WB_GAIN1                          ((0x100f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_wb_gain_2             // unsigned ,    RW, default = 256  u4.8 B gain for wb each color each channels
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_3             // unsigned ,    RW, default = 256  u4.8 Gb gain for wb each color each channels
#define ISP_LSWB_WB_GAIN2                          ((0x1010  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_wb_rate_rs            // unsigned ,    RW, default = 0  extra fractional bits (right shift)  for the reg_wb_gain[5], default=0; 0:gain=4.8; 1:gain=3.9; 2:2.10; 3: 1.11
//Bit 15:12        reserved
//Bit 11: 0        reg_wb_gain_4             // unsigned ,    RW, default = 256  u4.8 Ir gain of 4x4 rgbir pattern for wb each color each channels
#define ISP_LSWB_WB_LIMIT0                         ((0x1011  << 2) + 0xff000000)
//Bit 31:16        reg_wb_limit_0            // unsigned ,    RW, default = 0  float16 Gr for white balance each color each channels
//Bit 15: 0        reg_wb_limit_1            // unsigned ,    RW, default = 0  float16 Rg for white balance each color each channels
#define ISP_LSWB_WB_LIMIT1                         ((0x1012  << 2) + 0xff000000)
//Bit 31:16        reg_wb_limit_2            // unsigned ,    RW, default = 0  float16 Bg for white balance each color each channels
//Bit 15: 0        reg_wb_limit_3            // unsigned ,    RW, default = 0  float16 Gb for white balance each color each channels
#define ISP_LSWB_WB_LIMIT2                         ((0x1013  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_wb_limit_4            // unsigned ,    RW, default = 0  float16 IR for white balance each color each channels
#define ISP_LSWB_WB_PHSOFST                        ((0x1014  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_wb_xphs_ofst          // unsigned ,    RW, default = 0  wb horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_wb_yphs_ofst          // unsigned ,    RW, default = 0  wb vertical phase offset, supporting 4x4
#define ISP_LSWB_LNS_PHSOFST                       ((0x1015  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 2        reg_lns_xphs_ofst         // unsigned ,    RW, default = 1  horizontal phase offset, supporting 4x4
//Bit  1: 0        reg_lns_yphs_ofst         // unsigned ,    RW, default = 0  vertical phase offset, supporting 4x4
#define ISP_LSWB_RS_PARAM                          ((0x1016  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11           reg_lns_rad_chnmode       // unsigned ,    RW, default = 1  0:RGB three channel LUT, 1:GRBG/RGBIr four channel LUT
//Bit 10           reg_lns_rad_gainmode      // unsigned ,    RW, default = 0  0: final gain = (x); 1:final gain = (1+x)
//Bit  9           reg_lns_rad_dbg           // unsigned ,    RW, default = 0  0: debug mode off, 1: debug mode on
//Bit  8: 0        reg_lns_rad_strength      // unsigned ,    RW, default = 256  radial shading correction strength
#define ISP_LSWB_RS_XSCALE                         ((0x1017  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lns_rad_xscale        // unsigned ,    RW, default = 8738  scale to x_dist to norm to 2^16 as "1" as input of the cordic; x scale <=65536/(ColMax)*256, ColMax>=256
#define ISP_LSWB_RS_YSCALE                         ((0x1018  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lns_rad_yscale        // unsigned ,    RW, default = 15534  scale to y_dist to norm to 2^16 as "1" as input of the cordic; y scale <=65536/(RowMax)*256, RowMax>=256
#define ISP_LSWB_RS_CENTER                         ((0x1019  << 2) + 0xff000000)
//Bit 31:16        reg_lns_rad_centerx       // unsigned ,    RW, default = 0  coordinates of the center of the image on the X axis, default = xsize/2
//Bit 15: 0        reg_lns_rad_centery       // unsigned ,    RW, default = 0  coordinates of the center of the image on the Y axis, default = ysize/2
#define ISP_LSWB_RS_CENTEROFST_0                   ((0x101a  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_0   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_0   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_0    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_1                   ((0x101b  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_1   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_1   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_1    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_2                   ((0x101c  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_2   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_2   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_2    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_RS_CENTEROFST_3                   ((0x101d  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_lns_rad_centofstx_3   // signed ,    RW, default = 0  center offset to reg_lns_rad_centerx for each phase_x,
//Bit 15:12        reg_lns_rad_centofsty_3   // signed ,    RW, default = 0  center offset to reg_lns_rad_centery for each phase_y,
//Bit 11: 0        reg_lns_rad_multgain_3    // unsigned ,    RW, default = 1448  BLUE rad scale up to fill 129bin lut, set to 2048 * 2 / sqrt(a ^ 2 + b ^ 2), norm to 2048 as "128" bins all cover radius
#define ISP_LSWB_MS_PARAM                          ((0x101e  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_lns_mesh_chnmode      // unsigned ,    RW, default = 1  0:RGB three channel LUT, 1:GRBG/RGBIr four channel LUT
//Bit 18           reg_lns_mesh_gainmode     // unsigned ,    RW, default = 0  0: final gain = (x); 1:final gain = (1+x)
//Bit 17:16        reg_lns_mesh_alpmode      // unsigned ,    RW, default = 0  0: orgin, 1:two light sources with 32 cols and 64 rows, 2 or 3: four light sources with 32 cols and 32 rows
//Bit 15           reg_lns_mesh_prtmode      // unsigned ,    RW, default = 0  0:no protect mesh shading correction 1:protect mesh shading correction
//Bit 14:13        reserved
//Bit 12: 1        reg_lns_mesh_strength     // unsigned ,    RW, default = 4095  0: no correction 4095: correction to match mesh data
//Bit  0           reg_lns_mesh_dbg          // unsigned ,    RW, default = 0  debug 1: debug mode on
#define ISP_LSWB_MS_LUTNORM_0                      ((0x101f  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_0 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_1                      ((0x1020  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_1 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_2                      ((0x1021  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_2 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_LUTNORM_3                      ((0x1022  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_lns_mesh_lutnorm_grbg_3 // unsigned ,    RW, default = 1  0 nrm 128; 1: nrm 64 2: nrm 32; 3: nrm 16
#define ISP_LSWB_MS_ALP                            ((0x1023  << 2) + 0xff000000)
//Bit 31:24        reg_lns_mesh_alp_0        // unsigned ,    RW, default = 255  for 1/2/4 light sources alp blend
//Bit 23:16        reg_lns_mesh_alp_1        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
//Bit 15: 8        reg_lns_mesh_alp_2        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
//Bit  7: 0        reg_lns_mesh_alp_3        // unsigned ,    RW, default = 0  for 1/2/4 light sources alp blend
#define ISP_LSWB_MS_XSHIFT                         ((0x1024  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17: 0        reg_lns_mesh_xshift       // unsigned ,    RW, default = 0  scalar shift in X axis
#define ISP_LSWB_MS_YSHIFT                         ((0x1025  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17: 0        reg_lns_mesh_yshift       // unsigned ,    RW, default = 0  scalar shift in Y axis
#define ISP_LSWB_MS_NUM                            ((0x1026  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_lns_mesh_xnum         // unsigned ,    RW, default = 32  horizontal direction region number, valid lut size = (xnum)*(ynum)*4
//Bit 15: 7        reserved
//Bit  6: 0        reg_lns_mesh_ynum         // unsigned ,    RW, default = 32  vertical direction region number, valid lut size = (xnum)*(ynum)*4
#define ISP_LSWB_MS_XSCALE                         ((0x1027  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lns_mesh_xscale       // unsigned ,    RW, default = 256  max support xnum = 64
#define ISP_LSWB_MS_YSCALE                         ((0x1028  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lns_mesh_yscale       // unsigned ,    RW, default = 256  max support ynum = 64
#define ISP_LSWB_MS_LIMIT                          ((0x1029  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lns_mesh_xlimit       // unsigned ,    RW, default = 255
//Bit  7: 0        reg_lns_mesh_ylimit       // unsigned ,    RW, default = 255
#define ISP_EOTF_DEBUG_IN_CHECKSUM                 ((0x102a  << 2) + 0xff000000)
//Bit 31: 0        ro_eotf_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_EOTF_DEBUG_OUT_CHECKSUM                ((0x102b  << 2) + 0xff000000)
//Bit 31: 0        ro_eotf_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_IDG_DEBUG_IN_CHECKSUM                  ((0x102c  << 2) + 0xff000000)
//Bit 31: 0        ro_idg_debug_in_checksum  // unsigned ,    RO, default = 0
#define ISP_IDG_DEBUG_OUT_CHECKSUM                 ((0x102d  << 2) + 0xff000000)
//Bit 31: 0        ro_idg_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_BL_DEBUG_IN_CHECKSUM                   ((0x102e  << 2) + 0xff000000)
//Bit 31: 0        ro_bl_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_BL_DEBUG_OUT_CHECKSUM                  ((0x102f  << 2) + 0xff000000)
//Bit 31: 0        ro_bl_debug_out_checksum  // unsigned ,    RO, default = 0
#define ISP_WB_DEBUG_IN_CHECKSUM                   ((0x1030  << 2) + 0xff000000)
//Bit 31: 0        ro_wb_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_WB_DEBUG_OUT_CHECKSUM                  ((0x1031  << 2) + 0xff000000)
//Bit 31: 0        ro_wb_debug_out_checksum  // unsigned ,    RO, default = 0
#define ISP_LSN_RAD_DEBUG_IN_CHECKSUM              ((0x1032  << 2) + 0xff000000)
//Bit 31: 0        ro_lsn_rad_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_RAD_DEBUG_OUT_CHECKSUM             ((0x1033  << 2) + 0xff000000)
//Bit 31: 0        ro_lsn_rad_debug_out_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_MESH_DEBUG_IN_CHECKSUM             ((0x1034  << 2) + 0xff000000)
//Bit 31: 0        ro_lsn_mesh_debug_in_checksum // unsigned ,    RO, default = 0
#define ISP_LSN_MESH_DEBUG_OUT_CHECKSUM            ((0x1035  << 2) + 0xff000000)
//Bit 31: 0        ro_lsn_mesh_debug_out_checksum // unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_lens_shading_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_lns_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LNS_RAD_LUT_ADDR                       ((0x10f0  << 2) + 0xff000000)
//Bit 31: 0       reg_lns_rad_lut_addr            // unsigned, RW, default = 32'h0
#define ISP_LNS_RAD_LUT_DATA                       ((0x10f1  << 2) + 0xff000000)
//Bit 31:0        reg_lns_rad_lut_data            // unsigned, RW, default = 32'h0
#define ISP_LNS_MESH_LUT_ADDR                      ((0x10f2  << 2) + 0xff000000)
//Bit 31: 0       reg_lns_mesh_lut_addr            // unsigned , RW, default = 32'h0
#define ISP_LNS_MESH_LUT_DATA                      ((0x10f3  << 2) + 0xff000000)
//Bit 31: 0       reg_lns_mesh_lut_data            // unsigned , RW, default = 32'h0
#define ISP_LNS_EOTF0_LUT_ADDR                     ((0x10f4  << 2) + 0xff000000)
//Bit 31:0       reg_eotf0_lut_addr         // unsigned, RW, default=0
#define ISP_LNS_EOTF0_LUT_DATA                     ((0x10f5  << 2) + 0xff000000)
//Bit 31:20      reserved
//Bit 19:0       reg_eotf0_lut_data         //unsigned, RW, default=0
#define ISP_LNS_EOTF1_LUT_ADDR                     ((0x10f6  << 2) + 0xff000000)
//Bit 31:0       reg_eotf1_lut_addr         //unsigned, RW, default=0
#define ISP_LNS_EOTF1_LUT_DATA                     ((0x10f7  << 2) + 0xff000000)
//Bit 31:20      reserved
//Bit 19:0       reg_eotf1_lut_data         //unsigned, RW, default=0
#define ISP_LNS_GCLK_CTRL                          ((0x10f8  << 2) + 0xff000000)
//Bit 31:0       reg_gclk_ctrl              //unsigned, RW, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_lns_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB1_APB_BASE = 0x11
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_gtm_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_GTM_GAIN                               ((0x1100  << 2) + 0xff000000)
//Bit 31:16        reg_gtm_gain              // unsigned ,    RW, default = 256  gain (u8.8) before tone mapping
//Bit 15: 1        reserved
//Bit  0           reg_gtm_lut_mode          // unsigned ,    RW, default = 1  0: equidistance, 1: non-equidistance, mode for global tone mapping lut
#define ISP_GTM_OFST                               ((0x1101  << 2) + 0xff000000)
//Bit 31:16        reg_gtm_pre_ofst          // unsigned ,    RW, default = 0  float16 offset before tone mapping
//Bit 15:12        reserved
//Bit 11: 0        reg_gtm_pst_ofst          // unsigned ,    RW, default = 0  (BIT_DEPTH5), offset after tone mapping
#define ISP_GTM_LUT_NUM                            ((0x1102  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_gtm_lut_num_7         // unsigned ,    RW, default = 5  numbers for each segment
//Bit 27            reserved
//Bit 26:24        reg_gtm_lut_num_6         // unsigned ,    RW, default = 4  numbers for each segment
//Bit 23            reserved
//Bit 22:20        reg_gtm_lut_num_5         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 19            reserved
//Bit 18:16        reg_gtm_lut_num_4         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 15            reserved
//Bit 14:12        reg_gtm_lut_num_3         // unsigned ,    RW, default = 3  numbers for each segment
//Bit 11            reserved
//Bit 10: 8        reg_gtm_lut_num_2         // unsigned ,    RW, default = 3  numbers for each segment
//Bit  7            reserved
//Bit  6: 4        reg_gtm_lut_num_1         // unsigned ,    RW, default = 4  numbers for each segment
//Bit  3            reserved
//Bit  2: 0        reg_gtm_lut_num_0         // unsigned ,    RW, default = 5  numbers for each segment
#define ISP_GTM_LUT_STP                            ((0x1103  << 2) + 0xff000000)
//Bit 31:28        reg_gtm_lut_stp_7         // unsigned ,    RW, default = 14  steps for each segment
//Bit 27:24        reg_gtm_lut_stp_6         // unsigned ,    RW, default = 14  steps for each segment
//Bit 23:20        reg_gtm_lut_stp_5         // unsigned ,    RW, default = 14  steps for each segment
//Bit 19:16        reg_gtm_lut_stp_4         // unsigned ,    RW, default = 13  steps for each segment
//Bit 15:12        reg_gtm_lut_stp_3         // unsigned ,    RW, default = 12  steps for each segment
//Bit 11: 8        reg_gtm_lut_stp_2         // unsigned ,    RW, default = 11  steps for each segment
//Bit  7: 4        reg_gtm_lut_stp_1         // unsigned ,    RW, default = 9  steps for each segment
//Bit  3: 0        reg_gtm_lut_stp_0         // unsigned ,    RW, default = 8  steps for each segment
#define ISP_GTM_LUT129_ADDR                        ((0x1110  << 2) + 0xff000000)
//Bit  31:7        reserved
//Bit  6: 0        reg_gtm_lut129_addr        // unsigned ,    RW, default = 0
#define ISP_GTM_LUT129_DATA                        ((0x1111  << 2) + 0xff000000)
//Bit  31: 24      reserved
//Bit  23: 0       reg_gtm_lut129_data        // unsigned ,    RW, default = 0
#define ISP_GTM_GLK_CTRL                           ((0x1112  << 2) + 0xff000000)
//Bit  31: 4       reserved
//Bit   3: 0       reg_glk_ctrl               // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_gtm_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_OBE_APB2_APB_BASE = 0x12
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ltm_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LTM_HIST_POW_Y                         ((0x1200  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_pow_y_u20         // unsigned ,    RW, default = 699051  pow y coef(x^y)
#define ISP_LTM_GLBWIN_H                           ((0x1201  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_glbwin_hend       // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_ltm_glbwin_hstart     // unsigned ,    RW, default = 0
#define ISP_LTM_GLBWIN_V                           ((0x1202  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_glbwin_vend       // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_ltm_glbwin_vstart     // unsigned ,    RW, default = 0
#define ISP_LTM_HIST_POW_DIVISOR                   ((0x1203  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22: 0        reg_ltm_pow_divisor_u23   // unsigned ,    RW, default = 82570  pow divisor coef
#define ISP_LTM_STA_FLOOR                          ((0x1204  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ltm_dark_floor_u8     // unsigned ,    RW, default = 32  dark noise floor base
//Bit 15:14        reserved
//Bit 13: 0        reg_ltm_bright_floor_u14  // unsigned ,    RW, default = 8192  noise bright floor
#define ISP_LTM_STAT_BIN                           ((0x1205  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14: 8        reg_ltm_lmax_bin          // unsigned ,    RW, default = 0  min width of lmax histogram bin num,
//Bit  7            reserved
//Bit  6: 0        reg_ltm_lmin_bin          // unsigned ,    RW, default = 0  min width of lmin histogram bin num,
#define ISP_LTM_STA_DARK_NOISE                     ((0x1206  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_dark_noise_u20    // unsigned ,    RW, default = 32768  dark side noise ofst
#define ISP_LTM_STA_GMIN_TOTAL                     ((0x1207  << 2) + 0xff000000)
//Bit 31: 0        reg_ltm_gmin_total        // unsigned ,    RW, default = 7441  gmin total
#define ISP_LTM_STA_GMAX_TOTAL                     ((0x1208  << 2) + 0xff000000)
//Bit 31: 0        reg_ltm_gmax_total        // unsigned ,    RW, default = 761303  gmax total
#define ISP_LTM_STA_LOC_PERC                       ((0x1209  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_ltm_lmax_pct_u10      // unsigned ,    RW, default = 1023  range 0...1024, #/1024
//Bit 15:10        reserved
//Bit  9: 0        reg_ltm_lmin_pct_u10      // unsigned ,    RW, default = 2  rnage 0...1024, #/1024
#define ISP_LTM_POW_CRTL                           ((0x120a  << 2) + 0xff000000)
//Bit 31:24        reg_ltm_min_factor_u8     // unsigned ,    RW, default = 32  range 0...255,   #/64
//Bit 23:16        reg_ltm_max_factor_u8     // unsigned ,    RW, default = 128  range 0...255,  #/64
//Bit 15            reserved
//Bit 14: 8        reg_ltm_hi_gm_u7          // unsigned ,    RW, default = 32  range 0...128, #/128
//Bit  7: 6        reserved
//Bit  5: 0        reg_ltm_lo_gm_u6          // unsigned ,    RW, default = 32  range 0...64,  #/32
#define ISP_LTM_SHRP_CRTL                          ((0x120b  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:24        reg_ltm_shrp_smth_lvlsft  // unsigned ,    RW, default = 3  level to adjust sigma filter
//Bit 23:16        reg_ltm_shrp_s_u8         // unsigned ,    RW, default = 16  sharpness strength(boost level), norm to 16 as 1.0 for no boost; default , 16
//Bit 15:14        reserved
//Bit 13: 8        reg_ltm_shrp_r_u6         // unsigned ,    RW, default = 32  sharpness range 0...64,  #/64
//Bit  7: 2        reg_ltm_shrp_base_alpha   // unsigned ,    RW, default = 0  R1024 blend coef in sharpen
//Bit  1            reserved
//Bit  0           reg_ltm_dtl_ehn_en        // unsigned ,    RW, default = 1  detail enhancement en
#define ISP_LTM_SHRP_NOISE                         ((0x120c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:20        reg_ltm_hi_noise_1024     // unsigned ,    RW, default = 51  hgh noise in sharpen
//Bit 19:10        reg_ltm_md_noise_1024     // unsigned ,    RW, default = 51  mid noise in sharpen
//Bit  9: 0        reg_ltm_lo_noise_1024     // unsigned ,    RW, default = 51  low noise in sharpen
#define ISP_LTM_SHRP_EXP_THD                       ((0x120d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_ltm_expblend_thd1     // unsigned ,    RW, default = 3600  wdr expblend thrd1 T_EXPSTITCH_PARAM prm_expst->reg_wdr_expcomb_blend_thd1;
//Bit 15:14        reserved
//Bit 13: 0        reg_ltm_expblend_thd0     // unsigned ,    RW, default = 2576  wdr expblend thrd0 T_EXPSTITCH_PARAM prm_expst->reg_wdr_expcomb_blend_thd0;
#define ISP_LTM_LOG_KEY                            ((0x120e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27: 0        reg_ltm_lr_u28            // unsigned ,    RW, default = 676200  key coef to adjust log mapping
#define ISP_LTM_WHITE_LEVEL                        ((0x120f  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_white_level       // unsigned ,    RW, default = 1048575  white level threshold
#define ISP_LTM_BLACK_LEVEL                        ((0x1210  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_ltm_black_level       // unsigned ,    RW, default = 0  black level threshold
#define ISP_LTM_FINAL_CTRL                         ((0x1211  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_ltm_vs_gtm_alpha      // unsigned ,    RW, default = 63  alpha blender coef between ltm and gtm, norm to 64 as 1.0, 0: 100% gtm; 63: 100% ltm_result
//Bit 23:22        reserved
//Bit 21:16        reg_ltm_b2luma_alpha      // unsigned ,    RW, default = 63  alpha of luma using filter Y or mRGB, 0: luma filter way; 63: mRGB way閿涳拷 1~62閿涳拷 blender of filter results and mRGB results, default, 63
//Bit 15:12        reserved
//Bit 11: 8        reg_ltm_dbg_mode          // unsigned ,    RW, default = 0  ltm debug model
//Bit  7           reg_ltm_mrgb_mode         // unsigned ,    RW, default = 0  mrgb mode selection 0: MAX(avg(rgb)), 1: MAX( MAX(avg(rgb)), y)
//Bit  6: 0        reg_ltm_final_gain        // unsigned ,    RW, default = 64  final gain norm 64 as 1.0
#define ISP_LTM_FLT_CTRL                           ((0x1212  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28           reg_ltm_cc_en             // unsigned ,    RW, default = 0  color compensation enable register
//Bit 27:26        reg_ltm_xphs_ofst         // unsigned ,    RW, default = 1  phase offset in x dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each senso
//Bit 25:24        reg_ltm_yphs_ofst         // unsigned ,    RW, default = 0  phase offset in y dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each senso
//Bit 23:20        reserved
//Bit 19: 8        reg_ltm_ccdis_thd         // unsigned ,    RW, default = 4095  to disable cc path, replace with out_fc_12b if in_ratio>thr*16, default = 4095
//Bit  7: 4        reg_ltm_stat_hblk_num     // unsigned ,    RW, default = 12  horizontal block number for ltm statistic
//Bit  3: 0        reg_ltm_stat_vblk_num     // unsigned ,    RW, default = 8  vertical block number for ltm statistic
#define ISP_LTM_STA_LPF_CTRL                       ((0x1213  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_ltm_lmin_lpf_taps     // unsigned ,    RW, default = 1  lpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:17        reserved
//Bit 16           reg_ltm_lmax_lpf_taps     // unsigned ,    RW, default = 1  lpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 15:13        reserved
//Bit 12           reg_ltm_lmin_med_en       // unsigned ,    RW, default = 1  enable lmin median filter: 0: disable, 1: enable
//Bit 11: 9        reserved
//Bit  8           reg_ltm_lmax_med_en       // unsigned ,    RW, default = 1  enable lmax median filter: 0: disable, 1: enable
//Bit  7: 6        reserved
//Bit  5: 4        reg_ltm_lmin_lpf_mode     // unsigned ,    RW, default = 2  adaptive lmin filter mode of regional statistics, 0: no lpf 1:mean, 2:MIN(org,mean), 3:min
//Bit  3: 2        reserved
//Bit  1: 0        reg_ltm_lmax_lpf_mode     // unsigned ,    RW, default = 2  adaptive lmax filter mode of regional statistics, 0: no lpf 1:mean, 2:MAX(org,mean), 3:max
#define ISP_LTM_STA_HIDX_0_1                       ((0x1214  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_1       // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_0       // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LTM_STA_HIDX_2_3                       ((0x1215  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_3       // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_2       // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LTM_STA_HIDX_4_5                       ((0x1216  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_5       // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_4       // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LTM_STA_HIDX_6_7                       ((0x1217  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_7       // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_6       // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LTM_STA_HIDX_8_9                       ((0x1218  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_9       // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_8       // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LTM_STA_HIDX_10_11                     ((0x1219  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_hidx_11      // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_ltm_stat_hidx_10      // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LTM_STA_HIDX_12                        ((0x121a  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ltm_stat_hidx_12      // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LTM_STA_VIDX_0_1                       ((0x121b  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_vidx_1       // unsigned ,    RW, default = 270  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_0       // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LTM_STA_VIDX_2_3                       ((0x121c  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_vidx_3       // unsigned ,    RW, default = 810  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_2       // unsigned ,    RW, default = 540  block boundary x-index
#define ISP_LTM_STA_VIDX_4_5                       ((0x121d  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_vidx_5       // unsigned ,    RW, default = 1350  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_4       // unsigned ,    RW, default = 1080  block boundary x-index
#define ISP_LTM_STA_VIDX_6_7                       ((0x121e  << 2) + 0xff000000)
//Bit 31:16        reg_ltm_stat_vidx_7       // unsigned ,    RW, default = 1890  block boundary x-index
//Bit 15: 0        reg_ltm_stat_vidx_6       // unsigned ,    RW, default = 1620  block boundary x-index
#define ISP_LTM_STA_VIDX_8                         ((0x121f  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ltm_stat_vidx_8       // unsigned ,    RW, default = 2160  block boundary x-index
#define ISP_LTM_STA_HST_SUM_GLBL                   ((0x1220  << 2) + 0xff000000)
//Bit 31: 0        ro_sum_log_4096_l         // unsigned ,    RO, default = 0  log_4096 sum lower u32
#define ISP_LTM_STA_HST_SUM_GLBH                   ((0x1221  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16: 0        ro_sum_log_4096_h         // unsigned ,    RO, default = 0  log_4096 sum higher u17
#define ISP_LTM_STA_GLB                            ((0x1222  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        ro_ltm_gmax_idx           // unsigned ,    RO, default = 0  global max index
//Bit 15:10        reserved
//Bit  9: 0        ro_ltm_gmin_idx           // unsigned ,    RO, default = 0  global min index
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ltm_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_ltm_reg_hw.h
//
// synopsys translate_off
// synopsys translate_on
//====================================================================================
//      ToneMapping HW/LUT register SPACE
//      0x80-0xff
//====================================================================================
#define ISP_LTM_STA_THD_ADDR                       ((0x1230  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_sta_thd_lut_addr // unsigned ,    RW, default = 0
#define ISP_LTM_STA_THD_DATA                       ((0x1231  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_sta_thd_lut_data // unsigned ,    RW, default = 0
#define ISP_LTM_BLK_STA_ADDR                       ((0x1232  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_blk_sta_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_BLK_STA_DATA                       ((0x1233  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_blk_sta_data     // unsigned ,    RW, default = 0
#define ISP_LTM_CCRAT_ADDR                         ((0x1234  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_ccrat_lut_addr   // unsigned ,    RW, default = 0
#define ISP_LTM_CCRAT_DATA                         ((0x1235  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_ccrat_lut_data   // unsigned ,    RW, default = 0
#define ISP_LTM_CCALP_ADDR                         ((0x1236  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_ccalp_lut_addr   // unsigned ,    RW, default = 0
#define ISP_LTM_CCALP_DATA                         ((0x1237  << 2) + 0xff000000)
//Bit 31:0      reg_isp_ltm_ccalp_lut_data   // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMIN_ADDR                       ((0x1238  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_lmin_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMIN_DATA                       ((0x1239  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_lmin_data     // unsigned ,    RO, default = 0
#define ISP_LTM_RO_LMAX_ADDR                       ((0x123a  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_lmax_addr     // unsigned ,    RW, default = 0
#define ISP_LTM_RO_LMAX_DATA                       ((0x123b  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_lmax_data     // unsigned ,    RO, default = 0
#define ISP_LTM_RO_BLK_SUM_ADDR                    ((0x123c  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_blk_sum_addr      // unsigned ,    RW, default = 0
#define ISP_LTM_RO_BLK_SUM_DATA                    ((0x123d  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_blk_sum_data      // unsigned ,    RO, default = 0
#define ISP_LTM_RO_GLB_ADDR                        ((0x123e  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_glb_addr      // unsigned ,    RW, default = 0
#define ISP_LTM_RO_GLB_DATA                        ((0x123f  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_sta_glb_data      // unsigned ,    RO, default = 0
#define ISP_LTM_RO_BIN_ADDR                        ((0x1240  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_bin_addr          // unsigned ,    RW, default = 0
#define ISP_LTM_RO_BIN_DATA                        ((0x1241  << 2) + 0xff000000)
//Bit 31:0      ro_isp_ltm_bin_data          // unsigned ,    RO, default = 0
#define ISP_TM_GCLK                                ((0x1242  << 2) + 0xff000000)
//Bit 31:13     reserved
//Bit 12        pls_frm_flg_clr              // unsigned  ,   W1T, default = 0 //pls to clear pingpong frm cnt
//Bit 11:0      reg_tm_gclk_ctrl             // unsigned  ,   RW, default = 0
#define ISP_LTM_DBGINFO_RST                        ((0x1243  << 2) + 0xff000000)
//Bit 31:3         reserved
//Bit 2:1          reg_ltm_frm_end_mask      // unsigned ,    RW, default = 0
//Bit 0            reg_ltm_dbginfo_rst       // unsigned ,    RW, default = 0
#define ISP_LTM_DBG_RO_0                           ((0x1244  << 2) + 0xff000000)
//Bit 31: 0        ro_ltm_dbg0               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_1                           ((0x1245  << 2) + 0xff000000)
//Bit 31: 0        ro_ltm_dbg1               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_2                           ((0x1246  << 2) + 0xff000000)
//Bit 31: 0        ro_ltm_dbg2               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_3                           ((0x1247  << 2) + 0xff000000)
//Bit 31: 0        ro_ltm_dbg3               // unsigned ,    RO, default = 0
#define ISP_LTM_DBG_RO_4                           ((0x1248  << 2) + 0xff000000)
//Bit 31: 0        ro_ltm_dbg4               // unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ltm_reg_hw.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB0_APB_BASE = 0x14
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_dms_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DMS_COMMON_PARAM0                      ((0x1400  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 5        reserved
//Bit  4           reg_dms_cdif_sgn_invrt    // unsigned ,    RW, default = 1  cdif sign invert enable, default = (reg_dms_xphase_ofst%2,=1, set once for each sensor
//Bit  3: 2        reg_dms_xphase_ofst       // unsigned ,    RW, default = 1  offset in x dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each sensor
//Bit  1: 0        reg_dms_yphase_ofst       // unsigned ,    RW, default = 0  offset in y dimension for 2x2 rgb bayer dms, if grbg, set xphs_ofst=yphs_ofst=0, rggb: xphs_ofst=1, yphs_ofst=0, set once for each sensor
#define ISP_DMS_COMMON_PARAM1                      ((0x1401  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25           reg_dms_ext_type          // unsigned ,    RW, default = 1  extend type for dms.0:2 lines extend 1:4 lines extend.
//Bit 24           reg_dms_pipe2b_org_en     // unsigned ,    RW, default = 1  enable register to do CDM filter on original R/B channels, default = 1
//Bit 23           reg_dms_rb_cerr_usecdif   // unsigned ,    RW, default = 0  int pipe2 use cdif for error_c calc instead of RB diff, default = 0, if set 1, care more about color diff as gradient
//Bit 22:19        reg_dms_rb_cerr_gain      // unsigned ,    RW, default = 4  int pipe2 error_c gain for blend with error_g for error, norm to 4 as 1.0, default = 4
//Bit 18:15        reg_dms_rb_cur_chn_cerr_gain // unsigned ,    RW, default = 8  int pipe2 error_c gain for blend with error_g for error, norm to 4 as 1.0, default = 4
//Bit 14: 9        reg_dms_rb_coring_ratio   // unsigned ,    RW, default = 24  adaptive coring ratio for high frequency color noise reduction for PIPE2 , norm to 64 as 1.0; default = 24;
//Bit  8: 3        reg_dms_p3_coring_ratio   // unsigned ,    RW, default = 24  adaptive coring ratio for high frequency color noise reduction for PIPE3 , norm to 64 as 1.0; default = 24;
//Bit  2: 0        reg_dms_bypass            // unsigned ,    RW, default = 0  0/1: n (no debug); 2: n-2 line results; 3:n-1 line;4:n-line 5:n+1 6:n+2; ; 7: n-line dms bypassed and put Bayer on RGB channels
#define ISP_DMS_CDM_GRN                            ((0x1402  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:17        reg_dms_grn_cdm_err_rs    // unsigned ,    RW, default = 2  right shift for the 6abs to get the normalized u8 error, default = 2
//Bit 16           reg_dms_grn_cdm_cor_dif   // unsigned ,    RW, default = 0  only have bigger texture cored by smaller one as adaptive coring, smaller texture coring to 0; default = 0;
//Bit 15:14        reserved
//Bit 13: 8        reg_dms_grn_cdm_cor_rat   // unsigned ,    RW, default = 8  coring rate to texture for the gradient, normalized to 64 as 1.0, default = 16, if rat=0, no coring
//Bit  7: 0        reg_dms_grn_cdm_cor_lmt   // unsigned ,    RW, default = 255  limit of coring to the gradient, final coring no more than this 2x in u11 scale, default = 255(*2);
#define ISP_DMS_GRN_REF0                           ((0x1403  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_dms_gref_marginx4     // signed ,    RW, default = 0  condition margin for green interpolation refinement
//Bit  7            reserved
//Bit  6           reg_dms_gref_chk_hfrq     // unsigned ,    RW, default = 1  check high frequency for green interpolation refinement
//Bit  5           reg_dms_gref_grd_sel      // unsigned ,    RW, default = 0  0: use gradh/gradv, 1: use varh/varv for green interpolation refinement
//Bit  4           reg_dms_gref_en_4         // unsigned ,    RW, default = 0  enable green interpolation refinement
//Bit  3           reg_dms_gref_en_3         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  2           reg_dms_gref_en_2         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  1           reg_dms_gref_en_1         // unsigned ,    RW, default = 1  enable green interpolation refinement
//Bit  0           reg_dms_gref_en_0         // unsigned ,    RW, default = 0  enable green interpolation refinement
#define ISP_DMS_GRN_REF1                           ((0x1404  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17: 8        reg_dms_gref_hrfq_thrd    // unsigned ,    RW, default = 94  high frequency threshold for green interpolation refinement
//Bit  7: 0        reg_dms_gref_strength     // unsigned ,    RW, default = 255  strength for green interpolation refinement
#define ISP_DMS_PRE_PARAM                          ((0x1405  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_prefilt_thrd_igrn     // unsigned ,    RW, default = 20  four pixel grouping sigma threshold for Green Channels, set to 255 will be force filter, default= 20
//Bit 15: 8        reg_prefilt_thrd_ired     // unsigned ,    RW, default = 18  four pixel grouping sigma threshold for Blue/Red Channels, set to 255 will be force filter, default=18
//Bit  7: 2        reserved
//Bit  1           reg_prefilt_force_raw2_ir // unsigned ,    RW, default = 0  force raw data onto IR, 0: no force, 1: force raw to IR component, default =0;
//Bit  0           reg_prefilt_force_raw2_bayer // unsigned ,    RW, default = 0  force raw data considered as bayer2x2, default =0
#define ISP_DMS_CT_PARAM0                          ((0x1406  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ctran_coring          // unsigned ,    RW, default = 30  coring to the color transition_level, ignore small color transition
//Bit  7: 6        reg_ctran_h_dial_win      // unsigned ,    RW, default = 2  horizontal dialation window size for ctran_h, 0: no dialation  else (x+1)
//Bit  5: 4        reg_ctran_v_dial_win      // unsigned ,    RW, default = 2  horizontal dialation window size for ctran_v, 0: no dialation, else (x+1)
//Bit  3           reg_ctran_powersaving     // unsigned ,    RW, default = 0  enable bit gate the ctran clock for power saving, just output cdf_l
//Bit  2           reg_ctrs_csat_max_en      // unsigned ,    RW, default = 1  enable bit to do ctrs and csat max to get ctrans, default = 1
//Bit  1           reg_ctran_h_lpf_en        // unsigned ,    RW, default = 1  enable bit to do horizontal [12221] lpf for lbuf_ctran_h_lpf, default = 1
//Bit  0           reg_ctran_v_lpf_en        // unsigned ,    RW, default = 1  enable bit to do horizontal [12221] lpf for lbuf_ctran_v_lpf, default = 1
#define ISP_DMS_CT_PARAM1                          ((0x1407  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_ctran_sat_thrd        // unsigned ,    RW, default = 40  to sat=abs(u or v), if smaller than thrd, sat_trs_leve=0; sat_level norm to 128 as 1
//Bit 15: 8        reg_ctran_sat_rate       // unsigned ,    RW, default = 32  to (sat-thrd)/32, norm to 32 as "1"; default = 32;
//Bit  7: 0        reg_ctran_sat_limt        // unsigned ,    RW, default = 128  limit, normalized 128 as 1
#define ISP_DMS_CT_PARAM2                          ((0x1408  << 2) + 0xff000000)
//Bit 31:24        reg_ctran_gain_h          // unsigned ,    RW, default = 128  final gain to tran_level_h to get alpha, normalized to 64 as 1, if =0, means cdf_l 100%
//Bit 23:16        reg_ctran_gain_v          // unsigned ,    RW, default = 128  final gain to tran_level_v to get alpha, normalized to 64 as 1, if =0, means cdf_l 100%
//Bit 15: 8        reg_ctran_alph_minmax_1   // unsigned ,    RW, default = 255  min and max limit for pct_h(alpha) for cdifh_long and cdifh_short blender, larger of pct_h, the more use cdifh_short
//Bit  7: 0        reg_ctran_alph_minmax_0   // unsigned ,    RW, default = 0  min and max limit for pct_h(alpha) for cdifh_long and cdifh_short blender, larger of pct_h, the more use cdifh_short
#define ISP_DMS_CT_PARAM3                          ((0x1409  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_ctran_alpv_minmax_1   // unsigned ,    RW, default = 255  min and max limit for pct_v(alpha) for cdifv_long and cdifv_short blender, larger of pct_v, the more use cdifv_short
//Bit  7: 0        reg_ctran_alpv_minmax_0   // unsigned ,    RW, default = 1  min and max limit for pct_v(alpha) for cdifv_long and cdifv_short blender, larger of pct_v, the more use cdifv_short
#define ISP_DMS_DRT_GRAD                           ((0x140a  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_drt_gradh_gain        // unsigned ,    RW, default = 8  gain to err_horz(2), normalized to 4 as 1.0
//Bit 11: 8        reg_drt_gradv_gain        // unsigned ,    RW, default = 8  gain to err_vert(2), normalized to 4 as 1.0
//Bit  7: 4        reg_drt_gradd_gain        // unsigned ,    RW, default = 8  gain to err_diag(1/3), normalized to 4 as 1.0
//Bit  3           reg_drt_onirraw_en        // unsigned ,    RW, default = 0  enable for IR raw, 0: only apply on bayer RGB2x2 after pre-filter, no Ir; 1: apply on raw with RGBIr, 2x2/4x4
//Bit  2           reg_drt_grad_phs03        // unsigned ,    RW, default = 1  enable to include Gr/Gb gradient, 0: no Gr/Gb gradient; 1: ws Gr/Gb gradient;
//Bit  1           reg_drt_grad_phs1         // unsigned ,    RW, default = 1  enable to include phase-1 pixels gradient, 0: no phs1 gradient; 1: ws phs1 gradient; ir4x4 is for R/B mix, set to "0"
//Bit  0           reg_drt_grad_phs2         // unsigned ,    RW, default = 1  enable to include phase-2 pixels gradient, 0: no phs2 gradient; 1: ws phs2 gradient; ir4x4 is for Ir, can set to '1'
#define ISP_DMS_DRT_MAXERR                         ((0x140b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_drt_maxerr_viir_thrd  // unsigned ,    RW, default = 60  4x is thrd to |maxerr_cur- maxerr_iir| for IIR mute, larger than 4x will mute the viir
//Bit 15:12        reg_drt_maxerr_viir_rate // unsigned ,    RW, default = 8  if (|maxerr_cur- maxerr_iir|> Max(maxerr_cur, maxerr_iir)*rate), for IIR mute,
//Bit 11: 8        reg_drt_maxerr_viir_alph  // unsigned ,    RW, default = 8  alpha for viir to maxerr, normalized to 16 as 1.0, default = 8;
//Bit  7: 5        reserved
//Bit  4           reg_drt_maxerr_viir_en    // unsigned ,    RW, default = 1  enable for the vertical iir filter enable
//Bit  3: 1        reserved
//Bit  0           reg_drt_maxerr_viir_frce  // unsigned ,    RW, default = 1  force viir if min_idx=2 detected
#define ISP_DMS_DRT_PARAM                          ((0x140c  << 2) + 0xff000000)
//Bit 31:24        reg_drt_grad_calp         // unsigned ,    RW, default = 40  color error alpha for final error blend, normalized to 32 as 1.0
//Bit 23:16        reg_drt_grad_calp_for_color_transition // unsigned ,    RW, default = 50  color error alpha for final error blend, normalized to 32 as 1.0
//Bit 15: 4        reg_drt_hfrq_coring       // unsigned ,    RW, default = 16  coring threshold for high frequency count in drt
//Bit  3: 1        reserved
//Bit  0           reg_drt_grad_err_mode     // unsigned ,    RW, default = 0  0: orginal error, 1: blended error, error mode for final error ouput
#define ISP_DMS_DRT_HFRQ0                          ((0x140d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_drt_hfrq_dif_thd_1    // unsigned ,    RW, default = 256  dif threshold1 for dif to gain calc. for high frequency count in drt
//Bit 15:12        reserved
//Bit 11: 0        reg_drt_hfrq_dif_thd_0    // unsigned ,    RW, default = 64  dif threshold0 for dif to gain calc. for high frequency count in drt
#define ISP_DMS_DRT_HFRQ1                          ((0x140e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_drt_hfrq_dif_thd_3    // unsigned ,    RW, default = 128  dif threshold3 for dif to gain calc. for high frequency count in drt
//Bit 15:12        reserved
//Bit 11: 0        reg_drt_hfrq_dif_thd_2    // unsigned ,    RW, default = 384  dif threshold2 for dif to gain calc. for high frequency count in drt
#define ISP_DMS_DRT_HFRQ2                          ((0x140f  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_drt_hfrq_hv_gain      // unsigned ,    RW, default = 16  horizontal or vertical gains for high frequency count in drt
//Bit  7: 4        reserved
//Bit  3: 0        reg_drt_hfrq_bld_alp      // unsigned ,    RW, default = 8  blend alpha for high frequency count in drt, normalized to 16 as 1.0
#define ISP_DMS_DRT_AMBG0                          ((0x1410  << 2) + 0xff000000)
//Bit 31:28        reg_drt_ambg_alp_lut_7    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 27:24        reg_drt_ambg_alp_lut_6    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 23:20        reg_drt_ambg_alp_lut_5    // unsigned ,    RW, default = 15  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 19:16        reg_drt_ambg_alp_lut_4    // unsigned ,    RW, default = 14  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 15:12        reg_drt_ambg_alp_lut_3    // unsigned ,    RW, default = 12  alpha lut of high frequency ambiguity for drt ambiguity
//Bit 11: 8        reg_drt_ambg_alp_lut_2    // unsigned ,    RW, default = 10  alpha lut of high frequency ambiguity for drt ambiguity
//Bit  7: 4        reg_drt_ambg_alp_lut_1    // unsigned ,    RW, default = 8  alpha lut of high frequency ambiguity for drt ambiguity
//Bit  3: 0        reg_drt_ambg_alp_lut_0    // unsigned ,    RW, default = 4  alpha lut of high frequency ambiguity for drt ambiguity
#define ISP_DMS_DRT_AMBG1                          ((0x1411  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_drt_ambg_mxerr_lmt_1  // unsigned ,    RW, default = 256  max err limit (min/max) for drt ambiguity
//Bit 15:10        reserved
//Bit  9: 0        reg_drt_ambg_mxerr_lmt_0  // unsigned ,    RW, default = 12  max err limit (min/max) for drt ambiguity
#define ISP_DMS_DRT_AMBG2                          ((0x1412  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_drt_ambg_hfrq_thd     // unsigned ,    RW, default = 128  high frequency threshold for dmsc with drt ambiguity
//Bit 15:10        reserved
//Bit  9: 0        reg_drt_ambg_cerr_thd     // unsigned ,    RW, default = 512  color error threshold for dmsc with drt ambiguity
#define ISP_DMS_DRT_AMBG3                          ((0x1413  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15            reserved
//Bit 14:12        reg_drt_ambg_var_sft      // signed ,    RW, default = -2  shift for var calc. for drt ambiguity
//Bit 11: 9        reserved
//Bit  8           reg_drt_ambg_var_frce     // unsigned ,    RW, default = 0  force var calc. for drt ambiguity
//Bit  7: 5        reserved
//Bit  4           reg_drt_ambg_ref_en_4     // unsigned ,    RW, default = 0  enable dmsc refinement for drt ambiguity
//Bit  3           reg_drt_ambg_ref_en_3     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  2           reg_drt_ambg_ref_en_2     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  1           reg_drt_ambg_ref_en_1     // unsigned ,    RW, default = 1  enable dmsc refinement for drt ambiguity
//Bit  0           reg_drt_ambg_ref_en_0     // unsigned ,    RW, default = 0  enable dmsc refinement for drt ambiguity
#define ISP_DMS_DRT_AMBG4                          ((0x1414  << 2) + 0xff000000)
//Bit 31:24        reg_drt_ambg_var_frce_val_0 // unsigned ,    RW, default = 255  force value for var calc. for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_frce_val_1 // unsigned ,    RW, default = 0  force value for var calc. for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_grd_thrd // unsigned ,    RW, default = 128  threshold of grad for var calc. for drt ambiguity
//Bit  7: 5        reserved
//Bit  4           reg_drt_ambg_var_grd_sel  // unsigned ,    RW, default = 1  0:short, 1: long, selection of grad for var calc. for drt ambiguity
//Bit  3: 1        reserved
//Bit  0           reg_drt_ambg_var_cdf_sel  // unsigned ,    RW, default = 0  0:short, 1: long, selection of cdif for var calc. for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_0                     ((0x1415  << 2) + 0xff000000)
//Bit 31:24        reg_drt_ambg_var_lut_3    // unsigned ,    RW, default = 45  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_2    // unsigned ,    RW, default = 32  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_1    // unsigned ,    RW, default = 23  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_0    // unsigned ,    RW, default = 0  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_1                     ((0x1416  << 2) + 0xff000000)
//Bit 31:24        reg_drt_ambg_var_lut_7    // unsigned ,    RW, default = 128  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_6    // unsigned ,    RW, default = 111  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_5    // unsigned ,    RW, default = 91  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_4    // unsigned ,    RW, default = 64  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_2                     ((0x1417  << 2) + 0xff000000)
//Bit 31:24        reg_drt_ambg_var_lut_11   // unsigned ,    RW, default = 181  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_10   // unsigned ,    RW, default = 169  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_9    // unsigned ,    RW, default = 157  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_8    // unsigned ,    RW, default = 143  lut of vars for drt ambiguity
#define ISP_DMS_AMBG_SQR_LUT_3                     ((0x1418  << 2) + 0xff000000)
//Bit 31:24        reg_drt_ambg_var_lut_15   // unsigned ,    RW, default = 255  lut of vars for drt ambiguity
//Bit 23:16        reg_drt_ambg_var_lut_14   // unsigned ,    RW, default = 239  lut of vars for drt ambiguity
//Bit 15: 8        reg_drt_ambg_var_lut_13   // unsigned ,    RW, default = 222  lut of vars for drt ambiguity
//Bit  7: 0        reg_drt_ambg_var_lut_12   // unsigned ,    RW, default = 202  lut of vars for drt ambiguity
#define ISP_DMS_PP_EN                              ((0x1419  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reserved
//Bit  7: 6        reserved
//Bit  5           reg_dms_pp_enable         // unsigned ,    RW, default = 1  enable for dms post-processing, 0, disable pp; 1: enable pp
//Bit  4           reg_plp_en                // unsigned ,    RW, default = 0  enable post median filter
//Bit  3: 0        reg_plp_alp               // unsigned ,    RW, default = 0  alpha to blend output of low-pass filter and current value.)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dms_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_dms_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
// in page offset 8'h00 | 8'h70~8'h7f
#define ISP_DMS_CORE_GCLK_CTRL                     ((0x1470  << 2) + 0xff000000)
//Bit  31: 0        reg_dms_core_gclk_ctrl          // unsigned ,    RW, default = 0
#define ISP_DMS_PP_GCLK_CTRL                       ((0x1471  << 2) + 0xff000000)
//Bit  31: 0        reg_dms_pp_gclk_ctrl            // unsigned ,    RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_dms_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB1_APB_BASE = 0x18
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg0_top_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_POST_TOP_MISC                          ((0x1800  << 2) + 0xff000000)
//Bit 31: 4        reg_post_misc             // unsigned ,    RW, default = 0
//Bit  3           reg_af_stats_path_en      // unsigned ,    RW, default = 0
//Bit  2           reg_flkr_stats_path_en    // unsigned ,    RW, default = 0
//Bit  1           reg_ir_out_path_en        // unsigned ,    RW, default = 0
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0
#define ISP_POST_TOP_GCLK_CTRL0                    ((0x1801  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl0            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_GCLK_CTRL1                    ((0x1802  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl1            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_SYNC_CTRL0                    ((0x1803  << 2) + 0xff000000)
//Bit 31: 0        reg_sync_ctrl0            // unsigned ,    RW, default = 0
#define ISP_POST_TOP_SYNC_CTRL1                    ((0x1804  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_sync_ctrl1            // unsigned ,    RW, default = 0
#define ISP_POST_STATS_RAM_ADDR                    ((0x1805  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0
#define ISP_POST_RO_STATS_RAM_DATA                 ((0x1806  << 2) + 0xff000000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0
#define ISP_POST_INT_EN                            ((0x1807  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_post_int_en           // unsigned ,    RW, default = 0
#define ISP_POST_INT_STATUS                        ((0x1808  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_post_int_status       // unsigned ,    RW, default = 0
#define ISP_POST_RO_DBG_STATE                      ((0x1809  << 2) + 0xff000000)
//Bit 31: 0        ro_post_dbg_state         // unsigned ,    RO, default = 0
#define ISP_POST_C422_MODE                         ((0x180f  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1: 0        reg_444to422_mode         // unsigned ,    RW, default = 2
#define ISP_CM0_INP_OFST01                         ((0x1810  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_offset_inp_1      // signed ,    RW, default = 0  input data offset1 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_offset_inp_0      // signed ,    RW, default = 0  input data offset0 for cm0
#define ISP_CM0_INP_OFST2                          ((0x1811  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_cm0_offset_inp_2      // signed ,    RW, default = 0  input data offset2 for cm0
#define ISP_CM0_COEF00_01                          ((0x1812  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_0_1     // signed ,    RW, default = 150  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_0_0     // signed ,    RW, default = 77  matrix coefficients for cm0
#define ISP_CM0_COEF02_10                          ((0x1813  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_1_0     // signed ,    RW, default = -43  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_0_2     // signed ,    RW, default = 29  matrix coefficients for cm0
#define ISP_CM0_COEF11_12                          ((0x1814  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_1_2     // signed ,    RW, default = 128  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_1_1     // signed ,    RW, default = -85  matrix coefficients for cm0
#define ISP_CM0_COEF20_21                          ((0x1815  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_3x3matrix_2_1     // signed ,    RW, default = -107  matrix coefficients for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_2_0     // signed ,    RW, default = 128  matrix coefficients for cm0
#define ISP_CM0_COEF22_OUP_OFST0                   ((0x1816  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm0_offset_oup_0      // signed ,    RW, default = 0  output data offset0 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_3x3matrix_2_2     // signed ,    RW, default = -21  matrix coefficients for cm0
#define ISP_CM0_OUP_OFST12_RS                      ((0x1817  << 2) + 0xff000000)
//Bit 31:30        reg_cm0_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s4.8; 1: s3.9; 2: s2.10 3:s1.11, matrix right shift for cm0
//Bit 29            reserved
//Bit 28:16        reg_cm0_offset_oup_2      // signed ,    RW, default = 512  output data offset2 for cm0
//Bit 15:13        reserved
//Bit 12: 0        reg_cm0_offset_oup_1      // signed ,    RW, default = 512  output data offset1 for cm0
#define ISP_CM1_INP_OFST01                         ((0x181e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_offset_inp_1      // signed ,    RW, default = -512  input data offset1 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_offset_inp_0      // signed ,    RW, default = 0  input data offset0 for cm1
#define ISP_CM1_INP_OFST2                          ((0x181f  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_cm1_offset_inp_2      // signed ,    RW, default = -512  input data offset2 for cm1
#define ISP_CM1_COEF00_01                          ((0x1820  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_0_1     // signed ,    RW, default = 0  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_0_0     // signed ,    RW, default = 256  matrix coefficients for cm1
#define ISP_CM1_COEF02_10                          ((0x1821  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_1_0     // signed ,    RW, default = 256  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_0_2     // signed ,    RW, default = 359  matrix coefficients for cm1
#define ISP_CM1_COEF11_12                          ((0x1822  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_1_2     // signed ,    RW, default = -183  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_1_1     // signed ,    RW, default = -88  matrix coefficients for cm1
#define ISP_CM1_COEF20_21                          ((0x1823  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_3x3matrix_2_1     // signed ,    RW, default = 454  matrix coefficients for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_2_0     // signed ,    RW, default = 256  matrix coefficients for cm1
#define ISP_CM1_COEF22_OUP_OFST0                   ((0x1824  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_cm1_offset_oup_0      // signed ,    RW, default = 0  output data offset0 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_3x3matrix_2_2     // signed ,    RW, default = 0  matrix coefficients for cm1
#define ISP_CM1_OUP_OFST12_RS                      ((0x1825  << 2) + 0xff000000)
//Bit 31:30        reg_cm1_3x3mtrx_rs        // unsigned ,    RW, default = 0  0 s4.8; 1: s3.9; 2: s2.10 3:s1.11, matrix right shift for cm0
//Bit 29            reserved
//Bit 28:16        reg_cm1_offset_oup_2      // signed ,    RW, default = 0  output data offset2 for cm1
//Bit 15:13        reserved
//Bit 12: 0        reg_cm1_offset_oup_1      // signed ,    RW, default = 0  output data offset1 for cm1
#define ISP_CCM_MTX_00_01                          ((0x1826  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_0_1     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_0_0     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_02_03                          ((0x1827  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_0_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_0_2     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_10_11                          ((0x1828  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_1_1     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_1_0     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_12_13                          ((0x1829  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_1_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_1_2     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_20_21                          ((0x182a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_4x3matrix_2_1     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_2_0     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_22_23_RS                       ((0x182b  << 2) + 0xff000000)
//Bit 31:30        reg_ccm_4x3mtrx_rs        // unsigned ,    RW, default = 0  0: s4.8 1: s3.9 2: s2.10, 3: s1.11, right shift for ccm normalization,
//Bit 29            reserved
//Bit 28:16        reg_ccm_4x3matrix_2_3     // signed ,    RW, default = 0  4x3 matrix coefficients for ccm
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_4x3matrix_2_2     // signed ,    RW, default = 256  4x3 matrix coefficients for ccm
#define ISP_CCM_MTX_GAIN01                         ((0x182c  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_gain_1            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_gain_0            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
#define ISP_CCM_MTX_GAIN23                         ((0x182d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_ccm_gain_3            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
//Bit 15:13        reserved
//Bit 12: 0        reg_ccm_gain_2            // signed ,    RW, default = 256  gain for R/G/B/IR channel for antifog function
#define ISP_CCM_MTX_OFST01                         ((0x182e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ccm_ofst_1            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
//Bit 15:12        reserved
//Bit 11: 0        reg_ccm_ofst_0            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
#define ISP_CCM_MTX_OFST23                         ((0x182f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ccm_ofst_3            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
//Bit 15:12        reserved
//Bit 11: 0        reg_ccm_ofst_2            // unsigned ,    RW, default = 0  offset R/G/B/IR for antifog function
#define ISP_PST_GAMMA_MODE                         ((0x1830  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_pst_gamma_mode        // unsigned ,    RW, default = 0  0: equidistance, 1: non-equidistance, mode for pst gamma lut
#define ISP_PST_GAMMA_STP                          ((0x1831  << 2) + 0xff000000)
//Bit 31:28        reg_pst_gamma_stp_7       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 27:24        reg_pst_gamma_stp_6       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 23:20        reg_pst_gamma_stp_5       // unsigned ,    RW, default = 4  step for each segment of  pst gamma lut
//Bit 19:16        reg_pst_gamma_stp_4       // unsigned ,    RW, default = 2  step for each segment of  pst gamma lut
//Bit 15:12        reg_pst_gamma_stp_3       // unsigned ,    RW, default = 2  step for each segment of  pst gamma lut
//Bit 11: 8        reg_pst_gamma_stp_2       // unsigned ,    RW, default = 1  step for each segment of  pst gamma lut
//Bit  7: 4        reg_pst_gamma_stp_1       // unsigned ,    RW, default = 0  step for each segment of  pst gamma lut
//Bit  3: 0        reg_pst_gamma_stp_0       // unsigned ,    RW, default = 0  step for each segment of  pst gamma lut
#define ISP_PST_GAMMA_NUM                          ((0x1832  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_pst_gamma_num_7       // unsigned ,    RW, default = 5  numbers for each segment of  pst gamma lut
//Bit 27            reserved
//Bit 26:24        reg_pst_gamma_num_6       // unsigned ,    RW, default = 4  numbers for each segment of  pst gamma lut
//Bit 23            reserved
//Bit 22:20        reg_pst_gamma_num_5       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 19            reserved
//Bit 18:16        reg_pst_gamma_num_4       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 15            reserved
//Bit 14:12        reg_pst_gamma_num_3       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit 11            reserved
//Bit 10: 8        reg_pst_gamma_num_2       // unsigned ,    RW, default = 3  numbers for each segment of  pst gamma lut
//Bit  7            reserved
//Bit  6: 4        reg_pst_gamma_num_1       // unsigned ,    RW, default = 4  numbers for each segment of  pst gamma lut
//Bit  3            reserved
//Bit  2: 0        reg_pst_gamma_num_0       // unsigned ,    RW, default = 5  numbers for each segment of  pst gamma lut
#define ISP_PST_GAMMA_LUT_ADDR                     ((0x1833  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_pst_gamma_lut_addr    // unsigned ,    RW, default = 0  gamma LUT address, max size is (129+1)/2*4=65*4
#define ISP_PST_GAMMA_LUT_DATA                     ((0x1834  << 2) + 0xff000000)
//Bit 31: 0        reg_pst_gamma_lut_data    // unsigned ,    RW, default = 0  gamma LUT data
#define ISP_CVR_RECT_EN                            ((0x1839  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_hlc_luma_trgt         // unsigned ,    RW, default = 40 hlc target luma value
//Bit 15:14        reserved
//Bit 13: 4        reg_hlc_luma_thd          // unsigned ,    RW, default = 992 hlc threshold
//Bit  3           reserved
//Bit  2           reg_hlc_en                // unsigned ,    RW, default = 0  enable high light cover
//Bit  1           reserved
//Bit  0           reg_cvr_rect_en           // unsigned ,    RW, default = 0  enable cover rectangles
#define ISP_CVR_RECT_HVSTART_0                     ((0x183a  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_0     // unsigned ,    RW, default = 0  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_0     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_0                      ((0x183b  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_0       // unsigned ,    RW, default = 180  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_0       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_0                         ((0x183c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_0      // unsigned ,    RW, default = 0  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_0      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_0      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_1                     ((0x183d  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_1     // unsigned ,    RW, default = 200  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_1     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_1                      ((0x183e  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_1       // unsigned ,    RW, default = 380  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_1       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_1                         ((0x183f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_1      // unsigned ,    RW, default = 36  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_1      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_1      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_2                     ((0x1840  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_2     // unsigned ,    RW, default = 400  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_2     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_2                      ((0x1841  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_2       // unsigned ,    RW, default = 580  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_2       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_2                         ((0x1842  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_2      // unsigned ,    RW, default = 72  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_2      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_2      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_3                     ((0x1843  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_3     // unsigned ,    RW, default = 600  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_3     // unsigned ,    RW, default = 200  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_3                      ((0x1844  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_3       // unsigned ,    RW, default = 780  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_3       // unsigned ,    RW, default = 380  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_3                         ((0x1845  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_3      // unsigned ,    RW, default = 108  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_3      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_3      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_4                     ((0x1846  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_4     // unsigned ,    RW, default = 800  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_4     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_4                      ((0x1847  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_4       // unsigned ,    RW, default = 980  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_4       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_4                         ((0x1848  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_4      // unsigned ,    RW, default = 144  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_4      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_4      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_5                     ((0x1849  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_5     // unsigned ,    RW, default = 1000  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_5     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_5                      ((0x184a  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_5       // unsigned ,    RW, default = 1180  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_5       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_5                         ((0x184b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_5      // unsigned ,    RW, default = 180  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_5      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_5      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_6                     ((0x184c  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_6     // unsigned ,    RW, default = 1200  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_6     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_6                      ((0x184d  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_6       // unsigned ,    RW, default = 1380  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_6       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_6                         ((0x184e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_6      // unsigned ,    RW, default = 216  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_6      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_6      // unsigned ,    RW, default = 128  V values of cover rectangles
#define ISP_CVR_RECT_HVSTART_7                     ((0x184f  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hstart_7     // unsigned ,    RW, default = 1400  horizontal start of cover rectangles
//Bit 15: 0        reg_cvr_rect_vstart_7     // unsigned ,    RW, default = 400  vertical start of cover rectangles
#define ISP_CVR_RECT_HVSIZE_7                      ((0x1850  << 2) + 0xff000000)
//Bit 31:16        reg_cvr_rect_hend_7       // unsigned ,    RW, default = 1580  horizontal size of cover rectangles
//Bit 15: 0        reg_cvr_rect_vend_7       // unsigned ,    RW, default = 580  vertical size of cover rectangles
#define ISP_CVR_RECT_YUV_7                         ((0x1851  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cvr_rect_val_y_7      // unsigned ,    RW, default = 255  Y values of cover rectangles
//Bit 15: 8        reg_cvr_rect_val_u_7      // unsigned ,    RW, default = 128  U values of cover rectangles
//Bit  7: 0        reg_cvr_rect_val_v_7      // unsigned ,    RW, default = 128  V values of cover rectangles
//cm2 from 0x52-0xbf
//
// Reading file:  ./isp_inc/inc_sw/isp_post_cm2_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CM2_ADDR_PORT                          ((0x1852  << 2) + 0xff000000)
//Bit 31: 0        reg_cm2_ram_addr          // unsigned ,    RW, default = 0
#define ISP_CM2_DATA_PORT                          ((0x1853  << 2) + 0xff000000)
//Bit 31: 0        reg_cm2_ram_data          // unsigned ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_0                     ((0x1854  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_adj_satglbgain_via_y_3 // signed ,    RW, default = 0
//Bit 23:16        reg_cm2_adj_satglbgain_via_y_2 // signed ,    RW, default = 0
//Bit 15: 8        reg_cm2_adj_satglbgain_via_y_1 // signed ,    RW, default = 0
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_0 // signed ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_1                     ((0x1855  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_adj_satglbgain_via_y_7 // signed ,    RW, default = 0
//Bit 23:16        reg_cm2_adj_satglbgain_via_y_6 // signed ,    RW, default = 0
//Bit 15: 8        reg_cm2_adj_satglbgain_via_y_5 // signed ,    RW, default = 0
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_4 // signed ,    RW, default = 0
#define ISP_CM2_SAT_GLB_GAIN_2                     ((0x1856  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_cm2_adj_satglbgain_via_y_8 // signed ,    RW, default = 0
#define ISP_CM2_EN                                 ((0x1857  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28            reserved
//Bit 27           reg_cm2_filter_en         // unsigned ,    RW, default = 1  enable signal for CM2 filter
//Bit 26           reg_cm2_lum_adj_en        // unsigned ,    RW, default = 1  enable bit for CM2_Lum_adj
//Bit 25           reg_cm2_hue_adj_en        // unsigned ,    RW, default = 1  enable bit for CM2_Hue_adj
//Bit 24           reg_cm2_sat_adj_en        // unsigned ,    RW, default = 1  Enable bit for CM2_Sat_adj
//Bit 23:12        reg_cm2_global_hue        // unsigned ,    RW, default = 0  global hue setting
//Bit 11: 0        reg_cm2_global_sat        // unsigned ,    RW, default = 512  global saturation setting normalized to 512
#define ISP_CM2_LUMA_MIN_MAX                       ((0x1858  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:25        reg_cm2_onlpf_mode        // unsigned ,    RW, default = 0
//Bit 24           reg_cm2_onlpf_interleave  // unsigned ,    RW, default = 0
//Bit 23:12        reg_cm2_luma_min          // unsigned ,    RW, default = 0  luma minimal
//Bit 11: 0        reg_cm2_luma_max          // unsigned ,    RW, default = 4095  luma max
#define ISP_CM2_CHRM_U_MIN_MAX                     ((0x1859  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_chrm_u_min        // unsigned ,    RW, default = 0  chroma u minimal
//Bit 11: 0        reg_cm2_chrm_u_max        // unsigned ,    RW, default = 4095  chroma u maximum
#define ISP_CM2_CHRM_V_MIN_MAX                     ((0x185a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_chrm_v_min        // unsigned ,    RW, default = 0  chroma v minimal
//Bit 11: 0        reg_cm2_chrm_v_max        // unsigned ,    RW, default = 4095  chroma v maximum
#define ISP_CM2_ADJ_LUMA_VIA_HUE                   ((0x185b  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:20        reg_cm2_adj_luma_via_hue_lshift // unsigned ,    RW, default = 0  no shift.  1: (-256~254) 2:(-512~508)  3: (-1024~1016)
//Bit 19: 8        reg_cm2_adj_luma_via_hue_satth // unsigned ,    RW, default = 400
//Bit  7: 0        reg_cm2_adj_luma_via_hue_satk // unsigned ,    RW, default = 64  normalized with 16
#define ISP_CM2_ADJ_HUE_VIA_HUE                    ((0x185c  << 2) + 0xff000000)
//Bit 31:20        reg_cm2_adj_hue_via_hue_satth // unsigned ,    RW, default = 100
//Bit 19:12        reg_cm2_adj_hue_via_hue_satk // unsigned ,    RW, default = 64  u4.4 normalized with 16
//Bit 11: 0        reg_cm2_adj_sat_via_hue_satth // unsigned ,    RW, default = 20
#define ISP_CM2_BEFORE_UV_OFFSET                   ((0x185d  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_adj_sat_via_hue_satk // unsigned ,    RW, default = 16
//Bit 23:12        reg_cm2_before_u_offset   // signed ,    RW, default = 0
//Bit 11: 0        reg_cm2_before_v_offset   // signed ,    RW, default = 0
#define ISP_CM2_AFTER_UV_OFFSET                    ((0x185e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_cm2_after_u_offset    // signed ,    RW, default = 0
//Bit 11: 0        reg_cm2_after_v_offset    // signed ,    RW, default = 0
#define ISP_CM2_HUE_ADJ_MISC                       ((0x185f  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16: 5        reg_cm2_before_hue_offset // unsigned ,    RW, default = 0  0~4095
//Bit  4           reg_cm2_hue_div_mode      // unsigned ,    RW, default = 0  32 pieces 360/32 degrees each slice; 1: first 20 slices 360/64 degrees, others 360/16 degrees
//Bit  3: 1        reg_cm2_adj_hue_via_hs_mode // unsigned ,    RW, default = 0  0: 1024/2048/3072, 4095; 1: 512, 1024, 1536, 2048; 2: 256, 512, 768, 1024; 3: 128, 256, 384, 512; 4: 512/1024/2048/4096; 5: 256/512/1024/2048; 6: 128/256/512/1024; 7: 128/256/512/1024
//Bit  0           reg_cm2_hue_protect_en    // unsigned ,    RW, default = 1  Hue protection if Saturation is out of UV range.
#define ISP_CM2_ADJ_SAT_VIA_HS                     ((0x1860  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:19        reg_cm2_adj_sat_via_hs_satth0 // unsigned ,    RW, default = 400  threshold on Sat
//Bit 18: 7        reg_cm2_adj_sat_via_hs_satth1 // unsigned ,    RW, default = 800
//Bit  6: 5        reg_cm2_adj_sat_via_hs_rshift // unsigned ,    RW, default = 0  0: (0,2)  1: (0.5, 1.5)
//Bit  4: 3        reg_cm2_adj_satgain_via_y_rshift // unsigned ,    RW, default = 0  0: (0,2)  1: (0.5, 1.5)
//Bit  2: 0        reg_cm2_adj_hue_via_hsv_lshift // unsigned ,    RW, default = 4  0: (-128,127)  1: (-256, 254)
#define ISP_CM2_LUMA_BC                            ((0x1861  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24:12        reg_cm2_luma_brightness   // signed ,    RW, default = 0  brightness of the image
//Bit 11: 0        reg_cm2_luma_contrast     // unsigned ,    RW, default = 1024  contrast of the luma, normalized to 1024 as 1.0
#define ISP_CM2_LUMA_BL                            ((0x1862  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_cm2_luma_blacklevel   // unsigned ,    RW, default = 256  black level of the luma during contrast adjustments
#define ISP_CM2_DEMO_ROI_START                     ((0x1863  << 2) + 0xff000000)
//Bit 31:28        reg_cm2_demo_coi_rplmode  // unsigned ,    RW, default = 0  bits[1:0] for COI, bits[3:2] for other pixels than COI;  bit[1:0]: 0 - no replacement for COI   1: disable CM2 Enhance for COI; 2 - Keep COI pixelsY, but replace [*HS];  3: ow COI pixels to [*YHS]; bit[3:2]: similar control to pixels other than COI
//Bit 27:14        reg_cm2_demo_roi_xstart   // unsigned ,    RW, default = 0  start col index of the Region of Interest (ROI)
//Bit 13: 0        reg_cm2_demo_roi_ystart   // unsigned ,    RW, default = 0  col index of the Region of Interest (ROI)
#define ISP_CM2_DEMO_ROI_END                       ((0x1864  << 2) + 0xff000000)
//Bit 31:18        reg_cm2_demo_roi_xend     // unsigned ,    RW, default = 0  ending row index of the Region of Interest (ROI)
//Bit 17: 4        reg_cm2_demo_roi_yend     // unsigned ,    RW, default = 0  ending row index of the Region of Interest (ROI)
//Bit  3: 0        reg_cm2_demo_roi_cm2mode  // unsigned ,    RW, default = 0  control ROI, bit[3:2] control other than ROI
#define ISP_CM2_DEMO_POI                           ((0x1865  << 2) + 0xff000000)
//Bit 31:18        reg_cm2_demo_poi_x        // unsigned ,    RW, default = 0  col index of the Pixel(position) of Interest (POI)
//Bit 17: 4        reg_cm2_demo_poi_y        // unsigned ,    RW, default = 0  row index of the Pixel(position) of Interest (POI)
//Bit  3: 0        reg_cm2_demo_poi_rplmode  // unsigned ,    RW, default = 0  pixel replace mode pixel(position) of Interest, 0 no replacements ;1 one pixle replace to [*YHS]; 2 3X3 pixels replace to [*YHS]; 3 5X5 pixels replace to [*YHS]
#define ISP_CM2_DEMO_OWR                           ((0x1866  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_demo_owr_y        // unsigned ,    RW, default = 200  luma value overrated ROI/POI/COI
//Bit 23:12        reg_cm2_demo_owr_h        // unsigned ,    RW, default = 1000  hue value overrated ROI/POI/COI
//Bit 11: 0        reg_cm2_demo_owr_s        // unsigned ,    RW, default = 2547  sat value overrated ROI/POI/COI
#define ISP_CM2_DEMO_COI_START                     ((0x1867  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_demo_coi_ystart   // unsigned ,    RW, default = 10  start of Luma value for Color of Interest (COI)
//Bit 23:12        reg_cm2_demo_coi_hstart   // unsigned ,    RW, default = 1748  start of Hue value for Color of Interest (COI)
//Bit 11: 0        reg_cm2_demo_coi_sstart   // unsigned ,    RW, default = 10  start of Sat value for Color of Interest (COI)
#define ISP_CM2_DEMO_COI_END                       ((0x1868  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_demo_coi_yend     // unsigned ,    RW, default = 220  ending of Luma value for Color of Interest (COI)
//Bit 23:12        reg_cm2_demo_coi_send     // unsigned ,    RW, default = 3000  ending of Sat value for Color of Interest (COI)
//Bit 11: 0        reg_cm2_demo_coi_hend     // unsigned ,    RW, default = 3000  ending of Hue value for Color of Interest (COI)
#define ISP_CM2_DEMO_SPLIT_CTR                     ((0x1869  << 2) + 0xff000000)
//Bit 31:19        reserved
//Bit 18:17        reg_cm2_demo_split_mode   // unsigned ,    RW, default = 0
//Bit 16: 4        reg_cm2_demo_split_post   // unsigned ,    RW, default = 0
//Bit  3: 0        reg_cm2_demo_split_width  // unsigned ,    RW, default = 0
#define ISP_CM2_DEMO_SPLIT_CHN                     ((0x186a  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_demo_split_Y      // unsigned ,    RW, default = 0  luma value  for the split line
//Bit 23:12        reg_cm2_demo_split_H      // unsigned ,    RW, default = 0  hue value for the split line
//Bit 11: 0        reg_cm2_demo_split_S      // unsigned ,    RW, default = 0  sat value for the split line
#define ISP_CM2_STA_WIN_01                         ((0x186b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_cm2_sta_stable_en     // unsigned ,    RW, default = 1  enable bits for statistics function 0: no sta, 1: sta enable within window, 2, sta enable outside window
//Bit 27:14        reg_cm2_sta_win_xxyy_0    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
//Bit 13: 0        reg_cm2_sta_win_xxyy_1    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
#define ISP_CM2_STA_WIN_23                         ((0x186c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:14        reg_cm2_sta_win_xxyy_2    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
//Bit 13: 0        reg_cm2_sta_win_xxyy_3    // unsigned ,    RW, default = 0  statistics window xy index [col_start col_end row_start row_end]
#define ISP_CM2_STA_SAT_HIST_MODE                  ((0x186d  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24:22        reg_cm2_sta_sat_hist_mode // unsigned ,    RW, default = 0  mode of saturation histogram: 0/3/7, 1 hue-range, sat_hist as 32bin*1range; 1: 2 hue-range, sat_hist as 16bins*2ranges; 2: 4 hue-range, sat_hist as 8bins*4ranges;4:  2 luma-range, sat_hist as 16bins*2ranges;  5:  4 luma-ranges, sat_hist as 8bins*4ranges;6: 2 hue-ranges, 2 luma_ranges, sat_hist as 8bins*4ranges
//Bit 21:16        reg_cm2_sta_sat_hist_scale // unsigned ,    RW, default = 29  norm to 16 as 1.0
//Bit 15: 8        reg_cm2_sta_sat_hist_rang_thrd_0 // unsigned ,    RW, default = 0  for hue range nodes for histogram statistics of saturations. 256 as 1.0
//Bit  7: 0        reg_cm2_sta_sat_hist_rang_thrd_1 // unsigned ,    RW, default = 64
#define ISP_CM2_STA_SAT_HIST_RANG_HTRD             ((0x186e  << 2) + 0xff000000)
//Bit 31:24        reg_cm2_sta_sat_hist_rang_thrd_2 // unsigned ,    RW, default = 128
//Bit 23:16        reg_cm2_sta_sat_hist_rang_thrd_3 // unsigned ,    RW, default = 192
//Bit 15: 8        reg_cm2_sta_sat_hist_rang_thrd_4 // unsigned ,    RW, default = 255
//Bit  7: 0        reg_cm2_sta_sat_hist_rang_thrd_5 // unsigned ,    RW, default = 255
#define ISP_CM2_STA_MISC                           ((0x186f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cm2_sta_hue_hist_sat_thrd // unsigned ,    RW, default = 32  hue_hist statistics only on pixels saturation>= thrd. 1024 as 1.0, default= 10
//Bit 15: 8        reg_cm2_sta_blk_thrd      // unsigned ,    RW, default = 1  threshold to luma_u8 to count number of black pixels luma_u8<thrd);
//Bit  7: 0        reg_cm2_sta_brt_thrd      // unsigned ,    RW, default = 254  threshold to luma_u8 to count number of bright pixels luma_u8>thrd);
#define FRAME_SIZE_REG                             ((0x1870  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_frm_height            // unsigned ,    RW, default = 0
//Bit 15:13        reserved
//Bit 12: 0        reg_frm_width             // unsigned ,    RW, default = 0
#define RO_FRAME_REG                               ((0x1871  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_cm_ro_frame           // unsigned ,    RW, default = 0
#define ISP_RO_CM2_HUE_HIST_0                      ((0x1872  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_0     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_0                      ((0x1873  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_0     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_1                      ((0x1874  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_1     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_1                      ((0x1875  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_1     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_2                      ((0x1876  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_2     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_2                      ((0x1877  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_2     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_3                      ((0x1878  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_3     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_3                      ((0x1879  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_3     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_4                      ((0x187a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_4     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_4                      ((0x187b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_4     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_5                      ((0x187c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_5     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_5                      ((0x187d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_5     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_6                      ((0x187e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_6     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_6                      ((0x187f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_6     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_7                      ((0x1880  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_7     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_7                      ((0x1881  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_7     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_8                      ((0x1882  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_8     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_8                      ((0x1883  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_8     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_9                      ((0x1884  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_9     // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_9                      ((0x1885  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_9     // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_10                     ((0x1886  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_10    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_10                     ((0x1887  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_10    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_11                     ((0x1888  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_11    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_11                     ((0x1889  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_11    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_12                     ((0x188a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_12    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_12                     ((0x188b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_12    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_13                     ((0x188c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_13    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_13                     ((0x188d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_13    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_14                     ((0x188e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_14    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_14                     ((0x188f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_14    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_15                     ((0x1890  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_15    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_15                     ((0x1891  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_15    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_16                     ((0x1892  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_16    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_16                     ((0x1893  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_16    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_17                     ((0x1894  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_17    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_17                     ((0x1895  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_17    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_18                     ((0x1896  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_18    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_18                     ((0x1897  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_18    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_19                     ((0x1898  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_19    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_19                     ((0x1899  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_19    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_20                     ((0x189a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_20    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_20                     ((0x189b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_20    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_21                     ((0x189c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_21    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_21                     ((0x189d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_21    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_22                     ((0x189e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_22    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_22                     ((0x189f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_22    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_23                     ((0x18a0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_23    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_23                     ((0x18a1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_23    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_24                     ((0x18a2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_24    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_24                     ((0x18a3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_24    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_25                     ((0x18a4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_25    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_25                     ((0x18a5  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_25    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_26                     ((0x18a6  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_26    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_26                     ((0x18a7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_26    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_27                     ((0x18a8  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_27    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_27                     ((0x18a9  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_27    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_28                     ((0x18aa  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_28    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_28                     ((0x18ab  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_28    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_29                     ((0x18ac  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_29    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_29                     ((0x18ad  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_29    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_30                     ((0x18ae  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_30    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_30                     ((0x18af  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_30    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_HUE_HIST_31                     ((0x18b0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_hue_hist_bin_31    // unsigned ,    RO, default = 0  32bins of histogram in hue domain, only pixels within sta_win and sat>sat_thrd will be counted.
#define ISP_RO_CM2_SAT_HIST_31                     ((0x18b1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_sat_hist_bin_31    // unsigned ,    RO, default = 0  32bins of histogram in saturation domain, num of bins in satur decided by sat_hist_mode.
#define ISP_RO_CM2_BLK_BIN                         ((0x18b2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_blk_bin            // unsigned ,    RO, default = 0  number of pixels withi luma< sta_blk_thrd.
#define ISP_RO_CM2_BRT_BIN                         ((0x18b3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_cm2_brt_bin            // unsigned ,    RO, default = 0  number of pixels withi luma> sta_brt_thrd.
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_cm2_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_post_stat_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LC_STA_CTRL                            ((0x18c0  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8           reg_lcstahist_lpf         // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
//Bit  7: 5        reserved
//Bit  4           reg_lc_sta_mode_blk       // unsigned ,    RW, default = 1  regional LC hst sta on XX separately 20bits*16bins:  0: Y-only; 1: MAX(R,G,B),
//Bit  3: 2        reg_lcstahist_pix_drop_mode // unsigned ,    RW, default = 0
//Bit  1           reg_lcsta_inputrgb_glb    // unsigned ,    RW, default = 1  LC glb statistic input 3 components is RGB or YUV:  0: YUV; 1:RGB
//Bit  0           reg_lcsta_inputrgb        // unsigned ,    RW, default = 1  LC blk statistic input 3 components is RGB or YUV:  0: YUV; 1:RGB
#define ISP_PST_DNLP_STA_CTRL                      ((0x18c1  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_pst_sta_sel           // unsigned ,    RW, default = 0  0: global hst sta after lut3d, 1: global hst sta after sharpness, 2: global hst sta after dmsc
//Bit 27:25        reserved
//Bit 24           reg_pst_sta_mode          // unsigned ,    RW, default = 0  LC global hst sta on 256bins:  0: Y-only; 1: MAX(R,G,B),
//Bit 23:17        reserved
//Bit 16           reg_pst_sta_hst_lpf       // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
//Bit 15:10        reserved
//Bit  9: 8        reg_dnlp_sta_sel          // unsigned ,    RW, default = 0  DNLP global hst sta source data sel reg, 0: post_proc NR Y_input; 1: post_proc NR_ouput; 2: post_proc Gaussian Y_output; 3 MAX_RGB of CCM output;
//Bit  7: 5        reserved
//Bit  4           reg_dnlp_sta_mode         // unsigned ,    RW, default = 0  DNLP global hst sta on 64bins:  0: Y-only; 1: MAX(R,G,B),
//Bit  3: 1        reserved
//Bit  0           reg_dnlp_sta_hst_lpf      // unsigned ,    RW, default = 0  STAhist statistics on [1 2 1]/4 filtered results
#define ISP_PST_GLBWIN_H                           ((0x18c2  << 2) + 0xff000000)
//Bit 31:16        reg_pst_glbwin_hend       // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_pst_glbwin_hstart     // unsigned ,    RW, default = 0
#define ISP_PST_GLBWIN_V                           ((0x18c3  << 2) + 0xff000000)
//Bit 31:16        reg_pst_glbwin_vend       // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_pst_glbwin_vstart     // unsigned ,    RW, default = 0
#define ISP_DNLP_GLBWIN_H                          ((0x18c4  << 2) + 0xff000000)
//Bit 31:16        reg_dnlp_glbwin_hend      // unsigned ,    RW, default = 1920
//Bit 15: 0        reg_dnlp_glbwin_hstart    // unsigned ,    RW, default = 0
#define ISP_DNLP_GLBWIN_V                          ((0x18c5  << 2) + 0xff000000)
//Bit 31:16        reg_dnlp_glbwin_vend      // unsigned ,    RW, default = 1080
//Bit 15: 0        reg_dnlp_glbwin_vstart    // unsigned ,    RW, default = 0
#define ISP_LC_STA_HV_NUM                          ((0x18c6  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lcsta_vnum            // unsigned ,    RW, default = 8  Maximum to BLKVMAX, should be same as reg_lc_blk_vnum
//Bit  7: 5        reserved
//Bit  4: 0        reg_lcsta_hnum            // unsigned ,    RW, default = 12  Maximum to BLKHMAX, should be same as reg_lc_blk_hnum
#define ISP_LC_STA_HIDX_0                          ((0x18c7  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_1          // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_0          // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LC_STA_HIDX_1                          ((0x18c8  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_3          // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_2          // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LC_STA_HIDX_2                          ((0x18c9  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_5          // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_4          // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LC_STA_HIDX_3                          ((0x18ca  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_7          // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_6          // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LC_STA_HIDX_4                          ((0x18cb  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_9          // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_8          // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LC_STA_HIDX_5                          ((0x18cc  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_hidx_11         // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_lcsta_hidx_10         // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LC_STA_HIDX_12                         ((0x18cd  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lcsta_hidx_12         // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LC_STA_VIDX_0                          ((0x18ce  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_vidx_1          // unsigned ,    RW, default = 270  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_0          // unsigned ,    RW, default = 0  block boundary y-index
#define ISP_LC_STA_VIDX_1                          ((0x18cf  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_vidx_3          // unsigned ,    RW, default = 810  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_2          // unsigned ,    RW, default = 540  block boundary y-index
#define ISP_LC_STA_VIDX_2                          ((0x18d0  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_vidx_5          // unsigned ,    RW, default = 1350  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_4          // unsigned ,    RW, default = 1080  block boundary y-index
#define ISP_LC_STA_VIDX_3                          ((0x18d1  << 2) + 0xff000000)
//Bit 31:16        reg_lcsta_vidx_7          // unsigned ,    RW, default = 1890  block boundary y-index
//Bit 15: 0        reg_lcsta_vidx_6          // unsigned ,    RW, default = 1620  block boundary y-index
#define ISP_LC_STA_VIDX_8                          ((0x18d2  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lcsta_vidx_8          // unsigned ,    RW, default = 2240  block boundary y-index
#define ISP_LC_STA_CSC_PREOFST_BLK                 ((0x18d3  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_preofst_0   // signed ,    RW, default = 0  pre-offset for luma, limit=1<<(bit_depth-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_preofst_1   // signed ,    RW, default = -512  pre-offset for chroma,       RGB2YUV=-512; / YUV2RGB=0;
#define ISP_LC_STA_CSC_PSTOFST_BLK                 ((0x18d4  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_pstofst_0   // signed ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_pstofst_1   // signed ,    RW, default = 512  rgb2yuv post-offset to yuv,  RGB2YUV=0;  / YUV2RGB=512;
#define ISP_LC_STA_CSC_CLIP_BLK                    ((0x18d5  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_lcsta_csc_clip_0      // unsigned ,    RW, default = 0  down clipping for rgb
//Bit 15:12        reserved
//Bit 11: 0        reg_lcsta_csc_clip_1      // unsigned ,    RW, default = 1023  down clipping for rgb
#define ISP_LC_STA_CSC_PREOFST_GLB                 ((0x18d6  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_preofst_glb_0 // signed ,    RW, default = 0  pre-offset for luma, limit=1<<(bit_depth-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_preofst_glb_1 // signed ,    RW, default = -512  pre-offset for chroma,       RGB2YUV=-512; / YUV2RGB=0;
#define ISP_LC_STA_CSC_PSTOFST_GLB                 ((0x18d7  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_lcsta_csc_pstofst_glb_0 // signed ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:11        reserved
//Bit 10: 0        reg_lcsta_csc_pstofst_glb_1 // signed ,    RW, default = 512  rgb2yuv post-offset to yuv,  RGB2YUV=0;  / YUV2RGB=512;
#define ISP_LC_STA_CSC_CLIP_GLB                    ((0x18d8  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_lcsta_csc_clip_glb_0  // unsigned ,    RW, default = 0  down clipping for rgb
//Bit 15:12        reserved
//Bit 11: 0        reg_lcsta_csc_clip_glb_1  // unsigned ,    RW, default = 1023  down clipping for rgb
#define ISP_LC_STA_BLK_BRT_THRD                    ((0x18d9  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lcsta_blk_thrd        // unsigned ,    RW, default = 1  to luma_u8 to count number of black pixels luma_u8 <drk_thrd;
//Bit  7: 0        reg_lcsta_brt_thrd        // unsigned ,    RW, default = 254  to luma_u8 to count number of bright pixels luma_u8>brt_thrd;
#define ISP_RO_LC_STA_BLK_NUM                      ((0x18da  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_lcsta_blk_num          // unsigned ,    RO, default = 0  of pixels withi luma< sta_blk_thrd.
#define ISP_RO_LC_STA_BRT_NUM                      ((0x18db  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        ro_lcsta_brt_num          // unsigned ,    RO, default = 0  of pixels withi luma> sta_brt_thrd.
#define ISP_RO_PST_STA                             ((0x18dc  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        ro_min_val_glb            // unsigned ,    RO, default = 1023  post glb hst min val
//Bit 15:10        reserved
//Bit  9: 0        ro_max_val_glb            // unsigned ,    RO, default = 0  post glb hst max val
#define ISP_LC_SKIN_HUE_SAT_CTRL                   ((0x18dd  << 2) + 0xff000000)
//Bit 31:24        reg_skin_sat_max          // unsigned ,    RW, default = 48  saturation max for skin color matching, dft =255
//Bit 23:16        reg_skin_sat_min          // unsigned ,    RW, default = 2  saturation min for skin color matching, dft =5,
//Bit 15: 8        reserved
//Bit  7: 4        reg_skin_hue_ed           // unsigned ,    RW, default = 5  hue end  of skin, dft =6
//Bit  3: 0        reg_skin_hue_st           // unsigned ,    RW, default = 4  hue start of skin, dft =5
#define ISP_LC_SKIN_LUMA_CTRL                      ((0x18de  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_skin_luma_max         // unsigned ,    RW, default = 120  luma max for skin color matching, dft =180
//Bit  7: 0        reg_skin_luma_min         // unsigned ,    RW, default = 60  luma min for skin color matching, dft =40
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_stat_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_post_sta_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
//Bit 31:18        reserved
//Bit 17           lc_start_read_region      // unsigned ,    RW, default = 0  signal to start reading region data
//Bit 16           lc_auto_clr_rd_idx        // unsigned ,    RW, default = 0  hist index read clear
//Bit 15:14        lc_rd_idx_auto_inc_mode   // unsigned ,    RW, default = 0  mode of reading hist data, 0: no inc 1: inc by block 2:inc by bin 3: no inc
//Bit 13: 9        lc_rd_sub_index           // unsigned ,    RW, default = 0  hist bin index
//Bit  8: 7        reserved
//Bit  6: 0        lc_rd_index               // unsigned ,    RW, default = 0  hist block index
//Bit 31:31        lc_rd_vld                 // unsigned ,    RO, default = 0  hist read valid signal
//Bit 30: 0        lc_region_out             // unsigned ,    RO, default = 0  hist read data
#define ISP_LC_HIST_BLK_MISC                       ((0x18f6  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 6        lc_sta_blk_enable         // unsigned ,    RW, default = 0  blk stat enalbe
//Bit  5: 0        clk_gating                // unsigned ,    RW, default = 0  clock gating
#define ISP_POST_STA_GLB_MISC                      ((0x18f7  << 2) + 0xff000000)
//Bit 31:30        ro_status                 // unsigned ,    RO, default = 0  bit0:1:ram init done 0:ram not init done bit1:1:data in when ram init 0:normal
//Bit 29:16        reserved
//Bit 15: 8        reg_pst_sta_rd_paddr      // unsigned ,    RW, default = 0  apb read address
//Bit  7: 5        reserved
//Bit  4           reg_pst_sta_err_clr       // unsigned ,    RW, default = 0  ram state error clear
//Bit  3           reg_pst_sta_auto_inc      // unsigned ,    RW, default = 0  1:addr auto increase 0:addr not increase
//Bit  2           reg_pst_sta_clr_ram       // unsigned ,    WO, default = 0  glb ram clear zero, pulse
//Bit  1           reg_pst_sta_auto_clr      // unsigned ,    RW, default = 0  1:clear hist data automatically 0:clear hist data manually
//Bit  0           reg_pst_sta_enable        // unsigned ,    RW, default = 0  global stat enable
#define ISP_POST_STA_GLB_RD                        ((0x18f8  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:0         post_sta_glb_hist_out     // unsigned ,    RO, default = 0  hist read data
#define ISP_POST_STA_BLK_DMA_CNT                   ((0x18f9  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15           reg_clr_errcnt1           // unsigned ,    WO, default = 0  errcnt1 clear signal, pulse
//Bit 14:8         ro_error_cnt1             // unsigned ,    RO, default = 0  errcnt1, the block num which is not received by dma
//Bit 7            reg_clr_errcnt0           // unsigned ,    WO, default = 0  errcnt0 clear signal, pulse
//Bit 6:0          ro_error_cnt0             // unsigned ,    RO, default = 0  errcnt0, the block num which 4 pipe does not finish before next de comes
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_sta_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg0_top_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB2_APB_BASE = 0x19
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg1_peak_cnr_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_POST_PK_GCLK_CTRL                      ((0x1900  << 2) + 0xff000000)
//Bit 31: 0        reg_pk_gclk_ctrl0         // unsigned ,    RW, default = 0
#define ISP_POST_PK_MISC                           ((0x1901  << 2) + 0xff000000)
//Bit 31:24        reg_pk_hblank             // unsigned ,    RW, default = 8
//Bit 23: 0        reg_pk_gclk_ctrl1         // unsigned ,    RW, default = 0
#define ISP_POST_PK_SYNC_CTRL                      ((0x1902  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_pk_sync_ctrl          // unsigned ,    RW, default = 0
#define ISP_POST_DPS_CTL                           ((0x1904  << 2) + 0xff000000)
//Bit 31           reg_pk_luma_ir_mux        // unsigned ,    RW, default = 0  0: luma, 1: ir, luma or ir mux for sharpness
//Bit 30: 8        reserved
//Bit  7           reg_dps_nrssd_en          // unsigned ,    RW, default = 0  enable of power saving for nr ssd calculation module; default=0
//Bit  6           reg_dps_nryflt_en         // unsigned ,    RW, default = 0  enable of power saving for nr Luma filter module; default=0
//Bit  5           reg_dps_nrcflt_en         // unsigned ,    RW, default = 0  enable of power saving for nr Chroma filter module; default=0
//Bit  4           reg_dps_nrbld_en          // unsigned ,    RW, default = 0  enable of power saving for nr Luma/chroma blender module; default=0
//Bit  3           reg_dps_hvcon_en          // unsigned ,    RW, default = 0  enable of power saving for peaking hvcon bank calculation module; default=0
//Bit  2           reg_dps_drtlpfpk_en       // unsigned ,    RW, default = 0  enable of power saving for peaking  module; default=0
//Bit  1           reg_dps_pktibld_en        // unsigned ,    RW, default = 0  enable of power saving for peaking lti  blender module; default=0
//Bit  0           reg_dps_osctr_en          // unsigned ,    RW, default = 0  enable of power saving for os_control module; default=0
#define ISP_POST_NRY_GAU_FILTER                    ((0x1905  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:22        reg_nry_gau_horz          // unsigned ,    RW, default = 1  gaussian filter mode for luma. 0: [1 2 1]/4; 1: [1 2 2 2 1]/8,  2/3: [1 2 3 4 3 2 1]/16
//Bit 21:20        reg_nry_gau_vert          // unsigned ,    RW, default = 1  gaussian filter mode for luma. 0: [1 2 1]/4; 1/up: [1 2 2 2 1]/8,
//Bit 19:16        reg_nry_gau_xrs4          // unsigned ,    RW, default = 15  x/16 is the percentage of gau blending org luma, 0: 100% ori; 15: 100% gau;  defaul= 0
//Bit 15: 8        reserved
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_strength          // unsigned ,    RW, default = 63  strength of the luma noise filter, 63: 100% NR, 0: no NR
#define ISP_POST_NRY_SIGMA_LUT                     ((0x1906  << 2) + 0xff000000)
//Bit 31:24        reg_nry_sigma_lut_4       // unsigned ,    RW, default = 35  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 23:16        reg_nry_sigma_lut_3       // unsigned ,    RW, default = 28  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 15: 8        reg_nry_sigma_lut_2       // unsigned ,    RW, default = 25  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit  7: 0        reg_nry_sigma_lut_1       // unsigned ,    RW, default = 20  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
#define ISP_POST_NRY_SIGMA_BURST                   ((0x1907  << 2) + 0xff000000)
//Bit 31:24        reg_nry_sigma_lut_0       // unsigned ,    RW, default = 15  luma based sigma curves, 4x will be the real sigma, ofst_luma= INT_LUT(luma, LUT);
//Bit 23:20        reg_nry_sigma_rate        // unsigned ,    RW, default = 4  sigma=  Max(k*|max-min|, ofst_luma) for adaptive sigma, the larger of this rate, the more LPF.
//Bit 19: 8        reserved
//Bit  7: 4        reg_nry_burst_num         // unsigned ,    RW, default = 0  number of homo pixels in SGM threshold for burst noise detection,  the larger of this threshold, the easier burst detected, default=3;
//Bit  3: 0        reg_nry_burst_rate        // unsigned ,    RW, default = 4  burst detection thresold delta= range*rate/16, the large this rate, the difficult to detect as burst, default=4;
#define ISP_POST_NRY_ALPHA_MAX_LUT                 ((0x1908  << 2) + 0xff000000)
//Bit 31:28        reg_nry_alpha0_maxerr_lut_7 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 27:24        reg_nry_alpha0_maxerr_lut_6 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 23:20        reg_nry_alpha0_maxerr_lut_5 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 19:16        reg_nry_alpha0_maxerr_lut_4 // unsigned ,    RW, default = 15  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 15:12        reg_nry_alpha0_maxerr_lut_3 // unsigned ,    RW, default = 14  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit 11: 8        reg_nry_alpha0_maxerr_lut_2 // unsigned ,    RW, default = 12  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit  7: 4        reg_nry_alpha0_maxerr_lut_1 // unsigned ,    RW, default = 3  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
//Bit  3: 0        reg_nry_alpha0_maxerr_lut_0 // unsigned ,    RW, default = 0  channel: alpha curv for blending gau_sigma filter results and orignal signal.[0, 8, 16, 32, 64, 128, 192,256]
#define ISP_POST_NRC_GAU_FILTER                    ((0x1909  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:22        reg_nrc_gau_horz          // unsigned ,    RW, default = 0  gaussian filter mode for chroma. 0: [1 2 1]/4; 1: [1 2 2 2 1]/8,  2/3: [1 2 3 4 3 2 1]/16
//Bit 21:20        reg_nrc_gau_vert          // unsigned ,    RW, default = 0  gaussian filter mode for chroma. 0: [1 2 1]/4; 1/up: [1 2 2 2 1]/8,
//Bit 19:16        reg_nrc_gau_xrs4          // unsigned ,    RW, default = 15  x/16 is the percentage of gau blending org chroma, 0: 100% ori; 15: 100% gau;  defaul= 0
//Bit 15: 6        reserved
//Bit  5: 0        reg_nrc_strength          // unsigned ,    RW, default = 63  strength of the chroma noise filter, 63: 100% NR, 0: no NR
#define ISP_POST_PK_SAD_GAIN                       ((0x190d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_sad_hor_gain       // unsigned ,    RW, default = 16  gain to sad[0], 16 normalized to "1";
//Bit 15: 8        reg_pk_sad_ver_gain       // unsigned ,    RW, default = 16  gain to sad[4], 16 normalized to "1";
//Bit  7: 0        reg_pk_sad_diag_gain      // unsigned ,    RW, default = 16  gain to sad[2] and sad[6], 16 normalized to "1";
#define ISP_POST_PK_SAD_RATE                       ((0x190e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_sadla_dis_rate     // unsigned ,    RW, default = 63  low angle and high angle error should not be no less than nearby_error*rate/64; default = 24; 0 same as before changes
//Bit 23:22        reserved
//Bit 21:16        reg_pk_sad_core_rate      // unsigned ,    RW, default = 6  rate of coring for sad(theta) - sad(theta+pi/2)*rate/64
//Bit 15           reg_pk_sad_intlev_mode    // unsigned ,    RW, default = 1  interleave detection xerr mode: 0 max; 1:sum ;
//Bit 14           reg_pk_sad_intlev_mod1    // unsigned ,    RW, default = 1  mode 1 of using diagonal protection: 0: no digonal protection; 1: with diagonal protection
//Bit 13: 8        reg_pk_sad_intlev_gain    // unsigned ,    RW, default = 12  interleave detection for sad gain applied, normalized to 8 as 1
//Bit  7: 0        reg_pk_drtdif_min2sad_th  // unsigned ,    RW, default = 16  for min2_sad threshold for ambiguity ignoring, if (min_sad<min2_sad/2 && min2_sad>thrd) drt_dif=1;
#define ISP_POST_PK_CIR_HP_GAIN                    ((0x190f  << 2) + 0xff000000)
//Bit 31:24        reg_pk_cir_hp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 23:16        reg_pk_cir_hp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_hp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_hp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_HP_GAIN_1                  ((0x1910  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cir_hp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for hpcon<th0) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_hp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_hp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for hpcon>th1) of curve to map hpcon to hpgain for circle hp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_BP_GAIN                    ((0x1911  << 2) + 0xff000000)
//Bit 31:24        reg_pk_cir_bp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit 23:16        reg_pk_cir_bp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map bpcon to bpgain for circle bp filter (all 8 direction same).
//Bit 15: 8        reg_pk_cir_bp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_bp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_CIR_BP_GAIN_1                  ((0x1912  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cir_bp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for bpcon<th0) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit 15: 8        reg_pk_cir_bp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
//Bit  7: 0        reg_pk_cir_bp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for bpcon>th1) of curve to map bpcon to bpgain for circle bp filter (all 8 direction same). 0~255.
#define ISP_POST_PK_DRT_HP_GAIN                    ((0x1913  << 2) + 0xff000000)
//Bit 31:24        reg_pk_drt_hp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit 23:16        reg_pk_drt_hp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_hp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_hp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_HP_GAIN_1                  ((0x1914  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_drt_hp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for hpcon<th0) of curve to map hpcon to hpgain for directional hp filter (best direction).
//Bit 15: 8        reg_pk_drt_hp_con2gain_3  // unsigned ,    RW, default = 61  level limit(for th0<hpcon<th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_hp_con2gain_4  // unsigned ,    RW, default = 61  level limit(for hpcon>th1) of curve to map hpcon to hpgain for directional hp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_BP_GAIN                    ((0x1915  << 2) + 0xff000000)
//Bit 31:24        reg_pk_drt_bp_con2gain_0  // unsigned ,    RW, default = 30  threshold0 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 23:16        reg_pk_drt_bp_con2gain_1  // unsigned ,    RW, default = 80  threshold1 of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_bp_con2gain_5  // unsigned ,    RW, default = 192  rate0 (for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_bp_con2gain_6  // unsigned ,    RW, default = 128  rate1 (for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
#define ISP_POST_PK_DRT_BP_GAIN_1                  ((0x1916  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_drt_bp_con2gain_2  // unsigned ,    RW, default = 60  level limit(for bpcon<th0) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit 15: 8        reg_pk_drt_bp_con2gain_3  // unsigned ,    RW, default = 60  level limit(for th0<bpcon<th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
//Bit  7: 0        reg_pk_drt_bp_con2gain_4  // unsigned ,    RW, default = 60  level limit(for bpcon>th1) of curve to map bpcon to bpgain for directional bp filter (best direction). 0~255.
#define ISP_POST_PK_CIR_FILT_GAIN                  ((0x1917  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_pk_circ_bpf_2dgain    // unsigned ,    RW, default = 64  gain to 2d circle bandpass filter results, normalized to 64 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2dgain    // unsigned ,    RW, default = 64  gain to 2d circle bandpass filter results, normalized to 64 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_0             ((0x1918  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_0_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_0_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_0_1 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_0_0 // signed ,    RW, default = 40  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_1             ((0x1919  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_1_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_1_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_1_1 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_1_0 // signed ,    RW, default = 3  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILTER_BPLUT_2             ((0x191a  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_bpf_2d5x7_2_3 // signed ,    RW, default = 0  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_bpf_2d5x7_2_2 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_bpf_2d5x7_2_1 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_bpf_2d5x7_2_0 // signed ,    RW, default = -4  quarter coef of the 2D bpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_0               ((0x191b  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_0_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_0_2 // signed ,    RW, default = -2  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_0_1 // signed ,    RW, default = -10  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_0_0 // signed ,    RW, default = 64  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_1               ((0x191c  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_1_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_1_2 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_1_1 // signed ,    RW, default = -4  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_1_0 // signed ,    RW, default = -10  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_CIR_FILT_HPLUT_2               ((0x191d  << 2) + 0xff000000)
//Bit 31:24        reg_pk_circ_hpf_2d5x7_2_3 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 23:16        reg_pk_circ_hpf_2d5x7_2_2 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit 15: 8        reg_pk_circ_hpf_2d5x7_2_1 // signed ,    RW, default = 0  quarter coef of the 2D hpf, normalized to 128 as 1.0
//Bit  7: 0        reg_pk_circ_hpf_2d5x7_2_0 // signed ,    RW, default = -2  quarter coef of the 2D hpf, normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_GAIN                  ((0x191e  << 2) + 0xff000000)
//Bit 31:24        reg_pk_bpf_hzgain         // unsigned ,    RW, default = 64  gain to long horizontal BPF for peaking, normalized to 64 as 1.0
//Bit 23:16        reg_pk_bpf_vdgain         // unsigned ,    RW, default = 64  gain to long vertical and diagonal BPF for peaking, normalized to 64 as 1.0
//Bit 15: 8        reg_pk_hpf_hzgain         // unsigned ,    RW, default = 64  gain to long horizontal HPF for peaking, normalized to 64 as 1.0
//Bit  7: 0        reg_pk_hpf_vdgain         // unsigned ,    RW, default = 64  gain to long vertical and diagonal HPF for peaking, normalized to 64 as 1.0
#define ISP_POST_PK_DRT_FILT_BP_LUT                ((0x191f  << 2) + 0xff000000)
//Bit 31:24        reg_pk_bpf_hztap09_3      // signed ,    RW, default = 0  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_bpf_hztap09_2      // signed ,    RW, default = -32  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_bpf_hztap09_1      // signed ,    RW, default = 4  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_bpf_hztap09_0      // signed ,    RW, default = 56  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_HP_LUT                ((0x1920  << 2) + 0xff000000)
//Bit 31:24        reg_pk_hpf_hztap09_3      // signed ,    RW, default = 0  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_hpf_hztap09_2      // signed ,    RW, default = -4  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_hpf_hztap09_1      // signed ,    RW, default = -28  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_hpf_hztap09_0      // signed ,    RW, default = 64  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_BP_LUT_1              ((0x1921  << 2) + 0xff000000)
//Bit 31:24        reg_pk_bpf_hztap09_4      // signed ,    RW, default = 0  tap09 BPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_bpf_vdtap05_2      // signed ,    RW, default = -32  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_bpf_vdtap05_1      // signed ,    RW, default = 4  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_bpf_vdtap05_0      // signed ,    RW, default = 56  tap05 BPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_DRT_FILT_HP_LUT_1              ((0x1922  << 2) + 0xff000000)
//Bit 31:24        reg_pk_hpf_hztap09_4      // signed ,    RW, default = 0  tap09 HPF for horizontal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 23:16        reg_pk_hpf_vdtap05_2      // signed ,    RW, default = -4  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit 15: 8        reg_pk_hpf_vdtap05_1      // signed ,    RW, default = -28  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
//Bit  7: 0        reg_pk_hpf_vdtap05_0      // signed ,    RW, default = 64  tap05 HPF for vertical and diagonal peaking filter, only store half of the filter normalized to 128 as 1.0
#define ISP_POST_PK_FILT_CORING                    ((0x1923  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_cir_hp_coring      // unsigned ,    RW, default = 2  coring of HP for circle filter, is in u10 scale
//Bit 23:22        reserved
//Bit 21:16        reg_pk_cir_bp_coring      // unsigned ,    RW, default = 2  coring of BP for circle filter, is in u10 scale
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_drt_hp_coring      // unsigned ,    RW, default = 2  coring of HP for directional filter, is in u10 scale
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_drt_bp_coring      // unsigned ,    RW, default = 2  coring of BP for directional filter, is in u10 scale
#define ISP_POST_PK_DRT_FILT_MODE                  ((0x1924  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_pk_bias_diag          // unsigned ,    RW, default = 0  bias towards diagonal (45/135) filter for low/high angle filters, default = 0;
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_drt_hp_elpf_mode   // unsigned ,    RW, default = 2  edge adaptive lpf mode for direction HP, larger mode means heavier lpf along edge. 0:no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_drt_bp_elpf_mode   // unsigned ,    RW, default = 2  edge adaptive lpf mode for direction BP, larger mode means heavier lpf along edge. 0:no vert filter on HP; 1: [1 2 1]/4; 2/3: [1 2 2 2 1]/8
#define ISP_POST_PK_BLEND                          ((0x1925  << 2) + 0xff000000)
//Bit 31:28        reg_pk_drtbld_beta_3      // unsigned ,    RW, default = 0  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 27:24        reg_pk_drtbld_beta_2      // unsigned ,    RW, default = 4  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 23:20        reg_pk_drtbld_beta_1      // unsigned ,    RW, default = 8  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 19:16        reg_pk_drtbld_beta_0      // unsigned ,    RW, default = 15  beta for drt and cir blend base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use cir wo drt
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_min           // unsigned ,    RW, default = 0  normalized to 64 as '1'
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_max           // unsigned ,    RW, default = 63  normalized to 64 as '1'
#define ISP_POST_PK_BLEND_ALP_LUT_0                ((0x1926  << 2) + 0xff000000)
//Bit 31:28        reg_pk_alp2_lut2d_7       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_6       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_5       // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_4       // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_3       // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_2       // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_1       // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_0       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_1                ((0x1927  << 2) + 0xff000000)
//Bit 31:28        reg_pk_alp2_lut2d_15      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_14      // unsigned ,    RW, default = 0  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_13      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_12      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_11      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_10      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_9       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_8       // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_2                ((0x1928  << 2) + 0xff000000)
//Bit 31:28        reg_pk_alp2_lut2d_23      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_22      // unsigned ,    RW, default = 10  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_21      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_20      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_19      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_18      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_17      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_16      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_ALP_LUT_3                ((0x1929  << 2) + 0xff000000)
//Bit 31:28        reg_pk_alp2_lut2d_31      // unsigned ,    RW, default = 14  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_alp2_lut2d_30      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 23:20        reg_pk_alp2_lut2d_29      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 19:16        reg_pk_alp2_lut2d_28      // unsigned ,    RW, default = 8  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 15:12        reg_pk_alp2_lut2d_27      // unsigned ,    RW, default = 10  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_26      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_25      // unsigned ,    RW, default = 2  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_24      // unsigned ,    RW, default = 4  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 31           reg_pk_drtbld_beta_en     // unsigned ,    RW, default = 1  enable of direction ambiguity protection for drt and cir blend, beta for , 0, equivalent beta[i]=15, 1, enable
//Bit 30           reg_pk_alp2_maxerr_mode   // unsigned ,    RW, default = 1  0 max err; 1: xerr
//Bit 29:16        reserved
//Bit 15:12        reg_pk_alp2_lut2d_35      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_alp2_lut2d_34      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_alp2_lut2d_33      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_alp2_lut2d_32      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for cir-PK blender, larger coef means less drt-pk, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation, mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_0            ((0x192b  << 2) + 0xff000000)
//Bit 31:28        reg_pk_elpf_lut2d_7       // unsigned ,    RW, default = 0  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_6       // unsigned ,    RW, default = 0
//Bit 23:20        reg_pk_elpf_lut2d_5       // unsigned ,    RW, default = 2
//Bit 19:16        reg_pk_elpf_lut2d_4       // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_3       // unsigned ,    RW, default = 4
//Bit 11: 8        reg_pk_elpf_lut2d_2       // unsigned ,    RW, default = 6
//Bit  7: 4        reg_pk_elpf_lut2d_1       // unsigned ,    RW, default = 12
//Bit  3: 0        reg_pk_elpf_lut2d_0       // unsigned ,    RW, default = 15
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_1            ((0x192c  << 2) + 0xff000000)
//Bit 31:28        reg_pk_elpf_lut2d_15      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_14      // unsigned ,    RW, default = 0
//Bit 23:20        reg_pk_elpf_lut2d_13      // unsigned ,    RW, default = 2
//Bit 19:16        reg_pk_elpf_lut2d_12      // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_11      // unsigned ,    RW, default = 4
//Bit 11: 8        reg_pk_elpf_lut2d_10      // unsigned ,    RW, default = 6
//Bit  7: 4        reg_pk_elpf_lut2d_9       // unsigned ,    RW, default = 15
//Bit  3: 0        reg_pk_elpf_lut2d_8       // unsigned ,    RW, default = 15
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_2            ((0x192d  << 2) + 0xff000000)
//Bit 31:28        reg_pk_elpf_lut2d_23      // unsigned ,    RW, default = 6  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_22      // unsigned ,    RW, default = 10
//Bit 23:20        reg_pk_elpf_lut2d_21      // unsigned ,    RW, default = 15
//Bit 19:16        reg_pk_elpf_lut2d_20      // unsigned ,    RW, default = 2
//Bit 15:12        reg_pk_elpf_lut2d_19      // unsigned ,    RW, default = 2
//Bit 11: 8        reg_pk_elpf_lut2d_18      // unsigned ,    RW, default = 4
//Bit  7: 4        reg_pk_elpf_lut2d_17      // unsigned ,    RW, default = 6
//Bit  3: 0        reg_pk_elpf_lut2d_16      // unsigned ,    RW, default = 12
#define ISP_POST_PK_BLEND_DRT_EDG_LUT_3            ((0x192e  << 2) + 0xff000000)
//Bit 31:28        reg_pk_elpf_lut2d_31      // unsigned ,    RW, default = 14  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 27:24        reg_pk_elpf_lut2d_30      // unsigned ,    RW, default = 15
//Bit 23:20        reg_pk_elpf_lut2d_29      // unsigned ,    RW, default = 4
//Bit 19:16        reg_pk_elpf_lut2d_28      // unsigned ,    RW, default = 8
//Bit 15:12        reg_pk_elpf_lut2d_27      // unsigned ,    RW, default = 10
//Bit 11: 8        reg_pk_elpf_lut2d_26      // unsigned ,    RW, default = 15
//Bit  7: 4        reg_pk_elpf_lut2d_25      // unsigned ,    RW, default = 2
//Bit  3: 0        reg_pk_elpf_lut2d_24      // unsigned ,    RW, default = 4
//Bit 31:16        reserved
//Bit 15:12        reg_pk_elpf_lut2d_35      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit 11: 8        reg_pk_elpf_lut2d_34      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  7: 4        reg_pk_elpf_lut2d_33      // unsigned ,    RW, default = 15  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
//Bit  3: 0        reg_pk_elpf_lut2d_32      // unsigned ,    RW, default = 12  2D-LUT for alpha2 for PK lpf along edge blender, larger coef means less lpf along edge, x-min_err, y-max_err, nodes as 0,8,16,32,64,128,192,256, use bilinear interpolation,  mi=0,ma=0.8..256; mi=8, ma=8..256, ...
#define ISP_POST_PK_FILT_BLEND                     ((0x1930  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_bpf_elpf_frcalp    // unsigned ,    RW, default = 0  force alpha of non-elpf result for bpf calculation, 0:use elpf_lut2d interpolated results, 1: 100% elpf; 63: 100% non-elpf; default = 0
//Bit 23:22        reserved
//Bit 21:16        reg_pk_hpf_elpf_frcalp    // unsigned ,    RW, default = 0  force alpha of non-elpf result for bpf calculation, 0:use elpf_lut2d interpolated results, 1: 100% elpf; 63: 100% non-elpf; default = 0
//Bit 15:10        reserved
//Bit  9: 8        reg_pk_hpdrt_mode         // unsigned ,    RW, default = 3  mode for HPdrt filter: 0 legacy, use minsad direction filter out; 1: new blend between min and min2 corresponding filter results;2: only blend when dat_min and dat_min2 same sign; otherwise use max amp of two; 3: always use max amp of dat_min and dat_min; default 2
//Bit  7: 6        reserved
//Bit  5: 4        reg_pk_bpdrt_mode         // unsigned ,    RW, default = 3  mode for BPdrt filter: 0 legacy, use minsad direction filter out; 1: new blend between min and min2 corresponding filter results;2: only blend when dat_min and dat_min2 same sign; otherwise use max amp of two; 3: always use max amp of dat_min and dat_min; default 2
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_drtbld_range       // unsigned ,    RW, default = 3  range of the min2 and min direction distance: 0 no this condition, 1: distance = 1; 2: distance =1,2; 3: distance = 1,2,3; default =1
#define ISP_POST_PK_LUMA_GAIN_LUT                  ((0x1931  << 2) + 0xff000000)
//Bit 31:28        reg_pkgain_vsluma_lut_7   // unsigned ,    RW, default = 6  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 27:24        reg_pkgain_vsluma_lut_6   // unsigned ,    RW, default = 8  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 23:20        reg_pkgain_vsluma_lut_5   // unsigned ,    RW, default = 7  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 19:16        reg_pkgain_vsluma_lut_4   // unsigned ,    RW, default = 7  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 15:12        reg_pkgain_vsluma_lut_3   // unsigned ,    RW, default = 6  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 11: 8        reg_pkgain_vsluma_lut_2   // unsigned ,    RW, default = 5  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit  7: 4        reg_pkgain_vsluma_lut_1   // unsigned ,    RW, default = 4  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit  3: 0        reg_pkgain_vsluma_lut_0   // unsigned ,    RW, default = 3  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_LUMA_GAIN_LUT_1                ((0x1932  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_pkgain_vsluma_lut_8   // unsigned ,    RW, default = 5  peaking hp/bp_gain vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_LUMA_OSHT_LUT                  ((0x1933  << 2) + 0xff000000)
//Bit 31:28        reg_pkosht_vsluma_lut_7   // unsigned ,    RW, default = 5  peaking overshoot up/down vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
//Bit 27:24        reg_pkosht_vsluma_lut_6   // unsigned ,    RW, default = 0
//Bit 23:20        reg_pkosht_vsluma_lut_5   // unsigned ,    RW, default = 1
//Bit 19:16        reg_pkosht_vsluma_lut_4   // unsigned ,    RW, default = 2
//Bit 15:12        reg_pkosht_vsluma_lut_3   // unsigned ,    RW, default = 3
//Bit 11: 8        reg_pkosht_vsluma_lut_2   // unsigned ,    RW, default = 3
//Bit  7: 4        reg_pkosht_vsluma_lut_1   // unsigned ,    RW, default = 3
//Bit  3: 0        reg_pkosht_vsluma_lut_0   // unsigned ,    RW, default = 2
#define ISP_POST_PK_LUMA_OSHT_LUT_1                ((0x1934  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3: 0        reg_pkosht_vsluma_lut_8   // unsigned ,    RW, default = 0  peaking overshoot up/down vs luma lut to give possibility to do different level of peaking for dark region and bright region, normalized 8 as "1"
#define ISP_POST_PK_FINAL_GAIN                     ((0x1935  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:18        reserved
//Bit 17:16        reg_final_gain_rs         // signed ,    RW, default = 0  right shift bits for the gain normalization, 0 normal to 32 as 1; 1 normalize to 64 as 1; -2 normalized to 8 as 1; -1 normalize 16 as 1. default = 0,
//Bit 15: 8        reg_hp_final_gain         // unsigned ,    RW, default = 100  gain to highpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32
//Bit  7: 0        reg_bp_final_gain         // unsigned ,    RW, default = 100  gain to bandpass boost result (including directional/circle blending), normalized 32 as '1', 0~255. 1.25 * 32
#define ISP_POST_PK_OSHT                           ((0x1936  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:20        reg_pk_os_up              // unsigned ,    RW, default = 830  up margin for overshoot control in 10bits scale, set to 1023 means now OS control.
//Bit 19:18        reserved
//Bit 17: 8        reg_pk_os_down            // unsigned ,    RW, default = 830  dn margin for overshoot control in 10bits scale, set to 1023 means now OS control.
//Bit  7: 6        reserved
//Bit  5: 4        reg_pk_osh_winsize        // unsigned ,    RW, default = 2  (2x+1) is window size in H direction for overshoot control
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_osv_winsize        // unsigned ,    RW, default = 2  (2x+1) is window size in V direction for overshoot control
#define ISP_POST_PK_DEBUG                          ((0x1937  << 2) + 0xff000000)
//Bit 31           reg_demo_hsvsharp_enable  // unsigned ,    RW, default = 0  enable for demo, 0: full screen sharpness enable: 1: only demo region with sharpness on; default=0
//Bit 30:28        reserved
//Bit 27:20        reg_pk_debug_edge         // unsigned ,    RW, default = 0  0 show color for edge
//Bit 19:18        reserved
//Bit 17:16        reg_demo_disp_position    // unsigned ,    RW, default = 2  demo screen split mode: 0: top region as demo; 1: bottom region as demo; 2: left region as demo; 3: right region as demo
//Bit 15: 0        reg_demo_left_top_screen_width // unsigned ,    RW, default = 360  demo mode x/y index for split;
#define ISP_POST_PK_DEBUG_DRT_FORCE                ((0x1938  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_pk_drt_force          // unsigned ,    RW, default = 24  direction of drt peaking filter: 0~7 hp drt force, 8~15: bp drt force; 16~23: bp+hp drt force; else no force; default=24 (do not change in application)
#define ISP_SDE_MODE                               ((0x1939  << 2) + 0xff000000)
//Bit 31:30        reg_pksde_lp_sel          // unsigned ,    RW, default = 1
//Bit 29:11        reserved
//Bit 10: 8        reg_pksde_yuv_mode_0      // unsigned ,    RW, default = 0  Y sde mode for pk, 0: no SDE; 1: YUVrplc+ peaking; 2: YUVrplc - peaking; 3: YUVrplc+ peaking>0; 4: YUVrplc + peaking<0; 5: YUVrplc+ abs(peaking) 6: YUVrplc-abs(peaking); 7: binary
//Bit  7: 0        reserved
#define ISP_SDE_RPLC_PKGAIN                        ((0x193a  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_pksde_pkgain_0        // unsigned ,    RW, default = 8  sde pk Y gain, normalized 8 as "1"
//Bit 19:16        reserved
//Bit 15:12        reserved
//Bit 11: 9        reserved
//Bit  8           reg_pksde_rplc_en_0       // unsigned ,    RW, default = 0  enable replace Y by replace value
//Bit  7: 5        reserved
//Bit  4            reserved
//Bit  3: 1        reserved
//Bit  0            reserved
#define ISP_SDE_YUVRPLC01                          ((0x193b  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reserved
//Bit 15:12        reserved
//Bit 11: 0        reg_pksde_yuv_rplc_0      // unsigned ,    RW, default = 512  Y replace value
#define ISP_SDE_YUV_POS                            ((0x193d  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pksde_yuv_posi_0      // unsigned ,    RW, default = 192  x4 for Y positive value in binary effects
//Bit 15: 8        reserved
//Bit  7: 0        reserved
#define ISP_SDE_YUV_NEG                            ((0x193e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pksde_yuv_negi_0      // unsigned ,    RW, default = 64  x4 for Y negative value in binary effects
//Bit 15: 8        reserved
//Bit  7: 0        reserved
#define ISP_POST_DRT_EN_CTL                        ((0x193f  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19           reg_pk_flt_src_mux        // unsigned ,    RW, default = 1  0: pre filtered data, 1: drt lpf data, filtered source mux for pk,
//Bit 18           reg_dps_drtlpf_en         // unsigned ,    RW, default = 1  enable of power saving for directed low-pass module; default=0
//Bit 17           reg_drtlpf_line_num       // unsigned ,    RW, default = 1  line number used in drt lpf; 0: 3 lines, 1:5 lines
//Bit 16           reg_drtlpf_theta_min_idx_replace // unsigned ,    RW, default = 0  replace min_idx and min_san with min2_idx and min2_sad. default:1
//Bit 15            reserved
//Bit 14           reg_sr3_drtlpf_enable_0   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels; filter module; default=0
//Bit 13           reg_sr3_drtlpf_enable_1   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels;
//Bit 12           reg_sr3_drtlpf_enable_2   // unsigned ,    RW, default = 1  directional lpf on luma U and V channels;
//Bit 11            reserved
//Bit 10           reg_sr3_drtlpf_theta_en_0 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection of power saving for nr Luma filter module; default=0
//Bit  9           reg_sr3_drtlpf_theta_en_1 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  8           reg_sr3_drtlpf_theta_en_2 // unsigned ,    RW, default = 0  theta (pure vertical and horizontal HF burst protection) enable. 0: not enable, 1:enable protection
//Bit  7            reserved
//Bit  6           reg_sr7_drtlpf_beta_en_0  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  5           reg_sr7_drtlpf_beta_en_1  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  4           reg_sr7_drtlpf_beta_en_2  // unsigned ,    RW, default = 0  enable of direction ambiguity protection for drt_lpf, beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx)
//Bit  3            reserved
//Bit  2           reg_sr7_drtlpf_edge_en_0  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
//Bit  1           reg_sr7_drtlpf_edge_en_1  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
//Bit  0           reg_sr7_drtlpf_edge_en_2  // unsigned ,    RW, default = 0  enable of direction lpf based on edge strength
#define ISP_POST_SR3_DRTLPF_DIFF_CTL               ((0x1940  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_drtlpf_diff_ratio     // unsigned ,    RW, default = 4  shift bits for the diff threshold. default:4
//Bit 23:22        reserved
//Bit 21:12        reg_drtlpf_diff_minimum   // unsigned ,    RW, default = 200  value of diff threshold. default: 200
//Bit 11:10        reserved
//Bit  9: 0        reg_drtlpf_diff_maximum   // unsigned ,    RW, default = 500  vvalue of diff threshold, the value must be bigger than minimum. defalut:500
#define ISP_POST_SR3_DRTLPF_ALP0_0                 ((0x1941  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_3    // unsigned ,    RW, default = 9  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_2    // unsigned ,    RW, default = 10  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_1    // unsigned ,    RW, default = 11  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_0    // unsigned ,    RW, default = 12  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_1                 ((0x1942  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_7    // unsigned ,    RW, default = 1  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_6    // unsigned ,    RW, default = 4  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_5    // unsigned ,    RW, default = 7  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_4    // unsigned ,    RW, default = 8  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_2                 ((0x1943  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_sr3_drtlpf_alpha_11   // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 23:22        reserved
//Bit 21:16        reg_sr3_drtlpf_alpha_10   // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit 15:14        reserved
//Bit 13: 8        reg_sr3_drtlpf_alpha_9    // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
//Bit  7: 6        reserved
//Bit  5: 0        reg_sr3_drtlpf_alpha_8    // unsigned ,    RW, default = 0  directional lpf alpha coef for min_sad/max_sad compared to x=0:7 correspond to[1:8]/16; x=8:1:11 correspond to[5:8]/8 ;
#define ISP_POST_SR3_DRTLPF_ALP0_OFST              ((0x1944  << 2) + 0xff000000)
//Bit 31:28        reg_sr3_drtlpf_alpha_ofst_7 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 27:24        reg_sr3_drtlpf_alpha_ofst_6 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 23:20        reg_sr3_drtlpf_alpha_ofst_5 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 19:16        reg_sr3_drtlpf_alpha_ofst_4 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 15:12        reg_sr3_drtlpf_alpha_ofst_3 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit 11: 8        reg_sr3_drtlpf_alpha_ofst_2 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit  7: 4        reg_sr3_drtlpf_alpha_ofst_1 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
//Bit  3: 0        reg_sr3_drtlpf_alpha_ofst_0 // signed ,    RW, default = 0  directional lpf alpha coef ofset of each directions;
#define ISP_POST_SR3_DRTLPF_THETA                  ((0x1945  << 2) + 0xff000000)
//Bit 31:28        reg_sr3_drtlpf_theta_7    // unsigned ,    RW, default = 15  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 27:24        reg_sr3_drtlpf_theta_6    // unsigned ,    RW, default = 14  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 23:20        reg_sr3_drtlpf_theta_5    // unsigned ,    RW, default = 12  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 19:16        reg_sr3_drtlpf_theta_4    // unsigned ,    RW, default = 9  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 15:12        reg_sr3_drtlpf_theta_3    // unsigned ,    RW, default = 6  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit 11: 8        reg_sr3_drtlpf_theta_2    // unsigned ,    RW, default = 4  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit  7: 4        reg_sr3_drtlpf_theta_1    // unsigned ,    RW, default = 2  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
//Bit  3: 0        reg_sr3_drtlpf_theta_0    // unsigned ,    RW, default = 0  directional lpf beta coef for min_sad/min2_sad compared to x=0:7 correspond to[1:8]/16;  0 means no drtLPF, 15: 100% alpha dependant drtLPF
#define ISP_POST_SR3_DRTLPF_BETA                   ((0x1946  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_sr7_drtlpf_beta_3     // unsigned ,    RW, default = 0  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit 11: 8        reg_sr7_drtlpf_beta_2     // unsigned ,    RW, default = 4  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit  7: 4        reg_sr7_drtlpf_beta_1     // unsigned ,    RW, default = 8  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
//Bit  3: 0        reg_sr7_drtlpf_beta_0     // unsigned ,    RW, default = 15  beta for drt filter coef base on the x=cal_drt_dif8(min_idx,min2_idx), beta = lut[x-1], the larger of x, means the higher possibility for ambiguity, beta=0 use org wo lpf
#define ISP_POST_SR3_DRTLPF_EDGE_0                 ((0x1947  << 2) + 0xff000000)
//Bit 31:28        reg_sr7_drtlpf_edge_7     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit 27:24        reg_sr7_drtlpf_edge_6     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit 23:20        reg_sr7_drtlpf_edge_5     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit 19:16        reg_sr7_drtlpf_edge_4     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit 15:12        reg_sr7_drtlpf_edge_3     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit 11: 8        reg_sr7_drtlpf_edge_2     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit  7: 4        reg_sr7_drtlpf_edge_1     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit  3: 0        reg_sr7_drtlpf_edge_0     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
#define ISP_POST_SR3_DRTLPF_EDGE_1                 ((0x1948  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_sr7_drtlpf_edge_9     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
//Bit  3: 0        reg_sr7_drtlpf_edge_8     // unsigned ,    RW, default = 15  lamda for drt lpf base on max_sad [0:16:128鎷㈠崲 255];
#define ISP_POST_ADA_GAIN_EN                       ((0x1949  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_pk_alp2_averstderr_en // unsigned ,    RW, default = 0  enable adaptive gain for peaking
//Bit  0           reg_nr_alp2_averstderr_en // unsigned ,    RW, default = 0  enable adaptive gain for nr.
#define ISP_POST_PK_ADA_GIAN_LUT_0                 ((0x194a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_3 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_2 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_1 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_0 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_1                 ((0x194b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_7 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_6 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_5 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_4 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_2                 ((0x194c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_11 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_10 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_9 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_8 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_3                 ((0x194d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_15 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_14 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_13 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_12 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_4                 ((0x194e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_19 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_18 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_17 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_16 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_5                 ((0x194f  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_23 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_22 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_21 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_20 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_6                 ((0x1950  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_27 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_26 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_25 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_24 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_7                 ((0x1951  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_31 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_30 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_29 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_28 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_8                 ((0x1952  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_35 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_34 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_33 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_32 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_9                 ((0x1953  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_39 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_38 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_37 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_36 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_10                ((0x1954  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_43 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_42 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_41 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_40 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_11                ((0x1955  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_pk_alp2_averstderr_lut2d_47 // unsigned ,    RW, default = 36  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 23:22        reserved
//Bit 21:16        reg_pk_alp2_averstderr_lut2d_46 // unsigned ,    RW, default = 42  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit 15:14        reserved
//Bit 13: 8        reg_pk_alp2_averstderr_lut2d_45 // unsigned ,    RW, default = 48  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
//Bit  7: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_44 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking, .
#define ISP_POST_PK_ADA_GIAN_LUT_12                ((0x1956  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_pk_alp2_averstderr_lut2d_48 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for peaking, larger coef means stronger peaking,
#define ISP_POST_NR_ADA_GIAN_LUT_0                 ((0x1957  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_3 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_2 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_1 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_0 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_1                 ((0x1958  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_7 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_6 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_5 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_4 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_2                 ((0x1959  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_11 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_10 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_9 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_8 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_3                 ((0x195a  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_15 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_14 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_13 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_12 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_4                 ((0x195b  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_19 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_18 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_17 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_16 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_5                 ((0x195c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_23 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_22 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_21 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_20 // unsigned ,    RW, default = 32  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_6                 ((0x195d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_27 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_26 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_25 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_24 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_7                 ((0x195e  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_31 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_30 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_29 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_28 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_8                 ((0x195f  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_35 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_34 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_33 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_32 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_9                 ((0x1960  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_39 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_38 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_37 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_36 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_10                ((0x1961  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_43 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_42 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_41 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_40 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_11                ((0x1962  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nr_alp2_averstderr_lut2d_47 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 23:22        reserved
//Bit 21:16        reg_nr_alp2_averstderr_lut2d_46 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit 15:14        reserved
//Bit 13: 8        reg_nr_alp2_averstderr_lut2d_45 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
//Bit  7: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_44 // unsigned ,    RW, default = 0  2D-LUT for adaptive gain for nr, larger coef means stronger nr.
#define ISP_POST_NR_ADA_GIAN_LUT_12                ((0x1963  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 0        reg_nr_alp2_averstderr_lut2d_48 // unsigned ,    RW, default = 63  2D-LUT for adaptive gain for nr, larger coef means stronger nr,
#define ISP_PK_MOTION_ADP_CTRL                     ((0x1964  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_nry_motion_adp_en     // unsigned ,    RW, default = 0  motion adaptive nry enable
//Bit  0           reg_pk_motion_adp_en      // unsigned ,    RW, default = 0  motion adaptive pk enable
#define ISP_NRY_MOTION_ADP_LUT_0                   ((0x1965  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nry_motion_adp_lut_3  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 23:22        reserved
//Bit 21:16        reg_nry_motion_adp_lut_2  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 15:14        reserved
//Bit 13: 8        reg_nry_motion_adp_lut_1  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_motion_adp_lut_0  // unsigned ,    RW, default = 63  motion adaptive nry lut
#define ISP_NRY_MOTION_ADP_LUT_1                   ((0x1966  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_nry_motion_adp_lut_7  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 23:22        reserved
//Bit 21:16        reg_nry_motion_adp_lut_6  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit 15:14        reserved
//Bit 13: 8        reg_nry_motion_adp_lut_5  // unsigned ,    RW, default = 63  motion adaptive nry lut
//Bit  7: 6        reserved
//Bit  5: 0        reg_nry_motion_adp_lut_4  // unsigned ,    RW, default = 63  motion adaptive nry lut
#define ISP_BP_MOTION_ADP_GAIN_LUT_0               ((0x1967  << 2) + 0xff000000)
//Bit 31:24        reg_bp_motion_adp_gain_lut_3 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 23:16        reg_bp_motion_adp_gain_lut_2 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 15: 8        reg_bp_motion_adp_gain_lut_1 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit  7: 0        reg_bp_motion_adp_gain_lut_0 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
#define ISP_BP_MOTION_ADP_GAIN_LUT_1               ((0x1968  << 2) + 0xff000000)
//Bit 31:24        reg_bp_motion_adp_gain_lut_7 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 23:16        reg_bp_motion_adp_gain_lut_6 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit 15: 8        reg_bp_motion_adp_gain_lut_5 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
//Bit  7: 0        reg_bp_motion_adp_gain_lut_4 // unsigned ,    RW, default = 100  motion adaptive pk bp lut
#define ISP_HP_MOTION_ADP_GAIN_LUT_0               ((0x1969  << 2) + 0xff000000)
//Bit 31:24        reg_hp_motion_adp_gain_lut_3 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 23:16        reg_hp_motion_adp_gain_lut_2 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 15: 8        reg_hp_motion_adp_gain_lut_1 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit  7: 0        reg_hp_motion_adp_gain_lut_0 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
#define ISP_HP_MOTION_ADP_GAIN_LUT_1               ((0x196a  << 2) + 0xff000000)
//Bit 31:24        reg_hp_motion_adp_gain_lut_7 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 23:16        reg_hp_motion_adp_gain_lut_6 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit 15: 8        reg_hp_motion_adp_gain_lut_5 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
//Bit  7: 0        reg_hp_motion_adp_gain_lut_4 // unsigned ,    RW, default = 100  motion adaptive pk hp lut
#define ISP_PST_PRE_CTRL                           ((0x1980  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_pre_hlpf_mode         // unsigned ,    RW, default = 1  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 23:21        reserved
//Bit 20           reg_pre_vlpf_mode         // unsigned ,    RW, default = 1  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 19:17        reserved
//Bit 16           reg_pre_hvlpf_mode        // unsigned ,    RW, default = 0  0: [1 2 1] lpf, 1: [1 2 2 2 1] lpf
//Bit 15:13        reserved
//Bit 12           reg_pre_bpc_en            // unsigned ,    RW, default = 0  enable pre bad pixel correction
//Bit 11: 9        reserved
//Bit  8           reg_pre_cbc_en            // unsigned ,    RW, default = 0  enable pre check board correction
//Bit  7: 5        reserved
//Bit  4           reg_pre_flt_en            // unsigned ,    RW, default = 1  enable pre fliter
//Bit  3: 1        reserved
//Bit  0           reg_pre_art_rmv_en        // unsigned ,    RW, default = 1  enable pre artifact removing in post
#define ISP_PST_PRE_STRENGTH                       ((0x1981  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_pre_flt_thrd          // unsigned ,    RW, default = 2  threshold for pre filter
//Bit 23:22        reserved
//Bit 21:16        reg_pre_bpc_strength      // unsigned ,    RW, default = 63  strength for pre bad pixel correction
//Bit 15:14        reserved
//Bit 13: 8        reg_pre_flt_strength      // unsigned ,    RW, default = 32  strength for pre single line correction
//Bit  7: 6        reserved
//Bit  5: 0        reg_pre_cbc_strength      // unsigned ,    RW, default = 63  strength for pre filter
#define ISP_PST_PRE_BPC_THRD_MARGIN                ((0x1982  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_bpc_dif_thrd      // unsigned ,    RW, default = 12  difference threshold for bpc function
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_bpc_margin        // signed ,    RW, default = -8  os margin for bpc function
#define ISP_PST_PRE_BPC_CTRL                       ((0x1983  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:12        reg_pre_bpc_adpt_rat      // unsigned ,    RW, default = 16  adaptive mode ratio for bpc function, 32 normalized as "1"
//Bit 11: 8        reg_pre_bpc_grp_thrd      // unsigned ,    RW, default = 2  group thresholds for bpc function
//Bit  7: 6        reserved
//Bit  5: 4        reg_pre_bpc_os_mode       // unsigned ,    RW, default = 1  0:use max/min, 1: use max2/min2, 2: use avg+dif1, 3: use avg+dif2, as OS mode for bpc function
//Bit  3: 1        reserved
//Bit  0           reg_pre_bpc_mode          // unsigned ,    RW, default = 0  0: use min2/max2, 1: use adaptive mode, for bpc function
#define ISP_PST_PRE_CBC_THRD0                      ((0x1984  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_cbc_dif01_thrd    // unsigned ,    RW, default = 40  dif01 threshold for cbc
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_cbc_dif02_thrd    // unsigned ,    RW, default = 20  dif02 threshold for cbc
#define ISP_PST_PRE_CBC_THRD1                      ((0x1985  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_pre_cbc_flg_thrd      // unsigned ,    RW, default = 0  threshold for cbc flag
//Bit  7: 6        reserved
//Bit  5: 0        reg_pre_cbc_dif02_vs_01_rat // unsigned ,    RW, default = 30  dif02 vs dif01 ratio for cbc
#define ISP_PST_PRE_SLINE_THRD01                   ((0x1986  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_pre_sline_dif01_min_thrd // unsigned ,    RW, default = 16  dif01 min threshold for single line detection
//Bit 15:10        reserved
//Bit  9: 0        reg_pre_sline_dif02_thrd  // unsigned ,    RW, default = 128  dif02 threshold for single line detection
#define ISP_POST_YRND_CRTL                         ((0x1990  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12           reg_pst_yrnd_seed_reset   // unsigned ,    RW, default = 1  random noise seed reset each frame
//Bit 11            reserved
//Bit 10: 8        reg_pst_yrnd_bandrand     // unsigned ,    RW, default = 6  strength of the noise to added to Y
//Bit  7: 4        reg_pst_yrnd_randlsft     // unsigned ,    RW, default = 5  left shift of rand noise before feeding to randslut, 0
//Bit  3           reg_pst_yrnd_randmode     // unsigned ,    RW, default = 1  mode of rand noise adding, 0: same noise strength for all difs; else: strenght of noise will not exceed the difs
//Bit  2           reg_pst_yrnd_lpf_mode     // unsigned ,    RW, default = 0  lpf mode, 0: 3x3, 1:3x5
//Bit  1           reg_pst_yrnd_hpxor        // unsigned ,    RW, default = 1  random hp portion xor, [0] for luma, [1] for chroma, same for below
//Bit  0           reg_pst_yrnd_en           // unsigned ,    RW, default = 0  enable adding y random noise for post proc.
#define ISP_POST_YRND_APRCT                        ((0x1991  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_pst_yrnd_adp_prct     // unsigned ,    RW, default = 0  adaptive protection for y random noise
#define ISP_POST_LUMA_THRD46                       ((0x1992  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pst_yrnd_luma_thrd_6  // unsigned ,    RW, default = 224  thresholds for luma decision
//Bit 15: 8        reg_pst_yrnd_luma_thrd_5  // unsigned ,    RW, default = 192  thresholds for luma decision
//Bit  7: 0        reg_pst_yrnd_luma_thrd_4  // unsigned ,    RW, default = 160  thresholds for luma decision
#define ISP_POST_LUMA_THRD03                       ((0x1993  << 2) + 0xff000000)
//Bit 31:24        reg_pst_yrnd_luma_thrd_3  // unsigned ,    RW, default = 128  thresholds for luma decision
//Bit 23:16        reg_pst_yrnd_luma_thrd_2  // unsigned ,    RW, default = 96  thresholds for luma decision
//Bit 15: 8        reg_pst_yrnd_luma_thrd_1  // unsigned ,    RW, default = 64  thresholds for luma decision
//Bit  7: 0        reg_pst_yrnd_luma_thrd_0  // unsigned ,    RW, default = 32  thresholds for luma decision
#define ISP_POST_YRND_MAX_MARGIN_LUT1              ((0x1994  << 2) + 0xff000000)
//Bit 31:24        reg_pst_yrnd_max_adp_margin_7 // signed ,    RW, default = -8  of the variation for max Y val after add random noise
//Bit 23:16        reg_pst_yrnd_max_adp_margin_6 // signed ,    RW, default = -7  of the variation for max Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_max_adp_margin_5 // signed ,    RW, default = -6  of the variation for max Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_max_adp_margin_4 // signed ,    RW, default = -5  of the variation for max Y val after add random noise
#define ISP_POST_YRND_MAX_MARGIN_LUT2              ((0x1995  << 2) + 0xff000000)
//Bit 31:24        reg_pst_yrnd_max_adp_margin_3 // signed ,    RW, default = -4  of the variation for max Y val after add random noise
//Bit 23:16        reg_pst_yrnd_max_adp_margin_2 // signed ,    RW, default = -3  of the variation for max Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_max_adp_margin_1 // signed ,    RW, default = -2  of the variation for max Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_max_adp_margin_0 // signed ,    RW, default = -1  of the variation for max Y val after add random noise
#define ISP_POST_YRND_MIN_MARGIN_LUT1              ((0x1996  << 2) + 0xff000000)
//Bit 31:24        reg_pst_yrnd_min_adp_margin_7 // signed ,    RW, default = -8  of the variation for min Y val after add random noise
//Bit 23:16        reg_pst_yrnd_min_adp_margin_6 // signed ,    RW, default = -7  of the variation for min Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_min_adp_margin_5 // signed ,    RW, default = -6  of the variation for min Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_min_adp_margin_4 // signed ,    RW, default = -5  of the variation for min Y val after add random noise
#define ISP_POST_YRND_MIN_MARGIN_LUT2              ((0x1997  << 2) + 0xff000000)
//Bit 31:24        reg_pst_yrnd_min_adp_margin_3 // signed ,    RW, default = -4  of the variation for min Y val after add random noise
//Bit 23:16        reg_pst_yrnd_min_adp_margin_2 // signed ,    RW, default = -3  of the variation for min Y val after add random noise
//Bit 15: 8        reg_pst_yrnd_min_adp_margin_1 // signed ,    RW, default = -2  of the variation for min Y val after add random noise
//Bit  7: 0        reg_pst_yrnd_min_adp_margin_0 // signed ,    RW, default = -1  of the variation for min Y val after add random noise
#define ISP_POST_YRND_LUT                          ((0x1998  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_pst_yrnd_randslut_7   // unsigned ,    RW, default = 0  strenght of randon noise adding base on different luma level
//Bit 27            reserved
//Bit 26:24        reg_pst_yrnd_randslut_6   // unsigned ,    RW, default = 1  strenght of randon noise adding base on different luma level
//Bit 23            reserved
//Bit 22:20        reg_pst_yrnd_randslut_5   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
//Bit 19            reserved
//Bit 18:16        reg_pst_yrnd_randslut_4   // unsigned ,    RW, default = 3  strenght of randon noise adding base on different luma level
//Bit 15            reserved
//Bit 14:12        reg_pst_yrnd_randslut_3   // unsigned ,    RW, default = 4  strenght of randon noise adding base on different luma level
//Bit 11            reserved
//Bit 10: 8        reg_pst_yrnd_randslut_2   // unsigned ,    RW, default = 3  strenght of randon noise adding base on different luma level
//Bit  7            reserved
//Bit  6: 4        reg_pst_yrnd_randslut_1   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
//Bit  3            reserved
//Bit  2: 0        reg_pst_yrnd_randslut_0   // unsigned ,    RW, default = 2  strenght of randon noise adding base on different luma level
#define ISP_POST_YRND_SEED                         ((0x1999  << 2) + 0xff000000)
//Bit 31           reg_pst_yrnd_seed_start   // unsigned ,    RW, default = 1  random seed start
//Bit 30: 0        reg_pst_yrnd_seed         // unsigned ,    RW, default = 31'h60a52f20  noise adding seed for Y. seed[0], 0x60a52f20); as default);
#define ISP_POST_UV_COMPENSATION1                  ((0x199a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_uvdiff_th             // unsigned ,    RW, default = 30  threshold of uv(cur line and cur-1 line,cur line and cur+1 line ) difference,
//Bit 15: 8        reg_uv_compensation_k     // unsigned ,    RW, default = 51  x slope for uv compensation alpha
//Bit  7: 1        reserved
//Bit  0           reg_uv_compensation_en    // unsigned ,    RW, default = 1  enable uv compensation befor cnr2.
#define ISP_POST_UV_COMPENSATION2                  ((0x199b  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:22        reserved
//Bit 21:16        reg_uv_compensation_y0    // unsigned ,    RW, default = 63  threshold0 for uv compensation beta
//Bit 15:14        reserved
//Bit 13: 8        reg_uv_compensation_y1    // unsigned ,    RW, default = 0  y threshold1 for uv compensation beta
//Bit  7: 4        reg_uv_compensation_norm  // unsigned ,    RW, default = 3  normalization for uv compensation beta
//Bit  3: 0        reserved
#define CNR_GCLK_CTRL                              ((0x19a0  << 2) + 0xff000000)
//Bit 31: 0        reg_cnr2_gclk_ctrl        // unsigned ,    RW, default = 0
#define CNR_MISC                                   ((0x19a1  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 0        reg_cnr2_input_hblank     // unsigned ,    RW, default = 8
#define CNR_CTRL                                   ((0x19a2  << 2) + 0xff000000)
//Bit 31:11        reserved
//Bit 10: 8        reg_cnr2_hwnd             // unsigned ,    RW, default = 4  horizontal filter window for cnr2
//Bit  7: 6        reserved
//Bit  5: 4        reg_cnr2_vwnd             // unsigned ,    RW, default = 2  vertical filter window for cnr2
//Bit  3           reg_cnr2_inp_sel          // unsigned ,    RW, default = 1  0: no replace, 1: replace, replace yuv5x center line by pk out line for cnr2
//Bit  2           reg_cnr2_proc_sel         // unsigned ,    RW, default = 0  0: ds42, 1: ds82, nr proc. enable for cnr2
//Bit  1           reg_cnr2_hflt_en          // unsigned ,    RW, default = 1  horizontal filter enable for nr proc. enable for cnr2
//Bit  0           reg_cnr2_vflt_en          // unsigned ,    RW, default = 1  vertical filter enable for nr proc. enable for cnr2
#define CNR_HVDIF_COR_SFT                          ((0x19a3  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reg_cnr2_hdif_rsft        // unsigned ,    RW, default = 2  hdif gain right shift for nr proc. of cnr2
//Bit 25:24        reg_cnr2_vdif_rsft        // unsigned ,    RW, default = 2  vdif gain right shift for nr proc. of cnr2
//Bit 23:16        reg_cnr2_hdif_coring      // unsigned ,    RW, default = 0  hdif coring for nr proc. of cnr2
//Bit 15: 8        reg_cnr2_vdif_coring      // unsigned ,    RW, default = 0  vdif coring for nr proc. of cnr2
//Bit  7            reserved
//Bit  6: 4        reg_cnr2_hdif_mode        // unsigned ,    RW, default = 1  0: ydif, 1: max(udif, vdif), 2: avg(udif, vdif), 3: max(ydif, udif, vdif), 4 or else: avg(ydif, udif, vdif), horizontal dif mode for nr proc. enable for cnr2
//Bit  3            reserved
//Bit  2: 0        reg_cnr2_vdif_mode        // unsigned ,    RW, default = 1  0: ydif, 1: max(udif, vdif), 2: avg(udif, vdif), 3: max(ydif, udif, vdif), 4 or else: avg(ydif, udif, vdif), vertical dif mode for nr proc. enable for cnr2
#define CNR_HVDIF_THRD                             ((0x19a4  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_hdif_minthrd     // unsigned ,    RW, default = 12  hdif min threshold for nr proc. of cnr2
//Bit 23:16        reg_cnr2_vdif_minthrd     // unsigned ,    RW, default = 12  vdif min threshold for nr proc. of cnr2
//Bit 15: 8        reg_cnr2_hdif_maxthrd     // unsigned ,    RW, default = 4  hdif max threshold for nr proc. of cnr2
//Bit  7: 0        reg_cnr2_vdif_maxthrd     // unsigned ,    RW, default = 4  vdif max threshold for nr proc. of cnr2
#define CNR_HDIF_GAIN                              ((0x19a5  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_cnr2_hdif_gain_0      // unsigned ,    RW, default = 0  hdif gain for weight of large min dif
//Bit 15:12        reg_cnr2_hdif_gain_1      // unsigned ,    RW, default = 8  hdif gain for weight related to min/max dif
//Bit 11: 8        reg_cnr2_hdif_gain_2      // unsigned ,    RW, default = 4  hdif gain for weight related to min/max dif
//Bit  7: 4        reg_cnr2_hdif_gain_3      // unsigned ,    RW, default = 1  hdif gain for weight related to min/max dif
//Bit  3: 0        reg_cnr2_hdif_gain_4      // unsigned ,    RW, default = 1  hdif gain for weight related to min/max dif
#define CNR_VDIF_GAIN                              ((0x19a6  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_cnr2_vdif_gain_0      // unsigned ,    RW, default = 0  vdif gain for weight of large min dif
//Bit 15:12        reg_cnr2_vdif_gain_1      // unsigned ,    RW, default = 8  vdif gain for weight related to min/max dif
//Bit 11: 8        reg_cnr2_vdif_gain_2      // unsigned ,    RW, default = 4  vdif gain for weight related to min/max dif
//Bit  7: 4        reg_cnr2_vdif_gain_3      // unsigned ,    RW, default = 1  vdif gain for weight related to min/max dif
//Bit  3: 0        reg_cnr2_vdif_gain_4      // unsigned ,    RW, default = 1  vdif gain for weight related to min/max dif
#define CNR_HVBLD_CTRL                             ((0x19a7  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 8        reg_cnr2_hbld_difgain     // unsigned ,    RW, default = 4  diff gain for horizontal blending, 8 is normalized as "1"
//Bit  7: 4        reg_cnr2_vbld_difgain     // unsigned ,    RW, default = 4  diff gain for vertical blending, 8 is normalized as "1"
//Bit  3           reg_cnr2_hbld_dltmode     // unsigned ,    RW, default = 0  0: max, 1: avg, delta mode for horizontal blending
//Bit  2           reg_cnr2_vbld_dltmode     // unsigned ,    RW, default = 0  0: max, 1: avg, delta mode for vertical blending
//Bit  1           reg_cnr2_hbld_en          // unsigned ,    RW, default = 0  enable horizontal blending
//Bit  0           reg_cnr2_vbld_en          // unsigned ,    RW, default = 0  enalbe vertical blending
#define CNR_HVBLD_ALP_MIMX                         ((0x19a8  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_hbld_alpmin      // unsigned ,    RW, default = 0  min alpha for horizontal blending
//Bit 23:16        reg_cnr2_hbld_alpmax      // unsigned ,    RW, default = 255  max alpha for horizontal blending
//Bit 15: 8        reg_cnr2_vbld_alpmin      // unsigned ,    RW, default = 0  min alpha for vertical blending
//Bit  7: 0        reg_cnr2_vbld_alpmax      // unsigned ,    RW, default = 255  max alpha for vertical blending
#define CNR_HVADD_GAIN                             ((0x19a9  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hadd_gain        // unsigned ,    RW, default = 0  u2.6 horizontal added gain for nr proc. of cnr2
//Bit  7: 0        reg_cnr2_vadd_gain        // unsigned ,    RW, default = 0  u2.6 vertical added gain for nr proc. of cnr2
#define CNR_ADPT_PRCT                              ((0x19aa  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_adp_prct_thrd    // signed ,    RW, default = 0  thresholds for adaptive protection before cnr2 output
//Bit  7: 1        reserved
//Bit  0           reg_cnr2_adp_prct_en      // unsigned ,    RW, default = 0  enable adaptive protection before cnr2 output
#define CNR_UMARGIN                                ((0x19ab  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_cnr2_umargin_up       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin up for nr proc. of cnr2
//Bit 15:12        reserved
//Bit 11: 0        reg_cnr2_umargin_dw       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin down for nr proc. of cnr2
#define CNR_VMARGIN                                ((0x19ac  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_cnr2_vmargin_up       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin up for nr proc. of cnr2
//Bit 15:12        reserved
//Bit 11: 0        reg_cnr2_vmargin_dw       // unsigned ,    RW, default = 1023  (BIT_DEPTH6), u margin down for nr proc. of cnr2
#define CNR_TDIF_RNG_LUT_0                         ((0x19ad  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_3   // unsigned ,    RW, default = 254  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_2   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_1   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_0   // unsigned ,    RW, default = 255  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_1                         ((0x19ae  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_7   // unsigned ,    RW, default = 172  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_6   // unsigned ,    RW, default = 205  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_5   // unsigned ,    RW, default = 232  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_4   // unsigned ,    RW, default = 249  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_2                         ((0x19af  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_11  // unsigned ,    RW, default = 53  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_10  // unsigned ,    RW, default = 76  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_9   // unsigned ,    RW, default = 105  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_8   // unsigned ,    RW, default = 138  tdif range lut for ds84 uv proc.
#define CNR_TDIF_RNG_LUT_3                         ((0x19b0  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_tdif_rng_lut_15  // unsigned ,    RW, default = 0  tdif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_tdif_rng_lut_14  // unsigned ,    RW, default = 2  tdif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_tdif_rng_lut_13  // unsigned ,    RW, default = 7  tdif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_tdif_rng_lut_12  // unsigned ,    RW, default = 21  tdif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_0                         ((0x19b1  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_3   // unsigned ,    RW, default = 254  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_2   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_1   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_0   // unsigned ,    RW, default = 255  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_1                         ((0x19b2  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_7   // unsigned ,    RW, default = 172  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_6   // unsigned ,    RW, default = 205  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_5   // unsigned ,    RW, default = 232  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_4   // unsigned ,    RW, default = 249  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_2                         ((0x19b3  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_11  // unsigned ,    RW, default = 53  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_10  // unsigned ,    RW, default = 76  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_9   // unsigned ,    RW, default = 105  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_8   // unsigned ,    RW, default = 138  ydif range lut for ds84 uv proc.
#define CNR_YDIF_RNG_LUT_3                         ((0x19b4  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_ydif_rng_lut_15  // unsigned ,    RW, default = 0  ydif range lut for ds84 uv proc.
//Bit 23:16        reg_cnr2_ydif_rng_lut_14  // unsigned ,    RW, default = 2  ydif range lut for ds84 uv proc.
//Bit 15: 8        reg_cnr2_ydif_rng_lut_13  // unsigned ,    RW, default = 7  ydif range lut for ds84 uv proc.
//Bit  7: 0        reg_cnr2_ydif_rng_lut_12  // unsigned ,    RW, default = 21  ydif range lut for ds84 uv proc.
#define CNR_FRG_CENT_RAD                           ((0x19b5  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_frg_cent_1       // unsigned ,    RW, default = 0  fringe center1 for cnr2 fringe weight
//Bit 23:16        reg_cnr2_frg_rad_1        // unsigned ,    RW, default = 0  fringe radius1 for cnr2 fringe weight
//Bit 15: 8        reg_cnr2_frg_cent_0       // unsigned ,    RW, default = 245  fringe center0 for cnr2 fringe weight
//Bit  7: 0        reg_cnr2_frg_rad_0        // unsigned ,    RW, default = 40  fringe radius0 for cnr2 fringe weight
#define CNR_CTRST_XTH_K                            ((0x19b6  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_ctrst_xthd       // unsigned ,    RW, default = 16  x threshold for cnr2 contrast
//Bit 15: 0        reg_cnr2_ctrst_kappa      // unsigned ,    RW, default = 480  x slope for cnr2 contrast
#define CNR_CTRST_YTH_NRM                          ((0x19b7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_ctrst_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 contrast
//Bit 15: 8        reg_cnr2_ctrst_ythd1      // unsigned ,    RW, default = 255  y threshold1 for cnr2 contrast
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_ctrst_norm       // unsigned ,    RW, default = 6  normalization for cnr2 contrast
#define CNR_HMAP0_XTH                              ((0x19b8  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hmap0_xthd0      // unsigned ,    RW, default = 205  x threshold0 for cnr2 hue map0
//Bit  7: 0        reg_cnr2_hmap0_xthd1      // unsigned ,    RW, default = 30  x threshold1 for cnr2 hue map0
#define CNR_HMAP0_K                                ((0x19b9  << 2) + 0xff000000)
//Bit 31:16        reg_cnr2_hmap0_kappa0     // unsigned ,    RW, default = 852  x slope0 for cnr2 hue map0
//Bit 15: 0        reg_cnr2_hmap0_kappa1     // unsigned ,    RW, default = 4266  x slope1 for cnr2 hue map0
#define CNR_HMAP0_YTH_NRM                          ((0x19ba  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_hmap0_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 hue map0
//Bit 23:16        reg_cnr2_hmap0_ythd1      // unsigned ,    RW, default = 0  y threshold1 for cnr2 hue map0
//Bit 15: 8        reg_cnr2_hmap0_ythd2      // unsigned ,    RW, default = 255  y threshold2 for cnr2 hue map0
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_hmap0_norm       // unsigned ,    RW, default = 6  normalization for cnr2 hue map0
#define CNR_HMAP1_XTH                              ((0x19bb  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_cnr2_hmap1_xthd0      // unsigned ,    RW, default = 52  x threshold0 for cnr2 hue map1
//Bit  7: 0        reg_cnr2_hmap1_xthd1      // unsigned ,    RW, default = 89  x threshold1 for cnr2 hue map1
#define CNR_HMAP1_K                                ((0x19bc  << 2) + 0xff000000)
//Bit 31:16        reg_cnr2_hmap1_kappa0     // unsigned ,    RW, default = 852  x slope0 for hue cnr2 map1
//Bit 15: 0        reg_cnr2_hmap1_kappa1     // unsigned ,    RW, default = 1800  x slope1 for hue cnr2 map1
#define CNR_HMAP1_YTH_NRM                          ((0x19bd  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_hmap1_ythd0      // unsigned ,    RW, default = 0  y threshold0 for cnr2 hue map1
//Bit 23:16        reg_cnr2_hmap1_ythd1      // unsigned ,    RW, default = 0  y threshold1 for cnr2 hue map1
//Bit 15: 8        reg_cnr2_hmap1_ythd2      // unsigned ,    RW, default = 0  y threshold2 for cnr2 hue map1
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_hmap1_norm       // unsigned ,    RW, default = 6  normalization for cnr2 hue map1
#define CNR_RAD_CENT                               ((0x19be  << 2) + 0xff000000)
//Bit 31:16        reg_cnr2_rad_xcent        // unsigned ,    RW, default = 240  x center for cnr2 radial map
//Bit 15: 0        reg_cnr2_rad_ycent        // unsigned ,    RW, default = 270  y center for cnr2 radial map
#define CNR_RAD_XTH_K                              ((0x19bf  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_rad_xthd         // unsigned ,    RW, default = 24  x threshold for cnr2 radial map
//Bit 15: 0        reg_cnr2_rad_kappa        // unsigned ,    RW, default = 186  x slope for cnr2 radial map
#define CNR_RAD_YTH_NRM                            ((0x19c0  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_rad_ythd0        // unsigned ,    RW, default = 255  y threshold0 for cnr2 radial map
//Bit 15: 8        reg_cnr2_rad_ythd1        // unsigned ,    RW, default = 255  y threshold1 for cnr2 radial map
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_rad_norm         // unsigned ,    RW, default = 6  normalization for cnr2 radial map
#define CNR_LUMA_XTH_K                             ((0x19c1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_luma_xthd        // unsigned ,    RW, default = 128  x threshold for cnr2 luma mapping
//Bit 15: 0        reg_cnr2_luma_kappa       // unsigned ,    RW, default = 640  x slope for cnr2 luma mapping
#define CNR_LUMA_YTH_NRM                           ((0x19c2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_luma_ythd0       // unsigned ,    RW, default = 255  y threshold0 for cnr2 luma mapping
//Bit 15: 8        reg_cnr2_luma_ythd1       // unsigned ,    RW, default = 160  y threshold1 for cnr2 luma mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_luma_norm        // unsigned ,    RW, default = 8  normalization for cnr2 luma mapping
#define CNR_SAT0_XTH_K                             ((0x19c3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat0_xthd        // unsigned ,    RW, default = 64  x threshold for cnr2 sat0 mapping
//Bit 15: 0        reg_cnr2_sat0_kappa       // unsigned ,    RW, default = 1920  x slope for cnr2 sat0 mapping
#define CNR_SAT0_YTH_NRM                           ((0x19c4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat0_ythd0       // unsigned ,    RW, default = 255  y threshold0 for cnr2 sat0 mapping
//Bit 15: 8        reg_cnr2_sat0_ythd1       // unsigned ,    RW, default = 0  y threshold1 for cnr2 sat0 mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_sat0_norm        // unsigned ,    RW, default = 6  normalization for cnr2 sat0 mapping
#define CNR_SAT1_XTH_K                             ((0x19c5  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat1_xthd        // unsigned ,    RW, default = 16  x threshold for cnr2 sat1 mapping
//Bit 15: 0        reg_cnr2_sat1_kappa       // unsigned ,    RW, default = 320  x slope for cnr2 sat1 mapping
#define CNR_SAT1_YTH                               ((0x19c6  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_sat1_ythd0       // unsigned ,    RW, default = 0  y threshold0 for cnr2 sat1 mapping
//Bit 15: 8        reg_cnr2_sat1_ythd1       // unsigned ,    RW, default = 255  y threshold1 for cnr2 sat1 mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_sat1_norm        // unsigned ,    RW, default = 6  normalization for cnr2 sat1 mapping
#define CNR_ALP_XTH_K                              ((0x19c7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_alp_xthd         // unsigned ,    RW, default = 16  x threshold for cnr2 final alpha
//Bit 15: 0        reg_cnr2_alp_kappa        // unsigned ,    RW, default = 64  x slope for cnr2 final alpha
#define CNR_ALP_YTH_NRM                            ((0x19c8  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_alp_ythd0        // unsigned ,    RW, default = 255  y threshold0 for cnr2 final alpha
//Bit 15: 8        reg_cnr2_alp_ythd1        // unsigned ,    RW, default = 255  y threshold1 for cnr2 final alpha
//Bit  7: 4        reserved
//Bit  3: 0        reg_cnr2_alp_norm         // unsigned ,    RW, default = 6  normalization for cnr2 final alpha
#define CNR_FRG_HVWT_BLD                           ((0x19c9  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_cnr2_frg_hwt_bld      // unsigned ,    RW, default = 128  horizontal blending between hue/sat and difs, for cnr2 fringe weight
//Bit 15: 8        reg_cnr2_frg_vwt_bld      // unsigned ,    RW, default = 128  vertical blending between hue/sat and difs, for cnr2 fringe weight
//Bit  7: 5        reserved
//Bit  4           reg_cnr2_frg_hwt_bypss    // unsigned ,    RW, default = 0  bypass horizontal fringe weight for cnr2 fringe weight
//Bit  3: 1        reserved
//Bit  0           reg_cnr2_frg_vwt_bypss    // unsigned ,    RW, default = 0  bypass vertical fringe weight for cnr2 fringe weight
#define CNR_HUE_PRT_LUT_0                          ((0x19ca  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_3    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_2    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_1    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_0    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_1                          ((0x19cb  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_7    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_6    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_5    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_4    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_2                          ((0x19cc  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_11   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_10   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_9    // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_8    // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_3                          ((0x19cd  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_15   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_14   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_13   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_12   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_4                          ((0x19ce  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_19   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_18   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_17   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_16   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_5                          ((0x19cf  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_23   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_22   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_21   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_20   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_6                          ((0x19d0  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_27   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_26   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_25   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_24   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_HUE_PRT_LUT_7                          ((0x19d1  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_cnr2_hue_prt_lut_31   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 23:22        reserved
//Bit 21:16        reg_cnr2_hue_prt_lut_30   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit 15:14        reserved
//Bit 13: 8        reg_cnr2_hue_prt_lut_29   // unsigned ,    RW, default = 63  hue protection lut for cnr2
//Bit  7: 6        reserved
//Bit  5: 0        reg_cnr2_hue_prt_lut_28   // unsigned ,    RW, default = 63  hue protection lut for cnr2
#define CNR_SATUR_BLK_NUM                          ((0x19d2  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 8        reg_cnr2_satur_blk_hnum_m1 // unsigned ,    RW, default = 31  horizontal block number minus 1 for cnr2 block saturation
//Bit  7: 5        reserved
//Bit  4: 0        reg_cnr2_satur_blk_vnum_m1 // unsigned ,    RW, default = 31  vertical block number minus 1 for cnr2 block saturation
#define CNR_SATUR_BLK_XSCL                         ((0x19d3  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_cnr2_satur_blk_xscl   // unsigned ,    RW, default = 8738  x scaler coefficient for cnr2 block saturation
#define CNR_SATUR_BLK_YSCL                         ((0x19d4  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_cnr2_satur_blk_yscl   // unsigned ,    RW, default = 7767  y scaler coefficient for cnr2 block saturation
#define CNR_SATUR_BLK_LUT_IDX                      ((0x19d5  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 0        reg_cnr2_satur_blk_idx    // unsigned ,    RW, default = 0
#define CNR_SATUR_BLK_LUT_DATA                     ((0x19d6  << 2) + 0xff000000)
//Bit 31: 0        reg_cnr2_satur_blk_data   // unsigned ,    RW, default = 0
#define CNR_CTRST_FRG_ALP                          ((0x19d7  << 2) + 0xff000000)
//Bit 31:24        reg_cnr2_frg_alp_min      // unsigned ,    RW, default = 0  min of fringe alpha
//Bit 23:16        reg_cnr2_frg_alp_max      // unsigned ,    RW, default = 255  max of fringe alpha
//Bit 15: 8        reg_cnr2_luma_osat_thd    // unsigned ,    RW, default = 80  luma over-saturated threshold for cnr2
//Bit  7           reg_cnr2_ctrst_mode       // unsigned ,    RW, default = 0  0: (max - cur), 1: (max - min); contrast calc. mode for cnr2 ctrst mapping
//Bit  6: 4        reg_cnr2_ctrst_hwnd       // unsigned ,    RW, default = 1  horizontal window size for contrast calc. mode for cnr2 ctrst mapping
//Bit  3            reserved
//Bit  2: 0        reg_cnr2_ctrst_vwnd       // unsigned ,    RW, default = 1  horizontal window size for contrast calc. mode for cnr2 ctrst mapping
#define CNR_HS_DBG_MISC                            ((0x19d8  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:24        reg_cnr2_adp_desat_hrz    // unsigned ,    RW, default = 0  0: no desaturation, 1: desaturation with middle value, 2or3: desaturation with min sat, horizontal adaptive desaturation mode
//Bit 23:22        reserved
//Bit 21:20        reg_cnr2_adp_desat_vrt    // unsigned ,    RW, default = 0  0: no desaturation, 1: desaturation with middle value, 2or3: desaturation with min sat, vertical adaptive desaturation mode
//Bit 19            reserved
//Bit 18:16        reg_cnr2_hue_rsft         // unsigned ,    RW, default = 4  hue right shift for cnr2 hue mapping
//Bit 15            reserved
//Bit 14:12        reg_cnr2_sat_sft          // signed ,    RW, default = 0  sat shift for sat mode0 for cnr2 hue mapping
//Bit 11           reg_cnr2_sat_mode         // unsigned ,    RW, default = 0  0: sqrt(udif^2 + vdif^2), 1: |udif| + |vdif|; sat calc. mode for cnr2 sat mapping
//Bit 10           reg_cnr2_sat2wt_mode      // unsigned ,    RW, default = 1  0: use sat value, 1: use sat1 map, for hs weight calc. for cnr2 sat mapping
//Bit  9: 8        reg_cnr2_fin_alp_mode     // unsigned ,    RW, default = 2  use 0: fin alp, 1: fringe alp, 2or3: fin alpha + fringe alpha, for cnr2 final blending
//Bit  7: 5        reserved
//Bit  4: 0        reg_cnr2_dbg_mode         // unsigned ,    RW, default = 0  cnr2 debug mode,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg1_peak_cnr_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DBE_APB3_APB_BASE = 0x1a
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_post_pg2_ctrst_regs.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_CNTRST_MISC                            ((0x1a00  << 2) + 0xff000000)
//Bit 31:24        reg_ctrst_hblank          // unsigned ,    RW, default = 8
//Bit 23: 0        reg_ctrst_gclk_ctrl       // unsigned ,    RW, default = 0
#define ISP_CNTRST_DNLP_CTRL                       ((0x1a04  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_dnlp_input_mode       // unsigned ,    RW, default = 4  dnlp input options. 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os)
#define ISP_CNTRST_DNLP_YGRID_0                    ((0x1a05  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_1          // unsigned ,    RW, default = 14  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_0          // unsigned ,    RW, default = 0  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_1                    ((0x1a06  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_3          // unsigned ,    RW, default = 43  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_2          // unsigned ,    RW, default = 29  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_2                    ((0x1a07  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_5          // unsigned ,    RW, default = 72  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_4          // unsigned ,    RW, default = 58  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_3                    ((0x1a08  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_7          // unsigned ,    RW, default = 101  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_6          // unsigned ,    RW, default = 86  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_4                    ((0x1a09  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_9          // unsigned ,    RW, default = 130  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_8          // unsigned ,    RW, default = 115  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_5                    ((0x1a0a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_11         // unsigned ,    RW, default = 159  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_10         // unsigned ,    RW, default = 144  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_6                    ((0x1a0b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_13         // unsigned ,    RW, default = 188  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_12         // unsigned ,    RW, default = 173  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_7                    ((0x1a0c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_15         // unsigned ,    RW, default = 217  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_14         // unsigned ,    RW, default = 202  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_8                    ((0x1a0d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_17         // unsigned ,    RW, default = 247  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_16         // unsigned ,    RW, default = 232  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_9                    ((0x1a0e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_19         // unsigned ,    RW, default = 277  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_18         // unsigned ,    RW, default = 262  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_10                   ((0x1a0f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_21         // unsigned ,    RW, default = 307  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_20         // unsigned ,    RW, default = 292  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_11                   ((0x1a10  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_23         // unsigned ,    RW, default = 338  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_22         // unsigned ,    RW, default = 322  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_12                   ((0x1a11  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_25         // unsigned ,    RW, default = 368  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_24         // unsigned ,    RW, default = 353  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_13                   ((0x1a12  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_27         // unsigned ,    RW, default = 400  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_26         // unsigned ,    RW, default = 384  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_14                   ((0x1a13  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_29         // unsigned ,    RW, default = 435  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_28         // unsigned ,    RW, default = 417  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_15                   ((0x1a14  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_31         // unsigned ,    RW, default = 473  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_30         // unsigned ,    RW, default = 454  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_16                   ((0x1a15  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_33         // unsigned ,    RW, default = 512  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_32         // unsigned ,    RW, default = 492  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_17                   ((0x1a16  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_35         // unsigned ,    RW, default = 552  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_34         // unsigned ,    RW, default = 532  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_18                   ((0x1a17  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_37         // unsigned ,    RW, default = 590  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_36         // unsigned ,    RW, default = 571  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_19                   ((0x1a18  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_39         // unsigned ,    RW, default = 629  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_38         // unsigned ,    RW, default = 610  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_20                   ((0x1a19  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_41         // unsigned ,    RW, default = 667  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_40         // unsigned ,    RW, default = 648  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_21                   ((0x1a1a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_43         // unsigned ,    RW, default = 706  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_42         // unsigned ,    RW, default = 686  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_22                   ((0x1a1b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_45         // unsigned ,    RW, default = 746  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_44         // unsigned ,    RW, default = 726  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_23                   ((0x1a1c  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_47         // unsigned ,    RW, default = 786  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_46         // unsigned ,    RW, default = 766  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_24                   ((0x1a1d  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_49         // unsigned ,    RW, default = 826  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_48         // unsigned ,    RW, default = 806  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_25                   ((0x1a1e  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_51         // unsigned ,    RW, default = 865  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_50         // unsigned ,    RW, default = 846  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_26                   ((0x1a1f  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_53         // unsigned ,    RW, default = 902  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_52         // unsigned ,    RW, default = 884  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_27                   ((0x1a20  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_55         // unsigned ,    RW, default = 938  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_54         // unsigned ,    RW, default = 921  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_28                   ((0x1a21  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_57         // unsigned ,    RW, default = 968  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_56         // unsigned ,    RW, default = 954  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_29                   ((0x1a22  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_59         // unsigned ,    RW, default = 992  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_58         // unsigned ,    RW, default = 981  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_30                   ((0x1a23  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_61         // unsigned ,    RW, default = 1010  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_60         // unsigned ,    RW, default = 1002  dnlp ygrid lut
#define ISP_CNTRST_DNLP_YGRID_31                   ((0x1a24  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dnlp_ygrid_63         // unsigned ,    RW, default = 1022  dnlp ygrid lut
//Bit 15:10        reserved
//Bit  9: 0        reg_dnlp_ygrid_62         // unsigned ,    RW, default = 1016  dnlp ygrid lut
#define ISP_CNTRST_SAT_PRT_CRTL                    ((0x1a25  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_satprt_sat_core       // unsigned ,    RW, default = 80  will be coring to cor(irgb_max-irgb_min) to calculate the oy_delt, the smaller the more protection to color, the larger only the rich color will be protected;
//Bit 15: 8        reg_satprt_sat_rate       // unsigned ,    RW, default = 64  rate to cor(irgb_max-irgb_min) to calculate the oy_delt, the larger the more protection to rich color; norm 16 as 1
//Bit  7: 4        reserved
//Bit  3: 2        reg_satprt_csc_mode       // unsigned ,    RW, default = 1  csc mode of current yuv input: 0:601, 1:709, 2:BT2020 NCL, 3:reserved
//Bit  1           reg_satprt_is_lmt         // unsigned ,    RW, default = 1  flag telling the YUV is limited range data or full range data, 0 full range, 1: limited range
//Bit  0           reg_satprt_enable         // unsigned ,    RW, default = 0  enable of saturation protection for dnlp adjustments
#define ISP_CNTRST_SAT_PRT_DIV_M                   ((0x1a26  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_satprt_div_m_2        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
//Bit 15: 8        reg_satprt_div_m_1        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
//Bit  7: 0        reg_satprt_div_m_0        // unsigned ,    RW, default = 128  1/m, normalized to 128 as 1, default=1
#define ISP_CNTRST_SAT_PRT_LMT_0_1                 ((0x1a27  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_satprt_lmt_rgb_1      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
//Bit 15:12        reserved
//Bit 11: 0        reg_satprt_lmt_rgb_0      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
#define ISP_CNTRST_SAT_PRT_LMT_2                   ((0x1a28  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_satprt_lmt_rgb_2      // unsigned ,    RW, default = 3840  limit of the rgb channel, for limited range RGB, set to 960, otherwise set to 1023;
#define ISP_CNTRST_LC_INPUT_MUX                    ((0x1a29  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 4        reg_lcinput_ysel          // unsigned ,    RW, default = 4  local contrast luma input options 0: org_y; 1: gau_y; 2: gauadp_y; 3: edgadplpf_y; 4: nr_y;5: lti_y; 6: pk_y (before os);7: pk_y (after os)
//Bit  3            reserved
//Bit  2: 0        reg_lcinput_csel          // unsigned ,    RW, default = 4  local contrast chroma input options 0: org_c; 1: gau_c; 2: gauadp_c; 3: edgadplpf_c; 4: nr_c;5: cti_c; 6: pk_c
#define ISP_CNTRST_PK_CLR_PRCT_CTL                 ((0x1a2a  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4           reg_pk_clr_prct_en        // unsigned ,    RW, default = 1  enable color protection
//Bit  3: 2        reserved
//Bit  1: 0        reg_pk_clr_prct_inpsel    // unsigned ,    RW, default = 1  input UV selection for color protection, 0: org; 1: NRout;
#define ISP_CNTRST_PK_CLR_PRCT_LUT_0               ((0x1a2b  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_7     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_6     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_5     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_4     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_3     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_2     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_1     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_0     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_1               ((0x1a2c  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_15    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_14    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_13    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_12    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_11    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_10    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_9     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_8     // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_2               ((0x1a2d  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_23    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_22    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_21    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_20    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_19    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_18    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_17    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_16    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_3               ((0x1a2e  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_31    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_30    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_29    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_28    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_27    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_26    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_25    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_24    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_4               ((0x1a2f  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_39    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_38    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_37    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_36    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_35    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_34    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_33    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_32    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_5               ((0x1a30  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_47    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_46    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_45    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_44    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_43    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_42    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_41    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_40    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_6               ((0x1a31  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_55    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_54    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_53    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_52    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_51    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_50    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_49    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_48    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_7               ((0x1a32  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_63    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_62    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_61    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_60    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_59    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_58    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_57    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_56    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_8               ((0x1a33  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_71    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_70    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_69    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_68    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_67    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_66    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_65    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_64    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_9               ((0x1a34  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_79    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_78    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_77    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_76    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_75    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_74    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_73    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_72    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_10              ((0x1a35  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_87    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_86    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_85    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_84    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_83    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_82    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_81    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_80    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_11              ((0x1a36  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_95    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_94    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_93    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_92    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_91    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_90    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_89    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_88    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_12              ((0x1a37  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_103   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_102   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_101   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_100   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_99    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_98    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_97    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_96    // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_13              ((0x1a38  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_111   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_110   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_109   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_108   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_107   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_106   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_105   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_104   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_14              ((0x1a39  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_119   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_118   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_117   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_116   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_115   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_114   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_113   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_112   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_15              ((0x1a3a  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_127   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_126   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_125   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_124   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_123   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_122   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_121   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_120   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_16              ((0x1a3b  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_135   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_134   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_133   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_132   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_131   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_130   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_129   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_128   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_17              ((0x1a3c  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_143   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_142   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_141   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_140   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_139   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_138   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_137   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_136   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_18              ((0x1a3d  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_151   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_150   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_149   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_148   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_147   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_146   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_145   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_144   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_19              ((0x1a3e  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_159   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_158   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_157   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_156   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_155   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_154   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_153   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_152   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_20              ((0x1a3f  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_167   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_166   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_165   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_164   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_163   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_162   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_161   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_160   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_21              ((0x1a40  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_175   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_174   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_173   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_172   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_171   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_170   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_169   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_168   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_22              ((0x1a41  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_183   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_182   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_181   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_180   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_179   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_178   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_177   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_176   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_23              ((0x1a42  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_191   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_190   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_189   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_188   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_187   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_186   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_185   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_184   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_24              ((0x1a43  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_199   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_198   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_197   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_196   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_195   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_194   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_193   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_192   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_25              ((0x1a44  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_207   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_206   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_205   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_204   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_203   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_202   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_201   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_200   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_26              ((0x1a45  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_215   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_214   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_213   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_212   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_211   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_210   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_209   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_208   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_27              ((0x1a46  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_223   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_222   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_221   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_220   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_219   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_218   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_217   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_216   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_28              ((0x1a47  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_231   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_230   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_229   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_228   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_227   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_226   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_225   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_224   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_29              ((0x1a48  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_239   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_238   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_237   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_236   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_235   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_234   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_233   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_232   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_30              ((0x1a49  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_247   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_246   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_245   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_244   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_243   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_242   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_241   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_240   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_LUT_31              ((0x1a4a  << 2) + 0xff000000)
//Bit 31:28        reg_pk_clr_prct_lut_255   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 27:24        reg_pk_clr_prct_lut_254   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 23:20        reg_pk_clr_prct_lut_253   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 19:16        reg_pk_clr_prct_lut_252   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 15:12        reg_pk_clr_prct_lut_251   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit 11: 8        reg_pk_clr_prct_lut_250   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  7: 4        reg_pk_clr_prct_lut_249   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
//Bit  3: 0        reg_pk_clr_prct_lut_248   // unsigned ,    RW, default = 15  color protection lut, 16 is normalized to 1
#define ISP_CNTRST_PK_CLR_PRCT_GAIN                ((0x1a4b  << 2) + 0xff000000)
//Bit 31:24        reg_pk_clr_prct_lc_gain_2 // unsigned ,    RW, default = 0;//64
//Bit 23:16        reg_pk_clr_prct_lc_gain_1 // unsigned ,    RW, default = 0;//64
//Bit 15: 8        reg_pk_clr_prct_lc_gain_0 // unsigned ,    RW, default = 0;//64  gain to de-boost of lc_dlt (y/u/v) base on color region, norm to 64 as 1.0, set to 0 as disable
//Bit  7: 0        reg_pk_clr_prct_dnlp_gain // unsigned ,    RW, default = 0;//64  gain to de-boost of dnlp_dlt base on color region, norm to 64 as 1.0, set to 0 as disable
#define ISP_CNTRST_PK_CC_CTRL                      ((0x1a4c  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_pk_cc_ydlt_pscl       // unsigned ,    RW, default = 64  prescale to the y-delta (if >0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.
//Bit 15: 8        reg_pk_cc_ydlt_nscl       // unsigned ,    RW, default = 64  prescale to the y-delta (if <0) before feeding to y-lumadlt, normalized 64 as 1.0. default = 64.
//Bit  7: 6        reg_pk_cc_yinp_sel        // unsigned ,    RW, default = 0  color compensation input luma selection, 0: org_y; 1: gau_y ; 2:gauadp_y; 3:edgeadp_y (same as dnlp input sel), default= 0
//Bit  5: 4        reg_pk_cc_ydlt_sel        // unsigned ,    RW, default = 2  color compensation output luma selection, 0: peaking+lti output; 1: dnlp output; 2/3: peaking+lti+dnlp, default = 2
//Bit  3: 2        reg_pk_cc_sat_norm        // unsigned ,    RW, default = 1  normalization of lut cell to saturation. 0: norm to 8 as 1.0, sat[0:23/8]; 1: norm to 16 as 1.0, sat[1/16:31/16]; 2: norm to 32 as 1.0, sat[17/32:47/32]; 3:norm to 64 as 1.0, sat[49/64:79/64]
//Bit  1            reserved
//Bit  0           reg_pk_cc_enable          // unsigned ,    RW, default = 1  color compensation enable, 0: no CC, 1: with CC, default = 1
#define ISP_CNTRST_PK_CC_LUT_0                     ((0x1a4d  << 2) + 0xff000000)
//Bit 31:28        reg_pk_cc_lut0_1_3        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 27:24        reg_pk_cc_lut0_1_2        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 23:20        reg_pk_cc_lut0_1_1        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 19:16        reg_pk_cc_lut0_1_0        // unsigned ,    RW, default = 0  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=8/8  dft={0, 0, 0, 0}
//Bit 15:12        reg_pk_cc_lut0_0_3        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit 11: 8        reg_pk_cc_lut0_0_2        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit  7: 4        reg_pk_cc_lut0_0_1        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
//Bit  3: 0        reg_pk_cc_lut0_0_0        // unsigned ,    RW, default = 0  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=0,    dft={0, 0, 0, 0}
#define ISP_CNTRST_PK_CC_LUT_1                     ((0x1a4e  << 2) + 0xff000000)
//Bit 31:28        reg_pk_cc_lut1_1_3        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 27:24        reg_pk_cc_lut1_1_2        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 23:20        reg_pk_cc_lut1_1_1        // unsigned ,    RW, default = 2  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 19:16        reg_pk_cc_lut1_1_0        // unsigned ,    RW, default = 1  valid for y-lumadlt= -1/4, -1/2,-3/4,-1.0; of x-lumainput=7/8  dft={1, 2, 4, 8}
//Bit 15:12        reg_pk_cc_lut1_0_3        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit 11: 8        reg_pk_cc_lut1_0_2        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit  7: 4        reg_pk_cc_lut1_0_1        // unsigned ,    RW, default = 2  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
//Bit  3: 0        reg_pk_cc_lut1_0_0        // unsigned ,    RW, default = 1  valid for y-lumadlt=  1/4, 1/2, 3/4, 1.0; of x-lumainput=1/8   dft={1, 2, 4, 8}
#define ISP_CNTRST_PK_CC_LUT_2                     ((0x1a4f  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_pk_cc_lut2_1_2        // unsigned ,    RW, default = 12  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 19:16        reg_pk_cc_lut2_1_1        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 15:12        reg_pk_cc_lut2_1_0        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=6/8   dft={4, 8,12}
//Bit 11: 8        reg_pk_cc_lut2_0_2        // unsigned ,    RW, default = 12  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
//Bit  7: 4        reg_pk_cc_lut2_0_1        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
//Bit  3: 0        reg_pk_cc_lut2_0_0        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=2/8   dft={4, 8,12}
#define ISP_CNTRST_PK_CC_LUT_3                     ((0x1a50  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_pk_cc_lut3_1_2        // unsigned ,    RW, default = 15  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 19:16        reg_pk_cc_lut3_1_1        // unsigned ,    RW, default = 10  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 15:12        reg_pk_cc_lut3_1_0        // unsigned ,    RW, default = 5  valid for y-lumadlt= -1/4, -1/2,-3/4,   ; of x-lumainput=5/8   dft={5,10,15}
//Bit 11: 8        reg_pk_cc_lut3_0_2        // unsigned ,    RW, default = 15  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
//Bit  7: 4        reg_pk_cc_lut3_0_1        // unsigned ,    RW, default = 10  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
//Bit  3: 0        reg_pk_cc_lut3_0_0        // unsigned ,    RW, default = 5  valid for y-lumadlt=  1/4, 1/2, 3/4     ; of x-lumainput=3/8   dft={5,10,15}
#define ISP_CNTRST_PK_CC_LUT_4                     ((0x1a51  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_pk_cc_lut4_1_1        // unsigned ,    RW, default = 15  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}
//Bit 11: 8        reg_pk_cc_lut4_1_0        // unsigned ,    RW, default = 8  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=4/8   dft={8,15}
//Bit  7: 4        reg_pk_cc_lut4_0_1        // unsigned ,    RW, default = 15  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}
//Bit  3: 0        reg_pk_cc_lut4_0_0        // unsigned ,    RW, default = 8  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=4/8   dft={8,15}
#define ISP_CNTRST_PK_CC_LUT_5_6_7                 ((0x1a52  << 2) + 0xff000000)
//Bit 31:28        reg_pk_cc_lut7_1_0        // unsigned ,    RW, default = 4  valid for y-lumadlt= -1/4,              ; of x-lumainput=1/8   dft={4}
//Bit 27:24        reg_pk_cc_lut7_0_0        // unsigned ,    RW, default = 4  valid for y-lumadlt=  1/4,              ; of x-lumainput=7/8   dft={4}
//Bit 23:20        reg_pk_cc_lut6_1_0        // unsigned ,    RW, default = 5  valid for y-lumadlt= -1/4,              ; of x-lumainput=2/8   dft={5}
//Bit 19:16        reg_pk_cc_lut6_0_0        // unsigned ,    RW, default = 5  valid for y-lumadlt=  1/4,              ; of x-lumainput=6/8   dft={5}
//Bit 15:12        reg_pk_cc_lut5_1_1        // unsigned ,    RW, default = 13  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}
//Bit 11: 8        reg_pk_cc_lut5_1_0        // unsigned ,    RW, default = 6  valid for y-lumadlt= -1/4, -1/2,        ; of x-lumainput=3/8   dft={6,13}
//Bit  7: 4        reg_pk_cc_lut5_0_1        // unsigned ,    RW, default = 13  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}
//Bit  3: 0        reg_pk_cc_lut5_0_0        // unsigned ,    RW, default = 6  valid for y-lumadlt=  1/4, 1/2,         ; of x-lumainput=5/8   dft={6,13}
#define ISP_LC_TOP_CTRL                            ((0x1a60  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:13        reserved
//Bit 12           reg_dhz_blkblend_mode     // unsigned ,    RW, default = 1  DHZ use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
//Bit 11: 9        reserved
//Bit  8           reg_dhz_cc_en             // unsigned ,    RW, default = 0  DHZ color compensation enable register
//Bit  7: 5        reserved
//Bit  4           reg_lc_blkblend_mode      // unsigned ,    RW, default = 1  LC use bilinear interpolation between blocks, 0: no interpolation 1: blender enabled
//Bit  3: 1        reserved
//Bit  0           reg_lc_cc_en              // unsigned ,    RW, default = 0  LC color compensation enable register
#define ISP_LC_DHZ_SKY_PROT0                       ((0x1a61  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25           reg_dhz_sky_prot_en       // unsigned ,    RW, default = 0  DHZ sky protection enable register
//Bit 24           reg_dhz_sky_prot_cc_en    // unsigned ,    RW, default = 0  DHZ sky color compensation enable register
//Bit 23:22        reserved
//Bit 21:12        reg_dhz_sky_prot_stre     // unsigned ,    RW, default = 614  DHZ sky protection strength register
//Bit 11:10        reserved
//Bit  9: 0        reg_dhz_atmos_light       // unsigned ,    RW, default = 625  DHZ sky atmosphere light register
#define ISP_LC_DHZ_SKY_PROT1                       ((0x1a62  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22: 8        reg_dhz_atmos_light_inver // unsigned ,    RW, default = 1677  dehaze 1/atmosphere light register
//Bit  7: 0        reg_dhz_atmo_light_upd_rat // unsigned ,    RW, default = 1  DHZ sky atmosphere light update rate register
#define ISP_LC_DHZ_SKY_TRANS_COEF                  ((0x1a63  << 2) + 0xff000000)
//Bit 31:24        reg_dhz_satura_ratio_sky  // unsigned ,    RW, default = 25
//Bit 23:22        reserved
//Bit 21:12        reg_dhz_trans_calcu_coeft // unsigned ,    RW, default = 973
//Bit 11:10        reserved
//Bit  9: 0        reg_dhz_sky_prot_offset   // unsigned ,    RW, default = 400
#define ISP_LC_HV_NUM                              ((0x1a64  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lc_blk_hnum           // unsigned ,    RW, default = 12  lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12)
//Bit  7: 5        reserved
//Bit  4: 0        reg_lc_blk_vnum           // unsigned ,    RW, default = 8  lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8)
#define ISP_LC_SAT_LUT_IDX                         ((0x1a65  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_lc_sta_lut_idx        // unsigned ,    RW, default = 0
#define ISP_LC_SAT_LUT_DATA                        ((0x1a66  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_lc_satur_lut_d1       // unsigned ,    RW, default = 0  saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_satur_lut_d0       // unsigned ,    RW, default = 0  saturation protection curve, normalized to 4096 as 1, default = y=x^1.2
#define ISP_LC_DHZ_SKY_PROT_LUT_IDX                ((0x1a67  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4: 0        reg_dhz_sky_prot_lut_idx  // unsigned ,    RW, default = 0
#define ISP_LC_DHZ_SKY_PROT_LUT_DATA               ((0x1a68  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_sky_prot_lut_d1   // unsigned ,    RW, default = 0  sky protection curve, normalized to 1024 as 1
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_sky_prot_lut_d0   // unsigned ,    RW, default = 0  sky protection curve, normalized to 1024 as 1
#define ISP_LC_CURVE_BLK_HIDX_0                    ((0x1a69  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_1         // unsigned ,    RW, default = 320  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_0         // unsigned ,    RW, default = 0  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_1                    ((0x1a6a  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_3         // unsigned ,    RW, default = 960  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_2         // unsigned ,    RW, default = 640  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_2                    ((0x1a6b  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_5         // unsigned ,    RW, default = 1600  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_4         // unsigned ,    RW, default = 1280  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_3                    ((0x1a6c  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_7         // unsigned ,    RW, default = 2240  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_6         // unsigned ,    RW, default = 1920  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_4                    ((0x1a6d  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_9         // unsigned ,    RW, default = 2880  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_8         // unsigned ,    RW, default = 2560  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_5                    ((0x1a6e  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_hidx_11        // unsigned ,    RW, default = 3520  block boundary x-index
//Bit 15: 0        reg_lc_blk_hidx_10        // unsigned ,    RW, default = 3200  block boundary x-index
#define ISP_LC_CURVE_BLK_HIDX_12                   ((0x1a6f  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lc_blk_hidx_12        // unsigned ,    RW, default = 3840  block boundary x-index
#define ISP_LC_CURVE_BLK_VIDX_0                    ((0x1a70  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_vidx_1         // unsigned ,    RW, default = 270  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_0         // unsigned ,    RW, default = 0  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_1                    ((0x1a71  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_vidx_3         // unsigned ,    RW, default = 810  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_2         // unsigned ,    RW, default = 540  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_2                    ((0x1a72  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_vidx_5         // unsigned ,    RW, default = 1350  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_4         // unsigned ,    RW, default = 1080  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_3                    ((0x1a73  << 2) + 0xff000000)
//Bit 31:16        reg_lc_blk_vidx_7         // unsigned ,    RW, default = 1890  block boundary y-index
//Bit 15: 0        reg_lc_blk_vidx_6         // unsigned ,    RW, default = 1620  block boundary y-index
#define ISP_LC_CURVE_BLK_VIDX_8                    ((0x1a74  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_lc_blk_vidx_8         // unsigned ,    RW, default = 2160  block boundary y-index
#define ISP_LC_YUV2RGB_MAT_0                       ((0x1a75  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_1   // signed ,    RW, default = 0  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_0   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_1                       ((0x1a76  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_3   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_2   // signed ,    RW, default = 1613  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_2                       ((0x1a77  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_5   // signed ,    RW, default = -479  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_4   // signed ,    RW, default = -191  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_3                       ((0x1a78  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_yuv2rgb_mat3x3_7   // signed ,    RW, default = 1901  yuv2rgb 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_6   // signed ,    RW, default = 1024  yuv2rgb 3x3 matrix
#define ISP_LC_YUV2RGB_MAT_8                       ((0x1a79  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_lc_yuv2rgb_mat3x3_8   // signed ,    RW, default = 0  yuv2rgb 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_0                       ((0x1a7a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_1   // signed ,    RW, default = 732  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_0   // signed ,    RW, default = 218  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_1                       ((0x1a7b  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_3   // signed ,    RW, default = -118  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_2   // signed ,    RW, default = 74  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_2                       ((0x1a7c  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_5   // signed ,    RW, default = 512  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_4   // signed ,    RW, default = -394  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_3                       ((0x1a7d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_mat3x3_7   // signed ,    RW, default = -465  rgb2yuv 3x3 matrix
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_6   // signed ,    RW, default = 512  rgb2yuv 3x3 matrix
#define ISP_LC_RGB2YUV_MAT_8                       ((0x1a7e  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_mat3x3_8   // signed ,    RW, default = -47  rgb2yuv 3x3 matrix
#define ISP_LC_YUV2RGB_OFST                        ((0x1a7f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_lc_yuv2rgb_ofset_0    // unsigned ,    RW, default = 0  yuv2rgb pre-offset to yuv,limit=1<<(bit-4); or full=0;
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_yuv2rgb_ofset_1    // unsigned ,    RW, default = 512  yuv2rgb pre-offset to yuv,
#define ISP_LC_YUV2RGB_CLIP                        ((0x1a80  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:28        reg_lc_yuv2rgb_rs         // unsigned ,    RW, default = 2  matrix normalization right shift extra bits, norm= (1<<(8+rs))
//Bit 27:16        reg_lc_yuv2rgb_clip_0     // unsigned ,    RW, default = 0  yuv2rgb converted RGB clipping range
//Bit 15:12        reserved
//Bit 11: 0        reg_lc_yuv2rgb_clip_1     // unsigned ,    RW, default = 1023  yuv2rgb converted RGB clipping range
#define ISP_LC_RGB2YUV_OFST                        ((0x1a81  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_lc_rgb2yuv_ofset_0    // unsigned ,    RW, default = 0  rgb2yuv post-offset to yuv, limit=1<<(bit-4); or full=0;
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_ofset_1    // unsigned ,    RW, default = 1024  rgb2yuv post-offset to yuv, u12, 2048
#define ISP_LC_RGB2YUV_CLIP                        ((0x1a82  << 2) + 0xff000000)
//Bit 31:30        reg_lc_rgb2yuv_rs         // unsigned ,    RW, default = 2  matrix normalization right shift extra bits, norm=(1<<(8+rs))
//Bit 29            reserved
//Bit 28:16        reg_lc_rgb2yuv_clip_0     // unsigned ,    RW, default = 0  rgb2yuv converted YUV clipping range
//Bit 15:13        reserved
//Bit 12: 0        reg_lc_rgb2yuv_clip_1     // unsigned ,    RW, default = 2047  rgb2yuv converted YUV clipping range, u12, 4095
#define ISP_LC_MAP_RAM_CTRL                        ((0x1a83  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_lc_cbus2ram_en        // unsigned ,    RW, default = 0  apb access LC RAM enable
#define ISP_LC_MAP_RAM_ADDR                        ((0x1a84  << 2) + 0xff000000)
//Bit 31           reg_lc_cbus2ram_rd_pflg   // unsigned ,    RW, default = 0
//Bit 30: 8        reserved
//Bit  7: 4        reg_lc_cbus2ram_vidx      // unsigned ,    RW, default = 0
//Bit  3: 0        reg_lc_cbus2ram_hidx      // unsigned ,    RW, default = 0
#define ISP_LC_MAP_RAM_DATA                        ((0x1a85  << 2) + 0xff000000)
//Bit 31: 0        reg_lc_cbus2ram_data      // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_CTRL                          ((0x1aa0  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15:12        reg_sync_ctrl             // unsigned ,    RW, default = 0
//Bit 11: 8        reg_gclk_ctrl             // unsigned ,    RW, default = 0
//Bit  7: 4        reserved
//Bit  3: 2        reg_curve_ram_rdmode      // unsigned ,    RW, default = 0  00: read lc nodes/pk nodes; 01: read lc nodes only; 10: read pk nodes only
//Bit  1           reg_curve_dhz_en          // unsigned ,    RW, default = 0
//Bit  0           reg_curve_lc_en           // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_RAM_ADDR                      ((0x1aa1  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_curve_ram_addr        // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_RO_RAM_DATA                   ((0x1aa2  << 2) + 0xff000000)
//Bit 31: 0        reg_curve_ram_data        // unsigned ,    RW, default = 0
#define ISP_LC_CURVE_YMINVAL_LMT_0                 ((0x1aa4  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_1      // unsigned ,    RW, default = 80  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_0      // unsigned ,    RW, default = 48  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_1                 ((0x1aa5  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_3      // unsigned ,    RW, default = 128  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_2      // unsigned ,    RW, default = 120  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_2                 ((0x1aa6  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_5      // unsigned ,    RW, default = 196  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_4      // unsigned ,    RW, default = 160  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_3                 ((0x1aa7  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_7      // unsigned ,    RW, default = 256  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_6      // unsigned ,    RW, default = 224  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_4                 ((0x1aa8  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_9      // unsigned ,    RW, default = 320  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_8      // unsigned ,    RW, default = 288  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_5                 ((0x1aa9  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_11     // unsigned ,    RW, default = 400  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_10     // unsigned ,    RW, default = 352  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_6                 ((0x1aaa  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_13     // unsigned ,    RW, default = 420  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_12     // unsigned ,    RW, default = 410  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YMINVAL_LMT_7                 ((0x1aab  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_yminval_lmt_15     // unsigned ,    RW, default = 440  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_yminval_lmt_14     // unsigned ,    RW, default = 430  lmt_val = lmt[minBV(64:64:1023)], and yminV= MAX(yminV,lmt_val), for very dark region boost, default= [48, 80, 120, 60]
#define ISP_LC_CURVE_YPKBV_LMT_0                   ((0x1aac  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_1        // unsigned ,    RW, default = 128  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_0        // unsigned ,    RW, default = 65  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_1                   ((0x1aad  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_3        // unsigned ,    RW, default = 256  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_2        // unsigned ,    RW, default = 192  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_2                   ((0x1aae  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_5        // unsigned ,    RW, default = 384  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_4        // unsigned ,    RW, default = 320  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_3                   ((0x1aaf  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_7        // unsigned ,    RW, default = 512  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_6        // unsigned ,    RW, default = 448  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_4                   ((0x1ab0  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_9        // unsigned ,    RW, default = 640  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_8        // unsigned ,    RW, default = 576  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_5                   ((0x1ab1  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_11       // unsigned ,    RW, default = 768  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_10       // unsigned ,    RW, default = 704  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_6                   ((0x1ab2  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_13       // unsigned ,    RW, default = 896  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_12       // unsigned ,    RW, default = 832  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YPKBV_LMT_7                   ((0x1ab3  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ypkbv_lmt_15       // unsigned ,    RW, default = 1023  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ypkbv_lmt_14       // unsigned ,    RW, default = 960  lmt_val = 4*lmt[pkBV(64:64:1023)] , and ypkBV = MAX(ypkBV,lmt[pkBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_0                 ((0x1ab4  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_1      // unsigned ,    RW, default = 150  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_0      // unsigned ,    RW, default = 120  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_1                 ((0x1ab5  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_3      // unsigned ,    RW, default = 274  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_2      // unsigned ,    RW, default = 230  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_2                 ((0x1ab6  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_5      // unsigned ,    RW, default = 384  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_4      // unsigned ,    RW, default = 330  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_3                 ((0x1ab7  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_7      // unsigned ,    RW, default = 524  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_6      // unsigned ,    RW, default = 456  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_4                 ((0x1ab8  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_9      // unsigned ,    RW, default = 660  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_8      // unsigned ,    RW, default = 592  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_5                 ((0x1ab9  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_11     // unsigned ,    RW, default = 800  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_10     // unsigned ,    RW, default = 728  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_6                 ((0x1aba  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_13     // unsigned ,    RW, default = 916  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_12     // unsigned ,    RW, default = 856  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_YMAXVAL_LMT_7                 ((0x1abb  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_ymaxval_lmt_15     // unsigned ,    RW, default = 1023  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_ymaxval_lmt_14     // unsigned ,    RW, default = 976  lmt_val = 4*lmt[maxBV(64:64:1023)], and ymaxV = MAX(ymaxV,lmt[maxBV]),
#define ISP_LC_CURVE_LPF_MOD_TAPS                  ((0x1abc  << 2) + 0xff000000)
//Bit 31           reg_lc_vlpf_taps_5        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 30           reg_lc_vlpf_taps_4        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 29           reg_lc_vlpf_taps_3        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 28           reg_lc_vlpf_taps_2        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 27           reg_lc_vlpf_taps_1        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 26           reg_lc_vlpf_taps_0        // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 25           reg_lc_hlpf_taps_5        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 24           reg_lc_hlpf_taps_4        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 23           reg_lc_hlpf_taps_3        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 22           reg_lc_hlpf_taps_2        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 21           reg_lc_hlpf_taps_1        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 20           reg_lc_hlpf_taps_0        // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:16        reserved
//Bit 15           reg_lc_vlpf_mode_5        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 14           reg_lc_vlpf_mode_4        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 13           reg_lc_vlpf_mode_3        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 12           reg_lc_vlpf_mode_2        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 11           reg_lc_vlpf_mode_1        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit 10           reg_lc_vlpf_mode_0        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  9           reg_lc_hlpf_mode_5        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  8           reg_lc_hlpf_mode_4        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  7           reg_lc_hlpf_mode_3        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  6           reg_lc_hlpf_mode_2        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  5           reg_lc_hlpf_mode_1        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  4           reg_lc_hlpf_mode_0        // unsigned ,    RW, default = 0  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf
//Bit  3: 1        reserved
//Bit  0           reg_lc_blackbar_mute_en   // unsigned ,    RW, default = 1  the black bar corresponding bin, 0: no mute, 1: mute enable; default= 1
#define ISP_LC_CURVE_HV_NUM                        ((0x1abd  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 8        reg_lc_cur_blk_hnum       // unsigned ,    RW, default = 12  lc processing region number of V, maximum to (STA_LEN_V-1)   (0~8), should be same as reg_lc_blk_hnum
//Bit  7: 5        reserved
//Bit  4: 0        reg_lc_cur_blk_vnum       // unsigned ,    RW, default = 8  lc processing region number of H, maximum to (STA_LEN_H-1)   (0~12), should be same as reg_lc_blk_vnum
#define ISP_LC_CURVE_LMT_RAT                       ((0x1abe  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_lmtrat_minmax      // unsigned ,    RW, default = 6  of amount
//Bit  7: 0        reg_lc_lmtrat_valid       // unsigned ,    RW, default = 20  of amount
#define ISP_LC_CURVE_CONTRAST_LH                   ((0x1abf  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_lc_contrast_low       // unsigned ,    RW, default = 20  gain to the lc for dark side, normalized 256 as "1", set adaptive TODO
//Bit 15:10        reserved
//Bit  9: 0        reg_lc_contrast_hig       // unsigned ,    RW, default = 32  gain to the lc for bright side, normalized 256 as "1"
#define ISP_LC_CURVE_CONTRAST_LMT_LH               ((0x1ac0  << 2) + 0xff000000)
//Bit 31:24        reg_lc_cntstlmt_low_0     // unsigned ,    RW, default = 10  for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit 23:16        reg_lc_cntstlmt_hig_0     // unsigned ,    RW, default = 20  for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
//Bit 15: 8        reg_lc_cntstlmt_low_1     // unsigned ,    RW, default = 255  for the contrast low, delta_low = MIN(delta_low, MIN( MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit  7: 0        reg_lc_cntstlmt_hig_1     // unsigned ,    RW, default = 255  for the contrast high,delta_hig = MIN(delta_hig, MIN( MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define ISP_LC_CURVE_CONTRAST_SCL_LH               ((0x1ac1  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_cntstscl_low       // unsigned ,    RW, default = 20  for the contrast low, norm 8 as 1; delta_low = MIN(delta_low, MIN(MAX((minBV-min_val)*scl_low/8, lmt_low[0]),lmt_low[1]))
//Bit  7: 0        reg_lc_cntstscl_hig       // unsigned ,    RW, default = 32  for the contrast high,norm 8 as 1; delta_hig = MIN(delta_hig, MIN(MAX((max_val-maxBV)*scl_hig/8, lmt_hig[0]),lmt_hig[1]))
#define ISP_LC_CURVE_CONTRAST_BVN_LH               ((0x1ac2  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_cntstbvn_low       // unsigned ,    RW, default = 20  to num_m as limit of min_val to minBV distance, to protect mono-color, default = 32; min_val= MAX(min_val, minBV- MAX(num_m-1,0)*bvn_low)
//Bit  7: 0        reg_lc_cntstbvn_hig       // unsigned ,    RW, default = 32  to num_m as limit of max_val to maxBV distance, to protect mono-color, default = 32; min_val= MIN(max_val, maxBV+ MAX(num_m-1,0)*bvn_lo
#define ISP_LC_CURVE_MISC0                         ((0x1ac3  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_lc_num_m_coring       // unsigned ,    RW, default = 2  to num_m, soft coring,default = 2;
//Bit 15: 8        reg_lc_vbin_min           // unsigned ,    RW, default = 48  is min width of valid histogram bin num,
//Bit  7: 0        reg_lc_slope_max_face     // unsigned ,    RW, default = 48  maximum slope for the pkBin-maxBV range curve to do face protection, normalized to 32 as 1, default= 48
#define ISP_LC_CURVE_YPKBV_RAT                     ((0x1ac4  << 2) + 0xff000000)
//Bit 31:24        reg_lc_ypkbv_ratio_0      // unsigned ,    RW, default = 140  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 4
//Bit 23:16        reg_lc_ypkbv_ratio_1      // unsigned ,    RW, default = 192  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 62
//Bit 15: 8        reg_lc_ypkbv_ratio_2      // unsigned ,    RW, default = 192  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1, 120
//Bit  7: 0        reg_lc_ypkbv_ratio_3      // unsigned ,    RW, default = 96  x= ratio*(maxBv-minBv)+min_val as low bound of the ypkBV; normalized to 256 as 1
#define ISP_LC_CURVE_YPKBV_SLP_LMT                 ((0x1ac5  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_lc_ypkbv_slope_lmt_0  // unsigned ,    RW, default = 32  min max slop for the curves to avoid artifacts, [0] for min_slope, [1] for max_slop, e.g.max_slope= limit*(pkBv-minBv)+min_val as high bound of the ypkBV; normalized to 32 as 1
//Bit  7: 0        reg_lc_ypkbv_slope_lmt_1  // unsigned ,    RW, default = 64
#define ISP_LC_CURVE_HISTVLD_THRD                  ((0x1ac6  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_lc_histvld_thrd       // unsigned ,    RW, default = 506  threshold to compare to bin to get number of valid bins
#define ISP_LC_CURVE_BB_MUTE_THRD                  ((0x1ac7  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        reg_lc_blackbar_mute_thrd // unsigned ,    RW, default = 10800  1/8 of the region
#define ISP_LC_PK_1STB_TH                          ((0x1ac8  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23: 0        reg_lc_pk_1stb_th         // unsigned ,    RW, default = 0  th of first bin to determin if it is pks;
#define ISP_LC_DB_VLD                              ((0x1ac9  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lc_pk_vld             // unsigned ,    RW, default = 506  pk valid thd
#define ISP_LC_DB_TRD_MRGN                         ((0x1aca  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_lc_pk_no_trd_mrgn     // unsigned ,    RW, default = 506  pk no trend margin
#define ISP_LC_PK_ADP_TH_0                         ((0x1acb  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_3         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_2         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_1         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_0         // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_1                         ((0x1acc  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_7         // unsigned ,    RW, default = 15  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_6         // unsigned ,    RW, default = 15  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_5         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_4         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_2                         ((0x1acd  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_11        // unsigned ,    RW, default = 11  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_10        // unsigned ,    RW, default = 13  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_9         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_8         // unsigned ,    RW, default = 14  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_LC_PK_ADP_TH_3                         ((0x1ace  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_lc_adp_thrd_15        // unsigned ,    RW, default = 4  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 23:22        reserved
//Bit 21:16        reg_lc_adp_thrd_14        // unsigned ,    RW, default = 5  adaptive threshold to decide whether the nodes is valid hist or not
//Bit 15:14        reserved
//Bit 13: 8        reg_lc_adp_thrd_13        // unsigned ,    RW, default = 7  adaptive threshold to decide whether the nodes is valid hist or not
//Bit  7: 6        reserved
//Bit  5: 0        reg_lc_adp_thrd_12        // unsigned ,    RW, default = 9  adaptive threshold to decide whether the nodes is valid hist or not
#define ISP_DHZ_CURVE_CUT                          ((0x1ad0  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_dhz_lmtrat_lowc       // unsigned ,    RW, default = 8  x/4096 of amount, //2000/1048576
//Bit 15:12        reserved
//Bit 11: 0        reg_dhz_lmtrat_higc       // unsigned ,    RW, default = 8  x/4096 of amount, //2000/1048576
#define ISP_DHZ_CURVE_RAT                          ((0x1ad1  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14: 0        reg_dhz_dlt_rat           // unsigned ,    RW, default = 750  dehaze delta ratio, norm 1024 as 1
#define ISP_DHZ_CURVE_DLT_RAT                      ((0x1ad2  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_hig_dlt_rat       // unsigned ,    RW, default = 256  dehaze high delta ratio, norm 256 as 1
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_low_dlt_rat       // unsigned ,    RW, default = 256  dehaze low delta ratio, norm 256 as 1
#define ISP_DHZ_CURVE_MIN_LMT_0                    ((0x1ad3  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_1     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_0     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_1                    ((0x1ad4  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_3     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_2     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_2                    ((0x1ad5  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_5     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_4     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_3                    ((0x1ad6  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_7     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_6     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_4                    ((0x1ad7  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_9     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_8     // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_5                    ((0x1ad8  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_11    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_10    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_6                    ((0x1ad9  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_13    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_12    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MIN_LMT_7                    ((0x1ada  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_minvval_lmt_15    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_minvval_lmt_14    // unsigned ,    RW, default = 0  lmt_val, 4*lmt[min_val(64:64:1023)], and minvval, MAX(minvval,lmt[min_val]))
#define ISP_DHZ_CURVE_MAX_LMT_0                    ((0x1adb  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_1     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_0     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_1                    ((0x1adc  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_3     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_2     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_2                    ((0x1add  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_5     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_4     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_3                    ((0x1ade  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_7     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_6     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_4                    ((0x1adf  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_9     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_8     // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_5                    ((0x1ae0  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_11    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_10    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_6                    ((0x1ae1  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_13    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_12    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_MAX_LMT_7                    ((0x1ae2  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_dhz_maxvval_lmt_15    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
//Bit 15:10        reserved
//Bit  9: 0        reg_dhz_maxvval_lmt_14    // unsigned ,    RW, default = 1023  lmt_val, 4*lmt[max_val(64:64:1023)], and maxvval, MAX(maxvval,lmt[max_val]))
#define ISP_DHZ_CURVE_LPF_MOD_TAPS                 ((0x1ae3  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           reg_dhz_vlpf_taps_4       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 28           reg_dhz_vlpf_taps_3       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 27           reg_dhz_vlpf_taps_2       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 26           reg_dhz_vlpf_taps_1       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 25           reg_dhz_vlpf_taps_0       // unsigned ,    RW, default = 1  vlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 24           reg_dhz_hlpf_taps_4       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 23           reg_dhz_hlpf_taps_3       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 22           reg_dhz_hlpf_taps_2       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 21           reg_dhz_hlpf_taps_1       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 20           reg_dhz_hlpf_taps_0       // unsigned ,    RW, default = 1  hlpf taps, 0: [0 8 16 8 0]/32, 1:[4 8 8 8 4]/32
//Bit 19:18        reg_dhz_vlpf_mode_4       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 17:16        reg_dhz_vlpf_mode_3       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 15:14        reg_dhz_vlpf_mode_2       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 13:12        reg_dhz_vlpf_mode_1       // unsigned ,    RW, default = 2  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit 11:10        reg_dhz_vlpf_mode_0       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  9: 8        reg_dhz_hlpf_mode_4       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  7: 6        reg_dhz_hlpf_mode_3       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  5: 4        reg_dhz_hlpf_mode_2       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  3: 2        reg_dhz_hlpf_mode_1       // unsigned ,    RW, default = 2  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
//Bit  1: 0        reg_dhz_hlpf_mode_0       // unsigned ,    RW, default = 1  adaptive lpf filter mode of regional statistics, 0: no lpf 1:lpf, 2:MIN(org,lpf)/MAX(org,lpf)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_post_pg2_ctrst_regs.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB0_APB_BASE = 0x20
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_TOP_TOP_CTRL                         ((0x2000  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP0_TOP_CRP2_START                       ((0x2001  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP0_TOP_CRP2_SIZE                        ((0x2002  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP0_TOP_OUT_SIZE                         ((0x2003  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP0_TOP_DITHER_EN                        ((0x2004  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP0_TOP_UV_DS_MODE                       ((0x2005  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP0_TOP_DTH_DATA                     ((0x2010  << 2) + 0xff000000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP0_TOP_DTH_ADDR                     ((0x2011  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP0_TOP_TOP_REG                      ((0x2012  << 2) + 0xff000000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP0_TOP_IN_SIZE                      ((0x2013  << 2) + 0xff000000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP0_TOP_TOP_GLK                      ((0x2014  << 2) + 0xff000000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_PPS_CLR                      ((0x2015  << 2) + 0xff000000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_PPS_DBG_RO                   ((0x2016  << 2) + 0xff000000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP0_TOP_SW_RST                       ((0x2017  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP0_TOP_HW_RE                        ((0x2018  << 2) + 0xff000000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_csc1_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_CSC2_OFFSET_INP01                    ((0x2040  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_inp_0     // signed ,    RW, default = 0  csc1 offset input
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_1     // signed ,    RW, default = 0  csc1 offset input
#define DISP0_CSC2_OFFSET_INP2                     ((0x2041  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_offset_inp_2     // signed ,    RW, default = 0  csc1 offset input
#define DISP0_CSC2_COEF_00_01                      ((0x2042  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_0    // signed ,    RW, default = 218  csc1 matrix00
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_0_1    // signed ,    RW, default = 732  csc1 matrix01
#define DISP0_CSC2_COEF_02_10                      ((0x2043  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_0_2    // signed ,    RW, default = 74  csc1 matrix 02
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_0    // signed ,    RW, default = -117  csc1 matrix 10
#define DISP0_CSC2_COEF_11_12                      ((0x2044  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_1_1    // signed ,    RW, default = -395  csc1 matrix 11
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_1_2    // signed ,    RW, default = 512  csc1 matrix 12
#define DISP0_CSC2_COEF_20_21                      ((0x2045  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_3x3matrix_2_0    // signed ,    RW, default = 512  csc1 matrix 20
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_1    // signed ,    RW, default = -465  csc1 matrix 21
#define DISP0_CSC2_COEF_22                         ((0x2046  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12: 0        reg_csc1_3x3matrix_2_2    // signed ,    RW, default = -48  csc1 matrix 22
#define DISP0_CSC2_OFFSET_OUP01                    ((0x2047  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_0     // signed ,    RW, default = 0  csc1 offset output
//Bit 15:13        reserved
//Bit 12: 0        reg_csc1_offset_oup_1     // signed ,    RW, default = 2048  csc1 offset output
#define DISP0_CSC2_OFFSET_OUP2                     ((0x2048  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_csc1_offset_oup_2     // signed ,    RW, default = 2048  csc1 offset output
//Bit 15: 3        reserved
//Bit  2: 0        reg_csc1_3x3mtrx_rs       // unsigned ,    RW, default = 2  coef shift, 0 s3.8; 1: s2.9; 2: s1.10 3:s0.11
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_csc1_regs_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP0_PPS_SCALE_EN                         ((0x2080  << 2) + 0xff000000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP0_PPS_PRE_HSCALE_COEF_0                ((0x2081  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_1                ((0x2082  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_2                ((0x2083  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP0_PPS_PRE_HSCALE_COEF_3                ((0x2084  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP0_PPS_PRE_VSCALE_COEF_0                ((0x2085  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_1                ((0x2086  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_2                ((0x2087  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_PRE_VSCALE_COEF_3                ((0x2088  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP0_PPS_VSC_START_PHASE_STEP             ((0x2089  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP0_PPS_VSC_LUMA_TOP_FIELD               ((0x208a  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP0_PPS_VSC_CHROMA_TOP_FIELD             ((0x208b  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP0_PPS_HSC_START_PHASE_STEP             ((0x208c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP0_PPS_HSC_LUMA_PHASE_CTRL              ((0x208d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP0_PPS_HSC_CHROMA_PHASE_CTRL            ((0x208e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP0_PPS_444TO422                         ((0x208f  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE0_COEF_IDX_LUMA                   ((0x2090  << 2) + 0xff000000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_LUMA                       ((0x2091  << 2) + 0xff000000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_IDX_CHRO                   ((0x2092  << 2) + 0xff000000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE0_COEF_CHRO                       ((0x2093  << 2) + 0xff000000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB1_APB_BASE = 0x21
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP1_TOP_TOP_CTRL                         ((0x2100  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP1_TOP_CRP2_START                       ((0x2101  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP1_TOP_CRP2_SIZE                        ((0x2102  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP1_TOP_OUT_SIZE                         ((0x2103  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP1_TOP_DITHER_EN                        ((0x2104  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP1_TOP_UV_DS_MODE                       ((0x2105  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP1_TOP_DTH_DATA                     ((0x2110  << 2) + 0xff000000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP1_TOP_DTH_ADDR                     ((0x2111  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP1_TOP_TOP_REG                      ((0x2112  << 2) + 0xff000000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP1_TOP_IN_SIZE                      ((0x2113  << 2) + 0xff000000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP1_TOP_TOP_GLK                      ((0x2114  << 2) + 0xff000000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_PPS_CLR                      ((0x2115  << 2) + 0xff000000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_PPS_DBG_RO                   ((0x2116  << 2) + 0xff000000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP1_TOP_SW_RST                       ((0x2117  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP1_TOP_HW_RE                        ((0x2118  << 2) + 0xff000000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP1_PPS_SCALE_EN                         ((0x2180  << 2) + 0xff000000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP1_PPS_PRE_HSCALE_COEF_0                ((0x2181  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_1                ((0x2182  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_2                ((0x2183  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP1_PPS_PRE_HSCALE_COEF_3                ((0x2184  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP1_PPS_PRE_VSCALE_COEF_0                ((0x2185  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_1                ((0x2186  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_2                ((0x2187  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_PRE_VSCALE_COEF_3                ((0x2188  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP1_PPS_VSC_START_PHASE_STEP             ((0x2189  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP1_PPS_VSC_LUMA_TOP_FIELD               ((0x218a  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP1_PPS_VSC_CHROMA_TOP_FIELD             ((0x218b  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP1_PPS_HSC_START_PHASE_STEP             ((0x218c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP1_PPS_HSC_LUMA_PHASE_CTRL              ((0x218d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP1_PPS_HSC_CHROMA_PHASE_CTRL            ((0x218e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP1_PPS_444TO422                         ((0x218f  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE1_COEF_IDX_LUMA                   ((0x2190  << 2) + 0xff000000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_LUMA                       ((0x2191  << 2) + 0xff000000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_IDX_CHRO                   ((0x2192  << 2) + 0xff000000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE1_COEF_CHRO                       ((0x2193  << 2) + 0xff000000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB2_APB_BASE = 0x22
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_top_regs_2.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP2_TOP_TOP_CTRL                         ((0x2200  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6           reg_csc1_en               // unsigned ,    RW, default = 0  enable color matrix1 for display
//Bit  5           reg_crp2_en               // unsigned ,    RW, default = 0  enable crop for display
//Bit  4           reg_csc2_en               // unsigned ,    RW, default = 0  enable color matrix2 for display
//Bit  3           reg_rgb_gamma_en          // unsigned ,    RW, default = 0  enable gamma for display
//Bit  2           reg_sharpen_en            // unsigned ,    RW, default = 0  enable sharpen for display
//Bit  1           reg_csc3_en               // unsigned ,    RW, default = 0  enable color matrix3 for display
//Bit  0           reg_uv_ds_en              // unsigned ,    RW, default = 0  enable change yuv444 to yuv422 or yuv420
#define DISP2_TOP_CRP2_START                       ((0x2201  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hstart           // unsigned ,    RW, default = 0  crop h start position
//Bit 15: 0        reg_crp2_vstart           // unsigned ,    RW, default = 0  crop v start position
#define DISP2_TOP_CRP2_SIZE                        ((0x2202  << 2) + 0xff000000)
//Bit 31:16        reg_crp2_hsize            // unsigned ,    RW, default = 1920  crop h size
//Bit 15: 0        reg_crp2_vsize            // unsigned ,    RW, default = 1080  crop v size
#define DISP2_TOP_OUT_SIZE                         ((0x2203  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:16        reg_out_hsize             // unsigned ,    RW, default = 1920  default =   1920,horizontal	scaler output width
//Bit 15:13        reserved
//Bit 12: 0        reg_out_vsize             // unsigned ,    RW, default = 1080  default =   1080,vertical	scaler output height
#define DISP2_TOP_DITHER_EN                        ((0x2204  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_disp_dth_en           // unsigned ,    RW, default = 0  enable dither
//Bit  0           reg_disp_dth_bw           // unsigned ,    RW, default = 0  output bits,0:(BIT_DEPTH6-2), 1:(BIT_DEPTH6-4)
#define DISP2_TOP_UV_DS_MODE                       ((0x2205  << 2) + 0xff000000)
//Bit 31: 7        reserved
//Bit  6: 5        reg_uv_ds_mode            // unsigned ,    RW, default = 0  0: yuv444 --> yuv422;  1: yuv444->yuv420
//Bit  4: 3        reg_uv_ds_422_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
//Bit  2: 0        reg_uv_ds_420_mode        // unsigned ,    RW, default = 0  0: y0y1y2...u0v0u2v2...; 1: y0y1y2...u0v1u2v3...; 2,3: flt121
#define ISP_DISP2_TOP_DTH_DATA                     ((0x2210  << 2) + 0xff000000)
//Bit 31:0        reg_dth_data                      // unsigned ,    RW, default = 32'h0
#define ISP_DISP2_TOP_DTH_ADDR                     ((0x2211  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4 :0        reg_dth_addr                      // unsigned ,    RW, default = 5'h0
#define ISP_DISP2_TOP_TOP_REG                      ((0x2212  << 2) + 0xff000000)
//Bit 31:30       reserved
//Bit 29:26       reg_csc1_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc1_gate clk ctrl
//Bit 25          reg_csc1_sync_en                  //unsigned ,   RW , default = 1'h0 , csc1_sync_en
//Bit 24:22       reg_csc1_dbg                      //unsigned ,   RW , default = 3'h0 , csc1_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 21:18       reg_csc2_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc2_gate clk ctrl
//Bit 17          reg_csc2_sync_en                  //unsigned ,   RW , default = 1'h0 , csc2_sync_en
//Bit 16:14       reg_csc2_dbg                      //unsigned ,   RW , default = 3'h0 , csc2_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 13:10       reg_csc3_glk_ctrl                 //unsigned ,   RW , default = 4'h0 , csc3_gate clk ctrl
//Bit 9           reg_csc3_sync_en                  //unsigned ,   RW , default = 1'h0 , csc3_sync_en
//Bit 8:6         reg_csc3_dbg                      //unsigned ,   RW , default = 3'h0 , csc3_dbg            0: debug-off 1: to-yuv 2:to-rgb
//Bit 5:2         reg_sharp_gclk_ctrl               //unsigned ,   RW , default = 4'h0 , sharp_gate clk ctrl
//Bit 1:0         reg_fmt_gclk_ctrl                 //unsigned ,   RW , default = 2'h0 , fmt_ds_gate clk ctrl
#define ISP_DISP2_TOP_IN_SIZE                      ((0x2213  << 2) + 0xff000000)
//Bit 31:29       reserved
//Bit 28:16       reg_in_hsize                      //unsigned ,   RW , default = 1920 , disp_in_hsize
//Bit 15:13       reserved
//Bit 12:0        reg_in_vsize                      //unsigned ,   RW , default = 1080 , disp_in_vsize
#define ISP_DISP2_TOP_TOP_GLK                      ((0x2214  << 2) + 0xff000000)
//Bit 31:22       reserved
//Bit 21:20       reg_dither_glk_ctrl               //unsigned ,   RW , default = 0
//Bit 19:16       reg_rect_glk_ctrl                 //unsigned ,   RW , default = 0
//Bit 15:12       reg_stats_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 11:10       reg_win_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 9:6         reg_pps_glk_ctrl                  //unsigned ,   RW , default = 0
//Bit 5:2         reg_gamma_glk_ctrl                //unsigned ,   RW , default = 0
//Bit 1:0         reg_top_glk_ctrl                  //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_PPS_CLR                      ((0x2215  << 2) + 0xff000000)
//Bit 31:4        reserved
//Bit 3:0         reg_pps_dbg_clr                   //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_PPS_DBG_RO                   ((0x2216  << 2) + 0xff000000)
//Bit 31:0        ro_pps_dbg                      //unsigned, RO, default=0
#define ISP_DISP2_TOP_SW_RST                       ((0x2217  << 2) + 0xff000000)
//Bit 31:5        reserved
//Bit 4:2         reg_dither_idx_force_val       //unsigned ,   RW , default = 0
//Bit 1           reg_dither_idx_force_en        //unsigned ,   RW , default = 0
//Bit 0           reg_sw_rst                     //unsigned ,   RW , default = 0
#define ISP_DISP2_TOP_HW_RE                        ((0x2218  << 2) + 0xff000000)
//Bit 31:6        reserved
//Bit 5:0         reg_din_dat_sel              //unsigned ,   RW , default = 6'h24
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_top_regs_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_disp_pps_regs_2.h
//
// synopsys translate_off
// synopsys translate_on
#define DISP2_PPS_SCALE_EN                         ((0x2280  << 2) + 0xff000000)
//Bit 31:28        reg_vsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of vsc
//Bit 27:24        reg_hsc_nor_rs_bits       // unsigned ,    RW, default = 7  default = 7, normalize right shift bits of hsc
//Bit 23           reg_prehsc_en             // unsigned ,    RW, default = 0  default	=	0	,prehsc_en
//Bit 22           reg_prevsc_en             // unsigned ,    RW, default = 0  default	=	0	,prevsc_en
//Bit 21           reg_vsc_en                // unsigned ,    RW, default = 0  default	=	0	,vsc_en
//Bit 20           reg_hsc_en                // unsigned ,    RW, default = 0  default	=	0	,hsc_en
//Bit 19:18        reg_prehsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:width, 1:width/2, 2:width/4 , 3:width/8
//Bit 17:16        reg_prevsc_rate           // unsigned ,    RW, default = 0  default =   0   ,0:height, 1:height/2, 2:height/4, 3:height/8
//Bit 15:12        reg_prehsc_flt_num        // unsigned ,    RW, default = 8  default =   4   ,horizontal tap number,2/4/6/8
//Bit 11: 8        reg_prevsc_flt_num        // unsigned ,    RW, default = 4  default =   4   ,vertical tap number 2/4/8
//Bit  7: 4        reg_hsc_tap_num           // unsigned ,    RW, default = 4  default	=	0	,horizontal	scaler	bank	length
//Bit  3: 0        reg_vsc_tap_num           // unsigned ,    RW, default = 4  default	=	4	,vertical	scaler	bank	length
#define DISP2_PPS_PRE_HSCALE_COEF_0                ((0x2281  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_1                ((0x2282  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_2                ((0x2283  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient0	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x00	,	coefficient1	pre horizontal	filter
#define DISP2_PPS_PRE_HSCALE_COEF_3                ((0x2284  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prehsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre horizontal	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prehsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre horizontal	filter
#define DISP2_PPS_PRE_VSCALE_COEF_0                ((0x2285  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_1    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_0    // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_1                ((0x2286  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_luma_coef_3    // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_luma_coef_2    // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_2                ((0x2287  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_1  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_0  // signed ,    RW, default = 256  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_PRE_VSCALE_COEF_3                ((0x2288  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_prevsc_chroma_coef_3  // signed ,    RW, default = 0  default	=	0x00	,	coefficient2	pre vertical	filter
//Bit 15:10        reserved
//Bit  9: 0        reg_prevsc_chroma_coef_2  // signed ,    RW, default = 0  default	=	0x40<<2	,	coefficient3	pre vertical	filter
#define DISP2_PPS_VSC_START_PHASE_STEP             ((0x2289  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29           reg_post_sc_mux_sel       // unsigned ,    RW, default = 0  default =	0	,post scale mux sel, 0: vsc stage0, hsc stage1, 1: hsc stage0, vsc stage1
//Bit 28           reg_vf_sep_coef_en        // unsigned ,    RW, default = 0  default = 0x0 ,if true, vertical separated coef enable
//Bit 27:24        reg_vsc_integer_part      // unsigned ,    RW, default = 1  default	=1,vertical	start phase	step,(source/dest)*(2^24),integer part	of	step
//Bit 23: 0        reg_vsc_fraction_part     // unsigned ,    RW, default = 0  default	=0,vertical	start phase	step,(source/dest)*(2^24),fraction part	of	step
#define DISP2_PPS_VSC_LUMA_TOP_FIELD               ((0x228a  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_luma_ini_phase    // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP2_PPS_VSC_CHROMA_TOP_FIELD             ((0x228b  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20:16        reg_vsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,vertical scaler initial integer
//Bit 15: 0        reg_vsc_chroma_ini_phase  // unsigned ,    RW, default = 0  default	=	0,vertical	scaler	field	initial	phase	for	top	field
#define DISP2_PPS_HSC_START_PHASE_STEP             ((0x228c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_hsc_integer_part      // unsigned ,    RW, default = 1  default	=	1,integer	part	of	step
//Bit 23: 0        reg_hsc_fraction_part     // unsigned ,    RW, default = 0  default	=	0,fraction	part	of	step
#define DISP2_PPS_HSC_LUMA_PHASE_CTRL              ((0x228d  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_luma_ini_integer  // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_luma_ini_phase0   // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP2_PPS_HSC_CHROMA_PHASE_CTRL            ((0x228e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_hsc_chroma_ini_integer // signed ,    RW, default = 0  default = 	0	,horizontal scaler initial integer
//Bit 23: 0        reg_hsc_chroma_ini_phase0 // unsigned ,    RW, default = 0  default	=	0	,horizontal	scaler	top	field initial phase0
#define DISP2_PPS_444TO422                         ((0x228f  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_hsc_yuv444to422_en    // unsigned ,    RW, default = 0  enable scale input do 444->422
#define ISP_SCALE2_COEF_IDX_LUMA                   ((0x2290  << 2) + 0xff000000)
//Bit 12:10        reg_luma_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_luma_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_luma_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_luma_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_luma_index                 //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_LUMA                       ((0x2291  << 2) + 0xff000000)
//bit 31:16        reg_luma_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_luma_coef_data_0           //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_IDX_CHRO                   ((0x2292  << 2) + 0xff000000)
//Bit 12:10        reg_chro_ctype                 //unsigned, RW, default = 0
//Bit 9            reg_chro_coef_s11_mode         //unsigned, RW, default = 0
//Bit 8            reg_chro_idx_inc               //unsigned, RW, default = 0
//Bit 7            reg_chro_apb_rd_coef_en        //unsigned, RW, default = 0
//Bit 6:0          reg_chro_index                 //unsigned, RW, default = 0
#define ISP_SCALE2_COEF_CHRO                       ((0x2293  << 2) + 0xff000000)
//bit 31:16        reg_chro_coef_data_1           //unsigned, RW, default = 0
//bit 15:0         reg_chro_coef_data_0           //unsigned, RW, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_disp_pps_regs_2.h
//
// -----------------------------------------------
// REG_BASE:  ISP_DISP_APB3_APB_BASE = 0x23
// -----------------------------------------------
//reserved "isp_disp_top_regs_3.h"           //0x0-0x1f  [DISP, DISP3_TOP]
//reserved "isp_disp_pps_regs_3.h"           //0x80-0x9f [DISP, DISP2_PPS, ISP_SCALE, ISP_SCALE2]
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB0_APB_BASE = 0x28
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_af_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AF_ROI01                               ((0x2800  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_1      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_0      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI23                               ((0x2801  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_3      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_2      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI45                               ((0x2802  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_af_roi_yuvlimt_5      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_af_roi_yuvlimt_4      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AF_STA
#define ISP_AF_ROI0_WIN01                          ((0x2803  << 2) + 0xff000000)
//Bit 31:16        reg_af_roi_xywin_0_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_0_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI1_WIN01                          ((0x2804  << 2) + 0xff000000)
//Bit 31:16        reg_af_roi_xywin_1_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_1_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI0_WIN23                          ((0x2805  << 2) + 0xff000000)
//Bit 31:16        reg_af_roi_xywin_0_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_0_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI1_WIN23                          ((0x2806  << 2) + 0xff000000)
//Bit 31:16        reg_af_roi_xywin_1_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_af_roi_xywin_1_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AF_ROI_EN_0                            ((0x2807  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_af_roi_enable_0       // unsigned ,    RW, default = 1  enable of af_roi_sta
#define ISP_RO_AF_ROI_STAT_PCK0_0                  ((0x2808  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack0_0     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [31:16] I4, [15:0] I2 or [31:16] h1, [15:0] h0
#define ISP_RO_AF_ROI_STAT_PCK1_0                  ((0x2809  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack1_0     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:16] v1, [15:0] v0
#define ISP_RO_AF_ROI_STAT_PCK2_0                  ((0x280a  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack2_0     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [23:16] ycnt, [15:0] y
#define ISP_RO_AF_ROI_STAT_PCK3_0                  ((0x280b  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack3_0     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:24] v1,[23:16] v0,[15:8] h1, [7:0] h0
#define ISP_AF_ROI_EN_1                            ((0x280c  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_af_roi_enable_1       // unsigned ,    RW, default = 1  enable of af_roi_sta
#define ISP_RO_AF_ROI_STAT_PCK0_1                  ((0x280d  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack0_1     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [31:16] I4, [15:0] I2 or [31:16] h1, [15:0] h0
#define ISP_RO_AF_ROI_STAT_PCK1_1                  ((0x280e  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack1_1     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:16] v1, [15:0] v0
#define ISP_RO_AF_ROI_STAT_PCK2_1                  ((0x280f  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack2_1     // unsigned ,    RO, default = 0  LSB of the AF local block statistic, [23:16] ycnt, [15:0] y
#define ISP_RO_AF_ROI_STAT_PCK3_1                  ((0x2810  << 2) + 0xff000000)
//Bit 31: 0        ro_afroi_stat_pack3_1     // unsigned ,    RO, default = 0  MSB of the AF local block statistic, [31:24] v1,[23:16] v0,[15:8] h1, [7:0] h0
#define ISP_AF_CTRL                                ((0x2811  << 2) + 0xff000000)
//Bit 31:18        reserved
//Bit 17:16        reg_af_xphs_ofst          // unsigned ,    RW, default = 1  phase shift for raw data for AF statistics, same as modules for corresponding block
//Bit 15:14        reg_af_yphs_ofst          // unsigned ,    RW, default = 0  phase shift for raw data for AF statistics, same as modules for corresponding block
//Bit 13           reg_af_stat_onchn_0       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 12           reg_af_stat_onchn_1       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 11           reg_af_stat_onchn_2       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit 10           reg_af_stat_onchn_3       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit  9           reg_af_stat_onchn_4       // unsigned ,    RW, default = 1  enable for AF statistics on that channel pixels, default=[1 1 1 1 1], valid on all channels
//Bit  8           reg_af_stat_flt_vmode     // unsigned ,    RW, default = 0  filter mode for auto focus statistics:   0: step=1; 1 and up: step=2
//Bit  7: 6        reg_af_stat_c4_mode       // unsigned ,    RW, default = 0  mode for C4 filter components 0閿涙um(diff[i]^4))1: sum(abs(dif[i])); 2: sum((dif[i])^2); i=0~4, default=0
//Bit  5: 4        reg_af_stat_flt_hmode     // unsigned ,    RW, default = 0  filter mode for auto focus statistics: 0: step=1; 1: step=3;  2: step=5; 3: step=7; default=0
//Bit  3: 2        reg_af_stat_rsft          // unsigned ,    RW, default = 0  right shift of input data for the AF statistics, under u15 precision
//Bit  1: 0        reg_af_stat_c4rs          // unsigned ,    RW, default = 0  4(x+1) as the right shift of the C4 before padding to RO, default =1;
#define ISP_AF_HV_START                            ((0x2812  << 2) + 0xff000000)
//Bit 31:16        reg_af_stat_hstart        // unsigned ,    RW, default = 0  AF global statistics window xstart, better to be >=8 to avoid boundary issue of filter
//Bit 15: 0        reg_af_stat_vstart        // unsigned ,    RW, default = 0  AF global statistics window ystart, better to be >=4 to avoid boundary issue of filter
#define ISP_AF_HV_SIZE                             ((0x2813  << 2) + 0xff000000)
//Bit 31:16        reg_af_stat_hsize         // unsigned ,    RW, default = 1920  AF global statistics window xsize, better to be <=xsize-16 to avoid boundary issue of filter
//Bit 15: 0        reg_af_stat_vsize         // unsigned ,    RW, default = 1080  AF global statistics window ysize, better to be <=ysize-8 to avoid boundary issue of filter
#define ISP_AF_HV_BLKNUM                           ((0x2814  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_af_stat_hblk_num      // unsigned ,    RW, default = 17  AF local block horizontal number, support max 17 horizontal blks for auto focus statistics
//Bit 15: 6        reserved
//Bit  5: 0        reg_af_stat_vblk_num      // unsigned ,    RW, default = 15  AF local block vertical number, support max 15 vertical blks for auto focus statistics
#define ISP_AF_EN_CTRL                             ((0x2815  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23           reg_af_iir0_ds_sel        // unsigned ,    RW, default = 0  it is usually to select the iir0 odd/even channel in downsmple mode,0=even,1=odd
//Bit 22           reg_af_iir1_ds_sel        // unsigned ,    RW, default = 0  it is usually to select the iir1 odd/even channel in downsmple mode,0=even,1=odd
//Bit 21           reg_af_stat_sel           // unsigned ,    RW, default = 0  it is usually to select the statistics output, 0 = old, 1 = new
//Bit 20           reg_af_oe_sel             // unsigned ,    RW, default = 0  it is used to control the odd even line selection in statistics
//Bit 19           reg_af_iir0_0_en          // unsigned ,    RW, default = 1  it is used to enable the first biquard filter in IIR0
//Bit 18           reg_af_iir0_1_en          // unsigned ,    RW, default = 1  it is used to enable the second biquard filter in IIR0
//Bit 17           reg_af_iir0_2_en          // unsigned ,    RW, default = 1  it is used to enable the third biquard filter in IIR0
//Bit 16           reg_af_iir1_0_en          // unsigned ,    RW, default = 1  it is used to enable the first biquard filter in IIR1
//Bit 15           reg_af_iir1_1_en          // unsigned ,    RW, default = 1  it is used to enable the second biquard filter in IIR1
//Bit 14           reg_af_iir1_2_en          // unsigned ,    RW, default = 1  it is used to enable the third biquard filter in IIR1
//Bit 13           reg_af_iir0_ds_en         // unsigned ,    RW, default = 0  it is used to set downsample mode for IIR0. 1= downsample, 1= normal
//Bit 12           reg_af_iir1_ds_en         // unsigned ,    RW, default = 0  it is used to set downsample mode for IIR1. 1= downsample, 1= normal
//Bit 11           reg_af_iir0_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for IIR0
//Bit 10           reg_af_iir1_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for IIR1
//Bit  9           reg_af_iir0_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for IIR0
//Bit  8           reg_af_iir1_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for IIR1
//Bit  7           reg_af_peak_mode          // unsigned ,    RW, default = 1  it used to set the statistics mode for IIR. 1= peak mode, 0= normal mode
//Bit  6           reg_af_sqr_mode           // unsigned ,    RW, default = 1  it used to set the statistics mode. 1= square mode, 0= normal mode
//Bit  5           reg_af_fir0_en            // unsigned ,    RW, default = 1  it is used to enable the FIR0
//Bit  4           reg_af_fir1_en            // unsigned ,    RW, default = 1  it is used to enable the FIR1
//Bit  3           reg_af_fir0_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for FIR0
//Bit  2           reg_af_fir1_ldg_en        // unsigned ,    RW, default = 1  it is used to enable the LDG processing for FIR1
//Bit  1           reg_af_fir0_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for FIR0
//Bit  0           reg_af_fir1_coring_en     // unsigned ,    RW, default = 1  it is used to enable the coring processing for FIR1
#define ISP_AF_IIR0_0_COEF                         ((0x2816  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_0_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_0 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_0_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_0 coef
#define ISP_AF_IIR0_1_COEF                         ((0x2817  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_1_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_1 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_1_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_1 coef
#define ISP_AF_IIR0_2_COEF                         ((0x2818  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir0_2_coef_0      // signed ,    RW, default = 0  it is used to set the IIR0_2 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir0_2_coef_1      // signed ,    RW, default = 0  it is used to set the IIR0_2 coef
#define ISP_AF_IIR1_0_COEF                         ((0x2819  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_0_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_0 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_0_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_0 coef
#define ISP_AF_IIR1_1_COEF                         ((0x281a  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_1_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_1 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_1_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_1 coef
#define ISP_AF_IIR1_2_COEF                         ((0x281b  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:16        reg_af_iir1_2_coef_0      // signed ,    RW, default = 512  it is used to set the IIR1_2 coef
//Bit 15:10        reserved
//Bit  9: 0        reg_af_iir1_2_coef_1      // signed ,    RW, default = 0  it is used to set the IIR1_2 coef
#define ISP_AF_IIR_INOUT_SHIFT                     ((0x281c  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14:12        reg_af_iir0_in_sft        // unsigned ,    RW, default = 3  it is used to set the shift of IIR0 input
//Bit 11            reserved
//Bit 10: 8        reg_af_iir1_in_sft        // unsigned ,    RW, default = 3  it is used to set the shift of IIR1 input
//Bit  7: 4        reg_af_iir0_out_sft       // unsigned ,    RW, default = 3  it is used to set the shift of IIR0 output
//Bit  3: 0        reg_af_iir1_out_sft       // unsigned ,    RW, default = 3  it is used to set the shift of IIR1 output
#define ISP_AF_IIR_SHIFT                           ((0x281d  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:20        reg_af_iir0_0_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_0
//Bit 19            reserved
//Bit 18:16        reg_af_iir0_1_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_1
//Bit 15            reserved
//Bit 14:12        reg_af_iir0_2_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR0_2
//Bit 11            reserved
//Bit 10: 8        reg_af_iir1_0_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_0
//Bit  7            reserved
//Bit  6: 4        reg_af_iir1_1_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_1
//Bit  3            reserved
//Bit  2: 0        reg_af_iir1_2_sft         // unsigned ,    RW, default = 3  it is used to set the shift of IIR1_2
#define ISP_AF_IIR_GAIN                            ((0x281e  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_af_iir0_gain          // unsigned ,    RW, default = 3  it is used to set the gain of IIR0
//Bit 15: 8        reserved
//Bit  7: 0        reg_af_iir1_gain          // unsigned ,    RW, default = 3  it is used to set the gain of IIR1
#define ISP_AF_FIR0_COEF                           ((0x281f  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_af_fir0_coef_0        // signed ,    RW, default = 0  it is used to set the FIR0 coef0
//Bit 23:18        reg_af_fir0_coef_1        // signed ,    RW, default = 0  it is used to set the FIR0 coef1
//Bit 17:12        reg_af_fir0_coef_2        // signed ,    RW, default = 32  it is used to set the FIR0 coef2
//Bit 11: 6        reg_af_fir0_coef_3        // signed ,    RW, default = 0  it is used to set the FIR0 coef3
//Bit  5: 0        reg_af_fir0_coef_4        // signed ,    RW, default = 0  it is used to set the FIR0 coef4
#define ISP_AF_FIR1_COEF                           ((0x2820  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_af_fir1_coef_0        // signed ,    RW, default = 0  it is used to set the FIR1 coef0
//Bit 23:18        reg_af_fir1_coef_1        // signed ,    RW, default = 0  it is used to set the FIR1 coef1
//Bit 17:12        reg_af_fir1_coef_2        // signed ,    RW, default = 32  it is used to set the FIR1 coef2
//Bit 11: 6        reg_af_fir1_coef_3        // signed ,    RW, default = 0  it is used to set the FIR1 coef3
//Bit  5: 0        reg_af_fir1_coef_4        // signed ,    RW, default = 0  it is used to set the FIR1 coef4
#define ISP_AF_IIR0_LDG                            ((0x2821  << 2) + 0xff000000)
//Bit 31:24        reg_af_iir0_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in IIR0 LDG
//Bit 23:16        reg_af_iir0_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in IIR0 LDG
//Bit 15: 8        reg_af_iir0_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in IIR0 LDG
//Bit  7: 0        reg_af_iir0_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in IIR0 LDG
#define ISP_AF_IIR1_LDG                            ((0x2822  << 2) + 0xff000000)
//Bit 31:24        reg_af_iir1_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in IIR1 LDG
//Bit 23:16        reg_af_iir1_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in IIR1 LDG
//Bit 15: 8        reg_af_iir1_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in IIR1 LDG
//Bit  7: 0        reg_af_iir1_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in IIR1 LDG
#define ISP_AF_IIR_LDG_SLP                         ((0x2823  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:20        reg_af_iir0_dilate        // unsigned ,    RW, default = 1  it is used to set the dilate selection in IIR0 LDG
//Bit 19            reserved
//Bit 18:16        reg_af_iir1_dilate        // unsigned ,    RW, default = 1  it is used to set the dilate selection in IIR1 LDG
//Bit 15:12        reg_af_iir0_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in IIR0 LDG
//Bit 11: 8        reg_af_iir0_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in IIR0 LDG
//Bit  7: 4        reg_af_iir1_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in IIR1 LDG
//Bit  3: 0        reg_af_iir1_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in IIR1 LDG
#define ISP_AF_IIR0_CORING                         ((0x2824  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_iir0_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in IIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_iir0_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in IIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_iir0_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in IIR1 coring
#define ISP_AF_IIR1_CORING                         ((0x2825  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_iir1_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in IIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_iir1_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in IIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_iir1_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in IIR1 coring
#define ISP_AF_FIR0_LDG                            ((0x2826  << 2) + 0xff000000)
//Bit 31:24        reg_af_fir0_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in FIR0 LDG
//Bit 23:16        reg_af_fir0_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in FIR0 LDG
//Bit 15: 8        reg_af_fir0_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in FIR0 LDG
//Bit  7: 0        reg_af_fir0_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in FIR0 LDG
#define ISP_AF_FIR1_LDG                            ((0x2827  << 2) + 0xff000000)
//Bit 31:24        reg_af_fir1_thd_l         // unsigned ,    RW, default = 10  it is used to set the low threshold in FIR1 LDG
//Bit 23:16        reg_af_fir1_thd_h         // unsigned ,    RW, default = 240  it is used to set the high threshold in FIR1 LDG
//Bit 15: 8        reg_af_fir1_gain_l        // unsigned ,    RW, default = 20  it is used to set the low gain in FIR1 LDG
//Bit  7: 0        reg_af_fir1_gain_h        // unsigned ,    RW, default = 10  it is used to set the high gain in FIR1 LDG
#define ISP_AF_FIR_LDG_SLOPE                       ((0x2828  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_af_fir0_out_sft       // unsigned ,    RW, default = 0  it is used to set the output shift in FIR0
//Bit 19:16        reg_af_fir1_out_sft       // unsigned ,    RW, default = 0  it is used to set the output_shift in FIR1
//Bit 15:12        reg_af_fir0_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in FIR0 LDG
//Bit 11: 8        reg_af_fir0_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in FIR0 LDG
//Bit  7: 4        reg_af_fir1_slp_l         // unsigned ,    RW, default = 8  it is used to set the low slope in FIR1 LDG
//Bit  3: 0        reg_af_fir1_slp_h         // unsigned ,    RW, default = 8  it is used to set the high slope in FIR1 LDG
#define ISP_AF_FIR0_CORING                         ((0x2829  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_fir0_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in FIR0 coring
//Bit 23            reserved
//Bit 22:12        reg_af_fir0_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in FIR0 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_fir0_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in FIR0 coring
#define ISP_AF_FIR1_CORING                         ((0x282a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_af_fir1_coring_slp    // unsigned ,    RW, default = 12  it is used to set the slope in FIR1 coring
//Bit 23            reserved
//Bit 22:12        reg_af_fir1_coring_thd    // unsigned ,    RW, default = 15  it is used to set the threshold in FIR1 coring
//Bit 11            reserved
//Bit 10: 0        reg_af_fir1_coring_lmt    // unsigned ,    RW, default = 2000  it is used to set the limit in FIR1 coring
#define ISP_AF_HOR_THD                             ((0x282b  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_af_h0_thd             // unsigned ,    RW, default = 0  it is used to set the horizontal theshold
//Bit 15:11        reserved
//Bit 10: 0        reg_af_h1_thd             // unsigned ,    RW, default = 0  it is used to set the horizontal theshold
#define ISP_AF_VER_THD                             ((0x282c  << 2) + 0xff000000)
//Bit 31:27        reserved
//Bit 26:16        reg_af_v0_thd             // unsigned ,    RW, default = 0  it is used to set the vertical theshold
//Bit 15:11        reserved
//Bit 10: 0        reg_af_v1_thd             // unsigned ,    RW, default = 0  it is used to set the vertical theshold
#define ISP_AF_STA_SHIFT                           ((0x282d  << 2) + 0xff000000)
//Bit 31:28        reg_af_h0_sft             // unsigned ,    RW, default = 8  it is used to set the shift for horizontal statistics0
//Bit 27:24        reg_af_h1_sft             // unsigned ,    RW, default = 8  it is used to set the shift for horizontal statistics1
//Bit 23:20        reg_af_v0_sft             // unsigned ,    RW, default = 8  it is used to set the shift for vertical statistics0
//Bit 19:16        reg_af_v1_sft             // unsigned ,    RW, default = 8  it is used to set the shift for vertical statistics1
//Bit 15:12        reg_af_hcnt0_sft          // unsigned ,    RW, default = 3  it is used to set the shift for horizontal counter0
//Bit 11: 8        reg_af_hcnt1_sft          // unsigned ,    RW, default = 3  it is used to set the shift for horizontal counter1
//Bit  7: 4        reg_af_vcnt0_sft          // unsigned ,    RW, default = 3  it is used to set the shift for vertical counter0
//Bit  3: 0        reg_af_vcnt1_sft          // unsigned ,    RW, default = 3  it is used to set the shift for vertical counter1
#define ISP_AF_STA_Y                               ((0x282e  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19:16        reg_af_y_sft              // unsigned ,    RW, default = 8  it is used to set the shift for y statistics
//Bit 15:12        reg_af_ycnt_sft           // unsigned ,    RW, default = 3  it is used to set the shift for y counter
//Bit 11: 0        reg_af_y_thd              // unsigned ,    RW, default = 0  it is used to set the Y theshold
#define ISP_AF_ROI0_STA_SHIFT                      ((0x282f  << 2) + 0xff000000)
//Bit 31:28        reg_af_roi_h0_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI0 statistics0
//Bit 27:24        reg_af_roi_h1_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI0 statistics1
//Bit 23:20        reg_af_roi_v0_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI0 statistics0
//Bit 19:16        reg_af_roi_v1_sft_0       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI0 statistics1
//Bit 15:12        reg_af_roi_hcnt0_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI0 counter0
//Bit 11: 8        reg_af_roi_hcnt1_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI0 counter1
//Bit  7: 4        reg_af_roi_vcnt0_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI0 counter0
//Bit  3: 0        reg_af_roi_vcnt1_sft_0    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI0 counter1
#define ISP_AF_ROI0_STA_Y_SFT                      ((0x2830  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_af_roi_y_sft_0        // unsigned ,    RW, default = 8  it is used to set the shift for ROI0 y statistics
//Bit  3: 0        reg_af_roi_ycnt_sft_0     // unsigned ,    RW, default = 3  it is used to set the shift for ROI0 y counter
#define ISP_AF_ROI1_STA_SHIFT                      ((0x2831  << 2) + 0xff000000)
//Bit 31:28        reg_af_roi_h0_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI1 statistics0
//Bit 27:24        reg_af_roi_h1_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for horizontal ROI1 statistics1
//Bit 23:20        reg_af_roi_v0_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI1 statistics0
//Bit 19:16        reg_af_roi_v1_sft_1       // unsigned ,    RW, default = 8  it is used to set the shift for vertical ROI1 statistics1
//Bit 15:12        reg_af_roi_hcnt0_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI1 counter0
//Bit 11: 8        reg_af_roi_hcnt1_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for horizontal ROI1 counter1
//Bit  7: 4        reg_af_roi_vcnt0_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI1 counter0
//Bit  3: 0        reg_af_roi_vcnt1_sft_1    // unsigned ,    RW, default = 3  it is used to set the shift for vertical ROI1 counter1
#define ISP_AF_ROI1_STA_Y_SFT                      ((0x2832  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_af_roi_y_sft_1        // unsigned ,    RW, default = 8  it is used to set the shift for ROI1 y statistics
//Bit  3: 0        reg_af_roi_ycnt_sft_1     // unsigned ,    RW, default = 3  it is used to set the shift for ROI1 y counter
#define ISP_AF_DEBUG_IN_CHECKSUM                   ((0x2833  << 2) + 0xff000000)
//Bit 31: 0        ro_af_debug_in_checksum   // unsigned ,    RO, default = 0
#define ISP_AF_DEBUG_PACK0_CHECKSUM                ((0x2834  << 2) + 0xff000000)
//Bit 31: 0        ro_af_debug_pack0_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK1_CHECKSUM                ((0x2835  << 2) + 0xff000000)
//Bit 31: 0        ro_af_debug_pack1_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK2_CHECKSUM                ((0x2836  << 2) + 0xff000000)
//Bit 31: 0        ro_af_debug_pack2_checksum // unsigned ,   RO, default = 0
#define ISP_AF_DEBUG_PACK3_CHECKSUM                ((0x2837  << 2) + 0xff000000)
//Bit 31: 0        ro_af_debug_pack3_checksum // unsigned ,   RO, default = 0
#define ISP_RO_AF_GLB_STAT_PCK0                    ((0x2838  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack0      // unsigned ,    RO, default = 0  LSB of the AF global block sparam_3a_inittatistic, [31:16] I4, [15:0] I2 or [31:0] h0
#define ISP_RO_AF_GLB_STAT_PCK1                    ((0x2839  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack1      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:26] I4_exp, [25:21] I2 _exp, [20:16] C4_exp; [15:0] C4 or [31:0] h1
#define ISP_RO_AF_GLB_STAT_PCK2                    ((0x283a  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack2      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] v0
#define ISP_RO_AF_GLB_STAT_PCK3                    ((0x283b  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack3      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] v1
#define ISP_RO_AF_GLB_STAT_PCK4                    ((0x283c  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack4      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [31:0] Y
#define ISP_RO_AF_GLB_STAT_PCK5                    ((0x283d  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack5      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [23:0] hcnt0
#define ISP_RO_AF_GLB_STAT_PCK6                    ((0x283e  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack6      // unsigned ,    RO, default = 0  LSB of the AF global block statistic, [23:0] hcnt1
#define ISP_RO_AF_GLB_STAT_PCK7                    ((0x283f  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack7      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=vcnt0
#define ISP_RO_AF_GLB_STAT_PCK8                    ((0x2840  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack8      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=vcnt1
#define ISP_RO_AF_GLB_STAT_PCK9                    ((0x2841  << 2) + 0xff000000)
//Bit 31: 0        ro_af_glb_stat_pack9      // unsigned ,    RO, default = 0  LSB of the AF global block statistic,[23:0]=y_cnt
#define ISP_AF_IDX_ADDR                            ((0x2870  << 2) + 0xff000000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_af_idx_addr       //unsigned  ,    RW, default = 0  addr for af_idx
#define ISP_AF_IDX_DATA                            ((0x2871  << 2) + 0xff000000)
//Bit 31:16        reg_isp_af_hidx_data      //unsigned  ,    RW, default = 0  data for af_hidx
//Bit 15:0         reg_isp_af_vidx_data      //unsigned  ,    RW, default = 0  data for af_vidx
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_af_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_flkr_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_DEFLICKER_OFST                         ((0x2880  << 2) + 0xff000000)
//Bit 31: 6        reserved
//Bit  5: 4        reg_flkr_xphs_ofst        // unsigned ,    RW, default = 1  horizontal phase offset
//Bit  3: 2        reserved
//Bit  1: 0        reg_flkr_yphs_ofst        // unsigned ,    RW, default = 0  vertical phase offset
#define ISP_DEFLICKER_STAT_YPOSITION               ((0x2881  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_flkr_stat_yst         // unsigned ,    RW, default = 0  row start for row statistic for flicker statistic
//Bit 15:14        reserved
//Bit 13: 0        reg_flkr_stat_yed         // unsigned ,    RW, default = 1079  row end for row statistic for flicker statistic
#define ISP_DEFLICKER_STAT_XPOSITION               ((0x2882  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_flkr_stat_xst         // unsigned ,    RW, default = 0  column start for flicker statistic
//Bit 15:14        reserved
//Bit 13: 0        reg_flkr_stat_xed         // unsigned ,    RW, default = 1919  column end for flicker statistic
#define ISP_DEFLICKER_DIV_COEF                     ((0x2883  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_flkr_stat_div_coef    // unsigned ,    RW, default = 1920  divide coefficient for sum diff for row statistic for flicker detection
#define ISP_DEFLICKER_WDR_RATIO                    ((0x2884  << 2) + 0xff000000)
//Bit 31:15        reserved
//Bit 14: 0        reg_flkr_wdr_ratio        // unsigned ,    RW, default = 64  exposure ratio between long and short1 for wdr mode. T7 wdr mode short frame input =long_expo/short_expo, else =1. default 64
#define ISP_DEFLICKER_CNTL                         ((0x2885  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_flkr_avg_chnen_0      // unsigned ,    RW, default = 1  enable of averaging of channel data during line sum calculation. for T7, mono/GrRBGb/GrRBIr/IrRBGb, default [1 1 1 1]; for isp GrRBGbIr, default=[1 0 0 1 0]
//Bit 19           reg_flkr_avg_chnen_1      // unsigned ,    RW, default = 0
//Bit 18           reg_flkr_avg_chnen_2      // unsigned ,    RW, default = 0
//Bit 17           reg_flkr_avg_chnen_3      // unsigned ,    RW, default = 1
//Bit 16           reg_flkr_avg_chnen_4      // unsigned ,    RW, default = 0
//Bit 15            reserved
//Bit 14:13        reserved
//Bit 12           reg_flkr_sta_input_format // unsigned ,    RW, default = 0  STA input select ISP output, 0: raw input 1: YUV/RGB
//Bit 11:10        reserved
//Bit  9: 8        reg_flkr_sta_cmpsel       // unsigned ,    RW, default = 0  component combine to Y when reg_flkr_sta_input_format, 1. 0: dat[0],Y, 1:dat[3], IR); 2/3: (dat[0]+ 2*dat[1]+ dat[2])/4, RGB
//Bit  7: 5        reserved
//Bit  4: 2        reg_flkr_binning_rs       // unsigned ,    RW, default = 0  row average binning step, 2^x. 0: RO for each row avg); 1: each RO for two rows); 2: each RO for 4rows); 3: each RO for 8rows);
//Bit  1            reserved
//Bit  0           reg_flkr_ro_mode          // unsigned ,    RW, default = 0  mode of RO-RAM, 0: avg(cur-p1); 1: avg(cur), 2: debug info, default, 0.
#define ISP_DEFLICKER_RO_IN_CHECKSUM0              ((0x2886  << 2) + 0xff000000)
//Bit 31:0         ro_flkr_debug_in_checksum0 //unsigned ,    RO, default = 0
#define ISP_DEFLICKER_RO_IN_CHECKSUM1              ((0x2887  << 2) + 0xff000000)
//Bit 31:0         ro_flkr_debug_in_checksum1 //unsigned ,    RO, default = 0
#define ISP_DEFLICKER_RO_OUT_CHECKSUM              ((0x2888  << 2) + 0xff000000)
//Bit 31:0         ro_flkr_debug_out_checksum //unsigned ,    RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_flkr_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_3a_hw_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_3A_GCLK_CTRL                           ((0x28c0  << 2) + 0xff000000)
//Bit 31:21 reserved
//Bit 20    reg_3a_dma_dbg              //unsigned, RW, default=0
//Bit 19:18 reg_3a_reg_gclk_ctrl        //unsigned, RW, default=0
//Bit 17:16 reg_awb_1c2_gclk_ctrl       //unsigned, RW, default=0
//Bit 15:12 reg_flkr_gclk_ctrl          //unsigned, RW, default=0
//Bit 11:8  reg_ae_gclk_ctrl            //unsigned, RW, default=0
//Bit 7:4   reg_awb_gclk_ctrl           //unsigned, RW, default=0
//Bit 3:0   reg_af_gclk_ctrl            //unsigned, RW, default=0
#define ISP_3A_DBGRO_CTRL                          ((0x28c1  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:8  reg_3a_dbg_en               //unsigned, RW, default=0
//Bit 7:0   reg_3a_dbg_clr              //unsigned, RW, default=0
#define ISP_3A_WATDOG_CTRL                         ((0x28c2  << 2) + 0xff000000)
//Bit 31:20 reserved
//Bit 19:4  reg_3a_watchdog_thrd        //unsigned, RW, default=65535
//Bit 3:0   reg_3a_watchdog_en          //unsigned, RW, default=15
#define ISP_3A_DBGPATH_SEL                         ((0x28d0  << 2) + 0xff000000)
//Bit 31:0   reg_3a_dbgpath_sel          //unsigned, RW, default=0
#define ISP_3A_DBG_CNT_EN                          ((0x28d1  << 2) + 0xff000000)
//Bit 31:4  reserved
//Bit 3:0   reg_3a_dbg_cnt_en           //unsigned, RW, default=0
#define ISP_3A_DBG_SIZE_0                          ((0x28d2  << 2) + 0xff000000)
//Bit 31:16 reg_3a_dbg_size_af          //unsigned, RW, default=0
//Bit 15:0  reg_3a_dbg_size_awb         //unsigned, RW, default=0
#define ISP_3A_DBG_SIZE_1                          ((0x28d3  << 2) + 0xff000000)
//Bit 31:16 reg_3a_dbg_size_ae          //unsigned, RW, default=0
//Bit 15:0  reg_3a_dbg_size_flkr        //unsigned, RW, default=0
#define ISP_3A_RO_STAT                             ((0x28e0  << 2) + 0xff000000)
//Bit 31:8  reserved
//Bit 7:0   ro_dma_size_err             //unsigned, RO, default=0 bit[7:4] dma_size setting larger than requested for each channel bit[3:0] dma_size setting smaller than requested for each channel
#define ISP_3A_RO_DBGPATH0                         ((0x28e1  << 2) + 0xff000000)
//Bit 31:0   ro_3a_dbgpath_dat0         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH1                         ((0x28e2  << 2) + 0xff000000)
//Bit 31:0   ro_3a_dbgpath_dat1         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH2                         ((0x28e3  << 2) + 0xff000000)
//Bit 31:0   ro_3a_dbgpath_dat2         //unsigned, RO, default=0
#define ISP_3A_RO_DBGPATH3                         ((0x28e4  << 2) + 0xff000000)
//Bit 31:0   ro_3a_dbgpath_dat3         //unsigned, RO, default=0
#define ISP_3A_RO_FRM_END                          ((0x28e5  << 2) + 0xff000000)
//Bit 31:8   reserved
//Bit 7:0    ro_3a_dbg_frm_end          //unsigned, RO, default=0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_3a_hw_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB1_APB_BASE = 0x29
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_ae_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AE_ROI01                               ((0x2900  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_1      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_0      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI23                               ((0x2901  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_3      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_2      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI45                               ((0x2902  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_ae_roi_yuvlimt_5      // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_roi_yuvlimt_4      // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, u_low, u_hig, v_low, v_hig,] to decide whether to added to EOI_AE_STA
#define ISP_AE_ROI0_WIN01                          ((0x2903  << 2) + 0xff000000)
//Bit 31:16        reg_ae_roi_xywin_0_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_0_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI1_WIN01                          ((0x2904  << 2) + 0xff000000)
//Bit 31:16        reg_ae_roi_xywin_1_1      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_1_0      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI0_WIN23                          ((0x2905  << 2) + 0xff000000)
//Bit 31:16        reg_ae_roi_xywin_0_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_0_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI1_WIN23                          ((0x2906  << 2) + 0xff000000)
//Bit 31:16        reg_ae_roi_xywin_1_3      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_ae_roi_xywin_1_2      // unsigned ,    RW, default = 50  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AE_ROI_EN_0                            ((0x2907  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_ae_roi_enable_0       // unsigned ,    RW, default = 1  enable of ae_roi_sta
//Bit  0           reg_ae_roi_mode_0         // unsigned ,    RW, default = 0  mode of the his5, 0: bins0134; 1: avg4
#define ISP_AE_ROI_EN_1                            ((0x2908  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_ae_roi_enable_1       // unsigned ,    RW, default = 1  enable of ae_roi_sta
//Bit  0           reg_ae_roi_mode_1         // unsigned ,    RW, default = 0  mode of the his5, 0: bins0134; 1: avg4
#define ISP_RO_AE_ROI_STAT_PCK0_0                  ((0x2909  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack0_0     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_0                  ((0x290a  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack1_0     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_1                  ((0x290b  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack0_1     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_1                  ((0x290c  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack1_1     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_2                  ((0x290d  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack0_2     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_2                  ((0x290e  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack1_2     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_RO_AE_ROI_STAT_PCK0_3                  ((0x290f  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack0_3     // unsigned ,    RO, default = 0  LSB of the AE local block statistic normalized, [31:16] BIN1 or Red_avg,             [15:0] BIN0 or Gr_avg, or Ir_avg
#define ISP_RO_AE_ROI_STAT_PCK1_3                  ((0x2910  << 2) + 0xff000000)
//Bit 31: 0        ro_aeroi_stat_pack1_3     // unsigned ,    RO, default = 0  MSB of the AE local block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg; [15:0] BIN3 or blu_avg
#define ISP_AE_SATUR_THRD                          ((0x2911  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ae_stat_satur_thrd    // unsigned ,    RW, default = 61440  global saturation threshold for saturation/unsaturation statistic in each block
#define ISP_AE_CTRL                                ((0x2912  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:26        reg_ae_xphs_ofst          // unsigned ,    RW, default = 1  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit 25:24        reg_ae_yphs_ofst          // unsigned ,    RW, default = 0  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit 23            reserved
//Bit 22:20        reg_ae_expos_stt          // unsigned ,    RW, default = 0  start of exposure frame AE statistics,  0: long, 1: short, 2: very short, 3: veryvery short, default = 0
//Bit 19            reserved
//Bit 18:16        reg_ae_expos_num          // unsigned ,    RW, default = 1  exposure number for AE statistics,  e.g DOL2+AESTA_GE, set to 2, x=[1,2]
//Bit 15:12        reg_ae_stat_hist_updt     // unsigned ,    RW, default = 0  bit0-bit3 set to 1, the possible hist0-hist3 to be updated at current AE histogram statistic
//Bit 11:10        reg_ae_stat_hist_mode     // unsigned ,    RW, default = 0  0: single hist, 1: two hist, 2or3: four hist, AE histogram mode for single exposure
//Bit  9: 8        reg_ae_luma_mode          // unsigned ,    RW, default = 0  blender mode between grn', red and blu to get luma for AE STA: 0: cur (reg_ae_input_2ln=0); 1: MAX(grn',Red, BLU); 2/3: filter
//Bit  7           reg_ae_input_2ln          // unsigned ,    RW, default = 1  input buffer 2 lines together, reg_ae_stat_switch=0, set 1, otherwise set to 0
//Bit  6            reserved
//Bit  5           reg_ae_histo_useweight    // unsigned ,    RW, default = 1  hist1024 use regional weight, default=1
//Bit  4           reg_ae_glbal_useweight    // unsigned ,    RW, default = 1  global use regional weight, default=1
//Bit  3: 2        reg_ae_stat_local_mode    // unsigned ,    RW, default = 0  AE statisic local sta mode: 0: BIN0/1/3/4 in pack0 and pack1; 1: Gr/R/B/Gb/Ir_avg in pack0 and pack1; 2o3: mean/max/min/sat/unsat etc packed. default=0
//Bit  1           reg_ae_stat_hist_sel      // unsigned ,    RW, default = 0  0: global win, 1: roi window, histogram from global window or roi window for ae stats
//Bit  0           reg_ae_stat_glbal_mode    // unsigned ,    RW, default = 0  AE statisic global sta mode: 0: BIN0/1/3/4 in pack0 and pack1; 1: Gr/R/B/Gb/Ir_avg in pack0 and pack1; default=0
#define ISP_AE_CRTL2_0                             ((0x2913  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_0        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_0       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_0       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_1                             ((0x2914  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_1        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_1       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_1       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_2                             ((0x2915  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_2        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_2       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_2       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_3                             ((0x2916  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_3        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_3       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_3       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_CRTL2_4                             ((0x2917  << 2) + 0xff000000)
//Bit 31:25        reserved
//Bit 24           reg_ae_luma_coef_4        // unsigned ,    RW, default = 1  luma estimate coef for AE, 0: not included in lumat estimate, 1: included; default, , 1 1 1 1 1;
//Bit 23:16        reg_ae_gain_grbgi_4       // unsigned ,    RW, default = 64  gain to grbgi before bleeding to luma, norm to 64 as 1.0, used to scale up blue/red to check if saturated. default, 64
//Bit 15:12        reserved
//Bit 11: 0        reg_ae_bl12_grbgi_4       // unsigned ,    RW, default = 0  offset to grbgi before gain and will add back after the gain, default, BLC, 16x is the level
#define ISP_AE_HV_START                            ((0x2918  << 2) + 0xff000000)
//Bit 31:16        reg_ae_stat_hstart        // unsigned ,    RW, default = 0  horizontal start for auto exposure statistics
//Bit 15: 0        reg_ae_stat_vstart        // unsigned ,    RW, default = 0  vertical start for auto exposure statistics
#define ISP_AE_HV_SIZE                             ((0x2919  << 2) + 0xff000000)
//Bit 31:16        reg_ae_stat_hsize         // unsigned ,    RW, default = 1920  horizontal size for auto exposure statistics
//Bit 15: 0        reg_ae_stat_vsize         // unsigned ,    RW, default = 1080  vertical size for auto exposure statistics
#define ISP_AE_HV_BLKNUM                           ((0x291a  << 2) + 0xff000000)
//Bit 31:23        reserved
//Bit 22:16        reg_ae_stat_hblk_num      // unsigned ,    RW, default = 17  AE local block horizontal number
//Bit 15: 7        reserved
//Bit  6: 0        reg_ae_stat_vblk_num      // unsigned ,    RW, default = 15  AE local block vertical number
#define ISP_AE_STAT_THD01                          ((0x291b  << 2) + 0xff000000)
//Bit 31:16        reg_ae_stat_thrd_1        // unsigned ,    RW, default = 16'h6000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
//Bit 15: 0        reg_ae_stat_thrd_0        // unsigned ,    RW, default = 16'h2000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
#define ISP_AE_STAT_THD23                          ((0x291c  << 2) + 0xff000000)
//Bit 31:16        reg_ae_stat_thrd_3        // unsigned ,    RW, default = 16'h9000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
//Bit 15: 0        reg_ae_stat_thrd_2        // unsigned ,    RW, default = 16'h6000  threshold for luma to decide percentile his5; if expos_num=0: 5bins; expos_num=2: 3bins*2; else 2binsx4
#define ISP_AE_DEBUG_IN0_CHECKSUM                  ((0x291d  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_in_checksum_0 // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_IN1_CHECKSUM                  ((0x291e  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_in_checksum_1 // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK0_CHECKSUM                ((0x291f  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_pack0_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK1_CHECKSUM                ((0x2920  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_pack1_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK2_CHECKSUM                ((0x2921  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_pack2_checksum // unsigned ,    RO, default = 0
#define ISP_AE_DEBUG_PACK3_CHECKSUM                ((0x2922  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_debug_pack3_checksum // unsigned ,    RO, default = 0
#define ISP_RO_AE_GLB_STAT_PCK0_0                  ((0x2923  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_glb_stat_pack0_0    // unsigned ,    RO, default = 0  LSB of the AE global block statistic normalized, [31:16] BIN1 or Red_avg or Max,             [15:0] BIN0 or Gr_avg, or Ir_avg or Min
#define ISP_RO_AE_GLB_STAT_PCK1_0                  ((0x2924  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_glb_stat_pack1_0    // unsigned ,    RO, default = 0  MSB of the AE global block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg or NULL; [15:0] BIN3 or blu_avg or Mean
#define ISP_RO_AE_GLB_STAT_PCK0_1                  ((0x2925  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_glb_stat_pack0_1    // unsigned ,    RO, default = 0  LSB of the AE global block statistic normalized, [31:16] BIN1 or Red_avg or Max,             [15:0] BIN0 or Gr_avg, or Ir_avg or Min
#define ISP_RO_AE_GLB_STAT_PCK1_1                  ((0x2926  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_glb_stat_pack1_1    // unsigned ,    RO, default = 0  MSB of the AE global block statistic normalized, [31:16] BIN4 or Gb_avg  or GbGr_avg or NULL; [15:0] BIN3 or blu_avg or Mean
#define ISP_RO_AE_STAT_GPNUM                       ((0x2927  << 2) + 0xff000000)
//Bit 31: 0        ro_ae_stat_glbpixnum      // unsigned ,    RO, default = 0  weighted global pixel num, equal to hist1024 sum for easier normalization
#define ISP_AE_IDX_ADDR                            ((0x2980  << 2) + 0xff000000)
//Bit 31:8         reserved
//Bit 7:0          reg_isp_ae_idx_addr       //unsigned  ,    RW, default = 0  addr for ae_idx
#define ISP_AE_IDX_DATA                            ((0x2981  << 2) + 0xff000000)
//Bit 31:16        reg_isp_ae_hidx_data      //unsigned  ,    RW, default = 0  data for ae_hidx
//Bit 15:0         reg_isp_ae_vidx_data      //unsigned  ,    RW, default = 0  data for ae_vidx
#define ISP_AE_BLK_WT_ADDR                         ((0x2982  << 2) + 0xff000000)
//Bit 31:9         reserved
//Bit 8:0          reg_isp_ae_blk_wt_addr    //unsigned  ,    RW, default = 0  addr for ae_weight
#define ISP_AE_BLK_WT_DATA                         ((0x2983  << 2) + 0xff000000)
//Bit 31:0         reg_isp_ae_blk_wt_data    //unsigned  ,    RW, default = 0  data for ae_weight
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_ae_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_3A_APB2_APB_BASE = 0x2a
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_awb_reg.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_AWB_STAT_ROI01                         ((0x2a00  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_1     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_0     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI23                         ((0x2a01  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_3     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_2     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI45                         ((0x2a02  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_roi_yuvlimt_5     // unsigned ,    RW, default = 4095  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_roi_yuvlimt_4     // unsigned ,    RW, default = 0  each pixel [y_low, y_hig, g/b_low, g/b_hig, g/r_low, g/r_hig,] to decide whether to added to EOI_AWB_STA
#define ISP_AWB_STAT_ROI0_WIN01                    ((0x2a03  << 2) + 0xff000000)
//Bit 31:16        reg_awb_roi_xywin_0_1     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_0_0     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI1_WIN01                    ((0x2a04  << 2) + 0xff000000)
//Bit 31:16        reg_awb_roi_xywin_1_1     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_1_0     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI0_WIN23                    ((0x2a05  << 2) + 0xff000000)
//Bit 31:16        reg_awb_roi_xywin_0_3     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_0_2     // unsigned ,    RW, default = 32  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI1_WIN23                    ((0x2a06  << 2) + 0xff000000)
//Bit 31:16        reg_awb_roi_xywin_1_3     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
//Bit 15: 0        reg_awb_roi_xywin_1_2     // unsigned ,    RW, default = 62  each roi xywin[h_start, h_size, v_start, v_size]
#define ISP_AWB_STAT_ROI_EN_0                      ((0x2a07  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_awb_roi_enable_0      // unsigned ,    RW, default = 1  enable of awb_roi_sta
//Bit  0           reg_awb_roi_mode_0        // unsigned ,    RW, default = 0  AWB statisic roi sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default=0
#define ISP_RO_AWB_ROI_STAT_PCK0_0                 ((0x2a08  << 2) + 0xff000000)
//Bit 31: 0        ro_awbroi_stat_pack0_0    // unsigned ,    RO, default = 0  LSB of the AWB roi statistic normalized, [31:16] AVG_GdivB or Red_avg,        [15:0] AVG_GdivRed or Gr_avg
#define ISP_RO_AWB_ROI_STAT_PCK1_0                 ((0x2a09  << 2) + 0xff000000)
//Bit 31: 0        ro_awbroi_stat_pack1_0    // unsigned ,    RO, default = 0  MSB of the AWB roi statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_STAT_ROI_EN_1                      ((0x2a0a  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_awb_roi_enable_1      // unsigned ,    RW, default = 1  enable of awb_roi_sta
//Bit  0           reg_awb_roi_mode_1        // unsigned ,    RW, default = 0  AWB statisic roi sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default=0
#define ISP_RO_AWB_ROI_STAT_PCK0_1                 ((0x2a0b  << 2) + 0xff000000)
//Bit 31: 0        ro_awbroi_stat_pack0_1    // unsigned ,    RO, default = 0  LSB of the AWB roi statistic normalized, [31:16] AVG_GdivB or Red_avg,        [15:0] AVG_GdivRed or Gr_avg
#define ISP_RO_AWB_ROI_STAT_PCK1_1                 ((0x2a0c  << 2) + 0xff000000)
//Bit 31: 0        ro_awbroi_stat_pack1_1    // unsigned ,    RO, default = 0  MSB of the AWB roi statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_CTRL                               ((0x2a0d  << 2) + 0xff000000)
//Bit 31: 5        reserved
//Bit  4           reg_awb_stat_ratio_mode   // unsigned ,    RW, default = 1  0: ratio g/r and g/b, 1: ratio r/g and b/g, statistic ratio mode
//Bit  3: 2        reg_awb_xphs_ofst         // unsigned ,    RW, default = 1  phase shift for raw data for AE statistics, same as modules for corresponding block
//Bit  1: 0        reg_awb_yphs_ofst         // unsigned ,    RW, default = 0  phase shift for raw data for AE statistics, same as modules for corresponding block
#define ISP_AWB_HV_START                           ((0x2a0e  << 2) + 0xff000000)
//Bit 31:16        reg_awb_stat_hstart       // unsigned ,    RW, default = 0  horizontal start for awb statistics
//Bit 15: 0        reg_awb_stat_vstart       // unsigned ,    RW, default = 0  vertical start for awb statistics
#define ISP_AWB_HV_SIZE                            ((0x2a0f  << 2) + 0xff000000)
//Bit 31:16        reg_awb_stat_hsize        // unsigned ,    RW, default = 1920  horizontal size for awb statistics
//Bit 15: 0        reg_awb_stat_vsize        // unsigned ,    RW, default = 1080  vertical size for awb statistics
#define ISP_AWB_HV_BLKNUM                          ((0x2a10  << 2) + 0xff000000)
//Bit 31:22        reserved
//Bit 21:16        reg_awb_stat_hblk_num     // unsigned ,    RW, default = 32  support max 33 horizontal blks for awb statistics
//Bit 15: 6        reserved
//Bit  5: 0        reg_awb_stat_vblk_num     // unsigned ,    RW, default = 24  support max 33 vertical blks for awb statistics
#define ISP_AWB_STAT_THD                           ((0x2a11  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_max_thd      // unsigned ,    RW, default = 4095  max threshold for pixel intensity of awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_min_thd      // unsigned ,    RW, default = 0  min threshold for pixel intensity of awb
#define ISP_AWB_STAT_RG                            ((0x2a12  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_rg_max       // unsigned ,    RW, default = 2048  u4.8, max value of r/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_rg_min       // unsigned ,    RW, default = 64  u4.8, min value of r/g in white region for awb
#define ISP_AWB_STAT_BG                            ((0x2a13  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_bg_max       // unsigned ,    RW, default = 2048  u4.8, max value of b/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_bg_min       // unsigned ,    RW, default = 64  u4.8, min value of b/g in white region for awb
#define ISP_AWB_STAT_RG_HL                         ((0x2a14  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_rg_high      // unsigned ,    RW, default = 4095  u4.8, high value of r/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_rg_low       // unsigned ,    RW, default = 0  u4.8, low value of r/g in white region for awb
#define ISP_AWB_STAT_BG_HL                         ((0x2a15  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_bg_high      // unsigned ,    RW, default = 4095  u4.8, high value of b/g in white region for awb
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_bg_low       // unsigned ,    RW, default = 0  u4.8, low value of b/g in white region for awb
#define ISP_AWB_STAT_CTRL2                         ((0x2a16  << 2) + 0xff000000)
//Bit 31:13        reserved
//Bit 12:11        reg_awb_luma_mode         // unsigned ,    RW, default = 2  blender mode between grn', red and blu to get luma for AWB STA: 0: cur; 1: MAX(grn',Red, BLU); 2/3: filter
//Bit 10: 9        reserved
//Bit  8           reg_awb_stat_input_format // unsigned ,    RW, default = 0  input frame buffer format: 0: raw; 1: RGB;  default = 0;
//Bit  7            reserved
//Bit  6           reg_awb_grn_use_avg       // unsigned ,    RW, default = 0  enable of Gb=Gr=(Gb+Gr+1)/2, 0: no average, 1: average
//Bit  5           reg_awb_glbal_useweight   // unsigned ,    RW, default = 1  global use regional weight, default=1
//Bit  4: 3        reg_awb_stat_luma_div_mode // unsigned ,    RW, default = 0  AWB separate STATS on Luma (x+1) ranges, Total STATS RAM same size, needs to reduce hblk_num/vblk_num if x>0. 0: no division; 1: div to 2 range; ...3: div to 4 ranges
//Bit  2           reg_awb_stat_local_mode   // unsigned ,    RW, default = 0  AWB statisic local sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default,0
//Bit  1           reg_awb_stat_glbal_mode   // unsigned ,    RW, default = 0  AWB statisic global sta mode: 0: ratio_bg/rg in pack0 and cnt in pack1; 1: (AVG_G<<16)+ AVG_R in pack0 and  (Nrm_cnt<<16)+ avg_B in pack1; default,0
//Bit  0           reg_awb_stat_satur_vald   // unsigned ,    RW, default = 0  AWB statistic over saturation control
#define ISP_AWB_STAT_BLC20_0                       ((0x2a17  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_0      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_1                       ((0x2a18  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_1      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_2                       ((0x2a19  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_2      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_BLC20_3                       ((0x2a1a  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        reg_awb_stat_blc20_3      // unsigned ,    RW, default = 0  blc  in AWB statistic to Gr/Red/Blue/GB in u20 scale
#define ISP_AWB_STAT_GAIN10_0                      ((0x2a1b  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_0     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_1                      ((0x2a1c  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_1     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_2                      ((0x2a1d  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_2     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_GAIN10_3                      ((0x2a1e  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        reg_awb_stat_gain10_3     // unsigned ,    RW, default = 256  gain in AWB statistic to Gr/Red/Blue/GB in u16 scale, norm to 256 as 1.0
#define ISP_AWB_STAT_LDIV_01                       ((0x2a1f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_awb_stat_luma_divth_1 // unsigned ,    RW, default = 2000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
//Bit 15:12        reserved
//Bit 11: 0        reg_awb_stat_luma_divth_0 // unsigned ,    RW, default = 1000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
#define ISP_AWB_STAT_LDIV_2                        ((0x2a20  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_awb_stat_luma_divth_2 // unsigned ,    RW, default = 3000  threshold to divide the AWB stats in to ranges base on Luma, in u12 precision
#define ISP_AWB_STAT_SATUR_CTRL                    ((0x2a21  << 2) + 0xff000000)
//Bit 31:16        reg_awb_stat_satur_high   // unsigned ,    RW, default = 65535  AWB statistic over-saturation threshold
//Bit 15: 0        reg_awb_stat_satur_low    // unsigned ,    RW, default = 0  AWB statistic under-saturation threshold
#define ISP_RO_AWB_GLB_STAT_PCK0_0                 ((0x2a22  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack0_0   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_0                 ((0x2a23  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack1_0   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_1                 ((0x2a24  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack0_1   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_1                 ((0x2a25  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack1_1   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_2                 ((0x2a26  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack0_2   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_2                 ((0x2a27  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack1_2   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_RO_AWB_GLB_STAT_PCK0_3                 ((0x2a28  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack0_3   // unsigned ,    RO, default = 0  LSB of the AWB global block statistic normalized, [31:16] AVG_GdivB or grn_avg,        [15:0] AVG_GdivRed or Red_avg
#define ISP_RO_AWB_GLB_STAT_PCK1_3                 ((0x2a29  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_glb_stat_pack1_3   // unsigned ,    RO, default = 0  MSB of the AWB global block statistic normalized, [31:16] WcountMSB16 or count_nrm16;  [15:0] Wcount_LSB16 or blu_avg
#define ISP_AWB_DEBUG_IN_CHECKSUM                  ((0x2a2a  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_debug_in_checksum  // unsigned ,    RO, default = 0
#define ISP_AWB_DEBUG_PACK0_CHECKSUM               ((0x2a2b  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_debug_pack0_checksum // unsigned ,    RO, default = 0
#define ISP_AWB_DEBUG_PACK1_CHECKSUM               ((0x2a2c  << 2) + 0xff000000)
//Bit 31: 0        ro_awb_debug_pack1_checksum // unsigned ,    RO, default = 0
#define ISP_AWB_IDX_ADDR                           ((0x2a80  << 2) + 0xff000000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_awb_idx_addr      //unsigned  ,    RW, default = 0  addr for awb_idx
#define ISP_AWB_IDX_DATA                           ((0x2a81  << 2) + 0xff000000)
//Bit 31:16        reg_isp_awb_hidx_data     //unsigned  ,    RW, default = 0  data for awb_hidx
//Bit 15:0         reg_isp_awb_vidx_data     //unsigned  ,    RW, default = 0  data for awb_vidx
#define ISP_AWB_BLK_WT_ADDR                        ((0x2a82  << 2) + 0xff000000)
//Bit 31:7         reserved
//Bit 6:0          reg_isp_awb_blk_wt_addr   //unsigned  ,    RW, default = 0  addr for awb_weight
#define ISP_AWB_BLK_WT_DATA                        ((0x2a83  << 2) + 0xff000000)
//Bit 31:0         reg_isp_awb_blk_wt_data   //unsigned  ,    RW, default = 0  data for awb_weight
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_awb_reg.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB0_APB_BASE = 0x30
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_top_reg.h
//
#define ISP_INTF_TOP_CTRL                          ((0x3000  << 2) + 0xff000000)
//Bit 31:28  reserved
//Bit 27:16  reg_intf_force_en             // unsigned ,    RW, default = 0,{wr{meta,mv,mix,pix},rd{meta,mv,mix,pix}
//Bit 15:4   reg_intf_force_val            // unsigned ,    RW, default = 0,{wr{meta,mv,mix,pix},rd{meta,mv,mix,pix}
//Bit 3:1    reserved
//Bit 0      reg_intf_sw_rst               // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_EN                        ((0x3001  << 2) + 0xff000000)
//Bit 31:0  reg_intf_irq_en                // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_CLR                       ((0x3002  << 2) + 0xff000000)
//Bit 31:0  pls_intf_irq_clr               // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_GCLK_CLR                      ((0x3003  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  reg_gclk_ctrl                  // unsigned ,    RW, default = 0
#define ISP_INTF_TOP_IRQ_STATS                     ((0x3004  << 2) + 0xff000000)
//Bit 31:0  ro_intf_irq_status             // unsigned ,    RO, default = 0
#define ISP_INTF_IDMAP_WRARB0_L                    ((0x3005  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_wrarb0_l        // unsigned ,    RW, default = 32'h11110000
#define ISP_INTF_IDMAP_WRARB0_H                    ((0x3006  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_wrarb0_h        // unsigned ,    RW, default = 32'h33332222
#define ISP_INTF_IDMAP_WRARB1_L                    ((0x3007  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_wrarb1_l        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_WRARB1_H                    ((0x3008  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_wrarb1_h        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_RDRB0_L                     ((0x3009  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_rdarb0_l        // unsigned ,    RW, default = 32'h76543210
#define ISP_INTF_IDMAP_RDARB0_H                    ((0x300a  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_rdarb0_h        // unsigned ,    RW, default = 32'h77777777
#define ISP_INTF_IDMAP_RDRB1_L                     ((0x300b  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_rdarb1_l        // unsigned ,    RW, default = 32'h32103210
#define ISP_INTF_IDMAP_RDARB1_H                    ((0x300c  << 2) + 0xff000000)
//Bit 31:0  reg_intf_idmap_rdarb1_h        // unsigned ,    RW, default = 32'h32103210
#define ISP_INTF_LOSSE_CTRL                        ((0x3010  << 2) + 0xff000000)
//Bit 31:25  reserved
//Bit 24:16  reg_losse1_slice_num          // unsigned ,    RW, default = 1
//Bit 15:9   reserved
//Bit 8 :0   reg_losse0_slice_num          // unsigned ,    RW, default = 1
#define ISP_INTF_LOSSE0_SIZE                       ((0x3011  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  reg_losse0_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_losse0_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSE1_SIZE                       ((0x3012  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  reg_losse1_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_losse1_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSD_CTRL                        ((0x3013  << 2) + 0xff000000)
//Bit 31:26  reserved
//Bit 25     reg_lossd1_mif_mode            // unsigned ,    RW, default = 1
//Bit 24:16  reg_lossd1_slice_num           // unsigned ,    RW, default = 1
//Bit 15:10  reserved
//Bit 9      reg_lossd0_mif_mode            // unsigned ,    RW, default = 1
//Bit 8 :0   reg_lossd0_slice_num           // unsigned ,    RW, default = 1
#define ISP_INTF_LOSSD0_SIZE                       ((0x3014  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  reg_lossd0_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_lossd0_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSSD1_SIZE                       ((0x3015  << 2) + 0xff000000)
//Bit 31:29  reserved
//Bit 28:16  reg_lossd1_hsize               // unsigned ,    RW, default = 1280
//Bit 15:13  reserved
//Bit 12:0   reg_lossd1_vsize               // unsigned ,    RW, default = 720
#define ISP_INTF_LOSS_LOOP0_CTRL                   ((0x3016  << 2) + 0xff000000)
//Bit 31:8  reserved
//Bit  7:4  reg_loop0_num                   // unsigned ,    RW, default = 2
//Bit  3:2  reserved
//Bit    1  reg_loop0_loss_en               // unsigned ,    RW, default = 0
//Bit    0  reg_loop0_en                    // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP1_CTRL                   ((0x3017  << 2) + 0xff000000)
//Bit 31:8  reserved
//Bit  7:4  reg_loop1_num                   // unsigned ,    RW, default = 2
//Bit  3:2  reserved
//Bit    1  reg_loop1_loss_en               // unsigned ,    RW, default = 0
//Bit    0  reg_loop1_en                    // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP0_BADDR00                ((0x3020  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_link_adr0           // unsigned ,    RW, default = 32'h5000000
#define ISP_INTF_LOSS_LOOP0_BADDR01                ((0x3021  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_link_adr1           // unsigned ,    RW, default = 32'h5100000
#define ISP_INTF_LOSS_LOOP0_BADDR02                ((0x3022  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_link_adr2           // unsigned ,    RW, default = 32'h5200000
#define ISP_INTF_LOSS_LOOP0_BADDR03                ((0x3023  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_link_adr3           // unsigned ,    RW, default = 32'h5300000
#define ISP_INTF_LOSS_LOOP0_BADDR10                ((0x3024  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_slice_adr0           // unsigned ,    RW, default = 32'h6000000
#define ISP_INTF_LOSS_LOOP0_BADDR11                ((0x3025  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_slice_adr1           // unsigned ,    RW, default = 32'h7000000
#define ISP_INTF_LOSS_LOOP0_BADDR12                ((0x3026  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_slice_adr2           // unsigned ,    RW, default = 32'h8000000
#define ISP_INTF_LOSS_LOOP0_BADDR13                ((0x3027  << 2) + 0xff000000)
//Bit  31:0 reg_loop0_slice_adr3           // unsigned ,    RW, default = 32'h9000000
#define ISP_INTF_LOSS_LOOP1_BADDR00                ((0x3030  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_link_adr0           // unsigned ,    RW, default = 32'h5400000
#define ISP_INTF_LOSS_LOOP1_BADDR01                ((0x3031  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_link_adr1           // unsigned ,    RW, default = 32'h5500000
#define ISP_INTF_LOSS_LOOP1_BADDR02                ((0x3032  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_link_adr2           // unsigned ,    RW, default = 32'h5600000
#define ISP_INTF_LOSS_LOOP1_BADDR03                ((0x3033  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_link_adr3           // unsigned ,    RW, default = 32'h5700000
#define ISP_INTF_LOSS_LOOP1_BADDR10                ((0x3034  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_slice_adr0           // unsigned ,    RW, default = 32'h16000000
#define ISP_INTF_LOSS_LOOP1_BADDR11                ((0x3035  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_slice_adr1           // unsigned ,    RW, default = 32'h17000000
#define ISP_INTF_LOSS_LOOP1_BADDR12                ((0x3036  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_slice_adr2           // unsigned ,    RW, default = 32'h18000000
#define ISP_INTF_LOSS_LOOP1_BADDR13                ((0x3037  << 2) + 0xff000000)
//Bit  31:0 reg_loop1_slice_adr3           // unsigned ,    RW, default = 32'h19000000
#define ISP_INTF_LOSS_LOOP0_SW                     ((0x3038  << 2) + 0xff000000)
//Bit  31:28 reserved
//Bit  27:24 reg_loop0_lossen_sw_sel         // unsigned ,    RW, default = 4
//Bit  23:22 reserved
//Bit  21:20 reg_loop0_lossen_sw_val         // unsigned ,    RW, default = 0
//Bit  19:18 reserved
//Bit  17:16 reg_loop0_lossen_sw_en          // unsigned ,    RW, default = 0
//Bit  15:8  reg_loop0_idx_sw_val            // unsigned ,    RW, default = 0
//Bit  7:4   reg_loop0_idx_sw_sel            // unsigned ,    RW, default = 4
//Bit  3:2   reserved
//Bit  1:0   reg_loop0_idx_sw_en             // unsigned ,    RW, default = 0
#define ISP_INTF_LOSS_LOOP1_SW                     ((0x3039  << 2) + 0xff000000)
//Bit  31:28 reserved
//Bit  27:24 reg_loop1_lossen_sw_sel         // unsigned ,    RW, default = 4
//Bit  23:22 reserved
//Bit  21:20 reg_loop1_lossen_sw_val         // unsigned ,    RW, default = 0
//Bit  19:18 reserved
//Bit  17:16 reg_loop1_lossen_sw_en          // unsigned ,    RW, default = 0
//Bit  15:8  reg_loop1_idx_sw_val            // unsigned ,    RW, default = 0
//Bit  7:4   reg_loop1_idx_sw_sel            // unsigned ,    RW, default = 4
//Bit  3:2   reserved
//Bit  1:0   reg_loop1_idx_sw_en             // unsigned ,    RW, default = 0
#define ISP_INTF_CHECKSUM_CTRL                     ((0x3040  << 2) + 0xff000000)
//Bit  31:8  reserved
//Bit  7:4   reg_checksum_sel                // unsigned ,    RW, default = 0
//Bit  3:1   reserved
//Bit  0     reg_checksum_en                 // unsigned ,    RW, default = 0
#define ISP_INTF_CHECKSUM_RO0                      ((0x3041  << 2) + 0xff000000)
//Bit  31:0  ro_checksum_in                  // unsigned ,    RO, default = 0
#define ISP_INTF_CHECKSUM_RO1                      ((0x3042  << 2) + 0xff000000)
//Bit  31:0  ro_checksum_out                 // unsigned ,    RO, default = 0
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_top_reg.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF0_CTRL1                            ((0x3080  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF0_CTRL2                            ((0x3081  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF0_CTRL3                            ((0x3082  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF0_CTRL4                            ((0x3083  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF0_SCOPE_X                          ((0x3084  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF0_SCOPE_Y                          ((0x3085  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF0_RO_STAT                          ((0x3086  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF0_CTRL5                            ((0x3087  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_rdmifx3_reg_0.h
//
//==========================================================================
// NOR_RD_MIF
//==========================================================================
#define ISP_RDMIF1_GEN_REG                         ((0x30c0  << 2) + 0xff000000)
//Bit 31        reg_enable_free_clk                //unsigned, RW, default = 0
//Bit 30        reserved                            //unsigned, pulse reg_sw_reset
//Bit 29        reg_reset_on_go_field              //unsigned, RW, default = 0
//Bit 28        reg_urgent_chroma                  //unsigned, RW, default = 0
//Bit 27        reg_urgent_luma                    //unsigned, RW, default = 0
//Bit 26        reg_chroma_end_at_last_line        //unsigned, RW, default = 0
//Bit 25        reg_luma_end_at_last_line          //unsigned, RW, default = 0
//Bit 24:19     reg_hold_lines[5:0]                //unsigned, RW, default = 6'h4
//Bit 18        reg_last_line_mode                 //unsigned, RW, default = 1'b1
//Bit 17        ro_busy                            //unsigned, RO, default = 0 //used as busy readback, ro ?
//Bit 16        reg_demux_mode                     //unsigned, RW, default = 0
//Bit 15:14     reg_bytes_per_pixel                //unsigned, RW, default = 0
//Bit 13:12     reg_ddr_burst_size_cr              //unsigned, RW, default = 0
//Bit 11:10     reg_ddr_burst_size_cb              //unsigned, RW, default = 0
//Bit 9:8       reg_ddr_burst_size_y               //unsigned, RW, default = 0
//Bit 7         reserved                           //unsigned, pulse reg_start_frame_man
//Bit 6         reg_chro_rpt_lastl                 //unsigned, RW, default = 0
//Bit 5         reserved                           //unsigned,
//Bit 4         reg_little_endian                  //unsigned, RW, default = 0
//Bit 3         reg_chroma_hz_avg                  //unsigned, RW, default = 0
//Bit 2         reg_luma_hz_avg                    //unsigned, RW, default = 0
//Bit 1         reg_st_separate_en                 //unsigned, RW, default = 0
//Bit 0         reg_enable                         //unsigned, RW, default = 0
#define ISP_RDMIF1_CANVAS0                         ((0x30c1  << 2) + 0xff000000)
//Bit 31        reg_canvas0_addr_syncen            //unsigned, RW, default = 0
//Bit 30:24     reserved
//Bit 23:16     reg_canvas0_addr2                  //unsigned, RW, default = 0
//Bit 15:8      reg_canvas0_addr1                  //unsigned, RW, default = 0
//Bit 7:0       reg_canvas0_addr0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA_X0                         ((0x30c3  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     reg_luma_x_end0                    //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      reg_luma_x_start0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA_Y0                         ((0x30c4  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     reg_luma_y_end0                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_luma_y_start0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA_X0                       ((0x30c5  << 2) + 0xff000000)
//Bit 31        reserved
//Bit 30:16     reg_chroma_x_end0                  //unsigned, RW, default = 0
//Bit 15        reserved
//Bit 14:0      reg_chroma_x_start0                //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA_Y0                       ((0x30c6  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     reg_chroma_y_end0                  //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_chroma_y_start0                //unsigned, RW, default = 0
#define ISP_RDMIF1_RPT_LOOP                        ((0x30cb  << 2) + 0xff000000)
//Bit 31:16     reserved
//Bit 15:8      reg_chroma_rpt_loop0               //unsigned, RW, default = 0
//Bit 7:0       reg_luma_rpt_loop0                 //unsigned, RW, default = 0
#define ISP_RDMIF1_LUMA0_RPT_PAT                   ((0x30cc  << 2) + 0xff000000)
//Bit 31:0      reg_luma_rpt_pat0                  //unsigned, RW, default = 0
#define ISP_RDMIF1_CHROMA0_RPT_PAT                 ((0x30cd  << 2) + 0xff000000)
//Bit 31:0      reg_chroma_rpt_pat0                //unsigned, RW, default = 0
#define ISP_RDMIF1_DUMMY_PIXEL                     ((0x30d2  << 2) + 0xff000000)
//Bit 31:0      reg_dummy_pixel_val                //unsigned, RW, default = 32'h00808000
#define ISP_RDMIF1_LUMA_FIFO_SIZE                  ((0x30d3  << 2) + 0xff000000)
//Bit 31:13     reserved
//Bit 12:0      reg_luma_fifo_size                 //unsigned, RW, default = 13'h80
#define ISP_RDMIF1_AXI_CMD_CNT                     ((0x30d4  << 2) + 0xff000000)
//Bit 31:0      ro_axi_cmd_cnt_sel                  //unsigned, RO, default = 0
#define ISP_RDMIF1_AXI_RDAT_CNT                    ((0x30d5  << 2) + 0xff000000)
//Bit 31:0      ro_axi_rdat_cnt_sel                 //unsigned, RO, default = 0
#define ISP_RDMIF1_RANGE_MAP_Y                     ((0x30d6  << 2) + 0xff000000)
//Bit 31:23     reg_din_offset_y                   //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_y               //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_y                 //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_y                  //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_y                 //unsigned, RW, default = 0
#define ISP_RDMIF1_RANGE_MAP_CB                    ((0x30d7  << 2) + 0xff000000)
//Bit 31:23     reg_din_offset_cb                  //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_cb              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_cb                //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_cb                 //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_cb                //unsigned, RW, default = 0
#define ISP_RDMIF1_RANGE_MAP_CR                    ((0x30d8  << 2) + 0xff000000)
//Bit 31:23     reg_din_offset_cr                  //unsigned, RW, default = 0
//Bit 22:15     reg_range_map_coef_cr              //unsigned, RW, default = 0
//Bit 14        reserved
//Bit 13:10     reg_range_map_sr_cr                //unsigned, RW, default = 0
//Bit 9:1       reg_dout_offset_cr                 //unsigned, RW, default = 0
//Bit 0         reg_range_map_en_cr                //unsigned, RW, default = 0
#define ISP_RDMIF1_GEN_REG2                        ((0x30d9  << 2) + 0xff000000)
//Bit 31:30     reserved
//Bit 29        reg_chroma_line_read_sel           //unsigned, RW, default = 0
//Bit 28        reg_luma_line_read_sel             //unsigned, RW, default = 0
//Bit 27:26     reserved
//Bit 25:24     reg_shift_pat_cr                   //unsigned, RW, default = 0
//Bit 23:18     reserved
//Bit 17:16     reg_shift_pat_cb                   //unsigned, RW, default = 0
//Bit 15:10     reserved
//Bit 9:8       reg_shift_pat_y                    //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6         reg_hold_lines[6]                  //unsigned, RW, default = 0
//Bit 5         reserved
//Bit 4         reserved
//Bit 3         reg_y_rev0                         //unsigned, RW, default = 0
//Bit 2         reg_x_rev0                         //unsigned, RW, default = 0
//Bit 1:0       reg_color_map                      //unsigned, RW, default = 0
#define ISP_RDMIF1_URGENT_CTRL                     ((0x30db  << 2) + 0xff000000)
//Bit 31:16     reg_urgent_ctrl_luma               //unsigned, RW, default = 0
//Bit 15:0      reg_urgent_ctrl_chroma             //unsigned, RW, default = 0
#define ISP_RDMIF1_GEN_REG3                        ((0x30dc  << 2) + 0xff000000)
//Bit 31:27     reserved
//Bit 26        reg_f0_stride32aligned2            //unsigned, RW, default = 0
//Bit 25        reg_f0_stride32aligned1            //unsigned, RW, default = 0
//Bit 24        reg_f0_stride32aligned0            //unsigned, RW, default = 0
//Bit 23:22     reg_f0_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 21:20     reg_f0_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 19:18     reg_f0_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 17:16     reg_abort_mode                     //unsigned, RW, default = 0
//Bit 15:14     reg_burst_len2                     //unsigned, RW, default = 2'd2
//Bit 13:12     reg_burst_len1                     //unsigned, RW, default = 2'd2
//Bit 11:10     reg_dbg_mode                       //unsigned, RW, default = 0
//Bit 9:8       reg_bits_mode                      //unsigned, RW, default = 0
//Bit 7         reserved
//Bit 6:4       reg_blk_len                        //unsigned, RW, default = 3'd3
//Bit 3         reserved
//Bit 2:1       reg_burst_len0                     //unsigned, RW, default = 2'd2
//Bit 0         reg_64bit_rev                      //unsigned, RW, default = 1'b1
#define ISP_RDMIF1_CFMT_CTRL                       ((0x30dd  << 2) + 0xff000000)
//Bit 31        reg_cfmt_gclk_bit_dis              //unsigned, RW, default = 0;
//Bit 30        reg_cfmt_soft_rst_bit              //unsigned, RW, default = 0;
//Bit 29        reserved
//Bit 28        reg_chfmt_rpt_pix                  //unsigned, RW, default = 0;
//Bit 27:24     reg_chfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 23        reg_chfmt_rpt_p0_en                //unsigned, RW, default = 0;
//Bit 22:21     reg_chfmt_yc_ratio                 //unsigned, RW, default = 0;
//Bit 20        reg_chfmt_en                       //unsigned, RW, default = 0;
//Bit 19        reg_cvfmt_phase0_always_en         //unsigned, RW, default = 0;
//Bit 18        reg_cvfmt_rpt_last_dis             //unsigned, RW, default = 0;
//Bit 17        reg_cvfmt_phase0_nrpt_en           //unsigned, RW, default = 0;
//Bit 16        reg_cvfmt_rpt_line0_en             //unsigned, RW, default = 0;
//Bit 15:12     reg_cvfmt_skip_line_num            //unsigned, RW, default = 0;
//Bit 11:8      reg_cvfmt_ini_phase                //unsigned, RW, default = 0;
//Bit 7:1       reg_cvfmt_phase_step               //unsigned, RW, default = 0;
//Bit 0         reg_cvfmt_en                       //unsigned, RW, default = 0;
#define ISP_RDMIF1_CFMT_W                          ((0x30de  << 2) + 0xff000000)
//Bit 31        reg_dbg_mode_ctrl1                 //unsigned, RW, default = 0;
//Bit 30        reg_dbg_mode_ctrl0                 //unsigned, RW, default = 0;
//Bit 29        reserved
//Bit 28:16     reg_chfmt_w                        //unsigned, RW, default = 0;
//Bit 15:13     reserved
//Bit 12:0      reg_cvfmt_w                        //unsigned, RW, default = 0;
#define ISP_RDMIF1_BADDR_Y                         ((0x30e0  << 2) + 0xff000000)
//Bit 31:0      reg_f0_baddr_y                        //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CB                        ((0x30e1  << 2) + 0xff000000)
//Bit 31:0      reg_f0_baddr_cb                       //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CR                        ((0x30e2  << 2) + 0xff000000)
//Bit 31:0      reg_f0_baddr_cr                       //unsigned, RW, default = 0
#define ISP_RDMIF1_STRIDE_0                        ((0x30e3  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     reg_f0_stride_cb                      //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      reg_f0_stride_y                       //unsigned, RW, default = 256
#define ISP_RDMIF1_STRIDE_1                        ((0x30e4  << 2) + 0xff000000)
//Bit 31:17     reserved
//Bit 16        reg_f0_acc_mode                       //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_f0_stride_cr                      //unsigned, RW, default = 256
#define ISP_RDMIF1_BADDR_Y_F1                      ((0x30e5  << 2) + 0xff000000)
//Bit 31:0      reg_f1_baddr_y                     //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CB_F1                     ((0x30e6  << 2) + 0xff000000)
//Bit 31:0      reg_f1_baddr_cb                    //unsigned, RW, default = 0
#define ISP_RDMIF1_BADDR_CR_F1                     ((0x30e7  << 2) + 0xff000000)
//Bit 31:0      reg_f1_baddr_cr                    //unsigned, RW, default = 0
#define ISP_RDMIF1_STRIDE_0_F1                     ((0x30e8  << 2) + 0xff000000)
//Bit 31:29     reserved
//Bit 28:16     reg_f1_stride_cb                   //unsigned, RW, default = 256
//Bit 15:13     reserved
//Bit 12:0      reg_f1_stride_y                    //unsigned, RW, default = 256;
#define ISP_RDMIF1_STRIDE_1_F1                     ((0x30e9  << 2) + 0xff000000)
//Bit 31:26     reserved
//Bit 25        reg_f1_stride32aligned2            //unsigned, RW, default = 0
//Bit 24        reg_f1_stride32aligned1            //unsigned, RW, default = 0
//Bit 23        reg_f1_stride32aligned0            //unsigned, RW, default = 0
//Bit 22:21     reg_f1_cav_blk_mode2               //unsigned, RW, default = 0
//Bit 20:19     reg_f1_cav_blk_mode1               //unsigned, RW, default = 0
//Bit 18:17     reg_f1_cav_blk_mode0               //unsigned, RW, default = 0
//Bit 16        reg_f1_acc_mode                    //unsigned, RW, default = 0
//Bit 15:13     reserved
//Bit 12:0      reg_f1_stride_cr                   //unsigned, RW, default = 256
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_rdmifx3_reg_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB1_APB_BASE = 0x31
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_0_CH0_CTRL0                    ((0x3100  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH0_CTRL1                    ((0x3101  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_CH1_CTRL0                    ((0x3102  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH1_CTRL1                    ((0x3103  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_CH2_CTRL0                    ((0x3104  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_0_CH2_CTRL1                    ((0x3105  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_0_BIT_FORCE                    ((0x3106  << 2) + 0xff000000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_0_WIN_LUMA_H                   ((0x3108  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_0_WIN_LUMA_V                   ((0x3109  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_0_WIN_CHROM_H                  ((0x310a  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_0_WIN_CHROM_V                  ((0x310b  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_0_CH0_BADDR                    ((0x3110  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH1_BADDR                    ((0x3111  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH2_BADDR                    ((0x3112  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CH0_BADDR_OFST               ((0x3113  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_CH1_BADDR_OFST               ((0x3114  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_CH2_BADDR_OFST               ((0x3115  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_0_BADDR_OFSTEN                 ((0x3116  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_0_TIMCTRL                      ((0x3117  << 2) + 0xff000000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_0_FMT_SIZE                     ((0x3119  << 2) + 0xff000000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_0_FMT_CTRL                     ((0x311a  << 2) + 0xff000000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7:6   reserved
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reserved
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_0_GCLK                         ((0x311d  << 2) + 0xff000000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_RO_STAT                      ((0x311e  << 2) + 0xff000000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_RO_CH01                      ((0x3120  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_RO_CH2                       ((0x3121  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_0_CRP_CTR                      ((0x3122  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CRP_HSIZE                    ((0x3123  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_0_CRP_VSIZE                    ((0x3124  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_1_CH0_CTRL0                    ((0x3140  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH0_CTRL1                    ((0x3141  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_CH1_CTRL0                    ((0x3142  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH1_CTRL1                    ((0x3143  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_CH2_CTRL0                    ((0x3144  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_1_CH2_CTRL1                    ((0x3145  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_1_BIT_FORCE                    ((0x3146  << 2) + 0xff000000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_1_WIN_LUMA_H                   ((0x3148  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_1_WIN_LUMA_V                   ((0x3149  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_1_WIN_CHROM_H                  ((0x314a  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_1_WIN_CHROM_V                  ((0x314b  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_1_CH0_BADDR                    ((0x3150  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH1_BADDR                    ((0x3151  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH2_BADDR                    ((0x3152  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CH0_BADDR_OFST               ((0x3153  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_CH1_BADDR_OFST               ((0x3154  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_CH2_BADDR_OFST               ((0x3155  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_1_BADDR_OFSTEN                 ((0x3156  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_1_TIMCTRL                      ((0x3157  << 2) + 0xff000000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_1_FMT_SIZE                     ((0x3159  << 2) + 0xff000000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_1_FMT_CTRL                     ((0x315a  << 2) + 0xff000000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7:6   reserved
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reserved
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_1_GCLK                         ((0x315d  << 2) + 0xff000000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_RO_STAT                      ((0x315e  << 2) + 0xff000000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_RO_CH01                      ((0x3160  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_RO_CH2                       ((0x3161  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_1_CRP_CTR                      ((0x3162  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CRP_HSIZE                    ((0x3163  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_1_CRP_VSIZE                    ((0x3164  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WRMIFX3_2_CH0_CTRL0                    ((0x3180  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch0_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch0_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch0_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch0_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch0_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch0_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch0_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch0_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH0_CTRL1                    ((0x3181  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch0_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch0_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch0_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch0_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch0_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_CH1_CTRL0                    ((0x3182  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch1_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch1_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch1_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch1_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch1_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch1_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch1_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch1_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH1_CTRL1                    ((0x3183  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch1_pix_bits_mode       // unsigned , RW, default=2, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch1_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch1_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch1_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch1_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_CH2_CTRL0                    ((0x3184  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_ch2_stride              // unsigned , RW, default = 4096,
//Bit 15    reserved
//Bit 14:12 reg_ch2_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_ch2_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_ch2_burst_len           // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 7     reg_ch2_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_ch2_little_endian       // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_ch2_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_ch2_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3:0   reserved
#define ISP_WRMIFX3_2_CH2_CTRL1                    ((0x3185  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30:27 reg_ch2_pix_bits_mode       // unsigned , RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 26:24 reg_ch2_din_pack_mode       // unsigned , RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
//Bit 23:22 reserved
//Bit 21:20 reg_ch2_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_ch2_sw_rst              // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_ch2_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WRMIFX3_2_BIT_FORCE                    ((0x3186  << 2) + 0xff000000)
//Bit 31:24 reg_mtx_obits2_force_val              // unsigned , RW, default = 0
//Bit 23:16 reg_mtx_obits1_force_val              // unsigned , RW, default = 0
//Bit 15:8  reg_mtx_obits0_force_val              // unsigned , RW, default = 0
//Bit 7:3   reserved
//Bit 2     reg_mtx_obits2_force_en               // unsigned , RW, default = 0
//Bit 1     reg_mtx_obits1_force_en               // unsigned , RW, default = 0
//Bit 0     reg_mtx_obits0_force_en               // unsigned , RW, default = 0
#define ISP_WRMIFX3_2_WIN_LUMA_H                   ((0x3188  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_2_WIN_LUMA_V                   ((0x3189  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_luma_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_luma_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_2_WIN_CHROM_H                  ((0x318a  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_hend           // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_hstart         // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WRMIFX3_2_WIN_CHROM_V                  ((0x318b  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_win_chrom_vend           // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_win_chrom_vstart         // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WRMIFX3_2_CH0_BADDR                    ((0x3190  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH1_BADDR                    ((0x3191  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH2_BADDR                    ((0x3192  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr                  // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CH0_BADDR_OFST               ((0x3193  << 2) + 0xff000000)
//Bit 31:0  reg_ch0_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_CH1_BADDR_OFST               ((0x3194  << 2) + 0xff000000)
//Bit 31:0  reg_ch1_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_CH2_BADDR_OFST               ((0x3195  << 2) + 0xff000000)
//Bit 31:0  reg_ch2_baddr_ofst             // unsigned, RW, default=0, for auto baddr ofst
#define ISP_WRMIFX3_2_BADDR_OFSTEN                 ((0x3196  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28    reg_tim_hold_en             //unsigned, RW, default = 0
//Bit 27:22 reg_tim_pass_num            //unsigned, RW, default = 1
//Bit 21:16 reg_tim_hold_num            //unsigned, RW, default = 0
//Bit 15:9  reserved
//Bit 8     reg_baddr_autoacc_en        // unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 7:0   reg_baddr_autoacc_num       // unsigned, RW, default=8, baddr ofst num
#define ISP_WRMIFX3_2_TIMCTRL                      ((0x3197  << 2) + 0xff000000)
//Bit 31:18 reserved
//Bit 17    pls_frm_drop_rst            //unsigned, W1T,default = 0, clean frm drop func
//Bit 16    reg_frm_drop_en             //unsigned, RW, default = 0, reg_drop_en
//Bit 15:8  reg_frm_drop_ini            //unsigned, RW, default = 0, frm_drop ini_drop_num
//Bit 7:4   reg_frm_drop_pass           //unsigned, RW, default = 0, frm_drop pass_num
//Bit 3:0   reg_frm_drop_num            //unsigned, RW, default = 0, frm_drop drop_num
#define ISP_WRMIFX3_2_FMT_SIZE                     ((0x3199  << 2) + 0xff000000)
//Bit 31:16 reg_fmt_vsize               //unsigned, RW, default = 1080,fmt_ds input vsize
//Bit 15:0  reg_fmt_hsize               //unsigned, RW, default = 1920,fmt_ds input hsize
#define ISP_WRMIFX3_2_FMT_CTRL                     ((0x319a  << 2) + 0xff000000)
//Bit 31:19 reserved
//Bit 18:16 reg_fmt_mode_out            //unsigned, RW, default = 2, 444 1:422 2:420 3:Y_only 4:raw_in
//Bit 15    reserved
//Bit 14:12 reg_fmt_hds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 11    reserved
//Bit 10:8  reg_fmt_vds_mode            //unsigned, RW, default = 0, 0:left 1:right 2/3:filter121 4:avg
//Bit 7:6   reserved
//Bit 5:4   reg_mtx_plane               //unsigned, RW, default = 1, 0:planex1 1:planex2 2:planex3
//Bit 3     reserved
//Bit 2     reg_mtx_uv_swap             //unsigned, RW, default = 0, 0:{v,u} 1:{u,v}
//Bit 1:0   reg_mtx_ibits               //unsigned, RW, default = 0, 0:8bit 1:10bit 2:12bit 3:16bit
#define ISP_WRMIFX3_2_GCLK                         ((0x319d  << 2) + 0xff000000)
//Bit 31:14 reserved
//Bit 13:12 reg_gclk_crop               // unsigned , RW, default = 0
//Bit 11:10 reg_gclk_arb                // unsigned , RW, default = 0
//Bit 9 :8  reg_gclk_fmt                // unsigned , RW, default = 0
//Bit 7 :6  reg_gclk_ch2                // unsigned , RW, default = 0
//Bit 5 :4  reg_gclk_ch1                // unsigned , RW, default = 0
//Bit 3 :2  reg_gclk_ch0                // unsigned , RW, default = 0
//Bit 1 :0  reg_gclk_reg                // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_RO_STAT                      ((0x319e  << 2) + 0xff000000)
//Bit 31:0  ro_status                   // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_RO_CH01                      ((0x31a0  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch01              // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_RO_CH2                       ((0x31a1  << 2) + 0xff000000)
//Bit 31:0  ro_status_ch2               // unsigned , RO, default = 0
#define ISP_WRMIFX3_2_CRP_CTR                      ((0x31a2  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel           //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel           //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:1   reserved
//Bit 0      reg_crop_en                 // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CRP_HSIZE                    ((0x31a3  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_h              // unsigned , RW, default = 1920,
//Bit 15:0  reg_crop_bgn_h              // unsigned , RW, default = 0,
#define ISP_WRMIFX3_2_CRP_VSIZE                    ((0x31a4  << 2) + 0xff000000)
//Bit 31:16 reg_crop_end_v              // unsigned , RW, default = 1080,
//Bit 15:0  reg_crop_bgn_v              // unsigned , RW, default = 0,
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_intf_wrmifx3_reg_2.h
//
 //reserved "isp_intf_wrmifx3_reg_3.h"      //0xc0-0xff  [ISP_WRMIFX3,ISP_WRMIFX3_3]
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB2_APB_BASE = 0x32
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/viu_dmawr_reg.h
//
#define VIU_DMAWR_CTRL1                            ((0x3200  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel            // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id           // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len        // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size        // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len           // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit          // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian       // unsigned , RW, default = 0, big endian enable
//Bit 5     reg_y_rev               // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev               // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode           // unsigned , RW, default = 5, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define VIU_DMAWR_CTRL2                            ((0x3201  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst              // unsigned , RW, default = 0,
//Bit 29:22 reserved
//Bit 21:20 reg_int_clr             // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl           // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl         // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define VIU_DMAWR_CTRL3                            ((0x3202  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en             // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num            // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num            // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode            // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride              // unsigned , RW, default = 4096,
#define VIU_DMAWR_SCOPE_X                          ((0x3204  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end               // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start             // unsigned , RW, default = 0, the canvas hor start pixel position
#define VIU_DMAWR_SCOPE_Y                          ((0x3205  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end               // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start             // unsigned , RW, default = 0, the canvas ver start pixel position
#define VIU_DMAWR_BADDR0                           ((0x3210  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_0       // unsigned , RW, default = 28'ha0000,
#define VIU_DMAWR_BADDR1                           ((0x3211  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_1       // unsigned , RW, default = 28'hb0000,
#define VIU_DMAWR_BADDR2                           ((0x3212  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_2       // unsigned , RW, default = 28'hc0000,
#define VIU_DMAWR_BADDR3                           ((0x3213  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_3       // unsigned , RW, default = 28'hd0000,
#define VIU_DMAWR_BADDR4                           ((0x3214  << 2) + 0xff000000)
//Bit 31:28 reserved
//Bit 27:0  reg_wrmif_baddr_4       // unsigned , RW, default = 28'he0000,
#define VIU_DMAWR_SIZE0                            ((0x3215  << 2) + 0xff000000)
//Bit 31:16  reg_chx_size_1         // unsigned , RW, default = 16'h800,
//Bit 15:0   reg_chx_size_0         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_SIZE1                            ((0x3216  << 2) + 0xff000000)
//Bit 31:16  reg_chx_size_3         // unsigned , RW, default = 16'h800,
//Bit 15:0   reg_chx_size_2         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_SIZE2                            ((0x3217  << 2) + 0xff000000)
//Bit 31:16  reserved
//Bit 15:0   reg_chx_size_4         // unsigned , RW, default = 16'h800,
#define VIU_DMAWR_BLKLEN0                          ((0x3218  << 2) + 0xff000000)
//Bit 31:24  reg_blk_len_3          // unsigned , RW, default =  8,
//Bit 23:16  reg_blk_len_2          // unsigned , RW, default = 16,
//Bit 15:8   reg_blk_len_1          // unsigned , RW, default = 16,
//Bit 7:0    reg_blk_len_0          // unsigned , RW, default = 16,
#define VIU_DMAWR_BLKLEN1                          ((0x3219  << 2) + 0xff000000)
//Bit 31:8   reserved
//Bit 7:0    reg_blk_len_4          // unsigned , RW, default = 16,
#define VIU_DMAWR_BUFDEPTH0                        ((0x321a  << 2) + 0xff000000)
//Bit 31:24  reg_chxbuf_depth_3     // unsigned , RW, default = 16,
//Bit 23:16  reg_chxbuf_depth_2     // unsigned , RW, default = 16,
//Bit 15:8   reg_chxbuf_depth_1     // unsigned , RW, default = 64,
//Bit 7:0    reg_chxbuf_depth_0     // unsigned , RW, default = 16,
#define VIU_DMAWR_BUFDEPTH1                        ((0x321b  << 2) + 0xff000000)
//Bit 31:8   reserved
//Bit 7:0    reg_chxbuf_depth_4     // unsigned , RW, default = 48,
#define VIU_DMAWR_RO_STAT                          ((0x321f  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_wrmif_status         // unsigned , RO ,default = 0,
//
// Closing file:  ./isp_inc/inc_sw/viu_dmawr_reg.h
//
//reserved  "viu_wrarb_reg_0.h"             //0x80-0x8f  [ISP_WRARB,ISP_WRARB0]
//reserved  "viu_wrarb_reg_1.h"             //0x90-0x9f  [ISP_WRARB,ISP_WRARB1]
//reserved  "viu_rdarb_reg.h"               //0xc0-0xcf
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB3_APB_BASE = 0x33
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_NR2_CTRL1                         ((0x3300  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_NR2_CTRL2                         ((0x3301  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_NR2_CTRL3                         ((0x3302  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_NR2_CTRL4                         ((0x3303  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_NR2_SCOPE_X                       ((0x3304  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_NR2_SCOPE_Y                       ((0x3305  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_NR2_RO_STAT                       ((0x3306  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_NR2_CTRL5                         ((0x3307  << 2) + 0xff000000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_NR2_CTRL6                         ((0x3308  << 2) + 0xff000000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_NR2_CTRL7                         ((0x3309  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_NR3_CTRL1                         ((0x3320  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_NR3_CTRL2                         ((0x3321  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_NR3_CTRL3                         ((0x3322  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_NR3_CTRL4                         ((0x3323  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_NR3_SCOPE_X                       ((0x3324  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_NR3_SCOPE_Y                       ((0x3325  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_NR3_RO_STAT                       ((0x3326  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_NR3_CTRL5                         ((0x3327  << 2) + 0xff000000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_NR3_CTRL6                         ((0x3328  << 2) + 0xff000000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_NR3_CTRL7                         ((0x3329  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_NR2_CTRL1                         ((0x3340  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_NR2_CTRL2                         ((0x3341  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_NR2_CTRL3                         ((0x3342  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_NR2_CTRL4                         ((0x3343  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_NR2_SCOPE_X                       ((0x3344  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_NR2_SCOPE_Y                       ((0x3345  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_NR2_RO_STAT                       ((0x3346  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_NR2_CTRL5                         ((0x3347  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_NR3_CTRL1                         ((0x3360  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_NR3_CTRL2                         ((0x3361  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_NR3_CTRL3                         ((0x3362  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_NR3_CTRL4                         ((0x3363  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_NR3_SCOPE_X                       ((0x3364  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_NR3_SCOPE_Y                       ((0x3365  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_NR3_RO_STAT                       ((0x3366  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_NR3_CTRL5                         ((0x3367  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_2.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_reg_3.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_RMIF_PNR0_CTRL1                        ((0x3380  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 3, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_RMIF_PNR0_CTRL2                        ((0x3381  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:28 reserved
//Bit 27:26 reg_gclk_ctrl1    // unsigned , RW, default = 0,
//Bit 25:22 reg_vstep         // unsigned , RW, default = 1
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_RMIF_PNR0_CTRL3                        ((0x3382  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_RMIF_PNR0_CTRL4                        ((0x3383  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_RMIF_PNR0_SCOPE_X                      ((0x3384  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_RMIF_PNR0_SCOPE_Y                      ((0x3385  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_RMIF_PNR0_RO_STAT                      ((0x3386  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0 ,
#define ISP_RMIF_PNR0_CTRL5                        ((0x3387  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:21  reserved
//Bit 20     reg_sft_aut_en       //unsigned, RW, default=0,
//Bit 19:18  reg_rpt_pix          //unsigned, RW, default=0, repeat pix
//Bit 17     reg_rpt_line         //unsigned, RW, default=0, repeat line
//Bit 16     reg_rd_msb           //unsigned, RW, default=1, 0:lsb 1:msb
//Bit 15:7   reg_rd_bwidth        //unsigned, RW, default=8, for pixel shift to MSB
//Bit 6:3    reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0    reg_out_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_reg_3.h
//
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_reg_2.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_WMIF_PNR0_CTRL1                        ((0x33c0  << 2) + 0xff000000)
//Bit 31:26 reserved
//Bit 25:24 reg_sync_sel      // unsigned , RW, default = 0, axi canvas id sync with frm rst
//Bit 23:16 reg_canvas_id     // unsigned , RW, default = 0, axi canvas id num
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd, // 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 9:8   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst2 2-bst4
//Bit 7     reg_swap_64bit    // unsigned , RW, default = 0, 64bits of 128bit swap enable
//Bit 6     reg_little_endian // unsigned , RW, default = 1, 1: little_endian 0:big endian enable
//Bit 5     reg_y_rev         // unsigned , RW, default = 0, vertical reverse enable
//Bit 4     reg_x_rev         // unsigned , RW, default = 0, horizontal reverse enable
//Bit 3     reserved
//Bit 2:0   reg_pack_mode     // unsigned , RW, default = 1, 0:4bit 1:8bit 2:16bit 3:32bit 4:64bit 5:128bit
#define ISP_WMIF_PNR0_CTRL2                        ((0x33c1  << 2) + 0xff000000)
//Bit 31:30 reg_sw_rst        // unsigned , RW, default = 0,
//Bit 29:24 reserved
//Bit 23:22 reg_gclk_ctrl1    // unsigned , RW, default = 0
//Bit 21:20 reg_int_clr       // unsigned , RW, default = 0
//Bit 19:18 reg_gclk_ctrl0    // unsigned , RW, default = 0,
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=wrmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_WMIF_PNR0_CTRL3                        ((0x33c2  << 2) + 0xff000000)
//Bit 31    reserved
//Bit 30    reg_hold_en       // unsigned , RW, default = 0
//Bit 29:24 reg_pass_num      // unsigned , RW, default = 1
//Bit 23:18 reg_hold_num      // unsigned , RW, default = 0
//Bit 17    reserved
//Bit 16    reg_acc_mode      // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_stride        // unsigned , RW, default = 4096,
#define ISP_WMIF_PNR0_CTRL4                        ((0x33c3  << 2) + 0xff000000)
//Bit 31:0  reg_baddr        // unsigned , RW, default = 0,
#define ISP_WMIF_PNR0_SCOPE_X                      ((0x33c4  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_x_end         // unsigned , RW, default = 4095, the canvas hor end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_x_start       // unsigned , RW, default = 0, the canvas hor start pixel position
#define ISP_WMIF_PNR0_SCOPE_Y                      ((0x33c5  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_y_end         // unsigned , RW, default = 0, the canvas ver end pixel position
//Bit 15:13 reserved
//Bit 12: 0 reg_y_start       // unsigned , RW, default = 0, the canvas ver start pixel position
#define ISP_WMIF_PNR0_RO_STAT                      ((0x33c6  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status        // unsigned , RO, default = 0
#define ISP_WMIF_PNR0_CTRL5                        ((0x33c7  << 2) + 0xff000000)
//Bit 31:25  reserved
//Bit 24    reg_baddr_ofst_en    //unsigned, RW, default=0, baddr ofst mode 0: intr config, 1: baddr ofst accumulate
//Bit 23:16 reg_baddr_ofst_num   //unsigned, RW, default=8, baddr ofst num
//Bit 15:8  reserved
//Bit 7     reg_wr_msb           //unsigned, RW, default=1, 1:msb, 0:lsb
//Bit 6:3   reg_pix_bits_mode    //unsigned, RW, default=1, 0:4b 1:8b 2:16b 3:32b 4:64b 5:128b 6:12b 7:10b 8:14b
//Bit 2:0   reg_din_pack_mode    //unsigned, RW, default=0, 0:1x 1:2x 2:4x 3:8x 4:16x 5:32x 6:64x
#define ISP_WMIF_PNR0_CTRL6                        ((0x33c8  << 2) + 0xff000000)
//Bit 31:0  reg_baddr_ofst      //unsigned, RW, default=0, for auto baddr ofst
#define ISP_WMIF_PNR0_CTRL7                        ((0x33c9  << 2) + 0xff000000)
//Bit 31:30  reg_lath_vld_sel     //unsigned, RW, default=0, latch use 0:frm_start 1:frm_end 2:1'b1 3: 1'b0
//Bit 29:28  reg_lath_out_sel     //unsigned, RW, default=0, [0]: 0:use latch 1:use reg,  [1]: 0:baddr use baddr_sel 1:baddr use reg
//Bit 27:18  reserved
//Bit 17:10  reg_frm_ctrl_ini    //unsigned, RW, default=8'h10, ini_drop_num
//Bit 9      pls_frm_ctrl_rst    //unsigned, RW, default=0, clean frm drop func
//Bit 8:0    reg_frm_ctrl        //unsigned, RW, default=0, bit8=reg_drop_en, bit7:4=pass_num, bit3:0=drop_num
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_reg_2.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB4_APB_BASE = 0x34
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSEM_PIX_TOP_CTRL                    ((0x3400  << 2) + 0xff000000)
//Bit 31    reg_crc_on          // unsigned, RW, default = 0
//Bit 30:13 reserved
//Bit 12    reg_losse_byp_en    // unsigned, RW, default = 1
//Bit 11:0  reg_gclk_ctrl       // unsigned, RW, default = 0
//
#define ISP_LOSSEM_PIX_CRC_SUM1                    ((0x3401  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_CRC_SUM2                    ((0x3402  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_CRC_SUM3                    ((0x3403  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum3         // unsigned, RO, default = 0
//MMU RDMIF REG
#define ISP_LOSSEM_PIX_MMU_MIF_CTRL0               ((0x3404  << 2) + 0xff000000)
//Bit 31:29 reserved           // unsigned, RW, default=0
//Bit 28:16	reg_stride         // unsigned, RW, default=4096
//Bit 15:14 reserved
//Bit 13:12	reg_auto_ctrl      // unsigned, RW, default=0
//Bit 11:10	reg_gclk_ctrl      // unsigned, RW, default=0
//Bit 9 : 8	reg_cmd_req_size   // unsigned, RW, default=1
//Bit 7     reserved
//Bit 6 : 4	reg_cmd_intr_len   // unsigned, RW, default=1
//Bit 3    	reg_swap_64bit     // unsigned, RW, default=0
//Bit 2    	reg_little_endian  // unsigned, RW, default=1
//Bit 1:0  	reg_burst_len      // unsigned, RW, default=1
#define ISP_LOSSEM_PIX_MMU_MIF_CTRL1               ((0x3405  << 2) + 0xff000000)
//Bit 31:24 reserved
//Bit 23:22 reg_int_clr         // unsigned, RW, default=0
//Bit 21:20 reserved
//Bit 19:18 reg_sw_rst          // unsigned, RW, default=0
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl     //unsigned, RW, default=0
#define ISP_LOSSEM_PIX_MMU_MIF_RO_STAT             ((0x3406  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status           // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_MIF_CTRL                    ((0x3407  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 17:16 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_burst_len     // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 9:8   reg_losse_clr     // unsigned , RW, default = 0,
//Bit 7     reserved
//Bit 6:4   reg_sw_rst        // unsigned , RW, default = 0
//Bit 3     reg_rst_mode      // unsigned , RW, default = 0
//Bit 2     reg_en_mode       // unsigned , RW, default = 0
//Bit 1     reg_enable        // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSEM_PIX_UGT_CTRL                    ((0x3408  << 2) + 0xff000000)
//Bit 31:17 reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSEM_PIX_GCLK_CTRL                   ((0x3409  << 2) + 0xff000000)
//Bit 31:12 reserved
//Bit 11:0  reg_pass_num      // unsigned , RW, default = 1
#define ISP_LOSSEM_PIX_LUT_SIZE                    ((0x340a  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_lut_vsize        // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_lut_hsize        // unsigned , RW, default = 4096,
#define ISP_LOSSEM_PIX_RO_STAT                     ((0x340b  << 2) + 0xff000000)
//Bit 31:0  ro_losse_stat       // unsigned, RO, default = 0
#define ISP_LOSSEM_PIX_RO_MMU_NUM                  ((0x340c  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_frm_mmu_num      // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/cmpr_raw_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSE_PIX_CTRL                         ((0x3480  << 2) + 0xff000000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSE_PIX_FRAME_HOLD                   ((0x3481  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define ISP_LOSSE_PIX_GCLK_CTRL                    ((0x3482  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSE_PIX_RO_CODEC_STATUS              ((0x3483  << 2) + 0xff000000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define ISP_LOSSE_PIX_MISC                         ((0x3484  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSE_PIX_BASIS                        ((0x3488  << 2) + 0xff000000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define ISP_LOSSE_PIX_OFST_BIT_DEPTH               ((0x3489  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define ISP_LOSSE_PIX_PIC_SIZE                     ((0x348a  << 2) + 0xff000000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSE_PIX_SLICE_SIZE                   ((0x348b  << 2) + 0xff000000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_1                 ((0x348c  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_2                 ((0x348d  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_SLICE_SIZE_3                 ((0x348e  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_PIX_PRESL_LAST_BITS              ((0x348f  << 2) + 0xff000000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define ISP_LOSSE_PIX_PRESL_FIFO_LEVEL             ((0x3490  << 2) + 0xff000000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define ISP_LOSSE_PIX_DEBUG                        ((0x3491  << 2) + 0xff000000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_REF_DATA                     ((0x3492  << 2) + 0xff000000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_REF_DATA_1                   ((0x3493  << 2) + 0xff000000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_REF_DATA_2                   ((0x3494  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define ISP_LOSSE_PIX_PRED_PROCE                   ((0x3495  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define ISP_LOSSE_PIX_GLOBAL_PHASE_LUT             ((0x3496  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSE_PIX_GLOBAL_PHASE_LUT_1           ((0x3497  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSE_PIX_PHASE_LUT                    ((0x3498  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define ISP_LOSSE_PIX_FLATNESS_0                   ((0x3499  << 2) + 0xff000000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSE_PIX_FLATNESS_QP                  ((0x349a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define ISP_LOSSE_PIX_FLATNESS_TH0                 ((0x349b  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_FLATNESS_TH1                 ((0x349c  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_FLATNESS_TH2                 ((0x349d  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_PIX_QP_MAP_CHN0                  ((0x349e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_1                ((0x349f  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_2                ((0x34a0  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_3                ((0x34a1  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_4                ((0x34a2  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_5                ((0x34a3  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_6                ((0x34a4  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_7                ((0x34a5  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_8                ((0x34a6  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN0_9                ((0x34a7  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1                  ((0x34a8  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_1                ((0x34a9  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_2                ((0x34aa  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_3                ((0x34ab  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_4                ((0x34ac  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_5                ((0x34ad  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_6                ((0x34ae  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_7                ((0x34af  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_8                ((0x34b0  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN1_9                ((0x34b1  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2                  ((0x34b2  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_1                ((0x34b3  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_2                ((0x34b4  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_3                ((0x34b5  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_4                ((0x34b6  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_5                ((0x34b7  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_6                ((0x34b8  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_7                ((0x34b9  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_8                ((0x34ba  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_QP_MAP_CHN2_9                ((0x34bb  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSE_PIX_RC_GROUP_2                   ((0x34bc  << 2) + 0xff000000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSE_PIX_RC_BUDGET_0                  ((0x34bd  << 2) + 0xff000000)
#define ISP_LOSSE_PIX_RC_BUDGET_1                  ((0x34be  << 2) + 0xff000000)
#define ISP_LOSSE_PIX_RC_BUDGET_2                  ((0x34bf  << 2) + 0xff000000)
#define ISP_LOSSE_PIX_RC_BUDGET_3                  ((0x34c0  << 2) + 0xff000000)
#define ISP_LOSSE_PIX_RC_BUDGET_4                  ((0x34c1  << 2) + 0xff000000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSE_PIX_RC_BUDGET_5                  ((0x34c2  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSE_PIX_RC_BUDGET_6                  ((0x34c3  << 2) + 0xff000000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSE_PIX_RC_QP_MARGIN                 ((0x34c4  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_1               ((0x34c5  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_2               ((0x34c6  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_PIX_RC_QP_MARGIN_3               ((0x34c7  << 2) + 0xff000000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_PIX_RC_QP_MARGIN_4               ((0x34c8  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_PIX_RC_QP_MARGIN_5               ((0x34c9  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_PIX_FLATNESS_ADJ0                ((0x34ca  << 2) + 0xff000000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSE_PIX_FLATNESS_ADJ1                ((0x34cb  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSE_PIX_FIFO_THD_0                   ((0x34cc  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_THD_1                   ((0x34cd  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_THD_2                   ((0x34ce  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_FIFO_AVG                     ((0x34cf  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSE_PIX_FIFO_DLT                     ((0x34d0  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_PIX_BITSGAP_THD_0                ((0x34d1  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSE_PIX_BITSGAP_THD_1                ((0x34d2  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSE_PIX_REF_ADJ                      ((0x34d3  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_0                ((0x34d4  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_1                ((0x34d5  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_2                ((0x34d6  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_3                ((0x34d7  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_DLT_4                ((0x34d8  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_REF_ADJ_DLT_5            ((0x34d9  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN0              ((0x34da  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN0_1            ((0x34db  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN1              ((0x34dc  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN1_1            ((0x34dd  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN2              ((0x34de  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define ISP_LOSSE_PIX_REF_ADJ_TH_CHN2_1            ((0x34df  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define ISP_LOSSE_PIX_ACCUM_OFSET_0                ((0x34e0  << 2) + 0xff000000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_1                ((0x34e1  << 2) + 0xff000000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_2                ((0x34e2  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_ACCUM_OFSET_3                ((0x34e3  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define ISP_LOSSE_PIX_WDR_LINE_DELAY               ((0x34e4  << 2) + 0xff000000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define ISP_LOSSE_PIX_CORING_TH_OFST               ((0x34e5  << 2) + 0xff000000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define ISP_LOSSE_PIX_CORING_RST                   ((0x34e6  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define ISP_LOSSE_PIX_STATS_RAM_MODE               ((0x34e7  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define ISP_LOSSE_PIX_STATS_RAM_ADDR               ((0x34e8  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define ISP_LOSSE_PIX_RO_STATS_RAM_DATA            ((0x34e9  << 2) + 0xff000000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/cmpr_raw_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB5_APB_BASE = 0x35
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSEM_MIX_TOP_CTRL                    ((0x3500  << 2) + 0xff000000)
//Bit 31    reg_crc_on          // unsigned, RW, default = 0
//Bit 30:13 reserved
//Bit 12    reg_losse_byp_en    // unsigned, RW, default = 1
//Bit 11:0  reg_gclk_ctrl       // unsigned, RW, default = 0
//
#define ISP_LOSSEM_MIX_CRC_SUM1                    ((0x3501  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_CRC_SUM2                    ((0x3502  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_CRC_SUM3                    ((0x3503  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum3         // unsigned, RO, default = 0
//MMU RDMIF REG
#define ISP_LOSSEM_MIX_MMU_MIF_CTRL0               ((0x3504  << 2) + 0xff000000)
//Bit 31:29 reserved           // unsigned, RW, default=0
//Bit 28:16	reg_stride         // unsigned, RW, default=4096
//Bit 15:14 reserved
//Bit 13:12	reg_auto_ctrl      // unsigned, RW, default=0
//Bit 11:10	reg_gclk_ctrl      // unsigned, RW, default=0
//Bit 9 : 8	reg_cmd_req_size   // unsigned, RW, default=1
//Bit 7     reserved
//Bit 6 : 4	reg_cmd_intr_len   // unsigned, RW, default=1
//Bit 3    	reg_swap_64bit     // unsigned, RW, default=0
//Bit 2    	reg_little_endian  // unsigned, RW, default=1
//Bit 1:0  	reg_burst_len      // unsigned, RW, default=1
#define ISP_LOSSEM_MIX_MMU_MIF_CTRL1               ((0x3505  << 2) + 0xff000000)
//Bit 31:24 reserved
//Bit 23:22 reg_int_clr         // unsigned, RW, default=0
//Bit 21:20 reserved
//Bit 19:18 reg_sw_rst          // unsigned, RW, default=0
//Bit 17    reserved
//Bit 16:0  reg_urgent_ctrl     //unsigned, RW, default=0
#define ISP_LOSSEM_MIX_MMU_MIF_RO_STAT             ((0x3506  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_status           // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_MIF_CTRL                    ((0x3507  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 17:16 reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 15    reserved
//Bit 14:12 reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 11:10 reg_burst_len     // unsigned , RW, default = 2, burst type: 0-single 1-bst2 2-bst4
//Bit 9:8   reg_losse_clr     // unsigned , RW, default = 0,
//Bit 7     reserved
//Bit 6:4   reg_sw_rst        // unsigned , RW, default = 0
//Bit 3     reg_rst_mode      // unsigned , RW, default = 0
//Bit 2     reg_en_mode       // unsigned , RW, default = 0
//Bit 1     reg_enable        // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSEM_MIX_UGT_CTRL                    ((0x3508  << 2) + 0xff000000)
//Bit 31:17 reserved
//Bit 16:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSEM_MIX_GCLK_CTRL                   ((0x3509  << 2) + 0xff000000)
//Bit 31:12 reserved
//Bit 11:0  reg_pass_num      // unsigned , RW, default = 1
#define ISP_LOSSEM_MIX_LUT_SIZE                    ((0x350a  << 2) + 0xff000000)
//Bit 31:29 reserved
//Bit 28:16 reg_lut_vsize        // unsigned , RW, default = 1,
//Bit 15:13 reserved
//Bit 12:0  reg_lut_hsize        // unsigned , RW, default = 4096,
#define ISP_LOSSEM_MIX_RO_STAT                     ((0x350b  << 2) + 0xff000000)
//Bit 31:0  ro_losse_stat       // unsigned, RO, default = 0
#define ISP_LOSSEM_MIX_RO_MMU_NUM                  ((0x350c  << 2) + 0xff000000)
//Bit 31:16 reserved
//Bit 15:0  ro_frm_mmu_num      // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_wrmif_losse_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/losslite_regs_0.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSE_MIX_CTRL                         ((0x3580  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reserved
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSE_MIX_FRAME_HOLD                   ((0x3581  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0
#define ISP_LOSSE_MIX_GCLK_CTRL                    ((0x3582  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSE_MIX_RO_CODEC_STATUS              ((0x3583  << 2) + 0xff000000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RO, default = 0  codec status, write 1 to clear
#define ISP_LOSSE_MIX_MISC                         ((0x3584  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSE_MIX_BASIS                        ((0x3588  << 2) + 0xff000000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:28        reserved
//Bit 27: 8        reserved
//Bit  7: 0        reg_ratio_bppx16          // unsigned ,    RW, default = 96  bits per pixel x16, fracbits_bpp = x/16;
#define ISP_LOSSE_MIX_PIC_SIZE                     ((0x3589  << 2) + 0xff000000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSE_MIX_SLICE_Y                      ((0x358a  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSE_MIX_SLICE_Y_1                    ((0x358b  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSE_MIX_QP_MAP_CHN0                  ((0x358c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_3       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_2       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_1       // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_0       // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_1                ((0x358d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_7       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_6       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_5       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_4       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_2                ((0x358e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_11      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_10      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_9       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_8       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_3                ((0x358f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_15      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_14      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_13      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_12      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_4                ((0x3590  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_19      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_18      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_17      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_16      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_QP_MAP_CHN0_5                ((0x3591  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_23      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_22      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_21      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_20      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
#define ISP_LOSSE_MIX_FLATNESS_0                   ((0x3592  << 2) + 0xff000000)
//Bit 31           reg_flat_en               // unsigned ,    RW, default = 0  enable signal for the flatness mode.
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29           reg_flatness_qerr_flag    // unsigned ,    RW, default = 0
//Bit 28            reserved
//Bit 27:24        reserved
//Bit 23:20        reg_flatness_qp_thresh    // unsigned ,    RW, default = 2  thresh qp for flatness to be used
//Bit 19:16        reserved
//Bit 15:12        reg_flatness_qp_reduce    // unsigned ,    RW, default = 2  if the cell is flatness qlevel = master_qp- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSE_MIX_FLATNESS_TH                  ((0x3593  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSE_MIX_RC_GROUP_2                   ((0x3594  << 2) + 0xff000000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1920  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSE_MIX_RC_BUDGET_0                  ((0x3595  << 2) + 0xff000000)
#define ISP_LOSSE_MIX_RC_BUDGET_1                  ((0x3596  << 2) + 0xff000000)
#define ISP_LOSSE_MIX_RC_BUDGET_2                  ((0x3597  << 2) + 0xff000000)
#define ISP_LOSSE_MIX_RC_BUDGET_3                  ((0x3598  << 2) + 0xff000000)
#define ISP_LOSSE_MIX_RC_BUDGET_4                  ((0x3599  << 2) + 0xff000000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSE_MIX_RC_BUDGET_5                  ((0x359a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_master_qp_max      // unsigned ,    RW, default = 9  maxmum qpx2 during the rc_loop
//Bit 23:20        reserved
//Bit 19:16        reg_rc_master_qp_min      // unsigned ,    RW, default = 0  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSE_MIX_RC_BUDGET_6                  ((0x359b  << 2) + 0xff000000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qp_margin3_blkth   // unsigned ,    RW, default = 0  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSE_MIX_RC_QP_MARGIN                 ((0x359c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_1    // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_0    // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSE_MIX_RC_QP_MARGIN_1               ((0x359d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_3    // signed ,    RW, default = 16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_2    // signed ,    RW, default = -32  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSE_MIX_RC_QP_MARGIN_2               ((0x359e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_qp_margin_dlt_3    // unsigned ,    RW, default = 4  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_qp_margin_dlt_2    // unsigned ,    RW, default = 3
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_qp_margin_dlt_1    // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_qp_margin_dlt_0    // unsigned ,    RW, default = 1  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
#define ISP_LOSSE_MIX_FLATNESS_ADJ0                ((0x359f  << 2) + 0xff000000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt, default=[1, 2]
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 0  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSE_MIX_FLATNESS_ADJ1                ((0x35a0  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 0  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSE_MIX_FIFO_THD_0                   ((0x35a1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_THD_1                   ((0x35a2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_THD_2                   ((0x35a3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_FIFO_AVG                     ((0x35a4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:16        reserved
//Bit 15:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 6  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSE_MIX_FIFO_DLT_1STCH               ((0x35a5  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 3  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 1  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSE_MIX_BITSGAP_THD_0                ((0x35a6  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSE_MIX_BITSGAP_THD_1                ((0x35a7  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSE_MIX_RC_QP_MARGIN_3               ((0x35a8  << 2) + 0xff000000)
//Bit 31:30        reg_rc_qp_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_MIX_RC_QP_MARGIN_4               ((0x35a9  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSE_MIX_RC_QP_MARGIN_5               ((0x35aa  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_qp_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_qp_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_qp_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_qp_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSE_MIX_LUMA                         ((0x35ab  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16           reg_luma_adjust_en        // unsigned ,    RW, default = 0  enable of luma(G) adjust
//Bit 15:13        reserved
//Bit 12: 8        reg_pixel_luma_adj_dlt_1  // unsigned ,    RW, default = 1  of qlevel according to luma
//Bit  7: 5        reserved
//Bit  4: 0        reg_pixel_luma_adj_dlt_0  // unsigned ,    RW, default = 2
#define ISP_LOSSE_MIX_LUMA_TH                      ((0x35ac  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_luma_adj_th_1   // unsigned ,    RW, default = 128  of luma level
//Bit 15: 0        reg_pixel_luma_adj_th_0   // unsigned ,    RW, default = 256
#define ISP_LOSSE_MIX_DEBUG                        ((0x35ad  << 2) + 0xff000000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30: 8        reserved
//Bit  7: 0        reg_dbg_qlevel            // unsigned ,    RW, default = 0
#define ISP_LOSSE_MIX_RO_MAX_ERROR                 ((0x35ae  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        ro_max_error              // unsigned ,    RO, default = 0  current channel max pixel diff
#define ISP_LOSSE_MIX_RO_SQUARE_L                  ((0x35af  << 2) + 0xff000000)
//Bit 31: 0        ro_error_acc_l            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSE_MIX_RO_SQUARE_H                  ((0x35b0  << 2) + 0xff000000)
//Bit 31: 0        ro_error_acc_h            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_0               ((0x35b1  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_0               ((0x35b2  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_1               ((0x35b3  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_1               ((0x35b4  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_2               ((0x35b5  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_2               ((0x35b6  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_H_3               ((0x35b7  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSE_MIX_RO_BIT_LEN_L_3               ((0x35b8  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/losslite_regs_0.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB6_APB_BASE = 0x36
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_0.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSDM_PIX_MIF_CTRL                    ((0x3600  << 2) + 0xff000000)
//Bit 31    reg_crc_on        // unsigned , RW, default = 1
//Bit 30    reserved
//Bit 29:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 19:18 reg_lossd_clr     // unsigned , RW, default = 0,
//Bit 17:16 reserved
//Bit 15    reg_lossd_byp_en  // unsigned , RW, default = 1
//Bit 14:12 reg_sw_rst        // unsigned , RW, default = 0
//Bit 11    reserved
//Bit 10:8  reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 7:6   reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 5:4   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 3     reg_swap_64bit    // unsigned , RW, default = 0
//Bit 2     reg_little_endian // unsigned , RW, default = 1
//Bit 1     reg_mif_enable    // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSDM_PIX_UGT_CTRL                    ((0x3601  << 2) + 0xff000000)
//Bit 31:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSDM_PIX_GCLK_CTRL                   ((0x3602  << 2) + 0xff000000)
//Bit 31:29 reg_body_intr_len   //unsigned, RW, default = 1
//Bit 28:27 reg_body_req_size   //unsigned, RW, default = 1
//Bit 26:16 reserved
//Bit 15:0  reg_gclk_ctrl       //unsigned, RW, default = 0
#define ISP_LOSSDM_PIX_RO_STAT                     ((0x3603  << 2) + 0xff000000)
//Bit 31:0  ro_mif_status       //unsigned, RO, default=0
#define ISP_LOSSDM_PIX_CRC_SUM1                    ((0x3604  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSDM_PIX_CRC_SUM2                    ((0x3605  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_0.h
//
//
// Reading file:  ./isp_inc/inc_sw/cmpr_raw_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSD_PIX_CTRL                         ((0x3680  << 2) + 0xff000000)
//Bit 31:29        reg_interrupt_en          // unsigned ,    RW, default = 0
//Bit 28:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6  horz blank size
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reg_stats_en              // unsigned ,    RW, default = 3  0 to enable stats of max_err/err_acc; 1 to enable error_count2
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSD_PIX_FRAME_HOLD                   ((0x3681  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0  configure regs use RDMA mode
#define ISP_LOSSD_PIX_GCLK_CTRL                    ((0x3682  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSD_PIX_RO_CODEC_STATUS              ((0x3683  << 2) + 0xff000000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RW, default = 0  codec status, write 1 to clear
#define ISP_LOSSD_PIX_MISC                         ((0x3684  << 2) + 0xff000000)
//Bit 31: 8        reserved
//Bit  7: 4        reg_misc                  // unsigned ,    RW, default = 0
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSD_PIX_BASIS                        ((0x3688  << 2) + 0xff000000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:24        reserved
//Bit 23            reserved
//Bit 22:20        reg_raw_mode              // unsigned ,    RW, default = 1  0: mono, 1:G R  ,2 :   I R     ,3:  G R   ,4:  G R G B, 5~7: other cases
//Bit 19           reg_mono_comp_mode        // unsigned ,    RW, default = 0  compression mode of mono data : 0  compression in Y ,  1: compression in bayer
//Bit 18           reg_group_ver_size_mode   // unsigned ,    RW, default = 1  the mode of vertical group size ,0 : vertical group size 2,  1: vertical group size 1
//Bit 17           reg_pred_step_mode        // unsigned ,    RW, default = 1  the mode of GbGr pred mode, 0: GbGr mix together as G, use the most recent data, 1: Gb use Gb,Gr use Gr  fix 1
//Bit 16           reg_pred_simple_mode      // unsigned ,    RW, default = 0  the mode of RGBIR4x4 R/B pred, 0: normal mode      1:simple average  fix 0
//Bit 15:13        reserved
//Bit 12: 4        reg_ratio_bppx16          // unsigned ,    RW, default = 80  bits per pixel x16, fracbits_bpp = x/16;
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_size         // unsigned ,    RW, default = 5  fix 5
#define ISP_LOSSD_PIX_OFST_BIT_DEPTH               ((0x3689  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11:10        reg_xphase_ofst           // unsigned ,    RW, default = 0  offset in x dimension
//Bit  9: 8        reg_yphase_ofst           // unsigned ,    RW, default = 0  phase offset in y dimension
//Bit  7: 5        reserved
//Bit  4: 0        reg_src_bit_depth         // unsigned ,    RW, default = 10  source data bit depth from sensor
#define ISP_LOSSD_PIX_PIC_SIZE                     ((0x368a  << 2) + 0xff000000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSD_PIX_SLICE_SIZE                   ((0x368b  << 2) + 0xff000000)
//Bit 31           reg_use_sw_preslc_bitaccum // unsigned ,    RW, default = 0
//Bit 30            reserved
//Bit 29:28        reg_slice_num_mode        // unsigned ,    RW, default = 0  num 1, 1:slice num 2  2:slice num 4  3:slice num 8
//Bit 27:16        reserved
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_1                 ((0x368c  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_2                 ((0x368d  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_4         // unsigned ,    RW, default = 0  slice window size
//Bit 15: 0        reg_slice_ysize_3         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_SLICE_SIZE_3                 ((0x368e  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_6         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_5         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_PIX_PRESL_LAST_BITS              ((0x368f  << 2) + 0xff000000)
//Bit 31: 0        reg_pre_slc_bitaccum      // signed ,    RW, default = 0  pre slice last bits  add to next slice
#define ISP_LOSSD_PIX_PRESL_FIFO_LEVEL             ((0x3690  << 2) + 0xff000000)
//Bit 31           reg_use_sw_preslc_fifolevel // unsigned ,    RW, default = 0
//Bit 30:16        reserved
//Bit 15: 0        reg_pre_slc_fifolevel     // unsigned ,    RW, default = 16  pre slice fifolevel  add to next slice
#define ISP_LOSSD_PIX_DEBUG                        ((0x3691  << 2) + 0xff000000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30:24        reserved
//Bit 23:16        reg_dbg_qlevel_2          // unsigned ,    RW, default = 0
//Bit 15: 8        reg_dbg_qlevel_1          // unsigned ,    RW, default = 0
//Bit  7: 0        reg_dbg_qlevel_0          // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_REF_DATA                     ((0x3692  << 2) + 0xff000000)
//Bit 31:16        reg_ref_data_1            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel  //need latch
//Bit 15: 0        reg_ref_data_0            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_REF_DATA_1                   ((0x3693  << 2) + 0xff000000)
//Bit 31:16        reg_ref_data_2            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
//Bit 15: 0        reg_ref_data_3            // unsigned ,    RW, default = 3840  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_REF_DATA_2                   ((0x3694  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_ref_data_4            // unsigned ,    RW, default = 32768  the reference data of adjust qlevel
#define ISP_LOSSD_PIX_PRED_PROCE                   ((0x3695  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_pred_ref_adj_en       // unsigned ,    RW, default = 0  enable of pred process,only for R/B chn   //need latch
//Bit 19:18        reserved
//Bit 17:16        reg_pred_ref_adj_ratio_mode // unsigned ,    RW, default = 3  the ratio mode of adjust pred, 0:pred = pred - (pred - ref)*1/8. 1::pred = pred - (pred - ref)*2/8, 2::pred = pred - (pred - ref)*4/8 , 3::pred = pred - (pred - ref)*8/8.
//Bit 15:10        reserved
//Bit  9: 0        reg_pred_ref_adj_th       // unsigned ,    RW, default = 0  threshold of pred process
#define ISP_LOSSD_PIX_GLOBAL_PHASE_LUT             ((0x3696  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_15         // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_14         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_13         // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_12         // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_11         // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_10         // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_9          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_8          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSD_PIX_GLOBAL_PHASE_LUT_1           ((0x3697  << 2) + 0xff000000)
//Bit 31            reserved
//Bit 30:28        reg_raw_phslut_7          // unsigned ,    RW, default = 3  raw phase lut
//Bit 27            reserved
//Bit 26:24        reg_raw_phslut_6          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 23            reserved
//Bit 22:20        reg_raw_phslut_5          // unsigned ,    RW, default = 3  global raw phase lut
//Bit 19            reserved
//Bit 18:16        reg_raw_phslut_4          // unsigned ,    RW, default = 2  global raw phase lut
//Bit 15            reserved
//Bit 14:12        reg_raw_phslut_3          // unsigned ,    RW, default = 1  raw phase lut
//Bit 11            reserved
//Bit 10: 8        reg_raw_phslut_2          // unsigned ,    RW, default = 0  global raw phase lut
//Bit  7            reserved
//Bit  6: 4        reg_raw_phslut_1          // unsigned ,    RW, default = 1  global raw phase lut
//Bit  3            reserved
//Bit  2: 0        reg_raw_phslut_0          // unsigned ,    RW, default = 0  raw phase lut
#define ISP_LOSSD_PIX_PHASE_LUT                    ((0x3698  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19            reserved
//Bit 18:16        reg_comp_chn_lut_4        // unsigned ,    RW, default = 0  compression phase lut
//Bit 15            reserved
//Bit 14:12        reg_comp_chn_lut_3        // unsigned ,    RW, default = 0  compression phase lut
//Bit 11            reserved
//Bit 10: 8        reg_comp_chn_lut_2        // unsigned ,    RW, default = 1  compression phase lut
//Bit  7            reserved
//Bit  6: 4        reg_comp_chn_lut_1        // unsigned ,    RW, default = 1  compression phase lut
//Bit  3            reserved
//Bit  2: 0        reg_comp_chn_lut_0        // unsigned ,    RW, default = 0  compression phase lut
#define ISP_LOSSD_PIX_FLATNESS_0                   ((0x3699  << 2) + 0xff000000)
//Bit 31           reg_flatness_adj_mode     // unsigned ,    RW, default = 0  0: only check 0 cell, 1: check -1, 0 ,1 3cell
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29:28        reserved
//Bit 27:25        reserved
//Bit 24:20        reg_flatness_qp_thresh_0  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 19:17        reserved
//Bit 16:12        reg_flatness_qp_reduce_0  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSD_PIX_FLATNESS_QP                  ((0x369a  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_flatness_qp_thresh_2  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit 23:21        reserved
//Bit 20:16        reg_flatness_qp_reduce_2  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
//Bit 15:13        reserved
//Bit 12: 8        reg_flatness_qp_thresh_1  // unsigned ,    RW, default = 4  thresh qp for flatness to be used
//Bit  7: 5        reserved
//Bit  4: 0        reg_flatness_qp_reduce_1  // unsigned ,    RW, default = 2  if the cell is flatness qlevel = qlevel- flatness_qp_reduce
#define ISP_LOSSD_PIX_FLATNESS_TH0                 ((0x369b  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_0 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_0 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_FLATNESS_TH1                 ((0x369c  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_1 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_1 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_FLATNESS_TH2                 ((0x369d  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min_2 // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max_2 // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_PIX_QP_MAP_CHN0                  ((0x369e  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_1                ((0x369f  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_2                ((0x36a0  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_3                ((0x36a1  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_4                ((0x36a2  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_5                ((0x36a3  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_6                ((0x36a4  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_7                ((0x36a5  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_8                ((0x36a6  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN0_9                ((0x36a7  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_0_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_0_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_0_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_0_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1                  ((0x36a8  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_1                ((0x36a9  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_2                ((0x36aa  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_3                ((0x36ab  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_4                ((0x36ac  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_5                ((0x36ad  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_6                ((0x36ae  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_7                ((0x36af  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_8                ((0x36b0  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN1_9                ((0x36b1  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_1_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_1_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_1_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_1_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2                  ((0x36b2  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_3     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_2     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_1     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_0     // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_1                ((0x36b3  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_7     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_6     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_5     // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_4     // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_2                ((0x36b4  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_11    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_10    // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_9     // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_8     // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_3                ((0x36b5  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_15    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_14    // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_13    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_12    // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_4                ((0x36b6  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_19    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_18    // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_17    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_16    // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_5                ((0x36b7  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_23    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_22    // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_21    // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_20    // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_6                ((0x36b8  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_27    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_26    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_25    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_24    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_7                ((0x36b9  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_31    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_30    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_29    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_28    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_8                ((0x36ba  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_35    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_34    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_33    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_32    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_QP_MAP_CHN2_9                ((0x36bb  << 2) + 0xff000000)
//Bit 31:29        reserved
//Bit 28:24        reg_lut_budget2qp_2_39    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:21        reserved
//Bit 20:16        reg_lut_budget2qp_2_38    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:13        reserved
//Bit 12: 8        reg_lut_budget2qp_2_37    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit  7: 5        reserved
//Bit  4: 0        reg_lut_budget2qp_2_36    // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
#define ISP_LOSSD_PIX_RC_GROUP_2                   ((0x36bc  << 2) + 0xff000000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1080  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSD_PIX_RC_BUDGET_0                  ((0x36bd  << 2) + 0xff000000)
#define ISP_LOSSD_PIX_RC_BUDGET_1                  ((0x36be  << 2) + 0xff000000)
#define ISP_LOSSD_PIX_RC_BUDGET_2                  ((0x36bf  << 2) + 0xff000000)
#define ISP_LOSSD_PIX_RC_BUDGET_3                  ((0x36c0  << 2) + 0xff000000)
#define ISP_LOSSD_PIX_RC_BUDGET_4                  ((0x36c1  << 2) + 0xff000000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSD_PIX_RC_BUDGET_5                  ((0x36c2  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_master_qpx2_max    // unsigned ,    RW, default = 23  maxmum qpx2 during the rc_loop
//Bit 23:22        reserved
//Bit 21:16        reg_rc_master_qpx2_min    // unsigned ,    RW, default = 14  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSD_PIX_RC_BUDGET_6                  ((0x36c3  << 2) + 0xff000000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qpx2_margin3_blkth // unsigned ,    RW, default = 240  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSD_PIX_RC_QP_MARGIN                 ((0x36c4  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_1  // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_0  // signed ,    RW, default = 8  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_1               ((0x36c5  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qpx2_margin_thd_3  // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qpx2_margin_thd_2  // signed ,    RW, default = -12  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, 16*16]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_2               ((0x36c6  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_qpx2_margin_dlt_3  // unsigned ,    RW, default = 6  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_qpx2_margin_dlt_2  // unsigned ,    RW, default = 5
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_qpx2_margin_dlt_1  // unsigned ,    RW, default = 3
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_qpx2_margin_dlt_0  // unsigned ,    RW, default = 2  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_PIX_RC_QP_MARGIN_3               ((0x36c7  << 2) + 0xff000000)
//Bit 31:30        reg_rc_qpx2_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_PIX_RC_QP_MARGIN_4               ((0x36c8  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qpx2_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qpx2_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_PIX_RC_QP_MARGIN_5               ((0x36c9  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_qpx2_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_qpx2_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_qpx2_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_qpx2_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_PIX_FLATNESS_ADJ0                ((0x36ca  << 2) + 0xff000000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 50  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 2  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSD_PIX_FLATNESS_ADJ1                ((0x36cb  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 512  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 7  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 2  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSD_PIX_FIFO_THD_0                   ((0x36cc  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_THD_1                   ((0x36cd  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_THD_2                   ((0x36ce  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_FIFO_AVG                     ((0x36cf  << 2) + 0xff000000)
//Bit 31:26        reserved
//Bit 25:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 12  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:18        reserved
//Bit 17:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 14  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSD_PIX_FIFO_DLT                     ((0x36d0  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 11  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:22        reserved
//Bit 21:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 8  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:14        reserved
//Bit 13: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 5  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 6        reserved
//Bit  5: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_PIX_BITSGAP_THD_0                ((0x36d1  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSD_PIX_BITSGAP_THD_1                ((0x36d2  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSD_PIX_REF_ADJ                      ((0x36d3  << 2) + 0xff000000)
//Bit 31:21        reserved
//Bit 20           reg_ref_adjust_en_4       // unsigned ,    RW, default = 0  enable of ref(phase 4) adjust
//Bit 19           reg_ref_adjust_en_3       // unsigned ,    RW, default = 0  enable of ref(phase 3) adjust
//Bit 18           reg_ref_adjust_en_2       // unsigned ,    RW, default = 1  enable of ref(phase 2) adjust
//Bit 17           reg_ref_adjust_en_1       // unsigned ,    RW, default = 1  enable of ref(phase 1) adjust
//Bit 16           reg_ref_adjust_en_0       // unsigned ,    RW, default = 0  enable of ref(phase 0) adjust  //need latch
//Bit 15:12        reg_pixel_ref_adj_dlt_12_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_12_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_12_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_12_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_0                ((0x36d4  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_1_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_1_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_1_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_1_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_0_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_0_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_0_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_0_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_1                ((0x36d5  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_3_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_3_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_3_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_3_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_2_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_2_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_2_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_2_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_2                ((0x36d6  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_5_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_5_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_5_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_5_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_4_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_4_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_4_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_4_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_3                ((0x36d7  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_7_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_7_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_7_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_7_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_6_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_6_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_6_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_6_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_DLT_4                ((0x36d8  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_9_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_9_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_9_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_9_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_8_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_8_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_8_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_8_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_REF_ADJ_DLT_5            ((0x36d9  << 2) + 0xff000000)
//Bit 31:28        reg_pixel_ref_adj_dlt_11_3 // unsigned ,    RW, default = 1
//Bit 27:24        reg_pixel_ref_adj_dlt_11_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit 23:20        reg_pixel_ref_adj_dlt_11_1 // unsigned ,    RW, default = 1
//Bit 19:16        reg_pixel_ref_adj_dlt_11_0 // unsigned ,    RW, default = 1
//Bit 15:12        reg_pixel_ref_adj_dlt_10_3 // unsigned ,    RW, default = 1
//Bit 11: 8        reg_pixel_ref_adj_dlt_10_2 // unsigned ,    RW, default = 1  of qlevel according to luma and distance to ref   //need latch
//Bit  7: 4        reg_pixel_ref_adj_dlt_10_1 // unsigned ,    RW, default = 1
//Bit  3: 0        reg_pixel_ref_adj_dlt_10_0 // unsigned ,    RW, default = 1
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN0              ((0x36da  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_0_1  // unsigned ,    RW, default = 3712  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_0  // unsigned ,    RW, default = 3200
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN0_1            ((0x36db  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_0_3  // unsigned ,    RW, default = 5120  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_0_2  // unsigned ,    RW, default = 4096
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN1              ((0x36dc  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_1_1  // unsigned ,    RW, default = 300  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_0  // unsigned ,    RW, default = 200
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN1_1            ((0x36dd  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_1_3  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_1_2  // unsigned ,    RW, default = 350
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN2              ((0x36de  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_2_1  // unsigned ,    RW, default = 400  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_0  // unsigned ,    RW, default = 300
#define ISP_LOSSD_PIX_REF_ADJ_TH_CHN2_1            ((0x36df  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_ref_adj_th_2_3  // unsigned ,    RW, default = 500  of distance to ref to adjust qlevel
//Bit 15: 0        reg_pixel_ref_adj_th_2_2  // unsigned ,    RW, default = 450
#define ISP_LOSSD_PIX_ACCUM_OFSET_0                ((0x36e0  << 2) + 0xff000000)
//Bit 31:24        reg_accum_add_ofset_2     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_1     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_0     // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 1        reg_accum_ofset_shift     // unsigned ,    RW, default = 2
//Bit  0           reg_accum_ofset_en        // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_1                ((0x36e1  << 2) + 0xff000000)
//Bit 31:24        reg_accum_add_ofset_6     // unsigned ,    RW, default = 0
//Bit 23:16        reg_accum_add_ofset_5     // unsigned ,    RW, default = 5
//Bit 15: 8        reg_accum_add_ofset_4     // unsigned ,    RW, default = 2
//Bit  7: 0        reg_accum_add_ofset_3     // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_2                ((0x36e2  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 8        reg_accum_add_ofset_8     // unsigned ,    RW, default = 255
//Bit  7: 0        reg_accum_add_ofset_7     // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_ACCUM_OFSET_3                ((0x36e3  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_normalize_idx_ratio   // unsigned ,    RW, default = 0
#define ISP_LOSSD_PIX_WDR_LINE_DELAY               ((0x36e4  << 2) + 0xff000000)
//Bit 31           reg_wdr_mode_en           // unsigned ,    RW, default = 0  mode enable,(in this mode have line delay between long and short frame)
//Bit 30           reg_wdr_adaptive_en        // unsigned ,    RW, default = 0  adaptive line wdr delay mode enable
//Bit 29:16        reg_wdr_adaptive_line      // unsigned ,    RW, default = 20  adaptive line of wdr delay mode, if less than line use wdr delay mode  else normal                                                    //u15
//Bit 15: 0        reg_wdr_delay_line        // unsigned ,    RW, default = 4  delay between long and short frame in wdr mode
#define ISP_LOSSD_PIX_CORING_TH_OFST               ((0x36e5  << 2) + 0xff000000)
//Bit 31:16        reg_nr_coring_ofset       // unsigned ,    RW, default = 0  ofset of coring
//Bit 15: 0        reg_nr_coring_th          // unsigned ,    RW, default = 0  coring  for 1 line  mode
#define ISP_LOSSD_PIX_CORING_RST                   ((0x36e6  << 2) + 0xff000000)
//Bit 31: 3        reserved
//Bit  2: 0        reg_nr_coring_rst         // unsigned ,    RW, default = 0  ofset of coring
#define ISP_LOSSD_PIX_STATS_RAM_MODE               ((0x36e7  << 2) + 0xff000000)
//Bit 31: 2        reserved
//Bit  1           reg_stats_slice_rdmode    // unsigned ,    RW, default = 0  0 to read slice according to reg_slice_num_mode
//Bit  0           reg_stats_ram_rden        // unsigned ,    RW, default = 0  0 to read ram enable
#define ISP_LOSSD_PIX_STATS_RAM_ADDR               ((0x36e8  << 2) + 0xff000000)
//Bit 31: 9        reserved
//Bit  8: 0        reg_stats_ram_addr        // unsigned ,    RW, default = 0  statistics info ram status address
#define ISP_LOSSD_PIX_RO_STATS_RAM_DATA            ((0x36e9  << 2) + 0xff000000)
//Bit 31: 0        ro_stats_ram_data         // unsigned ,    RO, default = 0  info ram data
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/cmpr_raw_regs_1.h
//
// -----------------------------------------------
// REG_BASE:  ISP_INTF_APB7_APB_BASE = 0x37
// -----------------------------------------------
//
// Reading file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_1.h
//
// synopsys translate_off
// synopsys translate_on
//  REGISTER_BASE_ADDR         32'h00000000
#define ISP_LOSSDM_MIX_MIF_CTRL                    ((0x3700  << 2) + 0xff000000)
//Bit 31    reg_crc_on        // unsigned , RW, default = 1
//Bit 30    reserved
//Bit 29:20 reg_fifo_size     // unsigned , RW, default = 256
//Bit 19:18 reg_lossd_clr     // unsigned , RW, default = 0,
//Bit 17:16 reserved
//Bit 15    reg_lossd_byp_en  // unsigned , RW, default = 1
//Bit 14:12 reg_sw_rst        // unsigned , RW, default = 0
//Bit 11    reserved
//Bit 10:8  reg_cmd_req_size  // unsigned , RW, default = 1, how many room fifo have, then axi send series req, 0=16 1=32 2=24 3=64
//Bit 7:6   reg_cmd_intr_len  // unsigned , RW, default = 1, interrupt send cmd when how many series axi cmd,// 0=12 1=16 2=24 3=32 4=40 5=48 6=56 7=64
//Bit 5:4   reg_burst_len     // unsigned , RW, default = 1, burst type: 0-single 1-bst4 2-bst8 3-bst16
//Bit 3     reg_swap_64bit    // unsigned , RW, default = 0
//Bit 2     reg_little_endian // unsigned , RW, default = 1
//Bit 1     reg_mif_enable    // unsigned , RW, default = 1
//Bit 0     reg_frm_start     // unsigned , RW, default = 0
#define ISP_LOSSDM_MIX_UGT_CTRL                    ((0x3701  << 2) + 0xff000000)
//Bit 31:0  reg_urgent_ctrl   // unsigned , RW, default = 0, urgent control reg ://  16  reg_ugt_init  :  urgent initial value//  15  reg_ugt_en    :  urgent enable//  14  reg_ugt_type  :  1= wrmif 0=rdmif// 7:4  reg_ugt_top_th:  urgent top threshold// 3:0  reg_ugt_bot_th:  urgent bottom threshold
#define ISP_LOSSDM_MIX_GCLK_CTRL                   ((0x3702  << 2) + 0xff000000)
//Bit 31:29 reg_body_intr_len   //unsigned, RW, default = 1
//Bit 28:27 reg_body_req_size   //unsigned, RW, default = 1
//Bit 26:16 reserved
//Bit 15:0  reg_gclk_ctrl       //unsigned, RW, default = 0
#define ISP_LOSSDM_MIX_RO_STAT                     ((0x3703  << 2) + 0xff000000)
//Bit 31:0  ro_mif_status       //unsigned, RO, default=0
#define ISP_LOSSDM_MIX_CRC_SUM1                    ((0x3704  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum1         // unsigned, RO, default = 0
#define ISP_LOSSDM_MIX_CRC_SUM2                    ((0x3705  << 2) + 0xff000000)
//Bit 31:0  ro_crc_sum2         // unsigned, RO, default = 0
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/isp_rdmif_lossd_reg_1.h
//
//
// Reading file:  ./isp_inc/inc_sw/losslite_regs_1.h
//
// synopsys translate_off
// synopsys translate_on
#define ISP_LOSSD_MIX_CTRL                         ((0x3780  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:16        reg_hblank                // unsigned ,    RW, default = 6
//Bit 15: 8        reg_sync_ctrl             // unsigned ,    RW, default = 0  shadow control, 0 to shadow
//Bit  7: 4        reg_use_inter_fmt         // unsigned ,    RW, default = 0  0 to use external format setting
//Bit  3           reg_status_rdbk_mode      // unsigned ,    RW, default = 0  0 to shadow the ro status
//Bit  2: 1        reserved
//Bit  0           reg_enable                // unsigned ,    RW, default = 1  enc/dec enable
#define ISP_LOSSD_MIX_FRAME_HOLD                   ((0x3781  << 2) + 0xff000000)
//Bit 31: 1        reserved
//Bit  0           reg_rdma_mode_en          // unsigned ,    RW, default = 0
#define ISP_LOSSD_MIX_GCLK_CTRL                    ((0x3782  << 2) + 0xff000000)
//Bit 31: 0        reg_gclk_ctrl             // unsigned ,    RW, default = 0  gated-clock control
#define ISP_LOSSD_MIX_RO_CODEC_STATUS              ((0x3783  << 2) + 0xff000000)
//Bit 31: 0        ro_codec_status           // unsigned ,    RO, default = 0  codec status, write 1 to clear
#define ISP_LOSSD_MIX_MISC                         ((0x3784  << 2) + 0xff000000)
//Bit 31: 4        reserved
//Bit  3           reg_inter_preslc_bitaccum // unsigned ,    RW, default = 0  for dec
//Bit  2           reg_inter_preslc_fifolevel // unsigned ,    RW, default = 0  for dec
//Bit  1           reg_dec_oflush_mode       // unsigned ,    RW, default = 0  for dec
//Bit  0           reg_busy_shown_till_inp   // unsigned ,    RW, default = 0  1 to shown codec busy till input come
#define ISP_LOSSD_MIX_BASIS                        ((0x3788  << 2) + 0xff000000)
//Bit 31           reg_lossless_en           // unsigned ,    RW, default = 0  enable of lossless
//Bit 30:28        reserved
//Bit 27: 8        reserved
//Bit  7: 0        reg_ratio_bppx16          // unsigned ,    RW, default = 96  bits per pixel x16, fracbits_bpp = x/16;
#define ISP_LOSSD_MIX_PIC_SIZE                     ((0x3789  << 2) + 0xff000000)
//Bit 31:16        reg_pic_ysize             // unsigned ,    RW, default = 1080  picture varietal size
//Bit 15: 0        reg_pic_xsize             // unsigned ,    RW, default = 1920  picture horizontal size
#define ISP_LOSSD_MIX_SLICE_Y                      ((0x378a  << 2) + 0xff000000)
//Bit 31:16        reg_slice_ysize_1         // unsigned ,    RW, default = 0  vertical slice window size
//Bit 15: 0        reg_slice_ysize_0         // unsigned ,    RW, default = 1080  vertical slice window size
#define ISP_LOSSD_MIX_SLICE_Y_1                    ((0x378b  << 2) + 0xff000000)
//Bit 31:16        reserved
//Bit 15: 0        reg_slice_ysize_2         // unsigned ,    RW, default = 0  vertical slice window size
#define ISP_LOSSD_MIX_QP_MAP_CHN0                  ((0x378c  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_3       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_2       // unsigned ,    RW, default = 10  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_1       // unsigned ,    RW, default = 11  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_0       // unsigned ,    RW, default = 12  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_1                ((0x378d  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_7       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_6       // unsigned ,    RW, default = 8  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_5       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_4       // unsigned ,    RW, default = 9  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_2                ((0x378e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_11      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_10      // unsigned ,    RW, default = 6  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_9       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_8       // unsigned ,    RW, default = 7  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_3                ((0x378f  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_15      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_14      // unsigned ,    RW, default = 4  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_13      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_12      // unsigned ,    RW, default = 5  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_4                ((0x3790  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_19      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_18      // unsigned ,    RW, default = 2  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_17      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_16      // unsigned ,    RW, default = 3  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_QP_MAP_CHN0_5                ((0x3791  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_lut_budget2qp_23      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 23:20        reserved
//Bit 19:16        reg_lut_budget2qp_22      // unsigned ,    RW, default = 0  from budget2x to master_qp mapping
//Bit 15:12        reserved
//Bit 11: 8        reg_lut_budget2qp_21      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
//Bit  7: 4        reserved
//Bit  3: 0        reg_lut_budget2qp_20      // unsigned ,    RW, default = 1  from budget2x to master_qp mapping
#define ISP_LOSSD_MIX_FLATNESS_0                   ((0x3792  << 2) + 0xff000000)
//Bit 31           reg_flat_en               // unsigned ,    RW, default = 0  enable signal for the flatness mode.
//Bit 30           reg_flatness_pixel_flag   // unsigned ,    RW, default = 0  enable signal for the flatness
//Bit 29           reg_flatness_qerr_flag    // unsigned ,    RW, default = 0
//Bit 28            reserved
//Bit 27:24        reserved
//Bit 23:20        reg_flatness_qp_thresh    // unsigned ,    RW, default = 2  thresh qp for flatness to be used
//Bit 19:16        reserved
//Bit 15:12        reg_flatness_qp_reduce    // unsigned ,    RW, default = 2  if the cell is flatness qlevel = master_qp- flatness_qp_reduce
//Bit 11: 0        reg_flatness_accum_thresh // signed ,    RW, default = 1024  thresh ibits_accum for flatness to be used x16
#define ISP_LOSSD_MIX_FLATNESS_TH                  ((0x3793  << 2) + 0xff000000)
//Bit 31:16        reg_flatness_det_thresh_min // unsigned ,    RW, default = 25  MAX-MIN for all components is required to be less than  this value , flatness to be used
//Bit 15: 0        reg_flatness_det_thresh_max // unsigned ,    RW, default = 32  MAX-MIN for all components is required to be less than this value , flatness to be used
#define ISP_LOSSD_MIX_RC_GROUP_2                   ((0x3794  << 2) + 0xff000000)
//Bit 31:16        reg_rc_group_y            // unsigned ,    RW, default = 1920  vertical size of group (super block) within picture for rate control algorithm
//Bit 15:14        reserved
//Bit 13: 0        reg_slcln_ratio           // unsigned ,    RW, default = 24  dynamic ratio to idx of extra bit budget for the cells within the line
#define ISP_LOSSD_MIX_RC_BUDGET_0                  ((0x3795  << 2) + 0xff000000)
#define ISP_LOSSD_MIX_RC_BUDGET_1                  ((0x3796  << 2) + 0xff000000)
#define ISP_LOSSD_MIX_RC_BUDGET_2                  ((0x3797  << 2) + 0xff000000)
#define ISP_LOSSD_MIX_RC_BUDGET_3                  ((0x3798  << 2) + 0xff000000)
#define ISP_LOSSD_MIX_RC_BUDGET_4                  ((0x3799  << 2) + 0xff000000)
//Bit 23:16        reg_rc_1stln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the slice, no prediction from pre-line;
//Bit 15: 8        reg_rc_2ndln_slice_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the 2nd line of the slice, with limited prediction from pre-line;
//Bit  7: 0        reg_rc_1stln_group_xbdgt  // unsigned ,    RW, default = 0  extra bit budget (in pct= x/128) for the first line of the group, still with prediction from pre-line;
#define ISP_LOSSD_MIX_RC_BUDGET_5                  ((0x379a  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_master_qp_max      // unsigned ,    RW, default = 9  maxmum qpx2 during the rc_loop
//Bit 23:20        reserved
//Bit 19:16        reg_rc_master_qp_min      // unsigned ,    RW, default = 0  minmum qpx2 during the rc_loop
//Bit 15: 8        reg_rc_dynamic_speed_long // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 2nd order gain of loop filter. normalized to 16 as 1;
//Bit  7: 0        reg_rc_dynamic_speed_short // unsigned ,    RW, default = 16  dynamic speed for using up the accumed bits, 1st order gain of loop filter. normalized to 64 as 1;
#define ISP_LOSSD_MIX_RC_BUDGET_6                  ((0x379b  << 2) + 0xff000000)
//Bit 31           reg_rc_precell_bits_reset // unsigned ,    RW, default = 0  enable for bits_cell_pre reset of each group  1, bits_cell_pre =0  0:bits_cell_pre value unchanged
//Bit 30:29        reserved
//Bit 28:16        reg_rc_dynamic_mxblk_long // unsigned ,    RW, default = 240  maximum number of blocks in group for long term dynamic factor, if set to 0, then no limit; otherwise set limit, default= numblk of one line
//Bit 15:13        reserved
//Bit 12: 0        reg_rc_qp_margin3_blkth   // unsigned ,    RW, default = 0  final guard margin threshold to blocks_left_in_group, default= rc_dynamic_mxblk_long;
#define ISP_LOSSD_MIX_RC_QP_MARGIN                 ((0x379c  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_1    // signed ,    RW, default = -16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_0    // signed ,    RW, default = -4  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSD_MIX_RC_QP_MARGIN_1               ((0x379d  << 2) + 0xff000000)
//Bit 31:30        reserved
//Bit 29:16        reg_rc_qp_margin_thd_3    // signed ,    RW, default = 16  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
//Bit 15:14        reserved
//Bit 13: 0        reg_rc_qp_margin_thd_2    // signed ,    RW, default = -32  threshold x16 to ibits_accum to assign extra pq margin to avoid buffer down flow, default=[-4*16, -16*16]
#define ISP_LOSSD_MIX_RC_QP_MARGIN_2               ((0x379e  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_qp_margin_dlt_3    // unsigned ,    RW, default = 4  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_qp_margin_dlt_2    // unsigned ,    RW, default = 3
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_qp_margin_dlt_1    // unsigned ,    RW, default = 2
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_qp_margin_dlt_0    // unsigned ,    RW, default = 1  delta qp margin to qp_max when ibits_accum lower than  rc_qp_margin_thd[2], default=[1, 2]
#define ISP_LOSSD_MIX_FLATNESS_ADJ0                ((0x379f  << 2) + 0xff000000)
//Bit 31           reg_adjsize_flatness_flag // unsigned ,    RW, default = 0  enable signal for the flatness mode,adj_predicted_size should be small in flatness
//Bit 30           reg_adjsize_complex_flag  // unsigned ,    RW, default = 0  enable signal for the complex mode,adj_predicted_size should be large in complex
//Bit 29           reg_rc_fifo_avgspeed_use_sbudget // unsigned ,    RW, default = 0  enable to use s_budget_block as budget_block: 0 use bits_perblk programable register, 1: use rc calculated s_budget_blk
//Bit 28           reg_rc_bits_gap_dlt_down_en // unsigned ,    RW, default = 0  to dlt_buget2x reduced based on bits_gap value
//Bit 27:16        reg_adjsize_flatness_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_flatness_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size lower than  reg_adjsize_flatness_sizedlt, default=[1, 2]
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_flatness_reduce // unsigned ,    RW, default = 0  the cell is flatness and adj_predicted_size > thd,adj_predicted_size = adj_predicted_size- reg_adjsize_flatness_reduce
#define ISP_LOSSD_MIX_FLATNESS_ADJ1                ((0x37a0  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_adjsize_complex_pixthd // unsigned ,    RW, default = 0  area if(MAX-MIN) bigger than pixthd
//Bit 15:13        reserved
//Bit 12: 8        reg_adjsize_complex_sizedlt // unsigned ,    RW, default = 0  delta size margin to adj_predicted_size when adj_predicted_size bigger than  reg_adjsize_complex_sizedlt
//Bit  7: 5        reserved
//Bit  4: 0        reg_adjsize_complex_increase // unsigned ,    RW, default = 0  if the cell is complex and adj_predicted_size < thd,adj_predicted_size = adj_predicted_size + reg_adjsize_complex_increase
#define ISP_LOSSD_MIX_FIFO_THD_0                   ((0x37a1  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_5  // unsigned ,    RW, default = 280  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_4  // unsigned ,    RW, default = 250  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_THD_1                   ((0x37a2  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_3  // unsigned ,    RW, default = 220  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_2  // unsigned ,    RW, default = 165  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_THD_2                   ((0x37a3  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:12        reg_rc_fifo_margin_thd_1  // unsigned ,    RW, default = 145  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_margin_thd_0  // unsigned ,    RW, default = 130  threshold of fifo level(in words=16bits) to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_FIFO_AVG                     ((0x37a4  << 2) + 0xff000000)
//Bit 31:24        reserved
//Bit 23:20        reg_rc_fifo_margin_dlt_5  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 19:16        reserved
//Bit 15:12        reg_rc_fifo_margin_dlt_4  // unsigned ,    RW, default = 6  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 11: 0        reg_rc_fifo_avgspeed_bits_perblk // unsigned ,    RW, default = 80  bits perblock fifo read/write speed, set to budget_block = (SIZE_BLK*(ratio_bppx16) )/16 as default
#define ISP_LOSSD_MIX_FIFO_DLT_1STCH               ((0x37a5  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_margin_dlt_3  // unsigned ,    RW, default = 4  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_margin_dlt_2  // unsigned ,    RW, default = 3  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_margin_dlt_1  // unsigned ,    RW, default = 2  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_margin_dlt_0  // unsigned ,    RW, default = 1  delta of fifo level to guard the rc loop by adding delta to p_budget2x, default=[]
#define ISP_LOSSD_MIX_BITSGAP_THD_0                ((0x37a6  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_bits_gap_margin_thd_1 // unsigned ,    RW, default = 50  threshold of bits gap to reduced dlt_buget2x
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_0 // unsigned ,    RW, default = 30
#define ISP_LOSSD_MIX_BITSGAP_THD_1                ((0x37a7  << 2) + 0xff000000)
//Bit 31:12        reserved
//Bit 11: 0        reg_rc_bits_gap_margin_thd_2 // unsigned ,    RW, default = 82  threshold of bits gap to reduced dlt_buget2x
#define ISP_LOSSD_MIX_RC_QP_MARGIN_3               ((0x37a8  << 2) + 0xff000000)
//Bit 31:30        reg_rc_qp_margin_dlt_mode // unsigned ,    RW, default = 1
//Bit 29:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_1 // unsigned ,    RW, default = 250  threshold  to fifo to assign extra pq margin to avoid buffer down flow,
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_0 // unsigned ,    RW, default = 150  threshold  to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_MIX_RC_QP_MARGIN_4               ((0x37a9  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:16        reg_rc_fifo_qp_margin_thd_3 // unsigned ,    RW, default = 500  threshold to fifo to assign extra pq margin to avoid buffer down flow
//Bit 15:12        reserved
//Bit 11: 0        reg_rc_fifo_qp_margin_thd_2 // unsigned ,    RW, default = 350  threshold to fifo to assign extra pq margin to avoid buffer down flow
#define ISP_LOSSD_MIX_RC_QP_MARGIN_5               ((0x37aa  << 2) + 0xff000000)
//Bit 31:28        reserved
//Bit 27:24        reg_rc_fifo_qp_margin_dlt_3 // unsigned ,    RW, default = 16  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
//Bit 23:20        reserved
//Bit 19:16        reg_rc_fifo_qp_margin_dlt_2 // unsigned ,    RW, default = 7
//Bit 15:12        reserved
//Bit 11: 8        reg_rc_fifo_qp_margin_dlt_1 // unsigned ,    RW, default = 5
//Bit  7: 4        reserved
//Bit  3: 0        reg_rc_fifo_qp_margin_dlt_0 // unsigned ,    RW, default = 3  delta qp margin to qp_max when fifo lower than  rc_qp_margin_thd[2], default=[1, 4]
#define ISP_LOSSD_MIX_LUMA                         ((0x37ab  << 2) + 0xff000000)
//Bit 31:17        reserved
//Bit 16           reg_luma_adjust_en        // unsigned ,    RW, default = 0  enable of luma(G) adjust
//Bit 15:13        reserved
//Bit 12: 8        reg_pixel_luma_adj_dlt_1  // unsigned ,    RW, default = 1  of qlevel according to luma
//Bit  7: 5        reserved
//Bit  4: 0        reg_pixel_luma_adj_dlt_0  // unsigned ,    RW, default = 2
#define ISP_LOSSD_MIX_LUMA_TH                      ((0x37ac  << 2) + 0xff000000)
//Bit 31:16        reg_pixel_luma_adj_th_1   // unsigned ,    RW, default = 128  of luma level
//Bit 15: 0        reg_pixel_luma_adj_th_0   // unsigned ,    RW, default = 256
#define ISP_LOSSD_MIX_DEBUG                        ((0x37ad  << 2) + 0xff000000)
//Bit 31           reg_debug_mode            // unsigned ,    RW, default = 0  enable of qlevel debug return qlevel value
//Bit 30: 8        reserved
//Bit  7: 0        reg_dbg_qlevel            // unsigned ,    RW, default = 0
#define ISP_LOSSD_MIX_RO_MAX_ERROR                 ((0x37ae  << 2) + 0xff000000)
//Bit 31:20        reserved
//Bit 19: 0        ro_max_error              // unsigned ,    RO, default = 0  current channel max pixel diff
#define ISP_LOSSD_MIX_RO_SQUARE_L                  ((0x37af  << 2) + 0xff000000)
//Bit 31: 0        ro_error_acc_l            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSD_MIX_RO_SQUARE_H                  ((0x37b0  << 2) + 0xff000000)
//Bit 31: 0        ro_error_acc_h            // unsigned ,    RO, default = 0  sum of square
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_0               ((0x37b1  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_0               ((0x37b2  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_0          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_1               ((0x37b3  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_1               ((0x37b4  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_1          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_2               ((0x37b5  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_2               ((0x37b6  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_2          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_H_3               ((0x37b7  << 2) + 0xff000000)
//Bit 31:10        reserved
//Bit  9: 0        ro_slice_len_h_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
#define ISP_LOSSD_MIX_RO_BIT_LEN_L_3               ((0x37b8  << 2) + 0xff000000)
//Bit 31: 0        ro_slice_len_l_3          // unsigned ,    RO, default = 0  bitstream length in 128bits
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./isp_inc/inc_sw/losslite_regs_1.h
//
//
// Closing file:  ./isp_inc/inc_sw/isp_regs_base.h
//
//
// Reading file:  ./ge2d_regs.h
//
// synopsys translate_off
// synopsys translate_on
//===========================================================================
////// GE2D Registers    0x8a0 - 0x8ff
//address is 0xd016_0000 - 0xd0160000 - 0xd01603ff
//===========================================================================
// -----------------------------------------------
// REG_BASE:  GE2D_GCBUS_BASE = 0x00
// -----------------------------------------------
//Bit 31, destination bytemask only if destination bitmask is enable
//Bit 30, destination bitmask enable
//Bit 29, source2 key  enable
//Bit 28, source2 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 27, source1 key  enable
//Bit 26, source1 key  mode, 0: mask data when match, 1: mask data when unmatch
//Bit 25:24, dst1 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 23  dst clip mode, 0: write inside clip window, 1: write outside clip window
//Bit 22:17,  reserved
//Bit 16:15, src2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 14     src2 fill mode, 0: repeat data, 1: fill default color
//Bit 13:12  src2 picture struct, 00: frame, 10: even, 11: odd
//Bit 11     src1 x direction yc ration, 0: 1:1, 1: 2:1
//Bit 10     src1 y direction yc ration, 0: 1:1, 1: 2:1
//Bit 9:7    reserved
//Bit 6:5,   src1  8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 4      src1 fill mode, 0: repeat data, 1: fill default color
//Bit 3      src1 lookup table enable
//Bit 2:1    src1 picture struct, 00: frame, 10: even, 11: odd
//Bit 0      src1 separate buffer enable
#define GE2D_GEN_CTRL0                             ((0x00a0  << 2) + 0xfe04c000)
//Bit 31, soft rst
//Bit 30, dst write response counter reset
//Bit 29, disable adding dst write response count to busy bit
//Bit 28:26, reserved
//bit 25:24, interrupt control, if bit[0] true, generate interrupt when one command done,
//                              if bit[1] true, generate interrupt when ge2d change from busy to not busy
//Bit 23:22 src2 burst size control
//Bit 21:16 src1 burst size control, 5:4, yfifo, 3:2, cbfifo, 1:0, crfifo
//          each 2bit, 00: 24 64bitword, 01: 32 64bitword, 10: 48 64bitwords, 11: 64 64bitwords
//Bit 15:14, dst1 picture struct, 00: frame, 10:top, 11: bottom
//Bit 13:12, bit 13 if true, force read src1, bit 12 if true, force read src2
//Bit 11, dst2 request urgent enable
//Bit 10, src1 request urgent enable
//Bit 9,  src2 request urgent enable
//Bit 8,  dst1 request urgent enable
//Bit 7:0 src1 global alpha
#define GE2D_GEN_CTRL1                             ((0x00a1  << 2) + 0xfe04c000)
//Bit31      alpha conversion mode in alu, 0: alpha_out = (alpha !=0) ? alpha +1 : 0;
//                 otherwise, alpha_out = (alpha < 128) ? alpha: alpha + 1;
//Bit30      color conversion mode in alu, 0: color_out = (color != 0) ? color +1: 0;
//                 otherwise, color_out = (color < 128) ? color: color + 1;
//Bit29      src1_gb_alpha_en, As = src1_gb_alpha_en ? Asr * Ag: Asr
//Bit28      dst1_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit27      src2_color_expand_mode, 0: add 0, 1: add MSBs
//Bit26      src2_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit25      src1_color_expand_mode, 0: add 0, 1: add MSBs
//Bit24      src1_alpha_expand_mode, 0: add 0, 1: add MSBs
//Bit 23     if true, dst little endian, otherwise big endian
//Bit 22:19 dst1 color_map
//        dst1_format=0                  : output 8-bit;
//        dst1_format=1, dst1_color_map=1: output 16-bit YCbCr  655;
//        dst1_format=1, dst1_color_map=2: output 16-bit YCbCr  844;
//        dst1_format=1, dst1_color_map=3: output 16-bit YCbCrA 6442;
//        dst1_format=1, dst1_color_map=4: output 16-bit YCbCrA 4444;
//        dst1_format=1, dst1_color_map=5: output 16-bit YCbCr  565;
//        dst1_format=1, dst1_color_map=6: output 16-bit AYCbCr 4444;
//        dst1_format=1, dst1_color_map=7: output 16-bit AYCbCr 1555;
//        dst1_format=1, dst1_color_map=8: output 16-bit YCbCrA 4642;
//        dst1_format=1, dst1_color_map=9: output 16-bit CbCr   88;
//        dst1_format=1, dst1_color_map=10:output 16-bit CrCb   88;
//        dst1_format=2, dst1_color_map=0: output 24-bit YCbCr  888;
//        dst1_format=2, dst1_color_map=1: output 24-bit YCbCrA 5658;
//        dst1_format=2, dst1_color_map=2: output 24-bit AYCbCr 8565;
//        dst1_format=2, dst1_color_map=3: output 24-bit YCbCrA 6666;
//        dst1_format=2, dst1_color_map=4: output 24-bit AYCbCr 6666;
//        dst1_format=2, dst1_color_map=5: output 24-bit CrCbY  888;
//        dst1_format=3, dst1_color_map=0: output 32-bit YCbCrA 8888;
//        dst1_format=3, dst1_color_map=1: output 32-bit AYCbCr 8888;
//        dst1_format=3, dst1_color_map=2: output 32-bit ACrCbY 8888;
//        dst1_format=3, dst1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst1_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15    if true, src2 little endian, otherwise big endian
//Bit 14:11  src2 color_map
//        src2_format=0                 : output 8-bit;
//        src2_format=1, src2_color_map=1: output 16-bit YCbCr  655;
//        src2_format=1, src2_color_map=2: output 16-bit YCbCr  844;
//        src2_format=1, src2_color_map=3: output 16-bit YCbCrA 6442;
//        src2_format=1, src2_color_map=4: output 16-bit YCbCrA 4444;
//        src2_format=1, src2_color_map=5: output 16-bit YCbCr  565;
//        src2_format=1, src2_color_map=6: output 16-bit AYCbCr 4444;
//        src2_format=1, src2_color_map=7: output 16-bit AYCbCr 1555;
//        src2_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src2_format=2, src2_color_map=0: output 24-bit YCbCr  888;
//        src2_format=2, src2_color_map=1: output 24-bit YCbCrA 5658;
//        src2_format=2, src2_color_map=2: output 24-bit AYCbCr 8565;
//        src2_format=2, src2_color_map=3: output 24-bit YCbCrA 6666;
//        src2_format=2, src2_color_map=4: output 24-bit AYCbCr 6666;
//        src2_format=2, src2_color_map=5: output 24-bit CrCbY  888;
//        src2_format=3, src2_color_map=0: output 32-bit YCbCrA 8888;
//        src2_format=3, src2_color_map=1: output 32-bit AYCbCr 8888;
//        src2_format=3, src2_color_map=2: output 32-bit ACrCbY 8888;
//        src2_format=3, src2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 9:8 src2 format, 00: 8bit, 01:16bit, 10:24bit 11: 32bit
//Bit 7     if true, src1 little endian, otherwise big endian
//Bit 6:3   src1 color_map
//        src1_format=0                 : output 8-bit;
//        src1_format=1, src1_color_map=0: output 4:2:2  (Y0Cb0Y1Cr0);
//        src1_format=1, src1_color_map=1: output 16-bit YCbCr  655;
//        src1_format=1, src1_color_map=2: output 16-bit YCbCr  844;
//        src1_format=1, src1_color_map=3: output 16-bit YCbCrA 6442;
//        src1_format=1, src1_color_map=4: output 16-bit YCbCrA 4444;
//        src1_format=1, src1_color_map=5: output 16-bit YCbCr  565;
//        src1_format=1, src1_color_map=6: output 16-bit AYCbCr 4444;
//        src1_format=1, src1_color_map=7: output 16-bit AYCbCr 1555;
//        src1_format=1, src2_color_map=8: output 16-bit YCbCrA 4642;
//        src1_format=2, src1_color_map=0: output 24-bit YCbCr  888;
//        src1_format=2, src1_color_map=1: output 24-bit YCbCrA 5658;
//        src1_format=2, src1_color_map=2: output 24-bit AYCbCr 8565;
//        src1_format=2, src1_color_map=3: output 24-bit YCbCrA 6666;
//        src1_format=2, src1_color_map=4: output 24-bit AYCbCr 6666;
//        src1_format=2, src1_color_map=5: output 24-bit CrCbY  888;
//        src1_format=2, src1_color_map=14:output 8-bit Y and 16-bit CbCr;
//        src1_format=2, src1_color_map=15:output 8-bit Y and 16-bit CrCb;
//        src1_format=3, src1_color_map=0: output 32-bit YCbCrA 8888;
//        src1_format=3, src1_color_map=1: output 32-bit AYCbCr 8888;
//        src1_format=3, src1_color_map=2: output 32-bit ACrCbY 8888;
//        src1_format=3, src1_color_map=3: output 32-bit CrCbYA 8888.
//Bit 1:0 src1 format, 00: 8bit, 01:16bit/4:2:2, 10:24bit 11: 32bit
#define GE2D_GEN_CTRL2                             ((0x00a2  << 2) + 0xfe04c000)
//Bit 9     if true, all src2 data use default color
//Bit 8     if true, all src1 data use default color
//Bit 7     if true, dst x/y swap
//Bit 6     if true, dst x direction reversely read
//Bit 5     if true, dst y direction reversely read
//Bit 4     if true, src2 x direction reversely read
//Bit 3     if true, src2 y direction reversely read
//Bit 2     if true, src1 x direction reversely read
//Bit 1     if true, src1 y direction reversely read
//Bit 0     cmd write
#define GE2D_CMD_CTRL                              ((0x00a3  << 2) + 0xfe04c000)
//Read only
//Bit 28:17 dst write response counter, for debug only
//Bit 16:7  ge2d_dp status, for debug only
//Bit 6     read src1 cmd ready
//Bit 5     read src2 cmd ready
//Bit 4     pre dpcmd ready
//Bit 3     ge2d dpcmd ready
//Bit 2     ge2d buffer command valid
//Bit 1     ge2d current command valid
//Bit 0     ge2d busy
#define GE2D_STATUS0                               ((0x00a4  << 2) + 0xfe04c000)
//
//Read only
// Bit 29:16 ge2d_dst1_status, for debug only
// Bit    15 ge2d_rd_src2 core.fifo_empty
// Bit    14 ge2d_rd_src2 core.fifo_overflow
// Bit 13:12 ge2d_rd_src2 core.req_st
// Bit    11 ge2d_rd_src2 cmd_if.cmd_err, true if cmd_format=1
// Bit    10 ge2d_rd_src2 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
// Bit     9 ge2d_rd_src1 luma_core(chroma_core).fifo_empty
// Bit     8 ge2d_rd_src1 luma_core(chroma_core).fifo_overflow
// Bit  7: 6 ge2d_rd_src1 chroma_core.req_st_cr
// Bit  5: 4 ge2d_rd_src1 chroma_core.req_st_cb
// Bit  3: 2 ge2d_rd_src1 luma_core.req_st_y
// Bit     1 ge2d_rd_src1 cmd_if.stat_read_window_err, 1=reading/clipping window setting exceed limit
// Bit     0 ge2d_rd_src1 cmd_if.cmd_st, 0=IDLE state, 1=BUSY state
#define GE2D_STATUS1                               ((0x00a5  << 2) + 0xfe04c000)
//SRC1 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC1_DEF_COLOR                        ((0x00a6  << 2) + 0xfe04c000)
//Bit 31, SRC1 clip x start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip x start
//Bit 15, SRC1 clip x end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip x end
#define GE2D_SRC1_CLIPX_START_END                  ((0x00a7  << 2) + 0xfe04c000)
//Bit 31, SRC1 clip y start extra, if true, one more data is read for chroma
//Bit 28:16, SRC1 clip y start
//Bit 15, SRC1 clip y end extra, if true, one more data is read for chroma
//Bit 12:0, SRC1 clip y end
#define GE2D_SRC1_CLIPY_START_END                  ((0x00a8  << 2) + 0xfe04c000)
//Bit 31:24, SRC1 canvas address0
//Bit 23:16, SRC1 canvas address1
//Bit 15:8, SRC1 canvas address2
#define GE2D_SRC1_CANVAS                           ((0x00a9  << 2) + 0xfe04c000)
//Bit 31, SRC1 x start extra bit1, if true, one more chroma data is read for x even start chroma data when y/c ratio = 2
//             or x even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 x start extra bit0, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 29:16, SRC1 x start, signed data
//Bit 15, SRC1 x end extra bit1, if true, one more chroma data is read for x odd end chroma data when y/c ratio = 2
//             or x even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 x end extra bit0, if true, one more chroma data is read for x even end chroma data when y/c ratio = 2
//Bit 13:0, SRC1 x end, signed data
#define GE2D_SRC1_X_START_END                      ((0x00aa  << 2) + 0xfe04c000)
//Bit 31, SRC1 y start extra, if true, one more chroma data is read for y even start chroma data when y/c ratio = 2
//             or y even/odd start chroma extra data when y/c ratio = 1
//Bit 30, SRC1 y start extra, if true, one more chroma data is read for x odd start chroma data when y/c ratio = 2
//Bit 28:16, SRC1 y start
//Bit 15, SRC1 y end extra bit1, if true, one more chroma data is read for y odd end chroma data when y/c ratio = 2
//             or y even/odd end chroma extra data when y/c ratio = 1
//Bit 14, SRC1 y end extra bit0, if true, one more chroma data is read for y even end chroma data when y/c ratio = 2
//Bit 12:0, SRC1 y end
#define GE2D_SRC1_Y_START_END                      ((0x00ab  << 2) + 0xfe04c000)
// Bit 31: 9 Reserved
// Bit     8 RW, 0 = Write LUT, 1 = Read LUT
// Bit  7: 0 RW, lut_addr
#define GE2D_SRC1_LUT_ADDR                         ((0x00ac  << 2) + 0xfe04c000)
// Bit 31:24 RW, Y or R
// Bit 23:16 RW, Cb or G
// Bit 15: 8 RW, Cr or B
// Bit  7: 0 RW, Alpha
#define GE2D_SRC1_LUT_DAT                          ((0x00ad  << 2) + 0xfe04c000)
//Bit 19, if true, horizontal formatter using repeat to get the pixel, otherwise using interpolation
//Bit 18, horizontal formatter en
//Bit 17, if true, vertical formatter using repeat to get the pixel, otherwise using interpolation
//Bit 16, vertical formatter en
//Bit 15:8 X direction chroma phase,
//          [7:4] for x direction even start/end chroma phase when y/c ratio = 2
//                or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for x direction odd start/end chroma phase only when y/c ration = 2
//Bit 7:0  Y direction chroma phase,
//          [7:4] for y direction even start/end chroma phase when y/c ratio = 2
//          or start/end even/odd chroma phase  when y/c ratio = 1
//          [3:0] for y direction odd start/end chroma phase only when y/c ration = 2
#define GE2D_SRC1_FMT_CTRL                         ((0x00ae  << 2) + 0xfe04c000)
//SRC2 default color
//{Y,Cb,Cr,A}/{R,G,B,A}
#define GE2D_SRC2_DEF_COLOR                        ((0x00af  << 2) + 0xfe04c000)
//Bit 28:16, SRC2 clip x start
//Bit 12:0, SRC2 clip x end
#define GE2D_SRC2_CLIPX_START_END                  ((0x00b0  << 2) + 0xfe04c000)
//Bit 28:16, SRC2 clip y start
//Bit 12:0, SRC2 clip y end
#define GE2D_SRC2_CLIPY_START_END                  ((0x00b1  << 2) + 0xfe04c000)
//Bit 28:16, SRC2 x start
//Bit 12:0, SRC2 x end
#define GE2D_SRC2_X_START_END                      ((0x00b2  << 2) + 0xfe04c000)
//Bit 28:16, SRC2 y start
//Bit 12:0, SRC2 y end
#define GE2D_SRC2_Y_START_END                      ((0x00b3  << 2) + 0xfe04c000)
//Bit 28:16, DST clip x start
//Bit 12:0, DST clip x end
#define GE2D_DST_CLIPX_START_END                   ((0x00b4  << 2) + 0xfe04c000)
//
//Bit 28:16, DST clip y start
//Bit 12:0, DST clip y end
#define GE2D_DST_CLIPY_START_END                   ((0x00b5  << 2) + 0xfe04c000)
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_X_START_END                       ((0x00b6  << 2) + 0xfe04c000)
//
//Bit 28:16, DST x start
//Bit 12:0, DST x end
#define GE2D_DST_Y_START_END                       ((0x00b7  << 2) + 0xfe04c000)
//Bit 23:16 DST2 canvas address
//Bit 15:8 SRC2 canvas address
//Bit 7:0 DST1 canvas address
#define GE2D_SRC2_DST_CANVAS                       ((0x00b8  << 2) + 0xfe04c000)
//vertical scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_VSC_START_PHASE_STEP                  ((0x00b9  << 2) + 0xfe04c000)
//phase slope
//Bit 24:0, bit 24 signed bit
#define GE2D_VSC_PHASE_SLOPE                       ((0x00ba  << 2) + 0xfe04c000)
//Bit 30:29, vertical repeat line0 number
//Bit 23:0, vertical scaler initial phase
#define GE2D_VSC_INI_CTRL                          ((0x00bb  << 2) + 0xfe04c000)
//horizontal scaler phase step
//Bit 28:0,  5.24 format
#define GE2D_HSC_START_PHASE_STEP                  ((0x00bc  << 2) + 0xfe04c000)
//phase slope
//Bit 24:0, bit 24 signed bit
#define GE2D_HSC_PHASE_SLOPE                       ((0x00bd  << 2) + 0xfe04c000)
//Bit 30:29, horizontal repeat line0 number
//Bit 23:0, horizontal scaler initial phase
#define GE2D_HSC_INI_CTRL                          ((0x00be  << 2) + 0xfe04c000)
//Bit 31:24, advance number in this round, if horizontal scaler is working on dividing mode
//Bit 23:0, horizontal scaler advance phase in this round, if horizontal scaler is working on dividing mode
#define GE2D_HSC_ADV_CTRL                          ((0x00bf  << 2) + 0xfe04c000)
//Bit 30, vertical nearest mode enable, must set vt_bank_length = 4
//Bit 29, horizontal nearest mode enable, must set hz_bank_length = 4
//Bit 28, horizontal scaler dividing mode enable
//Bit 27:15, horizontal dividing length, if bit 28 is enable
//Bit 14, pre horizontal scaler enable
//Bit 13, pre vertical scale enable
//Bit 12, vertical scale enable
//Bit 11, horizontal scaler enable
//Bit 9, if true, treat horizontal repeat line number(GE2D_HSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat horizontal repeat line number as minus line number.
//Bit 8, if true, treat vertical repeat line number(GE2D_VSC_INI_CTRL bit 30:29) as repeating line,
//        otherwise using treat vertical repeat line number as minus line number.
//Bit 7, if true, always use phase0 in vertical scaler
//Bit 6:4, vertical scaler bank length
//Bit 3, if true, always use phase0 in horizontal scaler
//Bit 2:0, horizontal scaler bank length
#define GE2D_SC_MISC_CTRL                          ((0x00c0  << 2) + 0xfe04c000)
//Read only
//vertical scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_VSC_NRND_POINT                        ((0x00c1  << 2) + 0xfe04c000)
//Read only
//vertical scaler next round phase
//bit 23:0
#define GE2D_VSC_NRND_PHASE                        ((0x00c2  << 2) + 0xfe04c000)
//Read only
//horizontal scaler next round integer pixel pointer, signed data
//Bit 13:0
#define GE2D_HSC_NRND_POINT                        ((0x00c3  << 2) + 0xfe04c000)
//Read only
//horizontal scaler next round phase
//bit 23:0
#define GE2D_HSC_NRND_PHASE                        ((0x00c4  << 2) + 0xfe04c000)
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX_PRE_OFFSET                     ((0x00c5  << 2) + 0xfe04c000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX_COEF00_01                      ((0x00c6  << 2) + 0xfe04c000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX_COEF02_10                      ((0x00c7  << 2) + 0xfe04c000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX_COEF11_12                      ((0x00c8  << 2) + 0xfe04c000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX_COEF20_21                      ((0x00c9  << 2) + 0xfe04c000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX_COEF22_CTRL                    ((0x00ca  << 2) + 0xfe04c000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX_OFFSET                         ((0x00cb  << 2) + 0xfe04c000)
//Bit 26:25, SRC1 color multiplier alpha selection
//           if 00, Cs = Csr
//           if 01, Cs = Csr * Asr * Ag (if source is not premultiplied)
//           if 10, Cs = Csr * Ag (if source is premultiplied)
//Bit 24    SRC2 color multiplier alpha selection
//          if 0, no multiplier, Cd = Cdr,  otherwise, Cd = Cdr * Ad.
//Bit 22:12 ALU color operation
//          bit10:8 Blending Mode Parameter
//            3'b000: ADD               Cs*Fs + Cd*Fd
//            3'b001: SUBTRACT          Cs*Fs - Cd*Fd
//            3'b010: REVERSE SUBTRACT  Cd*Fd - Cs*Fs
//            3'b011: MIN               min(Cs*Fs, Cd*Fd)
//            3'b100: MAX               max(Cs*Fs, Cd*Fd)
//            3'b101: LOGIC OP          Cs op Cd
//          bit7:4 Source Color Blending Factor CFs
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 dest Color Blending Factor CFd, when bit10:8 != LOGIC OP
//            4'b0000: ZERO                        0
//            4'b0001: ONE                         1
//            4'b0010: SRC_COLOR                   Cs(RGBs)
//            4'b0011: ONE_MINUS_SRC_COLOR         1 - Cs(RGBs)
//            4'b0100: DST_COLOR                   Cd(RGBd)
//            4'b0101: ONE_MINUS_DST_COLOR         1 - Cd(RGBd)
//            4'b0110: SRC_ALPHA                   As
//            4'b0111: ONE_MINUS_SRC_ALPHA         1 - As
//            4'b1000: DST_ALPHA                   Ad
//            4'b1001: ONE_MINUS_DST_ALPHA         1 - Ad
//            4'b1010: CONST_COLOR                 Cc(RGBc)
//            4'b1011: ONE_MINUS_CONST_COLOR       1 - Cc(RGBc)
//            4'b1100: CONST_ALPHA                 Ac
//            4'b1101: ONE_MINUS_CONST_ALPHA       1 - Ac
//            4'b1110: SRC_ALPHA_SATURATE          min(As,1-Ad)
//          bit3:0 logic operations, when bit10:8 == LOGIC OP
//            4'b0000: CLEAR                       0
//            4'b0001: COPY                        s
//            4'b0010: NOOP                        d
//            4'b0011: SET                         1
//            4'b0100: COPY_INVERT                 ~s
//            4'b0101: INVERT                      ~d
//            4'b0110: AND_REVERSE                 s & ~d
//            4'b0111: OR_REVERSE                  s | ~d
//            4'b1000: AND                         s & d
//            4'b1001: OR                          s | d
//            4'b1010: NAND                        ~(s & d)
//            4'b1011: NOR                         ~(s | d)
//            4'b1100: XOR                         s ^ d
//            4'b1101: EQUIV                       ~(s ^ d)
//            4'b1110: AND_INVERTED                ~s & d
//            4'b1111: OR_INVERTED                 ~s | d
//Bit 10:0  ALU alpha operation
//            bit10:8 Blending Equation Math Operation
//              3'b000: ADD               As*Fs + Ad*Fd
//              3'b001: SUBTRACT          As*Fs - Ad*Fd
//              3'b010: REVERSE SUBTRACT  Ad*Fd - As*Fs
//              3'b011: MIN               min(As*Fs, Ad*Fd)
//              3'b100: MAX               max(As*Fs, Ad*Fd)
//              3'b101: LOGIC OP          As op Ad
//            bit7:4 Source alpha Blending Factor AFs
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 Destination alpha Blending Factor AFd, when bit10:8 != LOGIC OP
//              4'b0000                       0
//              4'b0001                       1
//              4'b0010                       As
//              4'b0011                       1 - As
//              4'b0100                       Ad
//              4'b0101                       1 - Ad
//              4'b0110                       Ac
//              4'b0111                       1 - Ac
//               ....                         reserved
//            bit3:0 logic operations, when bit10:8 == LOGIC OP
//              4'b0000: CLEAR                       0
//              4'b0001: COPY                        s
//              4'b0010: NOOP                        d
//              4'b0011: SET                         1
//              4'b0100: COPY_INVERT                 ~s
//              4'b0101: INVERT                      ~d
//              4'b0110: AND_REVERSE                 s & ~d
//              4'b0111: OR_REVERSE                  s | ~d
//              4'b1000: AND                         s & d
//              4'b1001: OR                          s | d
//              4'b1010: NAND                        ~(s & d)
//              4'b1011: NOR                         ~(s | d)
//              4'b1100: XOR                         s ^ d
//              4'b1101: EQUIV                       ~(s ^ d)
//              4'b1110: AND_INVERTED                ~s & d
//              4'b1111: OR_INVERTED                 ~s | d
#define GE2D_ALU_OP_CTRL                           ((0x00cc  << 2) + 0xfe04c000)
//bit 31:0 (RGBA,YCBCRA)
#define GE2D_ALU_CONST_COLOR                       ((0x00cd  << 2) + 0xfe04c000)
//SRC1 Key
//31:0
#define GE2D_SRC1_KEY                              ((0x00ce  << 2) + 0xfe04c000)
//SRC1 Key Mask
//31:0
#define GE2D_SRC1_KEY_MASK                         ((0x00cf  << 2) + 0xfe04c000)
//SRC2 Key
//31:0
#define GE2D_SRC2_KEY                              ((0x00d0  << 2) + 0xfe04c000)
//SRC2 Key Mask
//31:0
#define GE2D_SRC2_KEY_MASK                         ((0x00d1  << 2) + 0xfe04c000)
//Destination Bit Mask
//31:0
#define GE2D_DST_BITMASK                           ((0x00d2  << 2) + 0xfe04c000)
//Bit 31    DP onoff mode, 0: on_counter means how many pixels will output before ge2d turns off
//                         1: on_counter means how many clocks will ge2d turn on before ge2d turns off
//Bit 30:16     DP on counter
//Bit 15        0: vd_format doesnt have onoff mode, 1: vd format has onoff mode
//Bit 14:0      DP off counter
#define GE2D_DP_ONOFF_CTRL                         ((0x00d3  << 2) + 0xfe04c000)
//Because there are many coefficients used in the vertical filter and horizontal filters,
//indirect access the coefficients of vertical filter and horizontal filter is used.
//For vertical filter, there are 33x4 coefficients
//For horizontal filter, there are 33x4 coefficients
//Bit 15	index increment, if bit9 == 1  then (0: index increase 1, 1: index increase 2) else (index increase 2)
//Bit 14	1: read coef through cbus enable, just for debug purpose in case when we wanna check the coef in ram in correct or not
//Bit 9     if true, use 9bit resolution coef, other use 8bit resolution coef
//Bit 8	    type of index, 0: vertical coef
//						   1: horizontal coef
//Bit 6:0 	coef index
#define GE2D_SCALE_COEF_IDX                        ((0x00d4  << 2) + 0xfe04c000)
//coefficients for vertical filter and horizontal filter
#define GE2D_SCALE_COEF                            ((0x00d5  << 2) + 0xfe04c000)
//Bit 24    src2 alpha fill mode: together with GE2D_GEN_CTRL0[4](fill_mode), define what alpha values are used
//                                for the area outside the clipping window. As below:
//                                fill_mode=0, alpha_fill_mode=0 : use inner alpha, (or default_alpha if src data have no alpha values);
//                                fill_mode=0, alpha_fill_mode=1 : use outside_alpha;
//                                fill_mode=1, alpha_fill_mode=0 : use default_alpha;
//                                fill_mode=1, alpha_fill_mode=1 : use outside_alpha.
//Bit 23:16 src2 outside alpha
//Bit 8     src1 alpha fill mode, refer to src2 alpha fill mode above.
//Bit 7:0   src1 outside alpha
#define GE2D_SRC_OUTSIDE_ALPHA                     ((0x00d6  << 2) + 0xfe04c000)
//Bit 31       antiflick enable
//Bit 24       1: alpha value for the first line use repeated alpha, 0: use bit 23:16 as the first line alpha
//Bit 23:16     register value for the first line alpha when bit 24 is 1
//Bit 8        1: alpha value for the last line use repeated alpha, 0: use bit 7:0 as the last line alpha
//Bit 7:0      register value for the last line alpha when bit 8 is 1
#define GE2D_ANTIFLICK_CTRL0                       ((0x00d8  << 2) + 0xfe04c000)
//Bit 25,    rgb_sel, 1: antiflick RGBA, 0: antiflick YCbCrA
//Bit 24,    cbcr_en, 1: also filter cbcr in case of antiflicking YCbCrA, 0: no filter on cbcr in case of antiflicking YCbCrA
//Bit 23:16, R mult coef for converting RGB to Y
//Bit 15:8,  G mult coef for converting RGB to Y
//Bit 7:0,   B mult coef for converting RGB to Y
//Y = (R * y_r + G * y_g + B * y_b) / 256
#define GE2D_ANTIFLICK_CTRL1                       ((0x00d9  << 2) + 0xfe04c000)
//Bit 31:24, Y threshold1, when   0<Y<=th1, use filter0;
//Bit 23:16, color antiflick filter0 n3
//Bit 15:8,  color antiflick filter0 n2
//Bit 7:0,   color antiflick filter0 n1
//Y = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_COLOR_FILT0                 ((0x00da  << 2) + 0xfe04c000)
//Bit 31:24, Y threshold2, when th1<Y<=th2, use filter1;
//Bit 23:16, color antiflick filter1 n3
//Bit 15:8,  color antiflick filter1 n2
//Bit 7:0,   color antiflick filter1 n1
#define GE2D_ANTIFLICK_COLOR_FILT1                 ((0x00db  << 2) + 0xfe04c000)
//Bit 31:24, Y threshold3, when th2<Y<=th3, use filter2; Y>th3, use filter3
//Bit 23:16, color antiflick filter2 n3
//Bit 15:8,  color antiflick filter2 n2
//Bit 7:0,   color antiflick filter2 n1
#define GE2D_ANTIFLICK_COLOR_FILT2                 ((0x00dc  << 2) + 0xfe04c000)
//Bit 23:16, color antiflick filter3 n3
//Bit 15:8,  color antiflick filter3 n2
//Bit 7:0,   color antiflick filter3 n1
#define GE2D_ANTIFLICK_COLOR_FILT3                 ((0x00dd  << 2) + 0xfe04c000)
//Bit 31:24, Alpha threshold1, when   0<Alpha<=th1, use filter0;
//Bit 23:16, Alpha antiflick filter0 n3
//Bit 15:8,  Alpha antiflick filter0 n2
//Bit 7:0,   Alpha antiflick filter0 n1
//Alpha = (line_up * n1 + line_center * n2 + line_dn * n3) / 128
#define GE2D_ANTIFLICK_ALPHA_FILT0                 ((0x00de  << 2) + 0xfe04c000)
//Bit 31:24, Alpha threshold2, when th1<Alpha<=th2, use filter1;
//Bit 23:16, Alpha antiflick filter1 n3
//Bit 15:8,  Alpha antiflick filter1 n2
//Bit 7:0,   Alpha antiflick filter1 n1
#define GE2D_ANTIFLICK_ALPHA_FILT1                 ((0x00df  << 2) + 0xfe04c000)
//Bit 31:24, Alpha threshold3, when th2<Alpha<=th3, use filter2; Alpha>th3, use filter3
//Bit 23:16, Alpha antiflick filter2 n3
//Bit 15:8,  Alpha antiflick filter2 n2
//Bit 7:0,   Alpha antiflick filter2 n1
#define GE2D_ANTIFLICK_ALPHA_FILT2                 ((0x00e0  << 2) + 0xfe04c000)
//Bit 23:16, Alpha antiflick filter3 n3
//Bit 15:8,  Alpha antiflick filter3 n2
//Bit 7:0,   Alpha antiflick filter3 n1
#define GE2D_ANTIFLICK_ALPHA_FILT3                 ((0x00e1  << 2) + 0xfe04c000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_Y_CTRL                 ((0x00e3  << 2) + 0xfe04c000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CB_CTRL                ((0x00e4  << 2) + 0xfe04c000)
//dout = clipto_0_255(((din + din_offset) * map_coef + ((1 << (map_sr - 1))) >> map_sr + dout_offset)
//Bit 30:22 din_offset (signed data)
//Bit 21:14 map_coef (unsigned data)
//Bit 13:10 map_sr (unsigned data)
//Bit 9:1   dout_offset (signed data)
//Bit 0     enable
#define GE2D_SRC1_RANGE_MAP_CR_CTRL                ((0x00e5  << 2) + 0xfe04c000)
//Bit 21:16     src1 pre arbiter burst number
//Bit 13:8      src2 pre arbiter burst number
//Bit 5:0       dst pre arbiter burst number
#define GE2D_ARB_BURST_NUM                         ((0x00e6  << 2) + 0xfe04c000)
//each 6bit ID, high 4bit are thread ID, low 2bits are the token
//Bit 21:16 src1 ID
//Bit 13:8 src2 ID
//Bit 5:0  dst ID
#define GE2D_TID_TOKEN                             ((0x00e7  << 2) + 0xfe04c000)
//Bit 31:28 dst2_bytemask_val. 1-bit mask for each byte (8-bit). Applicable only if both dst_bitmask_en=1 and dst_bytemask_only=1.
//Bit 27:26, dst2 picture struct, 00: frame, 10:top, 11: bottom
//Bit 25:24, dst2 8bit mode component selection,
//            00: select Y(R), 01: Cb(G), 10: Cr(B), 11: Alpha
//Bit 22:19 dst2 color_map
//        dst2_format=0                  : output 8-bit;
//        dst2_format=1, dst2_color_map=1: output 16-bit YCbCr  655;
//        dst2_format=1, dst2_color_map=2: output 16-bit YCbCr  844;
//        dst2_format=1, dst2_color_map=3: output 16-bit YCbCrA 6442;
//        dst2_format=1, dst2_color_map=4: output 16-bit YCbCrA 4444;
//        dst2_format=1, dst2_color_map=5: output 16-bit YCbCr  565;
//        dst2_format=1, dst2_color_map=6: output 16-bit AYCbCr 4444;
//        dst2_format=1, dst2_color_map=7: output 16-bit AYCbCr 1555;
//        dst2_format=1, dst2_color_map=8: output 16-bit YCbCrA 4642;
//        dst2_format=1, dst2_color_map=9: output 16-bit CbCr   88;
//        dst2_format=1, dst2_color_map=10:output 16-bit CrCb   88;
//        dst2_format=2, dst2_color_map=0: output 24-bit YCbCr  888;
//        dst2_format=2, dst2_color_map=1: output 24-bit YCbCrA 5658;
//        dst2_format=2, dst2_color_map=2: output 24-bit AYCbCr 8565;
//        dst2_format=2, dst2_color_map=3: output 24-bit YCbCrA 6666;
//        dst2_format=2, dst2_color_map=4: output 24-bit AYCbCr 6666;
//        dst2_format=2, dst2_color_map=5: output 24-bit CrCbY  888;
//        dst2_format=3, dst2_color_map=0: output 32-bit YCbCrA 8888;
//        dst2_format=3, dst2_color_map=1: output 32-bit AYCbCr 8888;
//        dst2_format=3, dst2_color_map=2: output 32-bit ACrCbY 8888;
//        dst2_format=3, dst2_color_map=3: output 32-bit CrCbYA 8888.
//Bit 17:16 dst2_format,  00: 8bit, 01:16bit, 10:24bit, 11: 32bit
//Bit 15     reserved
//Bit 14     dst2_color_round_mode, 0: truncate, 1: + 0.5 rounding
//Bit 13:12, dst2_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit 11:10, dst2_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     9 reserved
//Bit     8, dst2_enable. 0: disable dst2 (default); 1=enable dst2.
//Bit  7: 6 reserved
//Bit  5: 4, dst1_x_discard_mode. 00: no discard; 10=discard even x; 11=discard odd x. Note: x is post reverse/rotation.
//Bit  3: 2, dst1_y_discard_mode. 00: no discard; 10=discard even y; 11=discard odd y. Note: y is post reverse/rotation.
//Bit     1 reserved
//Bit     0, dst1_enable. 0: disable dst1; 1=enable dst1 (default).
#define GE2D_GEN_CTRL3                             ((0x00e8  << 2) + 0xfe04c000)
//Read only
// Bit 13:0 ge2d_dst2_status, for debug only
#define GE2D_STATUS2                               ((0x00e9  << 2) + 0xfe04c000)
//Bit 27:26  src1 Y fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 25:24  src2 fifo size control, 00: 512, 01: 256, 10: 128 11: 96
//Bit 23:22  dst1 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 21:20  dst2 fifo size control, 00: 512, 01: 256, 10: 128 11: 64
//Bit 19:18, dst1 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 17:16, dst2 fifo burst control, 00: 24x64, 01: 32x64, 10: 48x64, 11:64x64
//Bit 15:1, top_wrap_ctrl
//bit 0, if true, disable bug fix about the dp_out_done/scale_out_done(test1823) hang issue when scaling down ratio is high.
#define GE2D_GEN_CTRL4                             ((0x00ea  << 2) + 0xfe04c000)
#define GE2D_GCLK_CTRL0                            ((0x00ef  << 2) + 0xfe04c000)
#define GE2D_GCLK_CTRL1                            ((0x00f0  << 2) + 0xfe04c000)
#define GE2D_GEN_CTRL5                             ((0x00f1  << 2) + 0xfe04c000)
#define GE2D_DST1_BADDR_CTRL                       ((0x00f2  << 2) + 0xfe04c000)
//Bit 31:0, dst1 base address in 64bits
#define GE2D_DST1_STRIDE_CTRL                      ((0x00f3  << 2) + 0xfe04c000)
//Bit 19:0, dst1 stride size in 64bits
#define GE2D_DST2_BADDR_CTRL                       ((0x00f4  << 2) + 0xfe04c000)
//Bit 31:0, dst1 base address in 64bits
#define GE2D_DST2_STRIDE_CTRL                      ((0x00f5  << 2) + 0xfe04c000)
//Bit 19:0, dst1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_Y                     ((0x00f6  << 2) + 0xfe04c000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_Y                    ((0x00f7  << 2) + 0xfe04c000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_CB                    ((0x00f8  << 2) + 0xfe04c000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_CB                   ((0x00f9  << 2) + 0xfe04c000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC1_BADDR_CTRL_CR                    ((0x00fa  << 2) + 0xfe04c000)
//Bit 31:0, src1 base address in 64bits
#define GE2D_SRC1_STRIDE_CTRL_CR                   ((0x00fb  << 2) + 0xfe04c000)
//Bit 19:0, src1 stride size in 64bits
#define GE2D_SRC2_BADDR_CTRL                       ((0x00fc  << 2) + 0xfe04c000)
//Bit 31:0, src2 base address in 64bits
#define GE2D_SRC2_STRIDE_CTRL                      ((0x00fd  << 2) + 0xfe04c000)
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX2_PRE_OFFSET                    ((0x0090  << 2) + 0xfe04c000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX2_COEF00_01                     ((0x0091  << 2) + 0xfe04c000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX2_COEF02_10                     ((0x0092  << 2) + 0xfe04c000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX2_COEF11_12                     ((0x0093  << 2) + 0xfe04c000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX2_COEF20_21                     ((0x0094  << 2) + 0xfe04c000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX2_COEF22_CTRL                   ((0x0095  << 2) + 0xfe04c000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX2_OFFSET                        ((0x0096  << 2) + 0xfe04c000)
//Bit 19:0, src2 stride size in 64bits
//
//
//Bit 28:20, pre_offset0
//Bit 18:10, pre_offset1
//Bit 8:0,   pre_offset2
#define GE2D_MATRIX3_PRE_OFFSET                    ((0x0097  << 2) + 0xfe04c000)
//Bit 28:16 coef00
//Bit 12:0  coef01
#define GE2D_MATRIX3_COEF00_01                     ((0x0098  << 2) + 0xfe04c000)
//Bit 28:16 coef02
//Bit 12:0  coef10
#define GE2D_MATRIX3_COEF02_10                     ((0x0099  << 2) + 0xfe04c000)
//Bit 28:16 coef11
//Bit 12:0  coef12
#define GE2D_MATRIX3_COEF11_12                     ((0x009a  << 2) + 0xfe04c000)
//Bit 28:16 coef20
//Bit 12:0  coef21
#define GE2D_MATRIX3_COEF20_21                     ((0x009b  << 2) + 0xfe04c000)
//Bit 28:16 coef22
//Bit 7    input y/cb/cr saturation enable
//Bit 0    conversion matrix enable
#define GE2D_MATRIX3_COEF22_CTRL                   ((0x009c  << 2) + 0xfe04c000)
//Bit 28:20, offset0
//Bit 18:10, offset1
//Bit 8:0,   offset2
#define GE2D_MATRIX3_OFFSET                        ((0x009d  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_CTRL0                         ((0x0081  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_CTRL1                         ((0x0082  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_CTRL2                         ((0x0083  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_CTRL3                         ((0x0084  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_CTRL4                         ((0x0085  << 2) + 0xfe04c000)
#define GE2D_AXI2DMA_STATUS                        ((0x0086  << 2) + 0xfe04c000)
// synopsys translate_off
// synopsys translate_on
//
// Closing file:  ./ge2d_regs.h
//

#include "extra_register.h"

#endif // REGISTER_H

